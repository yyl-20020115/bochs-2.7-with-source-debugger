00001                                           ! 1 
00002                                           ! 1 # 1 "_rombiosl_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void _memsetb(value,offset,seg,count);
00040                                           !BCC_EOS
00041                                           ! 32   void _memcpyb(doffset,dseg,soffset,sseg,count);
00042                                           !BCC_EOS
00043                                           ! 33   void _memcpyd(doffset,dseg,soffset,sseg,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   _memsetb(value,offset,seg,count)
00047                                           ! 36     Bit16u value;
00048                                           export	__memsetb
00049                       00000000            __memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u seg;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            __memsetb.count	set	8
00061                       00000006            __memsetb.seg	set	6
00062                       00000002            __memsetb.value	set	2
00063                       00000004            __memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           E3           09                  jcxz memsetb_end
00072 000C           C47E         06                  les di, 6[bp] ; segment & offset
00073 000F           8A46         04                  mov al, 4[bp] ; value
00074 0012           FC                               cld
00075 0013           F3                               rep
00076 0014           AA                                stosb
00077                       00000015              memsetb_end:
00078 0015           5F                               pop di
00079 0016           07                               pop es
00080 0017           59                               pop cx
00081 0018           58                               pop ax
00082 0019           5D                             pop bp
00083                                           ! 61 endasm
00084                                           !BCC_ENDASM
00085                                           ! 62   }
00086 001A           C3                         ret
00087                                           ! 63     void
00088                                           ! 64   _memcpyb(doffset,dseg,soffset,sseg,count)
00089                                           ! 65     Bit16u doffset;
00090                                           export	__memcpyb
00091                       0000001B            __memcpyb:
00092                                           !BCC_EOS
00093                                           ! 66     Bit16u dseg;
00094                                           !BCC_EOS
00095                                           ! 67     Bit16u soffset;
00096                                           !BCC_EOS
00097                                           ! 68     Bit16u sseg;
00098                                           !BCC_EOS
00099                                           ! 69     Bit16u count;
00100                                           !BCC_EOS
00101                                           ! 70   {
00102                                           ! 71 #asm
00103                                           !BCC_ASM
00104                       0000000A            __memcpyb.count	set	$A
00105                       00000008            __memcpyb.sseg	set	8
00106                       00000006            __memcpyb.soffset	set	6
00107                       00000004            __memcpyb.dseg	set	4
00108                       00000002            __memcpyb.doffset	set	2
00109 001B           55                             push bp
00110 001C           89E5                           mov bp, sp
00111 001E           51                               push cx
00112 001F           06                               push es
00113 0020           57                               push di
00114 0021           1E                               push ds
00115 0022           56                               push si
00116 0023           8B4E         0C                  mov cx, 12[bp] ; count
00117 0026           E3           09                  jcxz memcpyb_end
00118 0028           C47E         04                  les di, 4[bp] ; dsegment & doffset
00119 002B           C576         08                  lds si, 8[bp] ; ssegment & soffset
00120 002E           FC                               cld
00121 002F           F3                               rep
00122 0030           A4                                movsb
00123                       00000031              memcpyb_end:
00124 0031           5E                               pop si
00125 0032           1F                               pop ds
00126 0033           5F                               pop di
00127 0034           07                               pop es
00128 0035           59                               pop cx
00129 0036           5D                             pop bp
00130                                           ! 93 endasm
00131                                           !BCC_ENDASM
00132                                           ! 94   }
00133 0037           C3                         ret
00134                                           ! 95     void
00135                                           ! 96   _memcpyd(doffset,dseg,soffset,sseg,count)
00136                                           ! 97     Bit16u doffset;
00137                                           export	__memcpyd
00138                       00000038            __memcpyd:
00139                                           !BCC_EOS
00140                                           ! 98     Bit16u dseg;
00141                                           !BCC_EOS
00142                                           ! 99     Bit16u soffset;
00143                                           !BCC_EOS
00144                                           ! 100     Bit16u sseg;
00145                                           !BCC_EOS
00146                                           ! 101     Bit16u count;
00147                                           !BCC_EOS
00148                                           ! 102   {
00149                                           ! 103 #asm
00150                                           !BCC_ASM
00151                       0000000A            __memcpyd.count	set	$A
00152                       00000008            __memcpyd.sseg	set	8
00153                       00000006            __memcpyd.soffset	set	6
00154                       00000004            __memcpyd.dseg	set	4
00155                       00000002            __memcpyd.doffset	set	2
00156 0038           55                             push bp
00157 0039           89E5                           mov bp, sp
00158 003B           51                               push cx
00159 003C           06                               push es
00160 003D           57                               push di
00161 003E           1E                               push ds
00162 003F           56                               push si
00163 0040           8B4E         0C                  mov cx, 12[bp] ; count
00164 0043           E3           0A                  jcxz memcpyd_end
00165 0045           C47E         04                  les di, 4[bp] ; dsegment & doffset
00166 0048           C576         08                  lds si, 8[bp] ; ssegment & soffset
00167 004B           FC                               cld
00168 004C           F3                               rep
00169 004D     66    A5                                movsd
00170                       0000004F              memcpyd_end:
00171 004F           5E                               pop si
00172 0050           1F                               pop ds
00173 0051           5F                               pop di
00174 0052           07                               pop es
00175 0053           59                               pop cx
00176 0054           5D                             pop bp
00177                                           ! 125 endasm
00178                                           !BCC_ENDASM
00179                                           ! 126   }
00180 0055           C3                         ret
00181                                           ! 127   static Bit32u _read_dword();
00182                                           !BCC_EOS
00183                                           ! 128   static void _write_dword();
00184                                           !BCC_EOS
00185                                           ! 129   static Bit32u read_dword_SS();
00186                                           !BCC_EOS
00187                                           ! 130     Bit32u
00188                                           ! 131   _read_dword(offset, seg)
00189                                           ! 132     Bit16u seg;
00190                                           export	__read_dword
00191                       00000056            __read_dword:
00192                                           !BCC_EOS
00193                                           ! 133     Bit16u offset;
00194                                           !BCC_EOS
00195                                           ! 134   {
00196                                           ! 135 #asm
00197                                           !BCC_ASM
00198                       00000004            __read_dword.seg	set	4
00199                       00000002            __read_dword.offset	set	2
00200 0056           55                             push bp
00201 0057           89E5                           mov bp, sp
00202 0059           53                               push bx
00203 005A           1E                               push ds
00204 005B           C55E         04                  lds bx, 4[bp] ; segment & offset
00205 005E           8B07                             mov ax, [bx]
00206 0060           8B57         02                  mov dx, 2[bx]
00207                                                 ;; ax = return value (word)
00208                                                 ;; dx = return value (word)
00209 0063           1F                               pop ds
00210 0064           5B                               pop bx
00211 0065           5D                             pop bp
00212                                           ! 148 endasm
00213                                           !BCC_ENDASM
00214                                           ! 149   }
00215 0066           C3                         ret
00216                                           ! 150     void
00217                                           ! 151   _write_dword(data, offset, seg)
00218                                           ! 152     Bit32u data;
00219                                           export	__write_dword
00220                       00000067            __write_dword:
00221                                           !BCC_EOS
00222                                           ! 153     Bit16u offset;
00223                                           !BCC_EOS
00224                                           ! 154     Bit16u seg;
00225                                           !BCC_EOS
00226                                           ! 155   {
00227                                           ! 156 #asm
00228                                           !BCC_ASM
00229                       00000008            __write_dword.seg	set	8
00230                       00000002            __write_dword.data	set	2
00231                       00000006            __write_dword.offset	set	6
00232 0067           55                             push bp
00233 0068           89E5                           mov bp, sp
00234 006A     66    50                               push eax
00235 006C           53                               push bx
00236 006D           1E                               push ds
00237 006E           C55E         08                  lds bx, 8[bp] ; segment & offset
00238 0071     66    8B46         04                  mov eax, 4[bp] ; data dword
00239 0075     66    8907                             mov [bx], eax ; write data dword
00240 0078           1F                               pop ds
00241 0079           5B                               pop bx
00242 007A     66    58                               pop eax
00243 007C           5D                             pop bp
00244                                           ! 169 endasm
00245                                           !BCC_ENDASM
00246                                           ! 170   }
00247 007D           C3                         ret
00248                                           ! 171     Bit32u
00249                                           ! 172   read_dword_SS(offset)
00250                                           ! 173     Bit16u offset;
00251                                           export	_read_dword_SS
00252                       0000007E            _read_dword_SS:
00253                                           !BCC_EOS
00254                                           ! 174   {
00255                                           ! 175 #asm
00256                                           !BCC_ASM
00257                       00000002            _read_dword_SS.offset	set	2
00258 007E           55                             push bp
00259 007F           89E5                           mov bp, sp
00260 0081           8B6E         04                mov bp, 4[bp] ; offset
00261 0084           8B46         00                mov ax, [bp]
00262 0087           8B56         02                mov dx, 2[bp]
00263                                               ;; ax = return value (word)
00264                                               ;; dx = return value (word)
00265 008A           5D                             pop bp
00266                                           ! 184 endasm
00267                                           !BCC_ENDASM
00268                                           ! 185   }
00269 008B           C3                         ret
00270                                           ! 186 #asm
00271                                           !BCC_ASM
00272                       00000002            _read_dword_SS.offset	set	2
00273                                             ;; and function
00274                       0000008C              landl:
00275                       0000008C              landul:
00276 008C           36                             SEG SS
00277 008D           2305                             and ax,[di]
00278 008F           36                             SEG SS
00279 0090           235D         02                  and bx,2[di]
00280 0093           C3                             ret
00281                                             ;; add function
00282                       00000094              laddl:
00283                       00000094              laddul:
00284 0094           36                             SEG SS
00285 0095           0305                             add ax,[di]
00286 0097           36                             SEG SS
00287 0098           135D         02                  adc bx,2[di]
00288 009B           C3                             ret
00289                                             ;; cmp function
00290                       0000009C              lcmpl:
00291                       0000009C              lcmpul:
00292 009C     66    25               0000FFFF      and eax, #0x0000FFFF
00293 00A2     66    C1E3                   10      shl ebx, #16
00294 00A6     66    09D8                           or eax, ebx
00295 00A9     66    C1EB                   10      shr ebx, #16
00296 00AD           36                             SEG SS
00297 00AE     66    3B05                             cmp eax, dword ptr [di]
00298 00B1           C3                             ret
00299                                             ;; sub function
00300                       000000B2              lsubl:
00301                       000000B2              lsubul:
00302 00B2           36                             SEG SS
00303 00B3           2B05                           sub ax,[di]
00304 00B5           36                             SEG SS
00305 00B6           1B5D         02                sbb bx,2[di]
00306 00B9           C3                             ret
00307                                             ;; mul function
00308                       000000BA              lmull:
00309                       000000BA              lmulul:
00310 00BA     66    25               0000FFFF      and eax, #0x0000FFFF
00311 00C0     66    C1E3                   10      shl ebx, #16
00312 00C4     66    09D8                           or eax, ebx
00313 00C7           36                             SEG SS
00314 00C8     66    F725                           mul eax, dword ptr [di]
00315 00CB     66    89C3                           mov ebx, eax
00316 00CE     66    C1EB                   10      shr ebx, #16
00317 00D2           C3                             ret
00318                                             ;; dec function
00319                       000000D3              ldecl:
00320                       000000D3              ldecul:
00321 00D3           36                             SEG SS
00322 00D4     66    FF0F                           dec dword ptr [bx]
00323 00D7           C3                             ret
00324                                             ;; or function
00325                       000000D8              lorl:
00326                       000000D8              lorul:
00327 00D8           36                             SEG SS
00328 00D9           0B05                           or ax,[di]
00329 00DB           36                             SEG SS
00330 00DC           0B5D         02                or bx,2[di]
00331 00DF           C3                             ret
00332                                             ;; inc function
00333                       000000E0              lincl:
00334                       000000E0              lincul:
00335 00E0           36                             SEG SS
00336 00E1     66    FF07                           inc dword ptr [bx]
00337 00E4           C3                             ret
00338                                             ;; tst function
00339                       000000E5              ltstl:
00340                       000000E5              ltstul:
00341 00E5     66    25               0000FFFF      and eax, #0x0000FFFF
00342 00EB     66    C1E3                   10      shl ebx, #16
00343 00EF     66    09D8                           or eax, ebx
00344 00F2     66    C1EB                   10      shr ebx, #16
00345 00F6     66    85C0                           test eax, eax
00346 00F9           C3                             ret
00347                                             ;; sr function
00348                       000000FA              lsrul:
00349 00FA           89F9                           mov cx,di
00350 00FC           E3           19                jcxz lsr_exit
00351 00FE     66    25               0000FFFF      and eax, #0x0000FFFF
00352 0104     66    C1E3                   10      shl ebx, #16
00353 0108     66    09D8                           or eax, ebx
00354                       0000010B              lsr_loop:
00355 010B     66    D1E8                           shr eax, #1
00356 010E           E2           FB                loop lsr_loop
00357 0110     66    89C3                           mov ebx, eax
00358 0113     66    C1EB                   10      shr ebx, #16
00359                       00000117              lsr_exit:
00360 0117           C3                             ret
00361                                             ;; sl function
00362                       00000118              lsll:
00363                       00000118              lslul:
00364 0118           89F9                           mov cx,di
00365 011A           E3           19                jcxz lsl_exit
00366 011C     66    25               0000FFFF      and eax, #0x0000FFFF
00367 0122     66    C1E3                   10      shl ebx, #16
00368 0126     66    09D8                           or eax, ebx
00369                       00000129              lsl_loop:
00370 0129     66    D1E0                           shl eax, #1
00371 012C           E2           FB                loop lsl_loop
00372 012E     66    89C3                           mov ebx, eax
00373 0131     66    C1EB                   10      shr ebx, #16
00374                       00000135              lsl_exit:
00375 0135           C3                             ret
00376                       00000136              idiv_:
00377 0136           99                             cwd
00378 0137           F7FB                           idiv bx
00379 0139           C3                             ret
00380                       0000013A              idiv_u:
00381 013A           31D2                           xor dx,dx
00382 013C           F7F3                           div bx
00383 013E           C3                             ret
00384                       0000013F              ldivul:
00385 013F     66    25               0000FFFF      and eax, #0x0000FFFF
00386 0145     66    C1E3                   10      shl ebx, #16
00387 0149     66    09D8                           or eax, ebx
00388 014C     66    31D2                           xor edx, edx
00389 014F           36                             SEG SS
00390 0150           8B5D         02                mov bx, 2[di]
00391 0153     66    C1E3                   10      shl ebx, #16
00392 0157           36                             SEG SS
00393 0158           8B1D                           mov bx, [di]
00394 015A     66    F7F3                           div ebx
00395 015D     66    89C3                           mov ebx, eax
00396 0160     66    C1EB                   10      shr ebx, #16
00397 0164           C3                             ret
00398                                           ! 312 endasm
00399                                           !BCC_ENDASM
00400                                           ! 313 typedef struct {
00401                                           ! 314   unsigned char filler1[0x400];
00402                                           !BCC_EOS
00403                                           ! 315   unsigned char filler2[0x6c];
00404                                           !BCC_EOS
00405                                           ! 316   Bit16u ticks_low;
00406                                           !BCC_EOS
00407                                           ! 317   Bit16u ticks_high;
00408                                           !BCC_EOS
00409                                           ! 318   Bit8u midnight_flag;
00410                                           !BCC_EOS
00411                                           ! 319 } bios_data_t;
00412                                           !BCC_EOS
00413                                           ! 320   typedef struct {
00414                                           ! 321     Bit16u heads;
00415                                           !BCC_EOS
00416                                           ! 322     Bit16u cylinders;
00417                                           !BCC_EOS
00418                                           ! 323     Bit16u spt;
00419                                           !BCC_EOS
00420                                           ! 324   } chs_t;
00421                                           !BCC_EOS
00422                                           ! 325   typedef struct {
00423                                           ! 326     Bit16u iobase1;
00424                                           !BCC_EOS
00425                                           ! 327     Bit16u iobase2;
00426                                           !BCC_EOS
00427                                           ! 328     Bit8u prefix;
00428                                           !BCC_EOS
00429                                           ! 329     Bit8u unused;
00430                                           !BCC_EOS
00431                                           ! 330     Bit8u irq;
00432                                           !BCC_EOS
00433                                           ! 331     Bit8u blkcount;
00434                                           !BCC_EOS
00435                                           ! 332     Bit8u dma;
00436                                           !BCC_EOS
00437                                           ! 333     Bit8u pio;
00438                                           !BCC_EOS
00439                                           ! 334     Bit16u options;
00440                                           !BCC_EOS
00441                                           ! 335     Bit16u reserved;
00442                                           !BCC_EOS
00443                                           ! 336     Bit8u revision;
00444                                           !BCC_EOS
00445                                           ! 337     Bit8u checksum;
00446                                           !BCC_EOS
00447                                           ! 338   } dpte_t;
00448                                           !BCC_EOS
00449                                           ! 339   typedef struct {
00450                                           ! 340     Bit8u iface;
00451                                           !BCC_EOS
00452                                           ! 341     Bit16u iobase1;
00453                                           !BCC_EOS
00454                                           ! 342     Bit16u iobase2;
00455                                           !BCC_EOS
00456                                           ! 343     Bit8u irq;
00457                                           !BCC_EOS
00458                                           ! 344   } ata_channel_t;
00459                                           !BCC_EOS
00460                                           ! 345   typedef struct {
00461                                           ! 346     Bit8u type;
00462                                           !BCC_EOS
00463                                           ! 347     Bit8u device;
00464                                           !BCC_EOS
00465                                           ! 348     Bit8u removable;
00466                                           !BCC_EOS
00467                                           ! 349     Bit8u lock;
00468                                           !BCC_EOS
00469                                           ! 350     Bit8u mode;
00470                                           !BCC_EOS
00471                                           ! 351     Bit16u blksize;
00472                                           !BCC_EOS
00473                                           ! 352     Bit8u translation;
00474                                           !BCC_EOS
00475                                           ! 353     chs_t lchs;
00476                                           !BCC_EOS
00477                                           ! 354     chs_t pchs;
00478                                           !BCC_EOS
00479                                           ! 355     Bit32u sectors_low;
00480                                           !BCC_EOS
00481                                           ! 356     Bit32u sectors_high;
00482                                           !BCC_EOS
00483                                           ! 357   } ata_device_t;
00484                                           !BCC_EOS
00485                                           ! 358   typedef struct {
00486                                           ! 359     ata_channel_t channels[4];
00487                                           !BCC_EOS
00488                                           ! 360     ata_device_t devices[(4*2)];
00489                                           !BCC_EOS
00490                                           ! 361     Bit8u hdcount, hdidmap[(4*2)];
00491                                           !BCC_EOS
00492                                           ! 362     Bit8u cdcount, cdidmap[(4*2
00493                                           ! 362 )];
00494                                           !BCC_EOS
00495                                           ! 363     dpte_t dpte;
00496                                           !BCC_EOS
00497                                           ! 364     Bit16u trsfsectors;
00498                                           !BCC_EOS
00499                                           ! 365     Bit32u trsfbytes;
00500                                           !BCC_EOS
00501                                           ! 366   } ata_t;
00502                                           !BCC_EOS
00503                                           ! 367   typedef struct {
00504                                           ! 368     Bit8u active;
00505                                           !BCC_EOS
00506                                           ! 369     Bit8u media;
00507                                           !BCC_EOS
00508                                           ! 370     Bit8u emulated_drive;
00509                                           !BCC_EOS
00510                                           ! 371     Bit8u controller_index;
00511                                           !BCC_EOS
00512                                           ! 372     Bit16u device_spec;
00513                                           !BCC_EOS
00514                                           ! 373     Bit32u ilba;
00515                                           !BCC_EOS
00516                                           ! 374     Bit16u buffer_segment;
00517                                           !BCC_EOS
00518                                           ! 375     Bit16u load_segment;
00519                                           !BCC_EOS
00520                                           ! 376     Bit16u sector_count;
00521                                           !BCC_EOS
00522                                           ! 377     chs_t vdevice;
00523                                           !BCC_EOS
00524                                           ! 378   } cdemu_t;
00525                                           !BCC_EOS
00526                                           ! 379   typedef struct {
00527                                           ! 380     Bit8u size;
00528                                           !BCC_EOS
00529                                           ! 381     unsigned char filler0[0x21];
00530                                           !BCC_EOS
00531                                           ! 382     Bit16u mouse_driver_offset;
00532                                           !BCC_EOS
00533                                           ! 383     Bit16u mouse_driver_seg;
00534                                           !BCC_EOS
00535                                           ! 384     Bit8u mouse_flag1;
00536                                           !BCC_EOS
00537                                           ! 385     Bit8u mouse_flag2;
00538                                           !BCC_EOS
00539                                           ! 386     Bit8u mouse_data[0x08];
00540                                           !BCC_EOS
00541                                           ! 387     unsigned char filler1[0x0D];
00542                                           !BCC_EOS
00543                                           ! 388     unsigned char fdpt0[0x10];
00544                                           !BCC_EOS
00545                                           ! 389     unsigned char fdpt1[0x10];
00546                                           !BCC_EOS
00547                                           ! 390     unsigned char filler2[0xC4];
00548                                           !BCC_EOS
00549                                           ! 391     ata_t ata;
00550                                           !BCC_EOS
00551                                           ! 392     cdemu_t cdemu;
00552                                           !BCC_EOS
00553                                           ! 393   } ebda_data_t;
00554                                           !BCC_EOS
00555                                           ! 394   typedef struct {
00556                                           ! 395     Bit8u size;
00557                                           !BCC_EOS
00558                                           ! 396     Bit8u reserved;
00559                                           !BCC_EOS
00560                                           ! 397     Bit16u count;
00561                                           !BCC_EOS
00562                                           ! 398     Bit16u offset;
00563                                           !BCC_EOS
00564                                           ! 399     Bit16u segment;
00565                                           !BCC_EOS
00566                                           ! 400     Bit32u lba1;
00567                                           !BCC_EOS
00568                                           ! 401     Bit32u lba2;
00569                                           !BCC_EOS
00570                                           ! 402   } int13ext_t;
00571                                           !BCC_EOS
00572                                           ! 403   typedef struct {
00573                                           ! 404     Bit16u size;
00574                                           !BCC_EOS
00575                                           ! 405     Bit16u infos;
00576                                           !BCC_EOS
00577                                           ! 406     Bit32u cylinders;
00578                                           !BCC_EOS
00579                                           ! 407     Bit32u heads;
00580                                           !BCC_EOS
00581                                           ! 408     Bit32u spt;
00582                                           !BCC_EOS
00583                                           ! 409     Bit32u sector_count1;
00584                                           !BCC_EOS
00585                                           ! 410     Bit32u sector_count2;
00586                                           !BCC_EOS
00587                                           ! 411     Bit16u blksize;
00588                                           !BCC_EOS
00589                                           ! 412     Bit16u dpte_offset;
00590                                           !BCC_EOS
00591                                           ! 413     Bit16u dpte_segment;
00592                                           !BCC_EOS
00593                                           ! 414     union {
00594                                           ! 415       struct {
00595                                           ! 416         Bit16u key;
00596                                           !BCC_EOS
00597                                           ! 417         Bit8u dpi_length;
00598                                           !BCC_EOS
00599                                           ! 418         Bit8u reserved1;
00600                                           !BCC_EOS
00601                                           ! 419         Bit16u reserved2;
00602                                           !BCC_EOS
00603                                           ! 420         Bit8u host_bus[4];
00604                                           !BCC_EOS
00605                                           ! 421         Bit8u iface_type[8];
00606                                           !BCC_EOS
00607                                           ! 422         Bit8u iface_path[8];
00608                                           !BCC_EOS
00609                                           ! 423         Bit8u device_path[8];
00610                                           !BCC_EOS
00611                                           ! 424         Bit8u reserved3;
00612                                           !BCC_EOS
00613                                           ! 425         Bit8u checksum;
00614                                           !BCC_EOS
00615                                           ! 426       } phoenix;
00616                                           !BCC_EOS
00617                                           ! 427       struct {
00618                                           ! 428         Bit16u key;
00619                                           !BCC_EOS
00620                                           ! 429         Bit8u dpi_length;
00621                                           !BCC_EOS
00622                                           ! 430         Bit8u reserved1;
00623                                           !BCC_EOS
00624                                           ! 431         Bit16u reserved2;
00625                                           !BCC_EOS
00626                                           ! 432         Bit8u host_bus[4];
00627                                           !BCC_EOS
00628                                           ! 433         Bit8u iface_type[8];
00629                                           !BCC_EOS
00630                                           ! 434         Bit8u iface_path[8];
00631                                           !BCC_EOS
00632                                           ! 435         Bit8u device_path[16];
00633                                           !BCC_EOS
00634                                           ! 436         Bit8u reserved3;
00635                                           !BCC_EOS
00636                                           ! 437         Bit8u checksum;
00637                                           !BCC_EOS
00638                                           ! 438       } t13;
00639                                           !BCC_EOS
00640                                           ! 439     } dpi;
00641                                           !BCC_EOS
00642                                           ! 440   } dpt_t;
00643                                           !BCC_EOS
00644                                           ! 441 typedef struct {
00645                                           ! 442   union {
00646                                           ! 443     struct {
00647                                           ! 444       Bit16u di, si, bp, sp;
00648                                           !BCC_EOS
00649                                           ! 445       Bit16u bx, dx, cx, ax;
00650                                           !BCC_EOS
00651                                           ! 446     } r16;
00652                                           !BCC_EOS
00653                                           ! 447     struct {
00654                                           ! 448       Bit16u filler[4];
00655                                           !BCC_EOS
00656                                           ! 449       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00657                                           !BCC_EOS
00658                                           ! 450     } r8;
00659                                           !BCC_EOS
00660                                           ! 451   } u;
00661                                           !BCC_EOS
00662                                           ! 452 } pusha_regs_t;
00663                                           !BCC_EOS
00664                                           ! 453 typedef struct {
00665                                           ! 454  union {
00666                                           ! 455   struct {
00667                                           ! 456     Bit32u edi, esi, ebp, esp;
00668                                           !BCC_EOS
00669                                           ! 457     Bit32u ebx, edx, ecx, eax
00670                                           ! 457 ;
00671                                           !BCC_EOS
00672                                           ! 458   } r32;
00673                                           !BCC_EOS
00674                                           ! 459   struct {
00675                                           ! 460     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00676                                           !BCC_EOS
00677                                           ! 461     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00678                                           !BCC_EOS
00679                                           ! 462   } r16;
00680                                           !BCC_EOS
00681                                           ! 463   struct {
00682                                           ! 464     Bit32u filler[4];
00683                                           !BCC_EOS
00684                                           ! 465     Bit8u bl, bh;
00685                                           !BCC_EOS
00686                                           ! 466     Bit16u filler1;
00687                                           !BCC_EOS
00688                                           ! 467     Bit8u dl, dh;
00689                                           !BCC_EOS
00690                                           ! 468     Bit16u filler2;
00691                                           !BCC_EOS
00692                                           ! 469     Bit8u cl, ch;
00693                                           !BCC_EOS
00694                                           ! 470     Bit16u filler3;
00695                                           !BCC_EOS
00696                                           ! 471     Bit8u al, ah;
00697                                           !BCC_EOS
00698                                           ! 472     Bit16u filler4;
00699                                           !BCC_EOS
00700                                           ! 473   } r8;
00701                                           !BCC_EOS
00702                                           ! 474  } u;
00703                                           !BCC_EOS
00704                                           ! 475 } pushad_regs_t;
00705                                           !BCC_EOS
00706                                           ! 476 typedef struct {
00707                                           ! 477   union {
00708                                           ! 478     struct {
00709                                           ! 479       Bit16u flags;
00710                                           !BCC_EOS
00711                                           ! 480     } r16;
00712                                           !BCC_EOS
00713                                           ! 481     struct {
00714                                           ! 482       Bit8u flagsl;
00715                                           !BCC_EOS
00716                                           ! 483       Bit8u flagsh;
00717                                           !BCC_EOS
00718                                           ! 484     } r8;
00719                                           !BCC_EOS
00720                                           ! 485   } u;
00721                                           !BCC_EOS
00722                                           ! 486 } flags_t;
00723                                           !BCC_EOS
00724                                           ! 487 typedef struct {
00725                                           ! 488   Bit16u ip;
00726                                           !BCC_EOS
00727                                           ! 489   Bit16u cs;
00728                                           !BCC_EOS
00729                                           ! 490   flags_t flags;
00730                                           !BCC_EOS
00731                                           ! 491 } iret_addr_t;
00732                                           !BCC_EOS
00733                                           ! 492 typedef struct {
00734                                           ! 493   Bit16u type;
00735                                           !BCC_EOS
00736                                           ! 494   Bit16u flags;
00737                                           !BCC_EOS
00738                                           ! 495   Bit32u vector;
00739                                           !BCC_EOS
00740                                           ! 496   Bit32u description;
00741                                           !BCC_EOS
00742                                           ! 497   Bit32u reserved;
00743                                           !BCC_EOS
00744                                           ! 498 } ipl_entry_t;
00745                                           !BCC_EOS
00746                                           ! 499 static Bit8u inb();
00747                                           !BCC_EOS
00748                                           ! 500 static Bit8u inb_cmos();
00749                                           !BCC_EOS
00750                                           ! 501 static void outb();
00751                                           !BCC_EOS
00752                                           ! 502 static void outb_cmos();
00753                                           !BCC_EOS
00754                                           ! 503 static Bit16u inw();
00755                                           !BCC_EOS
00756                                           ! 504 static void outw();
00757                                           !BCC_EOS
00758                                           ! 505 static void init_rtc();
00759                                           !BCC_EOS
00760                                           ! 506 static bx_bool rtc_updating();
00761                                           !BCC_EOS
00762                                           ! 507 static Bit8u _read_byte();
00763                                           !BCC_EOS
00764                                           ! 508 static Bit16u _read_word();
00765                                           !BCC_EOS
00766                                           ! 509 static void _write_byte();
00767                                           !BCC_EOS
00768                                           ! 510 static void _write_word();
00769                                           !BCC_EOS
00770                                           ! 511 static Bit8u read_byte_SS();
00771                                           !BCC_EOS
00772                                           ! 512 static Bit16u read_word_SS();
00773                                           !BCC_EOS
00774                                           ! 513 static void _write_byte_SS();
00775                                           !BCC_EOS
00776                                           ! 514 static void _write_word_SS();
00777                                           !BCC_EOS
00778                                           ! 515 static void bios_printf();
00779                                           !BCC_EOS
00780                                           ! 516 static Bit8u inhibit_mouse_int_and_events();
00781                                           !BCC_EOS
00782                                           ! 517 static void enable_mouse_int_and_events();
00783                                           !BCC_EOS
00784                                           ! 518 static Bit8u send_to_mouse_ctrl();
00785                                           !BCC_EOS
00786                                           ! 519 static Bit8u get_mouse_data();
00787                                           !BCC_EOS
00788                                           ! 520 static void set_kbd_command_byte();
00789                                           !BCC_EOS
00790                                           ! 521 static void int09_function();
00791                                           !BCC_EOS
00792                                           ! 522 static void int13_harddisk();
00793                                           !BCC_EOS
00794                                           ! 523 static void int13_cdrom();
00795                                           !BCC_EOS
00796                                           ! 524 static void int13_cdemu();
00797                                           !BCC_EOS
00798                                           ! 525 static void int13_eltorito();
00799                                           !BCC_EOS
00800                                           ! 526 static void int13_diskette_function();
00801                                           !BCC_EOS
00802                                           ! 527 static void int14_function();
00803                                           !BCC_EOS
00804                                           ! 528 static void int15_function();
00805                                           !BCC_EOS
00806                                           ! 529 static void int16_function();
00807                                           !BCC_EOS
00808                                           ! 530 static void int17_function();
00809                                           !BCC_EOS
00810                                           ! 531 static void int19_function();
00811                                           !BCC_EOS
00812                                           ! 532 static void int1a_function();
00813                                           !BCC_EOS
00814                                           ! 533 static void int70_function();
00815                                           !BCC_EOS
00816                                           ! 534 static void int74_function();
00817                                           !BCC_EOS
00818                                           ! 535 static Bit16u get_CS();
00819                                           !BCC_EOS
00820                                           ! 536 static Bit16u get_SS();
00821                                           !BCC_EOS
00822                                           ! 537 static Bit16u set_DS();
00823                                           !BCC_EOS
00824                                           ! 538 static unsigned int enqueue_key();
00825                                           !BCC_EOS
00826                                           ! 539 static unsigned int dequeue_key();
00827                                           !BCC_EOS
00828                                           ! 540 static void get_hd_geometry();
00829                                           !BCC_EOS
00830                                           ! 541 static void set_diskette_ret_status();
00831                                           !BCC_EOS
00832                                           ! 542 static void set_diskette_current_cyl();
00833                                           !BCC_EOS
00834                                           ! 543 static void determine
00835                                           ! 543 _floppy_media();
00836                                           !BCC_EOS
00837                                           ! 544 static bx_bool floppy_drive_exists();
00838                                           !BCC_EOS
00839                                           ! 545 static bx_bool floppy_drive_recal();
00840                                           !BCC_EOS
00841                                           ! 546 static bx_bool floppy_media_known();
00842                                           !BCC_EOS
00843                                           ! 547 static bx_bool floppy_media_sense();
00844                                           !BCC_EOS
00845                                           ! 548 static bx_bool set_enable_a20();
00846                                           !BCC_EOS
00847                                           ! 549 static void debugger_on();
00848                                           !BCC_EOS
00849                                           ! 550 static void debugger_off();
00850                                           !BCC_EOS
00851                                           ! 551 static void keyboard_init();
00852                                           !BCC_EOS
00853                                           ! 552 static void keyboard_panic();
00854                                           !BCC_EOS
00855                                           ! 553 static void shutdown_status_panic();
00856                                           !BCC_EOS
00857                                           ! 554 static void nmi_handler_msg();
00858                                           !BCC_EOS
00859                                           ! 555 static void delay_ticks();
00860                                           !BCC_EOS
00861                                           ! 556 static void delay_ticks_and_check_for_keystroke();
00862                                           !BCC_EOS
00863                                           ! 557 static void interactive_bootkey();
00864                                           !BCC_EOS
00865                                           ! 558 static void print_bios_banner();
00866                                           !BCC_EOS
00867                                           ! 559 static void print_boot_device();
00868                                           !BCC_EOS
00869                                           ! 560 static void print_boot_failure();
00870                                           !BCC_EOS
00871                                           ! 561 static void print_cdromboot_failure();
00872                                           !BCC_EOS
00873                                           ! 562 void ata_init();
00874                                           !BCC_EOS
00875                                           ! 563 void ata_detect();
00876                                           !BCC_EOS
00877                                           ! 564 void ata_reset();
00878                                           !BCC_EOS
00879                                           ! 565 Bit16u ata_cmd_non_data();
00880                                           !BCC_EOS
00881                                           ! 566 Bit16u ata_cmd_data_io();
00882                                           !BCC_EOS
00883                                           ! 567 Bit16u ata_cmd_packet();
00884                                           !BCC_EOS
00885                                           ! 568 Bit16u atapi_get_sense();
00886                                           !BCC_EOS
00887                                           ! 569 Bit16u atapi_is_ready();
00888                                           !BCC_EOS
00889                                           ! 570 Bit16u atapi_is_cdrom();
00890                                           !BCC_EOS
00891                                           ! 571 void cdemu_init();
00892                                           !BCC_EOS
00893                                           ! 572 Bit8u cdemu_isactive();
00894                                           !BCC_EOS
00895                                           ! 573 Bit8u cdemu_emulated_drive();
00896                                           !BCC_EOS
00897                                           ! 574 Bit16u cdrom_boot();
00898                                           !BCC_EOS
00899                                           ! 575 static char bios_svn_version_string[] = "$Revision: 14314 $ $Date: 2021-07-14 18:10:19 +0200 (Mi, 14. Jul 2021) $";
00900                                           
00901                       00000165            _bios_svn_version_string:
00902                       00000165            .1:
00903 0165                        24            .ascii	"$Revision: 14314 $ $Date: 2021-07-14 18:"
00904 018D                        31            .ascii	"10:19 +0200 (Mi, 14. Jul 2021) $"
00905 01AD                        00            .byte	0
00906                                           !BCC_EOS
00907                                           ! 576 static struct {
00908                                           ! 577   Bit16u normal;
00909                                           !BCC_EOS
00910                                           ! 578   Bit16u shift;
00911                                           !BCC_EOS
00912                                           ! 579   Bit16u control;
00913                                           !BCC_EOS
00914                                           ! 580   Bit16u alt;
00915                                           !BCC_EOS
00916                                           ! 581   Bit8u lock_flags;
00917                                           !BCC_EOS
00918                                           ! 582   } scan_to_scanascii[0x58 + 1] = {
00919 01AE                  00000001            .blkb	1
00920                       000001AF            _scan_to_scanascii:
00921                                           ! 583       { 0, 0, 0, 0, 0 },
00922 01AF                      0000            .word	0
00923 01B1                      0000            .word	0
00924 01B3                      0000            .word	0
00925 01B5                      0000            .word	0
00926 01B7                        00            .byte	0
00927 01B8                  00000001            .blkb	1
00928                                           ! 584       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00929 01B9                      011B            .word	$11B
00930 01BB                      011B            .word	$11B
00931 01BD                      011B            .word	$11B
00932 01BF                      0100            .word	$100
00933 01C1                        00            .byte	0
00934 01C2                  00000001            .blkb	1
00935                                           ! 585       { 0x0231, 0x0221, 0, 0x7800, 0 },
00936 01C3                      0231            .word	$231
00937 01C5                      0221            .word	$221
00938 01C7                      0000            .word	0
00939 01C9                      7800            .word	$7800
00940 01CB                        00            .byte	0
00941 01CC                  00000001            .blkb	1
00942                                           ! 586       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00943 01CD                      0332            .word	$332
00944 01CF                      0340            .word	$340
00945 01D1                      0300            .word	$300
00946 01D3                      7900            .word	$7900
00947 01D5                        00            .byte	0
00948 01D6                  00000001            .blkb	1
00949                                           ! 587       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00950 01D7                      0433            .word	$433
00951 01D9                      0423            .word	$423
00952 01DB                      0000            .word	0
00953 01DD                      7A00            .word	$7A00
00954 01DF                        00            .byte	0
00955 01E0                  00000001            .blkb	1
00956                                           ! 588       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00957 01E1                      0534            .word	$534
00958 01E3                      0524            .word	$524
00959 01E5                      0000            .word	0
00960 01E7                      7B00            .word	$7B00
00961 01E9                        00            .byte	0
00962 01EA                  00000001            .blkb	1
00963                                           ! 589       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00964 01EB                      0635            .word	$635
00965 01ED                      0625            .word	$625
00966 01EF                      0000            .word	0
00967 01F1                      7C00            .word	$7C00
00968 01F3                        00            .byte	0
00969 01F4                  00000001            .blkb	1
00970                                           ! 590       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00971 01F5                      0736            .word	$736
00972 01F7                      075E            .word	$75E
00973 01F9                      071E            .word	$71E
00974 01FB                      7D00            .word	$7D00
00975 01FD                        00            .byte	0
00976 01FE                  00000001            .blkb	1
00977                                           ! 591       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00978 01FF                      0837            .word	$837
00979 0201                      0826            .word	$826
00980 0203                      0000            .word	0
00981 0205                      7E00            .word	$7E00
00982 0207                        00            .byte	0
00983 0208                  00000001            .blkb	1
00984                                           ! 592       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00985 0209                      0938            .word	$938
00986 020B                      092A            .word	$92A
00987 020D                      0000            .word	0
00988 020F                      7F00            .word	$7F00
00989 0211                        00            .byte	0
00990 0212                  00000001            .blkb	1
00991                                           ! 593       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00992 0213                      0A39            .word	$A39
00993 0215                      0A28            .word	$A28
00994 0217                      0000            .word	0
00995 0219                      8000            .word	$8000
00996 021B                        00            .byte	0
00997 021C                  00000001            .blkb	1
00998                                           ! 594       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00999 021D                      0B30            .word	$B30
01000 021F                      0B29            .word	$B29
01001 0221                      0000            .word	0
01002 0223                      8100            .word	$8100
01003 0225                        00            .byte	0
01004 0226                  00000001            .blkb	1
01005                                           ! 595       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01006 0227                      0C2D            .word	$C2D
01007 0229                      0C5F            .word	$C5F
01008 022B                      0C1F            .word	$C1F
01009 022D                      8200            .word	$8200
01010 022F                        00            .byte	0
01011 0230                  00000001            .blkb	1
01012                                           ! 596       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01013 0231                      0D3D            .word	$D3D
01014 0233                      0D2B            .word	$D2B
01015 0235                      0000            .word	0
01016 0237                      8300            .word	$8300
01017 0239                        00            .byte	0
01018 023A                  00000001            .blkb	1
01019                                           ! 597       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01020 023B                      0E08            .word	$E08
01021 023D                      0E08            .word	$E08
01022 023F                      0E7F            .word	$E7F
01023 0241                      0000            .word	0
01024 0243                        00            .byte	0
01025 0244                  00000001            .blkb	1
01026                                           ! 598       { 0x0f09, 0x0f00, 0, 0, 0 },
01027 0245                      0F09            .word	$F09
01028 0247                      0F00            .word	$F00
01029 0249                      0000            .word	0
01030 024B                      0000            .word	0
01031 024D                        00            .byte	0
01032 024E                  00000001            .blkb	1
01033                                           ! 599       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01034 024F                      1071            .word	$1071
01035 0251                      1051            .word	$1051
01036 0253                      1011            .word	$1011
01037 0255                      1000            .word	$1000
01038 0257                        40            .byte	$40
01039 0258                  00000001            .blkb	1
01040                                           ! 600       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01041 0259                      1177            .word	$1177
01042 025B                      1157            .word	$1157
01043 025D                      1117            .word	$1117
01044 025F                      1100            .word	$1100
01045 0261                        40            .byte	$40
01046 0262                  00000001            .blkb	1
01047                                           ! 601       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01048 0263                      1265            .word	$1265
01049 0265                      1245            .word	$1245
01050 0267                      1205            .word	$1205
01051 0269                      1200            .word	$1200
01052 026B                        40            .byte	$40
01053 026C                  00000001            .blkb	1
01054                                           ! 602       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01055 026D                      1372            .word	$1372
01056 026F                      1352            .word	$1352
01057 0271                      1312            .word	$1312
01058 0273                      1300            .word	$1300
01059 0275                        40            .byte	$40
01060 0276                  00000001            .blkb	1
01061                                           ! 603       { 0x1474, 0x1454, 0x14
01062 0277                      1474            .word	$1474
01063 0279                      1454            .word	$1454
01064                                           ! 603 14, 0x1400, 0x40 },
01065 027B                      1414            .word	$1414
01066 027D                      1400            .word	$1400
01067 027F                        40            .byte	$40
01068 0280                  00000001            .blkb	1
01069                                           ! 604       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01070 0281                      1579            .word	$1579
01071 0283                      1559            .word	$1559
01072 0285                      1519            .word	$1519
01073 0287                      1500            .word	$1500
01074 0289                        40            .byte	$40
01075 028A                  00000001            .blkb	1
01076                                           ! 605       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01077 028B                      1675            .word	$1675
01078 028D                      1655            .word	$1655
01079 028F                      1615            .word	$1615
01080 0291                      1600            .word	$1600
01081 0293                        40            .byte	$40
01082 0294                  00000001            .blkb	1
01083                                           ! 606       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01084 0295                      1769            .word	$1769
01085 0297                      1749            .word	$1749
01086 0299                      1709            .word	$1709
01087 029B                      1700            .word	$1700
01088 029D                        40            .byte	$40
01089 029E                  00000001            .blkb	1
01090                                           ! 607       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01091 029F                      186F            .word	$186F
01092 02A1                      184F            .word	$184F
01093 02A3                      180F            .word	$180F
01094 02A5                      1800            .word	$1800
01095 02A7                        40            .byte	$40
01096 02A8                  00000001            .blkb	1
01097                                           ! 608       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01098 02A9                      1970            .word	$1970
01099 02AB                      1950            .word	$1950
01100 02AD                      1910            .word	$1910
01101 02AF                      1900            .word	$1900
01102 02B1                        40            .byte	$40
01103 02B2                  00000001            .blkb	1
01104                                           ! 609       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01105 02B3                      1A5B            .word	$1A5B
01106 02B5                      1A7B            .word	$1A7B
01107 02B7                      1A1B            .word	$1A1B
01108 02B9                      0000            .word	0
01109 02BB                        00            .byte	0
01110 02BC                  00000001            .blkb	1
01111                                           ! 610       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01112 02BD                      1B5D            .word	$1B5D
01113 02BF                      1B7D            .word	$1B7D
01114 02C1                      1B1D            .word	$1B1D
01115 02C3                      0000            .word	0
01116 02C5                        00            .byte	0
01117 02C6                  00000001            .blkb	1
01118                                           ! 611       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01119 02C7                      1C0D            .word	$1C0D
01120 02C9                      1C0D            .word	$1C0D
01121 02CB                      1C0A            .word	$1C0A
01122 02CD                      0000            .word	0
01123 02CF                        00            .byte	0
01124 02D0                  00000001            .blkb	1
01125                                           ! 612       { 0, 0, 0, 0, 0 },
01126 02D1                      0000            .word	0
01127 02D3                      0000            .word	0
01128 02D5                      0000            .word	0
01129 02D7                      0000            .word	0
01130 02D9                        00            .byte	0
01131 02DA                  00000001            .blkb	1
01132                                           ! 613       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01133 02DB                      1E61            .word	$1E61
01134 02DD                      1E41            .word	$1E41
01135 02DF                      1E01            .word	$1E01
01136 02E1                      1E00            .word	$1E00
01137 02E3                        40            .byte	$40
01138 02E4                  00000001            .blkb	1
01139                                           ! 614       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01140 02E5                      1F73            .word	$1F73
01141 02E7                      1F53            .word	$1F53
01142 02E9                      1F13            .word	$1F13
01143 02EB                      1F00            .word	$1F00
01144 02ED                        40            .byte	$40
01145 02EE                  00000001            .blkb	1
01146                                           ! 615       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01147 02EF                      2064            .word	$2064
01148 02F1                      2044            .word	$2044
01149 02F3                      2004            .word	$2004
01150 02F5                      2000            .word	$2000
01151 02F7                        40            .byte	$40
01152 02F8                  00000001            .blkb	1
01153                                           ! 616       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01154 02F9                      2166            .word	$2166
01155 02FB                      2146            .word	$2146
01156 02FD                      2106            .word	$2106
01157 02FF                      2100            .word	$2100
01158 0301                        40            .byte	$40
01159 0302                  00000001            .blkb	1
01160                                           ! 617       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01161 0303                      2267            .word	$2267
01162 0305                      2247            .word	$2247
01163 0307                      2207            .word	$2207
01164 0309                      2200            .word	$2200
01165 030B                        40            .byte	$40
01166 030C                  00000001            .blkb	1
01167                                           ! 618       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01168 030D                      2368            .word	$2368
01169 030F                      2348            .word	$2348
01170 0311                      2308            .word	$2308
01171 0313                      2300            .word	$2300
01172 0315                        40            .byte	$40
01173 0316                  00000001            .blkb	1
01174                                           ! 619       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01175 0317                      246A            .word	$246A
01176 0319                      244A            .word	$244A
01177 031B                      240A            .word	$240A
01178 031D                      2400            .word	$2400
01179 031F                        40            .byte	$40
01180 0320                  00000001            .blkb	1
01181                                           ! 620       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01182 0321                      256B            .word	$256B
01183 0323                      254B            .word	$254B
01184 0325                      250B            .word	$250B
01185 0327                      2500            .word	$2500
01186 0329                        40            .byte	$40
01187 032A                  00000001            .blkb	1
01188                                           ! 621       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01189 032B                      266C            .word	$266C
01190 032D                      264C            .word	$264C
01191 032F                      260C            .word	$260C
01192 0331                      2600            .word	$2600
01193 0333                        40            .byte	$40
01194 0334                  00000001            .blkb	1
01195                                           ! 622       { 0x273b, 0x273a, 0, 0, 0 },
01196 0335                      273B            .word	$273B
01197 0337                      273A            .word	$273A
01198 0339                      0000            .word	0
01199 033B                      0000            .word	0
01200 033D                        00            .byte	0
01201 033E                  00000001            .blkb	1
01202                                           ! 623       { 0x2827, 0x2822, 0, 0, 0 },
01203 033F                      2827            .word	$2827
01204 0341                      2822            .word	$2822
01205 0343                      0000            .word	0
01206 0345                      0000            .word	0
01207 0347                        00            .byte	0
01208 0348                  00000001            .blkb	1
01209                                           ! 624       { 0x2960, 0x297e, 0, 0, 0 },
01210 0349                      2960            .word	$2960
01211 034B                      297E            .word	$297E
01212 034D                      0000            .word	0
01213 034F                      0000            .word	0
01214 0351                        00            .byte	0
01215 0352                  00000001            .blkb	1
01216                                           ! 625       { 0, 0, 0, 0, 0 },
01217 0353                      0000            .word	0
01218 0355                      0000            .word	0
01219 0357                      0000            .word	0
01220 0359                      0000            .word	0
01221 035B                        00            .byte	0
01222 035C                  00000001            .blkb	1
01223                                           ! 626       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01224 035D                      2B5C            .word	$2B5C
01225 035F                      2B7C            .word	$2B7C
01226 0361                      2B1C            .word	$2B1C
01227 0363                      0000            .word	0
01228 0365                        00            .byte	0
01229 0366                  00000001            .blkb	1
01230                                           ! 627       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01231 0367                      2C7A            .word	$2C7A
01232 0369                      2C5A            .word	$2C5A
01233 036B                      2C1A            .word	$2C1A
01234 036D                      2C00            .word	$2C00
01235 036F                        40            .byte	$40
01236 0370                  00000001            .blkb	1
01237                                           ! 628       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01238 0371                      2D78            .word	$2D78
01239 0373                      2D58            .word	$2D58
01240 0375                      2D18            .word	$2D18
01241 0377                      2D00            .word	$2D00
01242 0379                        40            .byte	$40
01243 037A                  00000001            .blkb	1
01244                                           ! 629       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01245 037B                      2E63            .word	$2E63
01246 037D                      2E43            .word	$2E43
01247 037F                      2E03            .word	$2E03
01248 0381                      2E00            .word	$2E00
01249 0383                        40            .byte	$40
01250 0384                  00000001            .blkb	1
01251                                           ! 630       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01252 0385                      2F76            .word	$2F76
01253 0387                      2F56            .word	$2F56
01254 0389                      2F16            .word	$2F16
01255 038B                      2F00            .word	$2F00
01256 038D                        40            .byte	$40
01257 038E                  00000001            .blkb	1
01258                                           ! 631       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01259 038F                      3062            .word	$3062
01260 0391                      3042            .word	$3042
01261 0393                      3002            .word	$3002
01262 0395                      3000            .word	$3000
01263 0397                        40            .byte	$40
01264 0398                  00000001            .blkb	1
01265                                           ! 632       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01266 0399                      316E            .word	$316E
01267 039B                      314E            .word	$314E
01268 039D                      310E            .word	$310E
01269 039F                      3100            .word	$3100
01270 03A1                        40            .byte	$40
01271 03A2                  00000001            .blkb	1
01272                                           ! 633       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01273 03A3                      326D            .word	$326D
01274 03A5                      324D            .word	$324D
01275 03A7                      320D            .word	$320D
01276 03A9                      3200            .word	$3200
01277 03AB                        40            .byte	$40
01278 03AC                  00000001            .blkb	1
01279                                           ! 634       { 0x332c, 0x333c, 0, 0, 0 },
01280 03AD                      332C            .word	$332C
01281 03AF                      333C            .word	$333C
01282 03B1                      0000            .word	0
01283 03B3                      0000            .word	0
01284 03B5                        00            .byte	0
01285 03B6                  00000001            .blkb	1
01286                                           ! 635       { 0x342e, 0x343e, 0, 0, 0 },
01287 03B7                      342E            .word	$342E
01288 03B9                      343E            .word	$343E
01289 03BB                      0000            .word	0
01290 03BD                      0000            .word	0
01291 03BF                        00            .byte	0
01292 03C0                  00000001            .blkb	1
01293                                           ! 636       { 0x352f, 0x353f, 0, 0, 0 },
01294 03C1                      352F            .word	$352F
01295 03C3                      353F            .word	$353F
01296 03C5                      0000            .word	0
01297 03C7                      0000            .word	0
01298 03C9                        00            .byte	0
01299 03CA                  00000001            .blkb	1
01300                                           ! 637       { 0, 0, 0, 0, 0 },
01301 03CB                      0000            .word	0
01302 03CD                      0000            .word	0
01303 03CF                      0000            .word	0
01304 03D1                      0000            .word	0
01305 03D3                        00            .byte	0
01306 03D4                  00000001            .blkb	1
01307                                           ! 638       { 0x372a, 0x372a, 0, 0, 0 },
01308 03D5                      372A            .word	$372A
01309 03D7                      372A            .word	$372A
01310 03D9                      0000            .word	0
01311 03DB                      0000            .word	0
01312 03DD                        00            .byte	0
01313 03DE                  00000001            .blkb	1
01314                                           ! 639       { 0, 0, 0, 0, 0 },
01315 03DF                      0000            .word	0
01316 03E1                      0000            .word	0
01317 03E3                      0000            .word	0
01318 03E5                      0000            .word	0
01319 03E7                        00            .byte	0
01320 03E8                  00000001            .blkb	1
01321                                           ! 640       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01322 03E9                      3920            .word	$3920
01323 03EB                      3920            .word	$3920
01324 03ED                      3920            .word	$3920
01325 03EF                      3920            .word	$3920
01326 03F1                        00            .byte	0
01327 03F2                  00000001            .blkb	1
01328                                           ! 641       { 0, 0, 0, 0, 0 },
01329 03F3                      0000            .word	0
01330 03F5                      0000            .word	0
01331 03F7                      0000            .word	0
01332 03F9                      0000            .word	0
01333 03FB                        00            .byte	0
01334 03FC                  00000001            .blkb	1
01335                                           ! 642       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01336 03FD                      3B00            .word	$3B00
01337 03FF                      5400            .word	$5400
01338 0401                      5E00            .word	$5E00
01339 0403                      6800            .word	$6800
01340 0405                        00            .byte	0
01341 0406                  00000001            .blkb	1
01342                                           ! 643       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01343 0407                      3C00            .word	$3C00
01344 0409                      5500            .word	$5500
01345 040B                      5F00            .word	$5F00
01346 040D                      6900            .word	$6900
01347 040F                        00            .byte	0
01348 0410                  00000001            .blkb	1
01349                                           ! 644       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01350 0411                      3D00            .word	$3D00
01351 0413                      5600            .word	$5600
01352 0415                      6000            .word	$6000
01353 0417                      6A00            .word	$6A00
01354 0419                        00            .byte	0
01355 041A                  00000001            .blkb	1
01356                                           ! 645       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01357 041B                      3E00            .word	$3E00
01358 041D                      5700            .word	$5700
01359 041F                      6100            .word	$6100
01360 0421                      6B00            .word	$6B00
01361 0423                        00            .byte	0
01362 0424                  00000001            .blkb	1
01363                                           ! 646       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01364 0425                      3F00            .word	$3F00
01365 0427                      5800            .word	$5800
01366 0429                      6200            .word	$6200
01367 042B                      6C00            .word	$6C00
01368 042D                        00            .byte	0
01369 042E                  00000001            .blkb	1
01370                                           ! 647       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01371 042F                      4000            .word	$4000
01372 0431                      5900            .word	$5900
01373 0433                      6300            .word	$6300
01374 0435                      6D00            .word	$6D00
01375 0437                        00            .byte	0
01376 0438                  00000001            .blkb	1
01377                                           ! 648       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01378 0439                      4100            .word	$4100
01379 043B                      5A00            .word	$5A00
01380 043D                      6400            .word	$6400
01381 043F                      6E00            .word	$6E00
01382 0441                        00            .byte	0
01383 0442                  00000001            .blkb	1
01384                                           ! 649       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01385 0443                      4200            .word	$4200
01386 0445                      5B00            .word	$5B00
01387 0447                      6500            .word	$6500
01388 0449                      6F00            .word	$6F00
01389 044B                        00            .byte	0
01390 044C                  00000001            .blkb	1
01391                                           ! 650       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01392 044D                      4300            .word	$4300
01393 044F                      5C00            .word	$5C00
01394 0451                      6600            .word	$6600
01395 0453                      7000            .word	$7000
01396 0455                        00            .byte	0
01397 0456                  00000001            .blkb	1
01398                                           ! 651       { 0x4400, 0x5d00, 0x6700, 0x7100, 
01399 0457                      4400            .word	$4400
01400 0459                      5D00            .word	$5D00
01401 045B                      6700            .word	$6700
01402 045D                      7100            .word	$7100
01403                                           ! 651 0 },
01404 045F                        00            .byte	0
01405 0460                  00000001            .blkb	1
01406                                           ! 652       { 0, 0, 0, 0, 0 },
01407 0461                      0000            .word	0
01408 0463                      0000            .word	0
01409 0465                      0000            .word	0
01410 0467                      0000            .word	0
01411 0469                        00            .byte	0
01412 046A                  00000001            .blkb	1
01413                                           ! 653       { 0, 0, 0, 0, 0 },
01414 046B                      0000            .word	0
01415 046D                      0000            .word	0
01416 046F                      0000            .word	0
01417 0471                      0000            .word	0
01418 0473                        00            .byte	0
01419 0474                  00000001            .blkb	1
01420                                           ! 654       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01421 0475                      4700            .word	$4700
01422 0477                      4737            .word	$4737
01423 0479                      7700            .word	$7700
01424 047B                      0000            .word	0
01425 047D                        20            .byte	$20
01426 047E                  00000001            .blkb	1
01427                                           ! 655       { 0x4800, 0x4838, 0, 0, 0x20 },
01428 047F                      4800            .word	$4800
01429 0481                      4838            .word	$4838
01430 0483                      0000            .word	0
01431 0485                      0000            .word	0
01432 0487                        20            .byte	$20
01433 0488                  00000001            .blkb	1
01434                                           ! 656       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01435 0489                      4900            .word	$4900
01436 048B                      4939            .word	$4939
01437 048D                      8400            .word	$8400
01438 048F                      0000            .word	0
01439 0491                        20            .byte	$20
01440 0492                  00000001            .blkb	1
01441                                           ! 657       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01442 0493                      4A2D            .word	$4A2D
01443 0495                      4A2D            .word	$4A2D
01444 0497                      0000            .word	0
01445 0499                      0000            .word	0
01446 049B                        00            .byte	0
01447 049C                  00000001            .blkb	1
01448                                           ! 658       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01449 049D                      4B00            .word	$4B00
01450 049F                      4B34            .word	$4B34
01451 04A1                      7300            .word	$7300
01452 04A3                      0000            .word	0
01453 04A5                        20            .byte	$20
01454 04A6                  00000001            .blkb	1
01455                                           ! 659       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01456 04A7                      4C00            .word	$4C00
01457 04A9                      4C35            .word	$4C35
01458 04AB                      0000            .word	0
01459 04AD                      0000            .word	0
01460 04AF                        20            .byte	$20
01461 04B0                  00000001            .blkb	1
01462                                           ! 660       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01463 04B1                      4D00            .word	$4D00
01464 04B3                      4D36            .word	$4D36
01465 04B5                      7400            .word	$7400
01466 04B7                      0000            .word	0
01467 04B9                        20            .byte	$20
01468 04BA                  00000001            .blkb	1
01469                                           ! 661       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01470 04BB                      4E2B            .word	$4E2B
01471 04BD                      4E2B            .word	$4E2B
01472 04BF                      0000            .word	0
01473 04C1                      0000            .word	0
01474 04C3                        00            .byte	0
01475 04C4                  00000001            .blkb	1
01476                                           ! 662       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01477 04C5                      4F00            .word	$4F00
01478 04C7                      4F31            .word	$4F31
01479 04C9                      7500            .word	$7500
01480 04CB                      0000            .word	0
01481 04CD                        20            .byte	$20
01482 04CE                  00000001            .blkb	1
01483                                           ! 663       { 0x5000, 0x5032, 0, 0, 0x20 },
01484 04CF                      5000            .word	$5000
01485 04D1                      5032            .word	$5032
01486 04D3                      0000            .word	0
01487 04D5                      0000            .word	0
01488 04D7                        20            .byte	$20
01489 04D8                  00000001            .blkb	1
01490                                           ! 664       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01491 04D9                      5100            .word	$5100
01492 04DB                      5133            .word	$5133
01493 04DD                      7600            .word	$7600
01494 04DF                      0000            .word	0
01495 04E1                        20            .byte	$20
01496 04E2                  00000001            .blkb	1
01497                                           ! 665       { 0x5200, 0x5230, 0, 0, 0x20 },
01498 04E3                      5200            .word	$5200
01499 04E5                      5230            .word	$5230
01500 04E7                      0000            .word	0
01501 04E9                      0000            .word	0
01502 04EB                        20            .byte	$20
01503 04EC                  00000001            .blkb	1
01504                                           ! 666       { 0x5300, 0x532e, 0, 0, 0x20 },
01505 04ED                      5300            .word	$5300
01506 04EF                      532E            .word	$532E
01507 04F1                      0000            .word	0
01508 04F3                      0000            .word	0
01509 04F5                        20            .byte	$20
01510 04F6                  00000001            .blkb	1
01511                                           ! 667       { 0, 0, 0, 0, 0 },
01512 04F7                      0000            .word	0
01513 04F9                      0000            .word	0
01514 04FB                      0000            .word	0
01515 04FD                      0000            .word	0
01516 04FF                        00            .byte	0
01517 0500                  00000001            .blkb	1
01518                                           ! 668       { 0, 0, 0, 0, 0 },
01519 0501                      0000            .word	0
01520 0503                      0000            .word	0
01521 0505                      0000            .word	0
01522 0507                      0000            .word	0
01523 0509                        00            .byte	0
01524 050A                  00000001            .blkb	1
01525                                           ! 669       { 0x565c, 0x567c, 0, 0, 0 },
01526 050B                      565C            .word	$565C
01527 050D                      567C            .word	$567C
01528 050F                      0000            .word	0
01529 0511                      0000            .word	0
01530 0513                        00            .byte	0
01531 0514                  00000001            .blkb	1
01532                                           ! 670       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01533 0515                      8500            .word	$8500
01534 0517                      8700            .word	$8700
01535 0519                      8900            .word	$8900
01536 051B                      8B00            .word	$8B00
01537 051D                        00            .byte	0
01538 051E                  00000001            .blkb	1
01539                                           ! 671       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01540 051F                      8600            .word	$8600
01541 0521                      8800            .word	$8800
01542 0523                      8A00            .word	$8A00
01543 0525                      8C00            .word	$8C00
01544 0527                        00            .byte	0
01545 0528                  00000001            .blkb	1
01546                                           ! 672       };
01547                                           !BCC_EOS
01548                                           ! 673   Bit8u
01549                                           ! 674 inb(port)
01550                                           ! 675   Bit16u port;
01551                                           
01552                                           export	_inb
01553                       00000529            _inb:
01554                                           !BCC_EOS
01555                                           ! 676 {
01556                                           ! 677 #asm
01557                                           !BCC_ASM
01558                       00000002            _inb.port	set	2
01559 0529           55                           push bp
01560 052A           89E5                         mov bp, sp
01561 052C           52                             push dx
01562 052D           8B56         04                mov dx, 4[bp]
01563 0530           EC                             in al, dx
01564 0531           5A                             pop dx
01565 0532           5D                           pop bp
01566                                           ! 685 endasm
01567                                           !BCC_ENDASM
01568                                           ! 686 }
01569 0533           C3                         ret
01570                                           ! 687   Bit16u
01571                                           ! 688 inw(port)
01572                                           ! 689   Bit16u port;
01573                                           export	_inw
01574                       00000534            _inw:
01575                                           !BCC_EOS
01576                                           ! 690 {
01577                                           ! 691 #asm
01578                                           !BCC_ASM
01579                       00000002            _inw.port	set	2
01580 0534           55                           push bp
01581 0535           89E5                         mov bp, sp
01582 0537           52                             push dx
01583 0538           8B56         04                mov dx, 4[bp]
01584 053B           ED                             in ax, dx
01585 053C           5A                             pop dx
01586 053D           5D                           pop bp
01587                                           ! 699 endasm
01588                                           !BCC_ENDASM
01589                                           ! 700 }
01590 053E           C3                         ret
01591                                           ! 701   void
01592                                           ! 702 outb(port, val)
01593                                           ! 703   Bit16u port;
01594                                           export	_outb
01595                       0000053F            _outb:
01596                                           !BCC_EOS
01597                                           ! 704   Bit8u val;
01598                                           !BCC_EOS
01599                                           ! 705 {
01600                                           ! 706 #asm
01601                                           !BCC_ASM
01602                       00000004            _outb.val	set	4
01603                       00000002            _outb.port	set	2
01604 053F           55                           push bp
01605 0540           89E5                         mov bp, sp
01606 0542           50                             push ax
01607 0543           52                             push dx
01608 0544           8B56         04                mov dx, 4[bp]
01609 0547           8A46         06                mov al, 6[bp]
01610 054A           EE                             out dx, al
01611 054B           5A                             pop dx
01612 054C           58                             pop ax
01613 054D           5D                           pop bp
01614                                           ! 717 endasm
01615                                           !BCC_ENDASM
01616                                           ! 718 }
01617 054E           C3                         ret
01618                                           ! 719   void
01619                                           ! 720 outw(port, val)
01620                                           ! 721   Bit16u port;
01621                                           export	_outw
01622                       0000054F            _outw:
01623                                           !BCC_EOS
01624                                           ! 722   Bit16u val;
01625                                           !BCC_EOS
01626                                           ! 723 {
01627                                           ! 724 #asm
01628                                           !BCC_ASM
01629                       00000004            _outw.val	set	4
01630                       00000002            _outw.port	set	2
01631 054F           55                           push bp
01632 0550           89E5                         mov bp, sp
01633 0552           50                             push ax
01634 0553           52                             push dx
01635 0554           8B56         04                mov dx, 4[bp]
01636 0557           8B46         06                mov ax, 6[bp]
01637 055A           EF                             out dx, ax
01638 055B           5A                             pop dx
01639 055C           58                             pop ax
01640 055D           5D                           pop bp
01641                                           ! 735 endasm
01642                                           !BCC_ENDASM
01643                                           ! 736 }
01644 055E           C3                         ret
01645                                           ! 737   void
01646                                           ! 738 outb_cmos(cmos_reg, val)
01647                                           ! 739   Bit8u cmos_reg;
01648                                           export	_outb_cmos
01649                       0000055F            _outb_cmos:
01650                                           !BCC_EOS
01651                                           ! 740   Bit8u val;
01652                                           !BCC_EOS
01653                                           ! 741 {
01654                                           ! 742 #asm
01655                                           !BCC_ASM
01656                       00000002            _outb_cmos.cmos_reg	set	2
01657                       00000004            _outb_cmos.val	set	4
01658 055F           55                           push bp
01659 0560           89E5                         mov bp, sp
01660 0562           8A46         04                mov al, 4[bp] ;; cmos_reg
01661 0565           E6                     70      out 0x0070, al
01662 0567           8A46         06                mov al, 6[bp] ;; val
01663 056A           E6                     71      out 0x0071, al
01664 056C           5D                           pop bp
01665                                           ! 750 endasm
01666                                           !BCC_ENDASM
01667                                           ! 751 }
01668 056D           C3                         ret
01669                                           ! 752   Bit8u
01670                                           ! 753 inb_cmos(cmos_reg)
01671                                           ! 754   Bit8u cmos_reg;
01672                                           export	_inb_cmos
01673                       0000056E            _inb_cmos:
01674                                           !BCC_EOS
01675                                           ! 755 {
01676                                           ! 756 #asm
01677                                           !BCC_ASM
01678                       00000002            _inb_cmos.cmos_reg	set	2
01679 056E           55                           push bp
01680 056F           89E5                         mov bp, sp
01681 0571           8A46         04                mov al, 4[bp] ;; cmos_reg
01682 0574           E6                     70      out 0x0070, al
01683 0576           E4                     71      in al, 0x0071
01684 0578           5D                           pop bp
01685                                           ! 763 endasm
01686                                           !BCC_ENDASM
01687                                           ! 764 }
01688 0579           C3                         ret
01689                                           ! 765   void
01690                                           ! 766 init_rtc()
01691                                           ! 767 {
01692                                           export	_init_rtc
01693                       0000057A            _init_rtc:
01694                                           ! 768   outb_cmos(0x0a, 0x26);
01695 057A           55                         push	bp
01696 057B           89E5                       mov	bp,sp
01697                                           ! Debug: list int = const $26 (used reg = )
01698 057D           B8                   0026  mov	ax,*$26
01699 0580           50                         push	ax
01700                                           ! Debug: list int = const $A (used reg = )
01701 0581           B8                   000A  mov	ax,*$A
01702 0584           50                         push	ax
01703                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01704 0585           E8         FFD7            call	_outb_cmos
01705 0588           89EC                       mov	sp,bp
01706                                           !BCC_EOS
01707                                           ! 769   outb_cmos(0x0b, 0x02);
01708                                           ! Debug: list int = const 2 (used reg = )
01709 058A           B8                   0002  mov	ax,*2
01710 058D           50                         push	ax
01711                                           ! Debug: list int = const $B (used reg = )
01712 058E           B8                   000B  mov	ax,*$B
01713 0591           50                         push	ax
01714                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01715 0592           E8         FFCA            call	_outb_cmos
01716 0595           89EC                       mov	sp,bp
01717                                           !BCC_EOS
01718                                           ! 770   inb_cmos(0x0c);
01719                                           ! Debug: list int = const $C (used reg = )
01720 0597           B8                   000C  mov	ax,*$C
01721 059A           50                         push	ax
01722                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01723 059B           E8         FFD0            call	_inb_cmos
01724 059E           89EC                       mov	sp,bp
01725                                           !BCC_EOS
01726                                           ! 771   inb_cmos(0x0d);
01727                                           ! Debug: list int = const $D (used reg = )
01728 05A0           B8                   000D  mov	ax,*$D
01729 05A3           50                         push	ax
01730                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01731 05A4           E8         FFC7            call	_inb_cmos
01732 05A7           89EC                       mov	sp,bp
01733                                           !BCC_EOS
01734                                           ! 772 }
01735 05A9           5D                         pop	bp
01736 05AA           C3                         ret
01737                                           ! 773   bx_bool
01738                                           ! 774 rtc_updating()
01739                                           ! 775 {
01740                                           export	_rtc_updating
01741                       000005AB            _rtc_updating:
01742                                           ! 776   Bit16u count;
01743                                           !BCC_EOS
01744                                           ! 777   count = 25000;
01745 05AB           55                         push	bp
01746 05AC           89E5                       mov	bp,sp
01747 05AE           4C                         dec	sp
01748 05AF           4C                         dec	sp
01749                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01750 05B0           B8                   61A8  mov	ax,#$61A8
01751 05B3           8946         FE            mov	-2[bp],ax
01752                                           !BCC_EOS
01753                                           ! 778   while (--count != 0) {
01754 05B6           EB           15            jmp .3
01755                       000005B8            .4:
01756                                           ! 779     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01757                                           ! Debug: list int = const $A (used reg = )
01758 05B8           B8                   000A  mov	ax,*$A
01759 05BB           50                         push	ax
01760                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01761 05BC           E8         FFAF            call	_inb_cmos
01762 05BF           44                         inc	sp
01763 05C0           44                         inc	sp
01764                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01765 05C1           24                     80  and	al,#$80
01766                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01767 05C3           84C0                       test	al,al
01768 05C5           75           06            jne 	.5
01769                       000005C7            .6:
01770                                           ! 780       return(0);
01771 05C7           31C0                       xor	ax,ax
01772 05C9           89EC                       mov	sp,bp
01773 05CB           5D                         pop	bp
01774 05CC           C3                         ret
01775                                           !BCC_EOS
01776                                           ! 781     }
01777                                           ! 781 
01778                       000005CD            .5:
01779                                           ! 782   return(1);
01780                       000005CD            .3:
01781                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01782 05CD           8B46         FE            mov	ax,-2[bp]
01783 05D0           48                         dec	ax
01784 05D1           8946         FE            mov	-2[bp],ax
01785                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01786 05D4           85C0                       test	ax,ax
01787 05D6           75           E0            jne	.4
01788                       000005D8            .7:
01789                       000005D8            .2:
01790 05D8           B8                   0001  mov	ax,*1
01791 05DB           89EC                       mov	sp,bp
01792 05DD           5D                         pop	bp
01793 05DE           C3                         ret
01794                                           !BCC_EOS
01795                                           ! 783 }
01796                                           ! 784   Bit8u
01797                                           ! 785 _read_byte(offset, seg)
01798                                           ! 786   Bit16u offset;
01799                                           export	__read_byte
01800                       000005DF            __read_byte:
01801                                           !BCC_EOS
01802                                           ! 787   Bit16u seg;
01803                                           !BCC_EOS
01804                                           ! 788 {
01805                                           ! 789 #asm
01806                                           !BCC_ASM
01807                       00000004            __read_byte.seg	set	4
01808                       00000002            __read_byte.offset	set	2
01809 05DF           55                           push bp
01810 05E0           89E5                         mov bp, sp
01811 05E2           53                             push bx
01812 05E3           1E                             push ds
01813 05E4           C55E         04                lds bx, 4[bp] ; segment & offset
01814 05E7           8A07                           mov al, [bx]
01815                                               ;; al = return value (byte)
01816 05E9           1F                             pop ds
01817 05EA           5B                             pop bx
01818 05EB           5D                           pop bp
01819                                           ! 800 endasm
01820                                           !BCC_ENDASM
01821                                           ! 801 }
01822 05EC           C3                         ret
01823                                           ! 802   Bit16u
01824                                           ! 803 _read_word(offset, seg)
01825                                           ! 804   Bit16u offset;
01826                                           export	__read_word
01827                       000005ED            __read_word:
01828                                           !BCC_EOS
01829                                           ! 805   Bit16u seg;
01830                                           !BCC_EOS
01831                                           ! 806 {
01832                                           ! 807 #asm
01833                                           !BCC_ASM
01834                       00000004            __read_word.seg	set	4
01835                       00000002            __read_word.offset	set	2
01836 05ED           55                           push bp
01837 05EE           89E5                         mov bp, sp
01838 05F0           53                             push bx
01839 05F1           1E                             push ds
01840 05F2           C55E         04                lds bx, 4[bp] ; segment & offset
01841 05F5           8B07                           mov ax, [bx]
01842                                               ;; ax = return value (word)
01843 05F7           1F                             pop ds
01844 05F8           5B                             pop bx
01845 05F9           5D                           pop bp
01846                                           ! 818 endasm
01847                                           !BCC_ENDASM
01848                                           ! 819 }
01849 05FA           C3                         ret
01850                                           ! 820   void
01851                                           ! 821 _write_byte(data, offset, seg)
01852                                           ! 822   Bit8u data;
01853                                           export	__write_byte
01854                       000005FB            __write_byte:
01855                                           !BCC_EOS
01856                                           ! 823   Bit16u offset;
01857                                           !BCC_EOS
01858                                           ! 824   Bit16u seg;
01859                                           !BCC_EOS
01860                                           ! 825 {
01861                                           ! 826 #asm
01862                                           !BCC_ASM
01863                       00000006            __write_byte.seg	set	6
01864                       00000002            __write_byte.data	set	2
01865                       00000004            __write_byte.offset	set	4
01866 05FB           55                           push bp
01867 05FC           89E5                         mov bp, sp
01868 05FE           50                             push ax
01869 05FF           53                             push bx
01870 0600           1E                             push ds
01871 0601           C55E         06                lds bx, 6[bp] ; segment & offset
01872 0604           8A46         04                mov al, 4[bp] ; data byte
01873 0607           8807                           mov [bx], al ; write data byte
01874 0609           1F                             pop ds
01875 060A           5B                             pop bx
01876 060B           58                             pop ax
01877 060C           5D                           pop bp
01878                                           ! 839 endasm
01879                                           !BCC_ENDASM
01880                                           ! 840 }
01881 060D           C3                         ret
01882                                           ! 841   void
01883                                           ! 842 _write_word(data, offset, seg)
01884                                           ! 843   Bit16u data;
01885                                           export	__write_word
01886                       0000060E            __write_word:
01887                                           !BCC_EOS
01888                                           ! 844   Bit16u offset;
01889                                           !BCC_EOS
01890                                           ! 845   Bit16u seg;
01891                                           !BCC_EOS
01892                                           ! 846 {
01893                                           ! 847 #asm
01894                                           !BCC_ASM
01895                       00000006            __write_word.seg	set	6
01896                       00000002            __write_word.data	set	2
01897                       00000004            __write_word.offset	set	4
01898 060E           55                           push bp
01899 060F           89E5                         mov bp, sp
01900 0611           50                             push ax
01901 0612           53                             push bx
01902 0613           1E                             push ds
01903 0614           C55E         06                lds bx, 6[bp] ; segment & offset
01904 0617           8B46         04                mov ax, 4[bp] ; data word
01905 061A           8907                           mov [bx], ax ; write data word
01906 061C           1F                             pop ds
01907 061D           5B                             pop bx
01908 061E           58                             pop ax
01909 061F           5D                           pop bp
01910                                           ! 860 endasm
01911                                           !BCC_ENDASM
01912                                           ! 861 }
01913 0620           C3                         ret
01914                                           ! 862   Bit8u
01915                                           ! 863 read_byte_SS(offset)
01916                                           ! 864   Bit16u offset;
01917                                           export	_read_byte_SS
01918                       00000621            _read_byte_SS:
01919                                           !BCC_EOS
01920                                           ! 865 {
01921                                           ! 866 #asm
01922                                           !BCC_ASM
01923                       00000002            _read_byte_SS.offset	set	2
01924 0621           55                           push bp
01925 0622           89E5                         mov bp, sp
01926 0624           8B6E         04              mov bp, 4[bp] ; offset
01927 0627           8A46         00              mov al, [bp]
01928                                             ;; al = return value (byte)
01929 062A           5D                           pop bp
01930                                           ! 873 endasm
01931                                           !BCC_ENDASM
01932                                           ! 874 }
01933 062B           C3                         ret
01934                                           ! 875   Bit16u
01935                                           ! 876 read_word_SS(offset)
01936                                           ! 877   Bit16u offset;
01937                                           export	_read_word_SS
01938                       0000062C            _read_word_SS:
01939                                           !BCC_EOS
01940                                           ! 878 {
01941                                           ! 879 #asm
01942                                           !BCC_ASM
01943                       00000002            _read_word_SS.offset	set	2
01944 062C           55                           push bp
01945 062D           89E5                         mov bp, sp
01946 062F           8B6E         04              mov bp, 4[bp] ; offset
01947 0632           8B46         00              mov ax, [bp]
01948                                             ;; ax = return value (word)
01949 0635           5D                           pop bp
01950                                           ! 886 endasm
01951                                           !BCC_ENDASM
01952                                           ! 887 }
01953 0636           C3                         ret
01954                                           ! 888   void
01955                                           ! 889 _write_byte_SS(data, offset)
01956                                           ! 890   Bit8u data;
01957                                           export	__write_byte_SS
01958                       00000637            __write_byte_SS:
01959                                           !BCC_EOS
01960                                           ! 891   Bit16u offset;
01961                                           !BCC_EOS
01962                                           ! 892 {
01963                                           ! 893 #asm
01964                                           !BCC_ASM
01965                       00000002            __write_byte_SS.data	set	2
01966                       00000004            __write_byte_SS.offset	set	4
01967 0637           55                           push bp
01968 0638           89E5                         mov bp, sp
01969 063A           50                           push ax
01970 063B           8A46         04              mov al, 4[bp] ; data byte
01971 063E           8B6E         06              mov bp, 6[bp] ; offset
01972 0641           8846         00              mov [bp], al ; write data byte
01973 0644           58                           pop ax
01974 0645           5D                           pop bp
01975                                           ! 902 endasm
01976                                           !BCC_ENDASM
01977                                           ! 903 }
01978 0646           C3                         ret
01979                                           ! 904   void
01980                                           ! 905 _write_word_SS(data, offset)
01981                                           ! 906   Bit16u data;
01982                                           export	__write_word_SS
01983                       00000647            __write_word_SS:
01984                                           !BCC_EOS
01985                                           ! 907   Bit16u offset;
01986                                           !BCC_EOS
01987                                           ! 908 {
01988                                           ! 909 #asm
01989                                           !BCC_ASM
01990                       00000002            __write_word_SS.data	set	2
01991                       00000004            __write_word_SS.offset	set	4
01992 0647           55                           push bp
01993 0648           89E5                         mov bp, sp
01994 064A           50                           push ax
01995 064B           8B46         04              mov ax, 4[bp] ; data word
01996 064E           8B6E         06              mov bp, 6[bp] ; offset
01997 0651           8946         00              mov [bp], ax ; write data word
01998 0654           58                           pop ax
01999 0655           5D                           pop bp
02000                                           ! 918 endasm
02001                                           !BCC_ENDASM
02002                                           ! 919 }
02003 0656           C3                         ret
02004                                           ! 920   Bit16u
02005                                           ! 921 get_CS()
02006                                           ! 922 {
02007                                           export	_get_CS
02008                       00000657            _get_CS:
02009                                           ! 923 #asm
02010                                           !BCC_ASM
02011 0657           8CC8                         mov ax, cs
02012                                           ! 925 endasm
02013                                           !BCC_ENDASM
02014                                           ! 926 }
02015 0659           C3                         ret
02016                                           ! 927   Bit16u
02017                                           ! 928 get_SS()
02018                                           ! 929 {
02019                                           export	_get_SS
02020                       0000065A            _get_SS:
02021                                           ! 930 #asm
02022                                           !BCC_ASM
02023 065A           8CD0                         mov ax, ss
02024                                           ! 932 endasm
02025                                           !BCC_ENDASM
02026                                           ! 933 }
02027 065C           C3                         ret
02028                                           ! 934   Bit16u
02029                                           ! 935 set_DS(seg)
02030                                           ! 936   Bit16u seg;
02031                                           export	_set_DS
02032                       0000065D            _set_DS:
02033                                           !BCC_EOS
02034                                           ! 937 {
02035                                           ! 938 #asm
02036                                           !BCC_ASM
02037                       00000002            _set_DS.seg	set	2
02038 065D           55                           push bp
02039 065E           89E5                         mov bp, sp
02040 0660           1E                           push ds
02041 0661           8E5E         04              mov ds, 4[bp] ;; seg
02042 0664           58                           pop ax
02043 0665           5D                           pop bp
02044                                           ! 945 endasm
02045                                           !BCC_ENDASM
02046                                           ! 946 }
02047 0666           C3                         ret
02048                                           ! 947   Bit16u
02049                                           ! 948 get_ebda_seg()
02050                                           ! 949 {
02051                                           export	_get_ebda_seg
02052                       00000667            _get_ebda_seg:
02053                                           ! 950 #asm
02054                                           !BCC_ASM
02055 0667           53                           push bx
02056 0668           1E                           push ds
02057 0669           B8                   0040    mov ax, #0x0040
02058 066C           8ED8                         mov ds, ax
02059 066E           BB                   000E    mov bx, #0x000e
02060 0671           8B07                         mov ax, [bx]
02061                                             ;; ax = return value (word)
02062 0673           1F                           pop ds
02063 0674           5B                           pop bx
02064                                           ! 960 endasm
02065                                           !BCC_ENDASM
02066                                           ! 961 }
02067 0675           C3                         ret
02068                                           ! 962   void
02069                                           ! 963 wrch(c)
02070                                           ! 964   Bit8u c;
02071                                           export	_wrch
02072                       00000676            _wrch:
02073                                           !BCC_EOS
02074                                           ! 965 {
02075                                           ! 966 #asm
02076                                           !BCC_ASM
02077                       00000002            _wrch.c	set	2
02078 0676           55                           push bp
02079 0677           89E5                         mov bp, sp
02080 0679           53                           push bx
02081 067A           B4                     0E    mov ah, #0x0e
02082 067C           8A46         04              mov al, 4[bp]
02083 067F           31DB                         xor bx,bx
02084 0681           CD                     10    int #0x10
02085 0683           5B                           pop bx
02086 0684           5D                           pop bp
02087                                           ! 976 endasm
02088                                           !BCC_ENDASM
02089                                           ! 977 }
02090 0685           C3                         ret
02091                                           ! 978   void
02092                                           ! 979 send(action, c)
02093                                           ! 980   Bit16u action;
02094                                           export	_send
02095                       00000686            _send:
02096                                           !BCC_EOS
02097                                           ! 981   Bit8u c;
02098                                           !BCC_EOS
02099                                           ! 982 {
02100                                           ! 983   if (action & 8) outb(0x403, c);
02101 0686           55                         push	bp
02102 0687           89E5                       mov	bp,sp
02103                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02104 0689           8A46         04            mov	al,4[bp]
02105 068C           24                     08  and	al,*8
02106 068E           84C0                       test	al,al
02107 0690           74           0F            je  	.8
02108                       00000692            .9:
02109                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02110 0692           8A46         06            mov	al,6[bp]
02111 0695           30E4                       xor	ah,ah
02112 0697           50                         push	ax
02113                                           ! Debug: list int = const $403 (used reg = )
02114 0698           B8                   0403  mov	ax,#$403
02115 069B           50                         push	ax
02116                                           ! Debug: func () void = outb+0 (used reg = )
02117 069C           E8         FEA0            call	_outb
02118 069F           89EC                       mov	sp,bp
02119                                           !BCC_EOS
02120                                           ! 984   if (action & 4) outb(0x402, c);
02121                       000006A1            .8:
02122                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02123 06A1           8A46         04            mov	al,4[bp]
02124 06A4           24                     04  and	al,*4
02125 06A6           84C0                       test	al,al
02126 06A8           74           0F            je  	.A
02127                       000006AA            .B:
02128                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02129 06AA           8A46         06            mov	al,6[bp]
02130 06AD           30E4                       xor	ah,ah
02131 06AF           50                         push	ax
02132                                           ! Debug: list int = const $402 (used reg = )
02133 06B0           B8                   0402  mov	ax,#$402
02134 06B3           50                         push	ax
02135                                           ! Debug: func () void = outb+0 (used reg = )
02136 06B4           E8         FE88            call	_outb
02137 06B7           89EC                       mov	sp,bp
02138                                           !BCC_EOS
02139                                           ! 985   if (action & 2) {
02140                       000006B9            .A:
02141                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02142 06B9           8A46         04            mov	al,4[bp]
02143 06BC           24                     02  and	al,*2
02144 06BE           84C0                       test	al,al
02145 06C0           74           1B            je  	.C
02146                       000006C2            .D:
02147                                           ! 986     if (c == '\n') wrch('\r');
02148                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02149 06C2           8A46         06            mov	al,6[bp]
02150 06C5           3C                     0A  cmp	al,*$A
02151 06C7           75           09            jne 	.E
02152                       000006C9            .F:
02153                                           ! Debug: list int = const $D (used reg = )
02154 06C9           B8                   000D  mov	ax,*$D
02155 06CC           50                         push	ax
02156                                           ! Debug: func () void = wrch+0 (used reg = )
02157 06CD           E8         FFA6            call	_wrch
02158 06D0           89EC                       mov	sp,bp
02159                                           !BCC_EOS
02160                                           ! 987     wrch(c);
02161                       000006D2            .E:
02162                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02163 06D2           8A46         06            mov	al,6[bp]
02164 06D5           30E4                       xor	ah,ah
02165 06D7           50                         push	ax
02166                                           ! Debug: func () void = wrch+0 (used reg = )
02167 06D8           E8         FF9B            call	_wrch
02168 06DB           89EC                       mov	sp,bp
02169                                           !BCC_EOS
02170                                           ! 988   }
02171                                           ! 989 }
02172                       000006DD            .C:
02173 06DD           5D                         pop	bp
02174 06DE           C3                         ret
02175                                           ! 990   void
02176                                           ! 991 put_uint(action, val, width, neg)
02177                                           ! 992   Bit16u action;
02178                                           export	_put_uint
02179                       000006DF            _put_uint:
02180                                           !BCC_EOS
02181                                           ! 993   unsigned short val;
02182                                           !BCC_EOS
02183                                           ! 994   short width;
02184                                           !BCC_EOS
02185                                           ! 995   bx_bool neg;
02186                                           !BCC_EOS
02187                                           ! 996 {
02188                                           ! 997   unsigned short nval = val / 10;
02189 06DF           55                         push	bp
02190 06E0           89E5                       mov	bp,sp
02191 06E2           4C                         dec	sp
02192 06E3           4C                         dec	sp
02193                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02194 06E4           8B46         06            mov	ax,6[bp]
02195 06E7           BB                   000A  mov	bx,*$A
02196 06EA           E8         FA4D            call	idiv_u
02197                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02198 06ED           8946         FE            mov	-2[bp],ax
02199                                           !BCC_EOS
02200                                           ! 998   if (nval)
02201 06F0           8B46         FE            mov	ax,-2[bp]
02202 06F3           85C0                       test	ax,ax
02203 06F5           74           16            je  	.10
02204                       000006F7            .11:
02205                                           ! 999     put_uint(action, nval, width - 1, neg);
02206                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02207 06F7           FF76         0A            push	$A[bp]
02208                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02209 06FA           8B46         08            mov	ax,8[bp]
02210                                           ! Debug: list int = ax-1 (used reg = )
02211 06FD           48                         dec	ax
02212 06FE           50                         push	ax
02213                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02214 06FF           FF76         FE            push	-2[bp]
02215                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02216 0702           FF76         04            push	4[bp]
02217                                           ! Debug: func () void = put_uint+0 (used reg = )
02218 0705           E8         FFD7            call	_put_uint
02219 0708           83C4                   08  add	sp,*8
02220                                           !BCC_EOS
02221                                           ! 1000   else {
02222 070B           EB           2E            jmp .12
02223                       0000070D            .10:
02224                                           ! 1001     while (--width > 0) send(action, ' ');
02225 070D           EB           0D            jmp .14
02226                       0000070F            .15:
02227                                           ! Debug: list int = const $20 (used reg = )
02228 070F           B8                   0020  mov	ax,*$20
02229 0712           50                         push	ax
02230                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02231 0713           FF76         04            push	4[bp]
02232                                           ! Debug: func () void = send+0 (used reg = )
02233 0716           E8         FF6D            call	_send
02234 0719           83C4                   04  add	sp,*4
02235                                           !BCC_EOS
02236                                           ! 1002     if (neg) send(action, '-');
02237                       0000071C            .14:
02238                                           ! Debug: predec short width = [S+4+6] (used reg = )
02239 071C           8B46         08            mov	ax,8[bp]
02240 071F           48                         dec	ax
02241 0720           8946         08            mov	8[bp],ax
02242                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02243 0723           85C0                       test	ax,ax
02244 0725           7F           E8            jg 	.15
02245                       00000727            .16:
02246                       00000727            .13:
02247 0727           8B46         0A            mov	ax,$A[bp]
02248 072A           85C0                       test	ax,ax
02249 072C           74           0D            je  	.17
02250                       0000072E            .18:
02251                                           ! Debug: list int = const $2D (used reg = )
02252 072E           B8                   002D  mov	ax,*$2D
02253 0731           50                         push	ax
02254                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02255 0732           FF76         04            push	4[bp]
02256                                           ! Debug: func () void = send+0 (used reg = )
02257 0735           E8         FF4E            call	_send
02258 0738           83C4                   04  add	sp,*4
02259                                           !BCC_EOS
02260                                           ! 1003   }
02261                       0000073B            .17:
02262                                           ! 1004   send(action, val - (nval * 10) + '0');
02263                       0000073B            .12:
02264                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02265 073B           8B46         FE            mov	ax,-2[bp]
02266 073E           89C2                       mov	dx,ax
02267 0740           D1E0                       shl	ax,*1
02268 0742           D1E0                       shl	ax,*1
02269 0744           01D0                       add	ax,dx
02270 0746           D1E0                       shl	ax,*1
02271                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02272 0748           50                         push	ax
02273 0749           8B46         06            mov	ax,6[bp]
02274 074C           2B46         FC            sub	ax,-4[bp]
02275 074F           44                         inc	sp
02276 0750           44                         inc	sp
02277                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02278                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02279 0751           05                   0030  add	ax,*$30
02280 0754           50                         push	ax
02281                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02282 0755           FF76         04            push	4[bp]
02283                                           ! Debug: func () void = send+0 (used reg = )
02284 0758           E8         FF2B            call	_send
02285 075B           83C4                   04  add	sp,*4
02286                                           !BCC_EOS
02287                                           ! 1005 }
02288 075E           89EC                       mov	sp,bp
02289 0760           5D                         pop	bp
02290 0761           C3                         ret
02291                                           ! 1006   void
02292                                           ! Register BX used in function put_uint
02293                                           ! 1007 put_luint(action, val, width, neg)
02294                                           ! 1008   Bit16u action;
02295                                           export	_put_luint
02296                       00000762            _put_luint:
02297                                           !BCC_EOS
02298                                           ! 1009   unsigned long val;
02299                                           !BCC_EOS
02300                                           ! 1010   short width;
02301                                           !BCC_EOS
02302                                           ! 1011   bx_bool neg;
02303                                           !BCC_EOS
02304                                           ! 1012 {
02305                                           ! 1013   unsigned long nval = val / 10;
02306 0762           55                         push	bp
02307 0763           89E5                       mov	bp,sp
02308 0765           83C4                   FC  add	sp,*-4
02309                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02310 0768           B8                   000A  mov	ax,*$A
02311 076B           31DB                       xor	bx,bx
02312 076D           53                         push	bx
02313 076E           50                         push	ax
02314 076F           8B46         06            mov	ax,6[bp]
02315 0772           8B5E         08            mov	bx,8[bp]
02316 0775           8D7E         F8            lea	di,-8[bp]
02317 0778           E8         F9C4            call	ldivul
02318 077B           83C4                   04  add	sp,*4
02319                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02320 077E           8946         FC            mov	-4[bp],ax
02321 0781           895E         FE            mov	-2[bp],bx
02322                                           !BCC_EOS
02323                                           ! 1014   if (nval)
02324 0784           8B46         FC            mov	ax,-4[bp]
02325 0787           8B5E         FE            mov	bx,-2[bp]
02326 078A           E8         F958            call	ltstl
02327 078D           74           19            je  	.19
02328                       0000078F            .1A:
02329                                           ! 1015     put_luint(action, nval, width - 1, neg);
02330                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02331 078F           FF76         0C            push	$C[bp]
02332                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02333 0792           8B46         0A            mov	ax,$A[bp]
02334                                           ! Debug: list int = ax-1 (used reg = )
02335 0795           48                         dec	ax
02336 0796           50                         push	ax
02337                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02338 0797           FF76         FE            push	-2[bp]
02339 079A           FF76         FC            push	-4[bp]
02340                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02341 079D           FF76         04            push	4[bp]
02342                                           ! Debug: func () void = put_luint+0 (used reg = )
02343 07A0           E8         FFBF            call	_put_luint
02344 07A3           83C4                   0A  add	sp,*$A
02345                                           !BCC_EOS
02346                                           ! 1016   else {
02347 07A6           EB           2E            jmp .1B
02348                       000007A8            .19:
02349                                           ! 1017     while (--width > 0) send(action, ' ');
02350 07A8           EB           0D            jmp .1D
02351                       000007AA            .1E:
02352                                           ! Debug: list int = const $20 (used reg = )
02353 07AA           B8                   0020  mov	ax,*$20
02354 07AD           50                         push	ax
02355                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02356 07AE           FF76         04            push	4[bp]
02357                                           ! Debug: func () void = send+0 (used reg = )
02358 07B1           E8         FED2            call	_send
02359 07B4           83C4                   04  add	sp,*4
02360                                           !BCC_EOS
02361                                           ! 1018     if (neg) send(action, '-');
02362                       000007B7            .1D:
02363                                           ! Debug: predec short width = [S+6+8] (used reg = )
02364 07B7           8B46         0A            mov	ax,$A[bp]
02365 07BA           48                         dec	ax
02366 07BB           8946         0A            mov	$A[bp],ax
02367                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02368 07BE           85C0                       test	ax,ax
02369 07C0           7F           E8            jg 	.1E
02370                       000007C2            .1F:
02371                       000007C2            .1C:
02372 07C2           8B46         0C            mov	ax,$C[bp]
02373 07C5           85C0                       test	ax,ax
02374 07C7           74           0D            je  	.20
02375                       000007C9            .21:
02376                                           ! Debug: list int = const $2D (used reg = )
02377 07C9           B8                   002D  mov	ax,*$2D
02378 07CC           50                         push	ax
02379                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02380 07CD           FF76         04            push	4[bp]
02381                                           ! Debug: func () void = send+0 (used reg = )
02382 07D0           E8         FEB3            call	_send
02383 07D3           83C4                   04  add	sp,*4
02384                                           !BCC_EOS
02385                                           ! 1019   }
02386                       000007D6            .20:
02387                                           ! 1020   send(action, val - (nval * 10) + '0');
02388                       000007D6            .1B:
02389                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02390                                           ! Debug: expression subtree swapping
02391 07D6           B8                   000A  mov	ax,*$A
02392 07D9           31DB                       xor	bx,bx
02393 07DB           8D7E         FC            lea	di,-4[bp]
02394 07DE           E8         F8D9            call	lmulul
02395                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02396 07E1           53                         push	bx
02397 07E2           50                         push	ax
02398 07E3           8B46         06            mov	ax,6[bp]
02399 07E6           8B5E         08            mov	bx,8[bp]
02400 07E9           8D7E         F8            lea	di,-8[bp]
02401 07EC           E8         F8C3            call	lsubul
02402 07EF           83C4                   04  add	sp,*4
02403                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02404 07F2           53                         push	bx
02405 07F3           50                         push	ax
02406 07F4           B8                   0030  mov	ax,*$30
02407 07F7           31DB                       xor	bx,bx
02408 07F9           53                         push	bx
02409 07FA           50                         push	ax
02410 07FB           8B46         F8            mov	ax,-8[bp]
02411 07FE           8B5E         FA            mov	bx,-6[bp]
02412 0801           8D7E         F4            lea	di,-$C[bp]
02413 0804           E8         F88D            call	laddul
02414 0807           83C4                   08  add	sp,*8
02415                                           ! Debug: list unsigned long = bx+0 (used reg = )
02416 080A           53                         push	bx
02417 080B           50                         push	ax
02418                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02419 080C           FF76         04            push	4[bp]
02420                                           ! Debug: func () void = send+0 (used reg = )
02421 080F           E8         FE74            call	_send
02422 0812           83C4                   06  add	sp,*6
02423                                           !BCC_EOS
02424                                           ! 1021 }
02425 0815           89EC                       mov	sp,bp
02426 0817           5D                         pop	bp
02427 0818           C3                         ret
02428                                           ! 1022 void put_str(action, segment, offset)
02429                                           ! Register BX used in function put_luint
02430                                           ! 1023   Bit16u action;
02431                                           export	_put_str
02432                       00000819            _put_str:
02433                                           !BCC_EOS
02434                                           ! 1024   Bit16u segment;
02435                                           !BCC_EOS
02436                                           ! 1025   Bit16u offset;
02437                                           !BCC_EOS
02438                                           ! 1026 {
02439                                           ! 1027   Bit8u c;
02440                                           !BCC_EOS
02441                                           ! 1028   while (c = _read_byte(offset, segment)) {
02442 0819           55                         push	bp
02443 081A           89E5                       mov	bp,sp
02444 081C           4C                         dec	sp
02445 081D           4C                         dec	sp
02446 081E           EB           16            jmp .23
02447                       00000820            .24:
02448                                           ! 1029     send(action, c);
02449                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02450 0820           8A46         FF            mov	al,-1[bp]
02451 0823           30E4                       xor	ah,ah
02452 0825           50                         push	ax
02453                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02454 0826           FF76         04            push	4[bp]
02455                                           ! Debug: func () void = send+0 (used reg = )
02456 0829           E8         FE5A            call	_send
02457 082C           83C4                   04  add	sp,*4
02458                                           !BCC_EOS
02459                                           ! 1030     offset++;
02460                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02461 082F           8B46         08            mov	ax,8[bp]
02462 0832           40                         inc	ax
02463 0833           8946         08            mov	8[bp],ax
02464                                           !BCC_EOS
02465                                           ! 1031   }
02466                                           ! 1032 }
02467                       00000836            .23:
02468                                           ! Debug: list unsigned short segment = [S+4+4] (used reg = )
02469 0836           FF76         06            push	6[bp]
02470                                           ! Debug: list unsigned short offset = [S+6+6] (used reg = )
02471 0839           FF76         08            push	8[bp]
02472                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
02473 083C           E8         FDA0            call	__read_byte
02474 083F           83C4                   04  add	sp,*4
02475                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02476 0842           8846         FF            mov	-1[bp],al
02477 0845           84C0                       test	al,al
02478 0847           75           D7            jne	.24
02479                       00000849            .25:
02480                       00000849            .22:
02481 0849           89EC                       mov	sp,bp
02482 084B           5D                         pop	bp
02483 084C           C3                         ret
02484                                           ! 1033   void
02485                                           ! 1034 delay_ticks(ticks)
02486                                           ! 1035   Bit16u ticks;
02487                                           export	_delay_ticks
02488                       0000084D            _delay_ticks:
02489                                           !BCC_EOS
02490                                           ! 1036 {
02491                                           ! 1037   long ticks_to_wait, delta;
02492                                           !BCC_EOS
02493                                           ! 1038   Bit32u prev_ticks, t;
02494                                           !BCC_EOS
02495                                           ! 1039 #asm
02496 084D           55                         push	bp
02497 084E           89E5                       mov	bp,sp
02498 0850           83C4                   F0  add	sp,*-$10
02499                                           !BCC_EOS
02500                                           !BCC_ASM
02501                       00000014            _delay_ticks.ticks	set	$14
02502                       00000004            .delay_ticks.ticks	set	4
02503                       00000000            _delay_ticks.t	set	0
02504                       FFFFFFF0            .delay_ticks.t	set	-$10
02505                       00000004            _delay_ticks.prev_ticks	set	4
02506                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02507                       00000008            _delay_ticks.delta	set	8
02508                       FFFFFFF8            .delay_ticks.delta	set	-8
02509                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02510                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02511 0853           9C                           pushf
02512 0854           1E                           push ds
02513 0855           6A                     00    push #0x00
02514 0857           1F                           pop ds
02515 0858           FB                           sti
02516                                           ! 1045 endasm
02517                                           !BCC_ENDASM
02518                                           !BCC_EOS
02519                                           ! 1046   ticks_to_wait = ticks;
02520                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02521 0859           8B46         04            mov	ax,4[bp]
02522 085C           31DB                       xor	bx,bx
02523 085E           8946         FC            mov	-4[bp],ax
02524 0861           895E         FE            mov	-2[bp],bx
02525                                           !BCC_EOS
02526                                           ! 1047   prev_ticks = *((Bit32u *)(0x46c));
02527                                           ! Debug: eq unsigned long = [+$46C] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02528 0864           A1         046C            mov	ax,[$46C]
02529 0867           8B1E       046E            mov	bx,[$46E]
02530 086B           8946         F4            mov	-$C[bp],ax
02531 086E           895E         F6            mov	-$A[bp],bx
02532                                           !BCC_EOS
02533                                           ! 1048   do
02534                                           ! 1049   {
02535                       00000871            .28:
02536                                           ! 1050 #asm
02537                                           !BCC_EOS
02538                                           !BCC_ASM
02539                       00000014            _delay_ticks.ticks	set	$14
02540                       00000004            .delay_ticks.ticks	set	4
02541                       00000000            _delay_ticks.t	set	0
02542                       FFFFFFF0            .delay_ticks.t	set	-$10
02543                       00000004            _delay_ticks.prev_ticks	set	4
02544                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02545                       00000008            _delay_ticks.delta	set	8
02546                       FFFFFFF8            .delay_ticks.delta	set	-8
02547                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02548                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02549 0871           F4                             hlt
02550                                           ! 1052 endasm
02551                                           !BCC_ENDASM
02552                                           !BCC_EOS
02553                                           ! 1053     t = *((Bit32u *)(0x46c));
02554                                           ! Debug: eq unsigned long = [+$46C] to unsigned long t = [S+$12-$12] (used reg = )
02555 0872           A1         046C            mov	ax,[$46C]
02556 0875           8B1E       046E            mov	bx,[$46E]
02557 0879           8946         F0            mov	-$10[bp],ax
02558 087C           895E         F2            mov	-$E[bp],bx
02559                                           !BCC_EOS
02560                                           ! 1054     if (t > prev_ticks)
02561                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02562 087F           8B46         F4            mov	ax,-$C[bp]
02563 0882           8B5E         F6            mov	bx,-$A[bp]
02564 0885           8D7E         F0            lea	di,-$10[bp]
02565 0888           E8         F811            call	lcmpul
02566 088B           73           26            jae 	.29
02567                       0000088D            .2A:
02568                                           ! 1055     {
02569                                           ! 1056       delta = t - prev_ticks;
02570                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02571 088D           8B46         F0            mov	ax,-$10[bp]
02572 0890           8B5E         F2            mov	bx,-$E[bp]
02573 0893           8D7E         F4            lea	di,-$C[bp]
02574 0896           E8         F819            call	lsubul
02575                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02576 0899           8946         F8            mov	-8[bp],ax
02577 089C           895E         FA            mov	-6[bp],bx
02578                                           !BCC_EOS
02579                                           ! 1057       ticks_to_wait -= delta;
02580                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02581 089F           8B46         FC            mov	ax,-4[bp]
02582 08A2           8B5E         FE            mov	bx,-2[bp]
02583 08A5           8D7E         F8            lea	di,-8[bp]
02584 08A8           E8         F807            call	lsubl
02585 08AB           8946         FC            mov	-4[bp],ax
02586 08AE           895E         FE            mov	-2[bp],bx
02587                                           !BCC_EOS
02588                                           ! 1058     }
02589                                           ! 1059     else if (t < prev_ticks)
02590 08B1           EB           20            jmp .2B
02591                       000008B3            .29:
02592                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02593 08B3           8B46         F4            mov	ax,-$C[bp]
02594 08B6           8B5E         F6            mov	bx,-$A[bp]
02595 08B9           8D7E         F0            lea	di,-$10[bp]
02596 08BC           E8         F7DD            call	lcmpul
02597 08BF           76           12            jbe 	.2C
02598                       000008C1            .2D:
02599                                           ! 1060     {
02600                                           ! 1061       ticks_to_wait -= t;
02601                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02602 08C1           8B46         FC            mov	ax,-4[bp]
02603 08C4           8B5E         FE            mov	bx,-2[bp]
02604 08C7           8D7E         F0            lea	di,-$10[bp]
02605 08CA           E8         F7E5            call	lsubul
02606 08CD           8946         FC            mov	-4[bp],ax
02607 08D0           895E         FE            mov	-2[bp],bx
02608                                           !BCC_EOS
02609                                           ! 1062     }
02610                                           ! 1063     prev_ticks = t;
02611                       000008D3            .2C:
02612                       000008D3            .2B:
02613                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02614 08D3           8B46         F0            mov	ax,-$10[bp]
02615 08D6           8B5E         F2            mov	bx,-$E[bp]
02616 08D9           8946         F4            mov	-$C[bp],ax
02617 08DC           895E         F6            mov	-$A[bp],bx
02618                                           !BCC_EOS
02619                                           ! 1064   } while (ticks_to_wait > 0);
02620                       000008DF            .27:
02621                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02622 08DF           31C0                       xor	ax,ax
02623 08E1           31DB                       xor	bx,bx
02624 08E3           8D7E         FC            lea	di,-4[bp]
02625 08E6           E8         F7B3            call	lcmpl
02626 08E9           7C           86            jl 	.28
02627                       000008EB            .2E:
02628                                           !BCC_EOS
02629                                           ! 1065 #asm
02630                       000008EB            .26:
02631                                           !BCC_EOS
02632                                           !BCC_ASM
02633                       00000014            _delay_ticks.ticks	set	$14
02634                       00000004            .delay_ticks.ticks	set	4
02635                       00000000            _delay_ticks.t	set	0
02636                       FFFFFFF0            .delay_ticks.t	set	-$10
02637                       00000004            _delay_ticks.prev_ticks	set	4
02638                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02639                       00000008            _delay_ticks.delta	set	8
02640                       FFFFFFF8            .delay_ticks.delta	set	-8
02641                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02642                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02643 08EB           FA                           cli
02644 08EC           1F                           pop ds
02645 08ED           9D                           popf
02646                                           ! 1069 endasm
02647                                           !BCC_ENDASM
02648                                           !BCC_EOS
02649                                           ! 1070 }
02650 08EE           89EC                       mov	sp,bp
02651 08F0           5D                         pop	bp
02652 08F1           C3                         ret
02653                                           ! 1071   Bit8u
02654                                           ! Register BX used in function delay_ticks
02655                                           ! 1072 check_for_keystroke()
02656                                           ! 1073 {
02657                                           export	_check_for_keystroke
02658                       000008F2            _check_for_keystroke:
02659                                           ! 1074 #asm
02660                                           !BCC_ASM
02661 08F2           B8                   0100    mov ax, #0x100
02662 08F5           CD                     16    int #0x16
02663 08F7           74           04              jz no_key
02664 08F9           B0                     01    mov al, #1
02665 08FB           EB           02              jmp done
02666                       000008FD            no_key:
02667 08FD           30C0                         xor al, al
02668                       000008FF            done:
02669                                           ! 1083 endasm
02670                                           !BCC_ENDASM
02671                                           ! 1084 }
02672 08FF           C3                         ret
02673                                           ! 1085   Bit8u
02674                                           ! 1086 get_keystroke()
02675                                           ! 1087 {
02676                                           export	_get_keystroke
02677                       00000900            _get_keystroke:
02678                                           ! 1088 #asm
02679                                           !BCC_ASM
02680 0900           B8                   0000    mov ax, #0x0
02681 0903           CD                     16    int #0x16
02682 0905           86C4                         xchg ah, al
02683                                           ! 1092 endasm
02684                                           !BCC_ENDASM
02685                                           ! 1093 }
02686 0907           C3                         ret
02687                                           ! 1094   void
02688                                           ! 1095 delay_ticks_and_check_for_keystroke(ticks, count)
02689                                           ! 1096   Bit16u ticks, count;
02690                                           export	_delay_ticks_and_check_for_keystroke
02691                       00000908            _delay_ticks_and_check_for_keystroke:
02692                                           !BCC_EOS
02693                                           ! 1097 {
02694                                           ! 1098   Bit16u i;
02695                                           !BCC_EOS
02696                                           ! 1099   for (i = 1; i <= count; i++) {
02697 0908           55                         push	bp
02698 0909           89E5                       mov	bp,sp
02699 090B           4C                         dec	sp
02700 090C           4C                         dec	sp
02701                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02702 090D           B8                   0001  mov	ax,*1
02703 0910           8946         FE            mov	-2[bp],ax
02704                                           !BCC_EOS
02705                                           !BCC_EOS
02706 0913           EB           18            jmp .31
02707                       00000915            .32:
02708                                           ! 1100     delay_ticks(ticks);
02709                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02710 0915           FF76         04            push	4[bp]
02711                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02712 0918           E8         FF32            call	_delay_ticks
02713 091B           44                         inc	sp
02714 091C           44                         inc	sp
02715                                           !BCC_EOS
02716                                           ! 1101     if (check_for_keystroke())
02717                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02718 091D           E8         FFD2            call	_check_for_keystroke
02719 0920           84C0                       test	al,al
02720 0922           74           02            je  	.33
02721                       00000924            .34:
02722                                           ! 1102       break;
02723 0924           EB           0F            jmp .2F
02724                                           !BCC_EOS
02725                                           ! 1103   }
02726                       00000926            .33:
02727                                           ! 1104 }
02728                       00000926            .30:
02729                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02730 0926           8B46         FE            mov	ax,-2[bp]
02731 0929           40                         inc	ax
02732 092A           8946         FE            mov	-2[bp],ax
02733                       0000092D            .31:
02734                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02735 092D           8B46         FE            mov	ax,-2[bp]
02736 0930           3B46         06            cmp	ax,6[bp]
02737 0933           76           E0            jbe	.32
02738                       00000935            .35:
02739                       00000935            .2F:
02740 0935           89EC                       mov	sp,bp
02741 0937           5D                         pop	bp
02742 0938           C3                         ret
02743                                           ! 1105   void
02744                                           ! 1106 bios_printf(action, s)
02745                                           ! 1107   Bit16u action;
02746                                           export	_bios_printf
02747                       00000939            _bios_printf:
02748                                           !BCC_EOS
02749                                           ! 1108   Bit8u *s;
02750                                           !BCC_EOS
02751                                           ! 1109 {
02752                                           ! 1110   Bit8u c, format_char;
02753                                           !BCC_EOS
02754                                           ! 1111   bx_bool in_format;
02755                                           !BCC_EOS
02756                                           ! 1112   short i;
02757                                           !BCC_EOS
02758                                           ! 1113   Bit16u *arg_ptr;
02759                                           !BCC_EOS
02760                                           ! 1114   Bit16u arg, nibble, shift_count, format_width;
02761                                           !BCC_EOS
02762                                           ! 1115   Bit16u old_ds = set_DS(get_CS());
02763 0939           55                         push	bp
02764 093A           89E5                       mov	bp,sp
02765 093C           83C4                   EE  add	sp,*-$12
02766                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
02767 093F           E8         FD15            call	_get_CS
02768                                           ! Debug: list unsigned short = ax+0 (used reg = )
02769 0942           50                         push	ax
02770                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
02771 0943           E8         FD17            call	_set_DS
02772 0946           44                         inc	sp
02773 0947           44                         inc	sp
02774                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$14-$14] (used reg = )
02775 0948           8946         EE            mov	-$12[bp],ax
02776                                           !BCC_EOS
02777                                           ! 1116   Bit32u lval;
02778                                           !BCC_EOS
02779                                           ! 1117   arg_ptr = &s;
02780 094B           83C4                   FC  add	sp,*-4
02781                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02782 094E           8D5E         06            lea	bx,6[bp]
02783 0951           895E         F8            mov	-8[bp],bx
02784                                           !BCC_EOS
02785                                           ! 1118   in_format = 0;
02786                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02787 0954           31C0                       xor	ax,ax
02788 0956           8946         FC            mov	-4[bp],ax
02789                                           !BCC_EOS
02790                                           ! 1119   format_width = 0;
02791                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02792 0959           31C0                       xor	ax,ax
02793 095B           8946         F0            mov	-$10[bp],ax
02794                                           !BCC_EOS
02795                                           ! 1120   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02796                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02797 095E           8A46         04            mov	al,4[bp]
02798 0961           24                     07  and	al,*7
02799                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02800 0963           3C                     07  cmp	al,*7
02801 0965           75           1B            jne 	.36
02802                       00000967            .37:
02803                                           ! 1121     outb(0x401, 0x00);
02804                                           ! Debug: list int = const 0 (used reg = )
02805 0967           31C0                       xor	ax,ax
02806 0969           50                         push	ax
02807                                           ! Debug: list int = const $401 (used reg = )
02808 096A           B8                   0401  mov	ax,#$401
02809 096D           50                         push	ax
02810                                           ! Debug: func () void = outb+0 (used reg = )
02811 096E           E8         FBCE            call	_outb
02812 0971           83C4                   04  add	sp,*4
02813                                           !BCC_EOS
02814                                           ! 1122     bios_printf (2, "FATAL: ");
02815                                           ! Debug: list * char = .38+0 (used reg = )
02816 0974           BB                   DA02  mov	bx,#.38
02817 0977           53                         push	bx
02818                                           ! Debug: list int = const 2 (used reg = )
02819 0978           B8                   0002  mov	ax,*2
02820 097B           50                         push	ax
02821                                           ! Debug: func () void = bios_printf+0 (used reg = )
02822 097C           E8         FFBA            call	_bios_printf
02823 097F           83C4                   04  add	sp,*4
02824                                           !BCC_EOS
02825                                           ! 1123   }
02826                                           ! 1124   while (c = *((Bit8u *)(s))) {
02827                       00000982            .36:
02828 0982           E9         02B2            br 	.3A
02829                       00000985            .3B:
02830                                           ! 1125     if ( c == '%' ) {
02831                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02832 0985           8A46         FF            mov	al,-1[bp]
02833 0988           3C                     25  cmp	al,*$25
02834 098A           75           0E            jne 	.3C
02835                       0000098C            .3D:
02836                                           ! 1126       in_format = 1;
02837                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02838 098C           B8                   0001  mov	ax,*1
02839 098F           8946         FC            mov	-4[bp],ax
02840                                           !BCC_EOS
02841                                           ! 1127       format_width = 0;
02842                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02843 0992           31C0                       xor	ax,ax
02844 0994           8946         F0            mov	-$10[bp],ax
02845                                           !BCC_EOS
02846                                           ! 1128     }
02847                                           ! 1129     else if (in_format) {
02848 0997           E9         0296            br 	.3E
02849                       0000099A            .3C:
02850 099A           8B46         FC            mov	ax,-4[bp]
02851 099D           85C0                       test	ax,ax
02852 099F         0F84         027E            beq 	.3F
02853                       000009A3            .40:
02854                                           ! 1130       if ( (c>='0') && (c<='9') ) {
02855                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02856 09A3           8A46         FF            mov	al,-1[bp]
02857 09A6           3C                     30  cmp	al,*$30
02858 09A8           72           28            jb  	.41
02859                       000009AA            .43:
02860                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02861 09AA           8A46         FF            mov	al,-1[bp]
02862 09AD           3C                     39  cmp	al,*$39
02863 09AF           77           21            ja  	.41
02864                       000009B1            .42:
02865                                           ! 1131         format_width = (format_width * 10) + (c - '0');
02866                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02867 09B1           8A46         FF            mov	al,-1[bp]
02868 09B4           30E4                       xor	ah,ah
02869 09B6           05                   FFD0  add	ax,*-$30
02870 09B9           50                         push	ax
02871                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$12] (used reg = )
02872 09BA           8B46         F0            mov	ax,-$10[bp]
02873 09BD           89C2                       mov	dx,ax
02874 09BF           D1E0                       shl	ax,*1
02875 09C1           D1E0                       shl	ax,*1
02876 09C3           01D0                       add	ax,dx
02877 09C5           D1E0                       shl	ax,*1
02878                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02879 09C7           0346         E8            add	ax,-$18[bp]
02880 09CA           44                         inc	sp
02881 09CB           44                         inc	sp
02882                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$12] (used reg = )
02883 09CC           8946         F0            mov	-$10[bp],ax
02884                                           !BCC_EOS
02885                                           ! 1132       }
02886                                           ! 1133       else {
02887 09CF           E9         024D            br 	.44
02888                       000009D2            .41:
02889                                           ! 1134         arg_ptr++;
02890                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02891 09D2           8B5E         F8            mov	bx,-8[bp]
02892 09D5           43                         inc	bx
02893 09D6           43                         inc	bx
02894 09D7           895E         F8            mov	-8[bp],bx
02895                                           !BCC_EOS
02896                                           ! 1135         arg = read_word_SS(arg_ptr);
02897                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02898 09DA           FF76         F8            push	-8[bp]
02899                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
02900 09DD           E8         FC4C            call	_read_word_SS
02901 09E0           44                         inc	sp
02902 09E1           44                         inc	sp
02903                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02904 09E2           8946         F6            mov	-$A[bp],ax
02905                                           !BCC_EOS
02906                                           ! 1136         if ((c & 0xdf) == 'X') {
02907                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
02908 09E5           8A46         FF            mov	al,-1[bp]
02909 09E8           24                     DF  and	al,#$DF
02910                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
02911 09EA           3C                     58  cmp	al,*$58
02912 09EC           75           64            jne 	.45
02913                       000009EE            .46:
02914                                           ! 1137           if (format_width == 0)
02915                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02916 09EE           8B46         F0            mov	ax,-$10[bp]
02917 09F1           85C0                       test	ax,ax
02918 09F3           75           06            jne 	.47
02919                       000009F5            .48:
02920                                           ! 1138             format_width = 4;
02921                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$12] (used reg = )
02922 09F5           B8                   0004  mov	ax,*4
02923 09F8           8946         F0            mov	-$10[bp],ax
02924                                           !BCC_EOS
02925                                           ! 1139           for (i=format_width-1; i>=0; i--) {
02926                       000009FB            .47:
02927                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
02928 09FB           8B46         F0            mov	ax,-$10[bp]
02929                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02930 09FE           48                         dec	ax
02931 09FF           8946         FA            mov	-6[bp],ax
02932                                           !BCC_EOS
02933                                           !BCC_EOS
02934 0A02           EB           44            jmp .4B
02935                       00000A04            .4C:
02936                                           ! 1140             nibble = (arg >> (4 * i)) & 0x000f;
02937                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02938                                           ! Debug: expression subtree swapping
02939 0A04           8B46         FA            mov	ax,-6[bp]
02940 0A07           D1E0                       shl	ax,*1
02941 0A09           D1E0                       shl	ax,*1
02942                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02943 0A0B           89C3                       mov	bx,ax
02944 0A0D           8B46         F6            mov	ax,-$A[bp]
02945 0A10           89D9                       mov	cx,bx
02946 0A12           D3E8                       shr	ax,cl
02947                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
02948 0A14           24                     0F  and	al,*$F
02949                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
02950 0A16           30E4                       xor	ah,ah
02951 0A18           8946         F4            mov	-$C[bp],ax
02952                                           !BCC_EOS
02953                                           ! 1141             send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
02954                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
02955 0A1B           8B46         F4            mov	ax,-$C[bp]
02956 0A1E           3D                   0009  cmp	ax,*9
02957 0A21           77           08            ja  	.4D
02958                       00000A23            .4E:
02959                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
02960 0A23           8B46         F4            mov	ax,-$C[bp]
02961 0A26           05                   0030  add	ax,*$30
02962 0A29           EB           0C            jmp .4F
02963                       00000A2B            .4D:
02964                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
02965 0A2B           8B46         F4            mov	ax,-$C[bp]
02966 0A2E           0246         FF            add	al,-1[bp]
02967 0A31           80D4                   00  adc	ah,*0
02968                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
02969 0A34           05                   FFDF  add	ax,*-$21
02970                       00000A37            .4F:
02971                                           ! Debug: list unsigned int = ax+0 (used reg = )
02972 0A37           50                         push	ax
02973                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02974 0A38           FF76         04            push	4[bp]
02975                                           ! Debug: func () void = send+0 (used reg = )
02976 0A3B           E8         FC48            call	_send
02977 0A3E           83C4                   04  add	sp,*4
02978                                           !BCC_EOS
02979                                           ! 1142           }
02980                                           ! 1143         }
02981                       00000A41            .4A:
02982                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
02983 0A41           8B46         FA            mov	ax,-6[bp]
02984 0A44           48                         dec	ax
02985 0A45           8946         FA            mov	-6[bp],ax
02986                       00000A48            .4B:
02987                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
02988 0A48           8B46         FA            mov	ax,-6[bp]
02989 0A4B           85C0                       test	ax,ax
02990 0A4D           7D           B5            jge	.4C
02991                       00000A4F            .50:
02992                       00000A4F            .49:
02993                                           ! 1144         else if (c == 'u') {
02994 0A4F           E9         01C8            br 	.51
02995                       00000A52            .45:
02996                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
02997 0A52           8A46         FF            mov	al,-1[bp]
02998 0A55           3C                     75  cmp	al,*$75
02999 0A57           75           15            jne 	.52
03000                       00000A59            .53:
03001                                           ! 1145           put_uint(action, arg, format_width, 0);
03002                                           ! Debug: list int = const 0 (used reg = )
03003 0A59           31C0                       xor	ax,ax
03004 0A5B           50                         push	ax
03005                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03006 0A5C           FF76         F0            push	-$10[bp]
03007                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03008 0A5F           FF76         F6            push	-$A[bp]
03009                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03010 0A62           FF76         04            push	4[bp]
03011                                           ! Debug: func () void = put_uint+0 (used reg = )
03012 0A65           E8         FC77            call	_put_uint
03013 0A68           83C4                   08  add	sp,*8
03014                                           !BCC_EOS
03015                                           ! 1146         }
03016                                           ! 1147         else if (c == 'l') {
03017 0A6B           E9         01AC            br 	.54
03018                       00000A6E            .52:
03019                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03020 0A6E           8A46         FF            mov	al,-1[bp]
03021 0A71           3C                     6C  cmp	al,*$6C
03022 0A73         0F85         0102            bne 	.55
03023                       00000A77            .56:
03024                                           ! 1148           s++;
03025                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03026 0A77           8B5E         06            mov	bx,6[bp]
03027 0A7A           43                         inc	bx
03028 0A7B           895E         06            mov	6[bp],bx
03029                                           !BCC_EOS
03030                                           ! 1149           c = *((Bit8u *)(s));
03031 0A7E           8B5E         06            mov	bx,6[bp]
03032                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03033 0A81           8A07                       mov	al,[bx]
03034 0A83           8846         FF            mov	-1[bp],al
03035                                           !BCC_EOS
03036                                           ! 1150           arg_ptr++;
03037                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03038 0A86           8B5E         F8            mov	bx,-8[bp]
03039 0A89           43                         inc	bx
03040 0A8A           43                         inc	bx
03041 0A8B           895E         F8            mov	-8[bp],bx
03042                                           !BCC_EOS
03043                                           ! 1151           *(((Bit16u *)&lval)+1) = read_word_SS(arg_ptr);
03044                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03045 0A8E           FF76         F8            push	-8[bp]
03046                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03047 0A91           E8         FB98            call	_read_word_SS
03048 0A94           44                         inc	sp
03049 0A95           44                         inc	sp
03050                                           ! Debug: eq unsigned short = ax+0 to unsigned short lval = [S+$18-$16] (used reg = )
03051 0A96           8946         EC            mov	-$14[bp],ax
03052                                           !BCC_EOS
03053                                           ! 1152           *((Bit16u *)&lval) = arg;
03054                                           ! Debug: eq unsigned short arg = [S+$18-$C] to unsigned short lval = [S+$18-$18] (used reg = )
03055 0A99           8B46         F6            mov	ax,-$A[bp]
03056 0A9C           8946         EA            mov	-$16[bp],ax
03057                                           !BCC_EOS
03058                                           ! 1153           if (c == 'd') {
03059                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03060 0A9F           8A46         FF            mov	al,-1[bp]
03061 0AA2           3C                     64  cmp	al,*$64
03062 0AA4           75           42            jne 	.57
03063                       00000AA6            .58:
03064                                           ! 1154             if (*(((Bit16u *)&lval)+1) & 0x8000)
03065                                           ! Debug: and unsigned int = const $8000 to unsigned short lval = [S+$18-$16] (used reg = )
03066 0AA6           8B46         EC            mov	ax,-$14[bp]
03067 0AA9           25                   8000  and	ax,#$8000
03068 0AAC           85C0                       test	ax,ax
03069 0AAE           74           20            je  	.59
03070                       00000AB0            .5A:
03071                                           ! 1155               put_luint(action, 0L-lval, format_width-1, 1);
03072                                           ! Debug: list int = const 1 (used reg = )
03073 0AB0           B8                   0001  mov	ax,*1
03074 0AB3           50                         push	ax
03075                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03076 0AB4           8B46         F0            mov	ax,-$10[bp]
03077                                           ! Debug: list unsigned int = ax-1 (used reg = )
03078 0AB7           48                         dec	ax
03079 0AB8           50                         push	ax
03080                                           ! Debug: sub unsigned long lval = [S+$1C-$18] to long = const 0 (used reg = )
03081 0AB9           31C0                       xor	ax,ax
03082 0ABB           31DB                       xor	bx,bx
03083 0ABD           8D7E         EA            lea	di,-$16[bp]
03084 0AC0           E8         F5EF            call	lsubul
03085                                           ! Debug: list unsigned long = bx+0 (used reg = )
03086 0AC3           53                         push	bx
03087 0AC4           50                         push	ax
03088                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03089 0AC5           FF76         04            push	4[bp]
03090                                           ! Debug: func () void = put_luint+0 (used reg = )
03091 0AC8           E8         FC97            call	_put_luint
03092 0ACB           83C4                   0A  add	sp,*$A
03093                                           !BCC_EOS
03094                                           ! 1156             else
03095                                           ! 1157               put_luint(action, lval, format_width, 0);
03096 0ACE           EB           15            jmp .5B
03097                       00000AD0            .59:
03098                                           ! Debug: list int = const 0 (used reg = )
03099 0AD0           31C0                       xor	ax,ax
03100 0AD2           50                         push	ax
03101                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03102 0AD3           FF76         F0            push	-$10[bp]
03103                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03104 0AD6           FF76         EC            push	-$14[bp]
03105 0AD9           FF76         EA            push	-$16[bp]
03106                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03107 0ADC           FF76         04            push	4[bp]
03108                                           ! Debug: func () void = put_luint+0 (used reg = )
03109 0ADF           E8         FC80            call	_put_luint
03110 0AE2           83C4                   0A  add	sp,*$A
03111                                           !BCC_EOS
03112                                           ! 1158           }
03113                       00000AE5            .5B:
03114                                           ! 1159           else if (c == 'u') {
03115 0AE5           E9         008E            br 	.5C
03116                       00000AE8            .57:
03117                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03118 0AE8           8A46         FF            mov	al,-1[bp]
03119 0AEB           3C                     75  cmp	al,*$75
03120 0AED           75           17            jne 	.5D
03121                       00000AEF            .5E:
03122                                           ! 1160             put_luint(action, lval, format_width, 0);
03123                                           ! Debug: list int = const 0 (used reg = )
03124 0AEF           31C0                       xor	ax,ax
03125 0AF1           50                         push	ax
03126                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03127 0AF2           FF76         F0            push	-$10[bp]
03128                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03129 0AF5           FF76         EC            push	-$14[bp]
03130 0AF8           FF76         EA            push	-$16[bp]
03131                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03132 0AFB           FF76         04            push	4[bp]
03133                                           ! Debug: func () void = put_luint+0 (used reg = )
03134 0AFE           E8         FC61            call	_put_luint
03135 0B01           83C4                   0A  add	sp,*$A
03136                                           !BCC_EOS
03137                                           ! 1161           }
03138                                           ! 1162           else if ((c & 0xdf) == 'X')
03139 0B04           EB           70            jmp .5F
03140                       00000B06            .5D:
03141                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
03142 0B06           8A46         FF            mov	al,-1[bp]
03143 0B09           24                     DF  and	al,#$DF
03144                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
03145 0B0B           3C                     58  cmp	al,*$58
03146 0B0D           75           67            jne 	.60
03147                       00000B0F            .61:
03148                                           ! 1163           {
03149                                           ! 1164             if (format_width == 0)
03150                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
03151 0B0F           8B46         F0            mov	ax,-$10[bp]
03152 0B12           85C0                       test	ax,ax
03153 0B14           75           06            jne 	.62
03154                       00000B16            .63:
03155                                           ! 1165               format_width = 8;
03156                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$12] (used reg = )
03157 0B16           B8                   0008  mov	ax,*8
03158 0B19           8946         F0            mov	-$10[bp],ax
03159                                           !BCC_EOS
03160                                           ! 1166             for (i=format_
03161                       00000B1C            .62:
03162                                           ! 1166 width-1; i>=0; i--) {
03163                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
03164 0B1C           8B46         F0            mov	ax,-$10[bp]
03165                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03166 0B1F           48                         dec	ax
03167 0B20           8946         FA            mov	-6[bp],ax
03168                                           !BCC_EOS
03169                                           !BCC_EOS
03170 0B23           EB           4A            jmp .66
03171                       00000B25            .67:
03172                                           ! 1167               nibble = ((Bit16u)(lval >> (4 * i))) & 0x000f;
03173                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03174                                           ! Debug: expression subtree swapping
03175 0B25           8B46         FA            mov	ax,-6[bp]
03176 0B28           D1E0                       shl	ax,*1
03177 0B2A           D1E0                       shl	ax,*1
03178                                           ! Debug: sr int = ax+0 to unsigned long lval = [S+$18-$18] (used reg = )
03179 0B2C           50                         push	ax
03180 0B2D           8B46         EA            mov	ax,-$16[bp]
03181 0B30           8B5E         EC            mov	bx,-$14[bp]
03182 0B33           8B7E         E8            mov	di,-$18[bp]
03183 0B36           E8         F5C1            call	lsrul
03184 0B39           44                         inc	sp
03185 0B3A           44                         inc	sp
03186                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
03187                                           ! Debug: and int = const $F to unsigned short = ax+0 (used reg = )
03188 0B3B           24                     0F  and	al,*$F
03189                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03190 0B3D           30E4                       xor	ah,ah
03191 0B3F           8946         F4            mov	-$C[bp],ax
03192                                           !BCC_EOS
03193                                           ! 1168               send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03194                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03195 0B42           8B46         F4            mov	ax,-$C[bp]
03196 0B45           3D                   0009  cmp	ax,*9
03197 0B48           77           08            ja  	.68
03198                       00000B4A            .69:
03199                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03200 0B4A           8B46         F4            mov	ax,-$C[bp]
03201 0B4D           05                   0030  add	ax,*$30
03202 0B50           EB           0C            jmp .6A
03203                       00000B52            .68:
03204                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03205 0B52           8B46         F4            mov	ax,-$C[bp]
03206 0B55           0246         FF            add	al,-1[bp]
03207 0B58           80D4                   00  adc	ah,*0
03208                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03209 0B5B           05                   FFDF  add	ax,*-$21
03210                       00000B5E            .6A:
03211                                           ! Debug: list unsigned int = ax+0 (used reg = )
03212 0B5E           50                         push	ax
03213                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03214 0B5F           FF76         04            push	4[bp]
03215                                           ! Debug: func () void = send+0 (used reg = )
03216 0B62           E8         FB21            call	_send
03217 0B65           83C4                   04  add	sp,*4
03218                                           !BCC_EOS
03219                                           ! 1169             }
03220                                           ! 1170           }
03221                       00000B68            .65:
03222                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03223 0B68           8B46         FA            mov	ax,-6[bp]
03224 0B6B           48                         dec	ax
03225 0B6C           8946         FA            mov	-6[bp],ax
03226                       00000B6F            .66:
03227                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03228 0B6F           8B46         FA            mov	ax,-6[bp]
03229 0B72           85C0                       test	ax,ax
03230 0B74           7D           AF            jge	.67
03231                       00000B76            .6B:
03232                       00000B76            .64:
03233                                           ! 1171         }
03234                       00000B76            .60:
03235                       00000B76            .5F:
03236                       00000B76            .5C:
03237                                           ! 1172         else if (c == 'd') {
03238 0B76           E9         00A1            br 	.6C
03239                       00000B79            .55:
03240                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03241 0B79           8A46         FF            mov	al,-1[bp]
03242 0B7C           3C                     64  cmp	al,*$64
03243 0B7E           75           38            jne 	.6D
03244                       00000B80            .6E:
03245                                           ! 1173           if (arg & 0x8000)
03246                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$C] (used reg = )
03247 0B80           8B46         F6            mov	ax,-$A[bp]
03248 0B83           25                   8000  and	ax,#$8000
03249 0B86           85C0                       test	ax,ax
03250 0B88           74           1A            je  	.6F
03251                       00000B8A            .70:
03252                                           ! 1174             put_uint(action, -arg, format_width - 1, 1);
03253                                           ! Debug: list int = const 1 (used reg = )
03254 0B8A           B8                   0001  mov	ax,*1
03255 0B8D           50                         push	ax
03256                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03257 0B8E           8B46         F0            mov	ax,-$10[bp]
03258                                           ! Debug: list unsigned int = ax-1 (used reg = )
03259 0B91           48                         dec	ax
03260 0B92           50                         push	ax
03261                                           ! Debug: neg unsigned short arg = [S+$1C-$C] (used reg = )
03262 0B93           31C0                       xor	ax,ax
03263 0B95           2B46         F6            sub	ax,-$A[bp]
03264                                           ! Debug: list unsigned int = ax+0 (used reg = )
03265 0B98           50                         push	ax
03266                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03267 0B99           FF76         04            push	4[bp]
03268                                           ! Debug: func () void = put_uint+0 (used reg = )
03269 0B9C           E8         FB40            call	_put_uint
03270 0B9F           83C4                   08  add	sp,*8
03271                                           !BCC_EOS
03272                                           ! 1175           else
03273                                           ! 1176             put_uint(action, arg, format_width, 0);
03274 0BA2           EB           12            jmp .71
03275                       00000BA4            .6F:
03276                                           ! Debug: list int = const 0 (used reg = )
03277 0BA4           31C0                       xor	ax,ax
03278 0BA6           50                         push	ax
03279                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03280 0BA7           FF76         F0            push	-$10[bp]
03281                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03282 0BAA           FF76         F6            push	-$A[bp]
03283                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03284 0BAD           FF76         04            push	4[bp]
03285                                           ! Debug: func () void = put_uint+0 (used reg = )
03286 0BB0           E8         FB2C            call	_put_uint
03287 0BB3           83C4                   08  add	sp,*8
03288                                           !BCC_EOS
03289                                           ! 1177         }
03290                       00000BB6            .71:
03291                                           ! 1178         else if (c == 's') {
03292 0BB6           EB           62            jmp .72
03293                       00000BB8            .6D:
03294                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03295 0BB8           8A46         FF            mov	al,-1[bp]
03296 0BBB           3C                     73  cmp	al,*$73
03297 0BBD           75           12            jne 	.73
03298                       00000BBF            .74:
03299                                           ! 1179           put_str(action, get_CS(), arg);
03300                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03301 0BBF           FF76         F6            push	-$A[bp]
03302                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03303 0BC2           E8         FA92            call	_get_CS
03304                                           ! Debug: list unsigned short = ax+0 (used reg = )
03305 0BC5           50                         push	ax
03306                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03307 0BC6           FF76         04            push	4[bp]
03308                                           ! Debug: func () void = put_str+0 (used reg = )
03309 0BC9           E8         FC4D            call	_put_str
03310 0BCC           83C4                   06  add	sp,*6
03311                                           !BCC_EOS
03312                                           ! 1180         }
03313                                           ! 1181         else if (c == 'S') {
03314 0BCF           EB           49            jmp .75
03315                       00000BD1            .73:
03316                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03317 0BD1           8A46         FF            mov	al,-1[bp]
03318 0BD4           3C                     53  cmp	al,*$53
03319 0BD6           75           1F            jne 	.76
03320                       00000BD8            .77:
03321                                           ! 1182           arg_ptr++;
03322                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03323 0BD8           8B5E         F8            mov	bx,-8[bp]
03324 0BDB           43                         inc	bx
03325 0BDC           43                         inc	bx
03326 0BDD           895E         F8            mov	-8[bp],bx
03327                                           !BCC_EOS
03328                                           ! 1183           put_str(action, arg, read_word_SS(arg_ptr));
03329                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03330 0BE0           FF76         F8            push	-8[bp]
03331                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03332 0BE3           E8         FA46            call	_read_word_SS
03333 0BE6           44                         inc	sp
03334 0BE7           44                         inc	sp
03335                                           ! Debug: list unsigned short = ax+0 (used reg = )
03336 0BE8           50                         push	ax
03337                                           ! Debug: list unsigned short arg = [S+$1A-$C] (used reg = )
03338 0BE9           FF76         F6            push	-$A[bp]
03339                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03340 0BEC           FF76         04            push	4[bp]
03341                                           ! Debug: func () void = put_str+0 (used reg = )
03342 0BEF           E8         FC27            call	_put_str
03343 0BF2           83C4                   06  add	sp,*6
03344                                           !BCC_EOS
03345                                           ! 1184         }
03346                                           ! 1185         else if (c == 'c') {
03347 0BF5           EB           23            jmp .78
03348                       00000BF7            .76:
03349                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03350 0BF7           8A46         FF            mov	al,-1[bp]
03351 0BFA           3C                     63  cmp	al,*$63
03352 0BFC           75           0E            jne 	.79
03353                       00000BFE            .7A:
03354                                           ! 1186           send(action, arg);
03355                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03356 0BFE           FF76         F6            push	-$A[bp]
03357                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03358 0C01           FF76         04            push	4[bp]
03359                                           ! Debug: func () void = send+0 (used reg = )
03360 0C04           E8         FA7F            call	_send
03361 0C07           83C4                   04  add	sp,*4
03362                                           !BCC_EOS
03363                                           ! 1187         }
03364                                           ! 1188         else
03365                                           ! 1189           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03366 0C0A           EB           0E            jmp .7B
03367                       00000C0C            .79:
03368                                           ! Debug: list * char = .7C+0 (used reg = )
03369 0C0C           BB                   D9E5  mov	bx,#.7C
03370 0C0F           53                         push	bx
03371                                           ! Debug: list int = const 7 (used reg = )
03372 0C10           B8                   0007  mov	ax,*7
03373 0C13           50                         push	ax
03374                                           ! Debug: func () void = bios_printf+0 (used reg = )
03375 0C14           E8         FD22            call	_bios_printf
03376 0C17           83C4                   04  add	sp,*4
03377                                           !BCC_EOS
03378                                           ! 1190           in_format = 0;
03379                       00000C1A            .7B:
03380                       00000C1A            .78:
03381                       00000C1A            .75:
03382                       00000C1A            .72:
03383                       00000C1A            .6C:
03384                       00000C1A            .54:
03385                       00000C1A            .51:
03386                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03387 0C1A           31C0                       xor	ax,ax
03388 0C1C           8946         FC            mov	-4[bp],ax
03389                                           !BCC_EOS
03390                                           ! 1191       }
03391                                           ! 1192     }
03392                       00000C1F            .44:
03393                                           ! 1193     else {
03394 0C1F           EB           0F            jmp .7D
03395                       00000C21            .3F:
03396                                           ! 1194       send(action, c);
03397                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03398 0C21           8A46         FF            mov	al,-1[bp]
03399 0C24           30E4                       xor	ah,ah
03400 0C26           50                         push	ax
03401                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03402 0C27           FF76         04            push	4[bp]
03403                                           ! Debug: func () void = send+0 (used reg = )
03404 0C2A           E8         FA59            call	_send
03405 0C2D           83C4                   04  add	sp,*4
03406                                           !BCC_EOS
03407                                           ! 1195     }
03408                                           ! 1196     s ++;
03409                       00000C30            .7D:
03410                       00000C30            .3E:
03411                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03412 0C30           8B5E         06            mov	bx,6[bp]
03413 0C33           43                         inc	bx
03414 0C34           895E         06            mov	6[bp],bx
03415                                           !BCC_EOS
03416                                           ! 1197   }
03417                                           ! 1198   if (action & 1) {
03418                       00000C37            .3A:
03419 0C37           8B5E         06            mov	bx,6[bp]
03420                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03421 0C3A           8A07                       mov	al,[bx]
03422 0C3C           8846         FF            mov	-1[bp],al
03423 0C3F           84C0                       test	al,al
03424 0C41         0F85         FD40            bne 	.3B
03425                       00000C45            .7E:
03426                       00000C45            .39:
03427                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03428 0C45           8A46         04            mov	al,4[bp]
03429 0C48           24                     01  and	al,*1
03430 0C4A           84C0                       test	al,al
03431 0C4C           74           04            je  	.7F
03432                       00000C4E            .80:
03433                                           ! 1199 #asm
03434                                           !BCC_EOS
03435                                           !BCC_ASM
03436                       00000006            _bios_printf.format_width	set	6
03437                       FFFFFFF0            .bios_printf.format_width	set	-$10
03438                       00000014            _bios_printf.format_char	set	$14
03439                       FFFFFFFE            .bios_printf.format_char	set	-2
03440                       0000000E            _bios_printf.arg_ptr	set	$E
03441                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03442                       0000001A            _bios_printf.action	set	$1A
03443                       00000004            .bios_printf.action	set	4
03444                       00000010            _bios_printf.i	set	$10
03445                       FFFFFFFA            .bios_printf.i	set	-6
03446                       00000008            _bios_printf.shift_count	set	8
03447                       FFFFFFF2            .bios_printf.shift_count	set	-$E
03448                       00000012            _bios_printf.in_format	set	$12
03449                       FFFFFFFC            .bios_printf.in_format	set	-4
03450                       0000001C            _bios_printf.s	set	$1C
03451                       00000006            .bios_printf.s	set	6
03452                       00000000            _bios_printf.lval	set	0
03453                       FFFFFFEA            .bios_printf.lval	set	-$16
03454                       0000000A            _bios_printf.nibble	set	$A
03455                       FFFFFFF4            .bios_printf.nibble	set	-$C
03456                       00000015            _bios_printf.c	set	$15
03457                       FFFFFFFF            .bios_printf.c	set	-1
03458                       0000000C            _bios_printf.arg	set	$C
03459                       FFFFFFF6            .bios_printf.arg	set	-$A
03460                       00000004            _bios_printf.old_ds	set	4
03461                       FFFFFFEE            .bios_printf.old_ds	set	-$12
03462 0C4E           FA                             cli
03463                       00000C4F             halt2_loop:
03464 0C4F           F4                             hlt
03465 0C50           EB           FD                jmp halt2_loop
03466                                           ! 1204 endasm
03467                                           !BCC_ENDASM
03468                                           !BCC_EOS
03469                                           ! 1205   }
03470                                           ! 1206   set_DS(old_ds);
03471                       00000C52            .7F:
03472                                           ! Debug: list unsigned short old_ds = [S+$18-$14] (used reg = )
03473 0C52           FF76         EE            push	-$12[bp]
03474                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
03475 0C55           E8         FA05            call	_set_DS
03476 0C58           44                         inc	sp
03477 0C59           44                         inc	sp
03478                                           !BCC_EOS
03479                                           ! 1207 }
03480 0C5A           89EC                       mov	sp,bp
03481 0C5C           5D                         pop	bp
03482 0C5D           C3                         ret
03483                                           ! 1208   void
03484                                           ! Register BX used in function bios_printf
03485                                           ! 1209 keyboard_init()
03486                                           ! 1210 {
03487                                           export	_keyboard_init
03488                       00000C5E            _keyboard_init:
03489                                           ! 1211     Bit16u max;
03490                                           !BCC_EOS
03491                                           ! 1212     max=0xffff;
03492 0C5E           55                         push	bp
03493 0C5F           89E5                       mov	bp,sp
03494 0C61           4C                         dec	sp
03495 0C62           4C                         dec	sp
03496                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03497 0C63           B8                   FFFF  mov	ax,#$FFFF
03498 0C66           8946         FE            mov	-2[bp],ax
03499                                           !BCC_EOS
03500                                           ! 1213     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03501 0C69           EB           0D            jmp .82
03502                       00000C6B            .83:
03503                                           ! Debug: list int = const 0 (used reg = )
03504 0C6B           31C0                       xor	ax,ax
03505 0C6D           50                         push	ax
03506                                           ! Debug: list int = const $80 (used reg = )
03507 0C6E           B8                   0080  mov	ax,#$80
03508 0C71           50                         push	ax
03509                                           ! Debug: func () void = outb+0 (used reg = )
03510 0C72           E8         F8CA            call	_outb
03511 0C75           83C4                   04  add	sp,*4
03512                                           !BCC_EOS
03513                                           ! 1214     max=0x2000;
03514                       00000C78            .82:
03515                                           ! Debug: list int = const $64 (used reg = )
03516 0C78           B8                   0064  mov	ax,*$64
03517 0C7B           50                         push	ax
03518                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03519 0C7C           E8         F8AA            call	_inb
03520 0C7F           44                         inc	sp
03521 0C80           44                         inc	sp
03522                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03523 0C81           24                     02  and	al,*2
03524 0C83           84C0                       test	al,al
03525 0C85           74           0B            je  	.84
03526                       00000C87            .85:
03527                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03528 0C87           8B46         FE            mov	ax,-2[bp]
03529 0C8A           48                         dec	ax
03530 0C8B           8946         FE            mov	-2[bp],ax
03531                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03532 0C8E           85C0                       test	ax,ax
03533 0C90           75           D9            jne	.83
03534                       00000C92            .84:
03535                       00000C92            .81:
03536                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03537 0C92           B8                   2000  mov	ax,#$2000
03538 0C95           8946         FE            mov	-2[bp],ax
03539                                           !BCC_EOS
03540                                           ! 1215     while (--max > 0) {
03541 0C98           EB           2B            jmp .87
03542                       00000C9A            .88:
03543                                           ! 1216         outb(0x0080, 0x00);
03544                                           ! Debug: list int = const 0 (used reg = )
03545 0C9A           31C0                       xor	ax,ax
03546 0C9C           50                         push	ax
03547                                           ! Debug: list int = const $80 (used reg = )
03548 0C9D           B8                   0080  mov	ax,#$80
03549 0CA0           50                         push	ax
03550                                           ! Debug: func () void = outb+0 (used reg = )
03551 0CA1           E8         F89B            call	_outb
03552 0CA4           83C4                   04  add	sp,*4
03553                                           !BCC_EOS
03554                                           ! 1217         if (inb(0x0064) & 0x01) {
03555                                           ! Debug: list int = const $64 (used reg = )
03556 0CA7           B8                   0064  mov	ax,*$64
03557 0CAA           50                         push	ax
03558                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03559 0CAB           E8         F87B            call	_inb
03560 0CAE           44                         inc	sp
03561 0CAF           44                         inc	sp
03562                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03563 0CB0           24                     01  and	al,*1
03564 0CB2           84C0                       test	al,al
03565 0CB4           74           0F            je  	.89
03566                       00000CB6            .8A:
03567                                           ! 1218             inb(0x0060);
03568                                           ! Debug: list int = const $60 (used reg = )
03569 0CB6           B8                   0060  mov	ax,*$60
03570 0CB9           50                         push	ax
03571                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03572 0CBA           E8         F86C            call	_inb
03573 0CBD           44                         inc	sp
03574 0CBE           44                         inc	sp
03575                                           !BCC_EOS
03576                                           ! 1219             max = 0x2000;
03577                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03578 0CBF           B8                   2000  mov	ax,#$2000
03579 0CC2           8946         FE            mov	-2[bp],ax
03580                                           !BCC_EOS
03581                                           ! 1220         }
03582                                           ! 1221     }
03583                       00000CC5            .89:
03584                                           ! 1222     outb(0x0064, 0xaa);
03585                       00000CC5            .87:
03586                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03587 0CC5           8B46         FE            mov	ax,-2[bp]
03588 0CC8           48                         dec	ax
03589 0CC9           8946         FE            mov	-2[bp],ax
03590                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03591 0CCC           85C0                       test	ax,ax
03592 0CCE           75           CA            jne	.88
03593                       00000CD0            .8B:
03594                       00000CD0            .86:
03595                                           ! Debug: list int = const $AA (used reg = )
03596 0CD0           B8                   00AA  mov	ax,#$AA
03597 0CD3           50                         push	ax
03598                                           ! Debug: list int = const $64 (used reg = )
03599 0CD4           B8                   0064  mov	ax,*$64
03600 0CD7           50                         push	ax
03601                                           ! Debug: func () void = outb+0 (used reg = )
03602 0CD8           E8         F864            call	_outb
03603 0CDB           83C4                   04  add	sp,*4
03604                                           !BCC_EOS
03605                                           ! 1223     max=0xffff;
03606                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03607 0CDE           B8                   FFFF  mov	ax,#$FFFF
03608 0CE1           8946         FE            mov	-2[bp],ax
03609                                           !BCC_EOS
03610                                           ! 1224     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03611 0CE4           EB           0D            jmp .8D
03612                       00000CE6            .8E:
03613                                           ! Debug: list int = const 0 (used reg = )
03614 0CE6           31C0                       xor	ax,ax
03615 0CE8           50                         push	ax
03616                                           ! Debug: list int = const $80 (used reg = )
03617 0CE9           B8                   0080  mov	ax,#$80
03618 0CEC           50                         push	ax
03619                                           ! Debug: func () void = outb+0 (used reg = )
03620 0CED           E8         F84F            call	_outb
03621 0CF0           83C4                   04  add	sp,*4
03622                                           !BCC_EOS
03623                                           ! 1225     if (max==0x0) keyboard_panic(00);
03624                       00000CF3            .8D:
03625                                           ! Debug: list int = const $64 (used reg = )
03626 0CF3           B8                   0064  mov	ax,*$64
03627 0CF6           50                         push	ax
03628                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03629 0CF7           E8         F82F            call	_inb
03630 0CFA           44                         inc	sp
03631 0CFB           44                         inc	sp
03632                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03633 0CFC           24                     02  and	al,*2
03634 0CFE           84C0                       test	al,al
03635 0D00           74           0B            je  	.8F
03636                       00000D02            .90:
03637                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03638 0D02           8B46         FE            mov	ax,-2[bp]
03639 0D05           48                         dec	ax
03640 0D06           8946         FE            mov	-2[bp],ax
03641                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03642 0D09           85C0                       test	ax,ax
03643 0D0B           75           D9            jne	.8E
03644                       00000D0D            .8F:
03645                       00000D0D            .8C:
03646                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03647 0D0D           8B46         FE            mov	ax,-2[bp]
03648 0D10           85C0                       test	ax,ax
03649 0D12           75           08            jne 	.91
03650                       00000D14            .92:
03651                                           ! Debug: list int = const 0 (used reg = )
03652 0D14           31C0                       xor	ax,ax
03653 0D16           50                         push	ax
03654                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03655 0D17           E8         0488            call	_keyboard_panic
03656 0D1A           44                         inc	sp
03657 0D1B           44                         inc	sp
03658                                           !BCC_EOS
03659                                           ! 1226     max=0xffff;
03660                       00000D1C            .91:
03661                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03662 0D1C           B8                   FFFF  mov	ax,#$FFFF
03663 0D1F           8946         FE            mov	-2[bp],ax
03664                                           !BCC_EOS
03665                                           ! 1227     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x01);
03666 0D22           EB           0E            jmp .94
03667                       00000D24            .95:
03668                                           ! Debug: list int = const 1 (used reg = )
03669 0D24           B8                   0001  mov	ax,*1
03670 0D27           50                         push	ax
03671                                           ! Debug: list int = const $80 (used reg = )
03672 0D28           B8                   0080  mov	ax,#$80
03673 0D2B           50                         push	ax
03674                                           ! Debug: func () void = outb+0 (used reg = )
03675 0D2C           E8         F810            call	_outb
03676 0D2F           83C4                   04  add	sp,*4
03677                                           !BCC_EOS
03678                                           ! 1228     if (max==0x0) keyboard_panic(01);
03679                       00000D32            .94:
03680                                           ! Debug: list int = const $64 (used reg = )
03681 0D32           B8                   0064  mov	ax,*$64
03682 0D35           50                         push	ax
03683                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03684 0D36           E8         F7F0            call	_inb
03685 0D39           44                         inc	sp
03686 0D3A           44                         inc	sp
03687                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03688 0D3B           24                     01  and	al,*1
03689                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03690 0D3D           84C0                       test	al,al
03691 0D3F           75           0B            jne 	.96
03692                       00000D41            .97:
03693                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03694 0D41           8B46         FE            mov	ax,-2[bp]
03695 0D44           48                         dec	ax
03696 0D45           8946         FE            mov	-2[bp],ax
03697                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03698 0D48           85C0                       test	ax,ax
03699 0D4A           75           D8            jne	.95
03700                       00000D4C            .96:
03701                       00000D4C            .93:
03702                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03703 0D4C           8B46         FE            mov	ax,-2[bp]
03704 0D4F           85C0                       test	ax,ax
03705 0D51           75           09            jne 	.98
03706                       00000D53            .99:
03707                                           ! Debug: list int = const 1 (used reg = )
03708 0D53           B8                   0001  mov	ax,*1
03709 0D56           50                         push	ax
03710                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03711 0D57           E8         0448            call	_keyboard_panic
03712 0D5A           44                         inc	sp
03713 0D5B           44                         inc	sp
03714                                           !BCC_EOS
03715                                           ! 1229     if ((inb(0x0060) != 0x55)){
03716                       00000D5C            .98:
03717                                           ! Debug: list int = const $60 (used reg = )
03718 0D5C           B8                   0060  mov	ax,*$60
03719 0D5F           50                         push	ax
03720                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03721 0D60           E8         F7C6            call	_inb
03722 0D63           44                         inc	sp
03723 0D64           44                         inc	sp
03724                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03725 0D65           3C                     55  cmp	al,*$55
03726 0D67           74           09            je  	.9A
03727                       00000D69            .9B:
03728                                           ! 1230         keyboard_panic(991);
03729                                           ! Debug: list int = const $3DF (used reg = )
03730 0D69           B8                   03DF  mov	ax,#$3DF
03731 0D6C           50                         push	ax
03732                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03733 0D6D           E8         0432            call	_keyboard_panic
03734 0D70           44                         inc	sp
03735 0D71           44                         inc	sp
03736                                           !BCC_EOS
03737                                           ! 1231     }
03738                                           ! 1232     outb(0x0064,0xab);
03739                       00000D72            .9A:
03740                                           ! Debug: list int = const $AB (used reg = )
03741 0D72           B8                   00AB  mov	ax,#$AB
03742 0D75           50                         push	ax
03743                                           ! Debug: list int = const $64 (used reg = )
03744 0D76           B8                   0064  mov	ax,*$64
03745 0D79           50                         push	ax
03746                                           ! Debug: func () void = outb+0 (used reg = )
03747 0D7A           E8         F7C2            call	_outb
03748 0D7D           83C4                   04  add	sp,*4
03749                                           !BCC_EOS
03750                                           ! 1233     max=0xffff;
03751                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03752 0D80           B8                   FFFF  mov	ax,#$FFFF
03753 0D83           8946         FE            mov	-2[bp],ax
03754                                           !BCC_EOS
03755                                           ! 1234     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03756 0D86           EB           0E            jmp .9D
03757                       00000D88            .9E:
03758                                           ! Debug: list int = const $10 (used reg = )
03759 0D88           B8                   0010  mov	ax,*$10
03760 0D8B           50                         push	ax
03761                                           ! Debug: list int = const $80 (used reg = )
03762 0D8C           B8                   0080  mov	ax,#$80
03763 0D8F           50                         push	ax
03764                                           ! Debug: func () void = outb+0 (used reg = )
03765 0D90           E8         F7AC            call	_outb
03766 0D93           83C4                   04  add	sp,*4
03767                                           !BCC_EOS
03768                                           ! 1235     if (max==0x0) keyboard_panic(10);
03769                       00000D96            .9D:
03770                                           ! Debug: list int = const $64 (used reg = )
03771 0D96           B8                   0064  mov	ax,*$64
03772 0D99           50                         push	ax
03773                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03774 0D9A           E8         F78C            call	_inb
03775 0D9D           44                         inc	sp
03776 0D9E           44                         inc	sp
03777                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03778 0D9F           24                     02  and	al,*2
03779 0DA1           84C0                       test	al,al
03780 0DA3           74           0B            je  	.9F
03781                       00000DA5            .A0:
03782                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03783 0DA5           8B46         FE            mov	ax,-2[bp]
03784 0DA8           48                         dec	ax
03785 0DA9           8946         FE            mov	-2[bp],ax
03786                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03787 0DAC           85C0                       test	ax,ax
03788 0DAE           75           D8            jne	.9E
03789                       00000DB0            .9F:
03790                       00000DB0            .9C:
03791                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03792 0DB0           8B46         FE            mov	ax,-2[bp]
03793 0DB3           85C0                       test	ax,ax
03794 0DB5           75           09            jne 	.A1
03795                       00000DB7            .A2:
03796                                           ! Debug: list int = const $A (used reg = )
03797 0DB7           B8                   000A  mov	ax,*$A
03798 0DBA           50                         push	ax
03799                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03800 0DBB           E8         03E4            call	_keyboard_panic
03801 0DBE           44                         inc	sp
03802 0DBF           44                         inc	sp
03803                                           !BCC_EOS
03804                                           ! 1236     max=0xffff;
03805                       00000DC0            .A1:
03806                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03807 0DC0           B8                   FFFF  mov	ax,#$FFFF
03808 0DC3           8946         FE            mov	-2[bp],ax
03809                                           !BCC_EOS
03810                                           ! 1237     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x11);
03811 0DC6           EB           0E            jmp .A4
03812                       00000DC8            .A5:
03813                                           ! Debug: list int = const $11 (used reg = )
03814 0DC8           B8                   0011  mov	ax,*$11
03815 0DCB           50                         push	ax
03816                                           ! Debug: list int = const $80 (used reg = )
03817 0DCC           B8                   0080  mov	ax,#$80
03818 0DCF           50                         push	ax
03819                                           ! Debug: func () void = outb+0 (used reg = )
03820 0DD0           E8         F76C            call	_outb
03821 0DD3           83C4                   04  add	sp,*4
03822                                           !BCC_EOS
03823                                           ! 1238     if (max==0x0) keyboard_panic(11);
03824                       00000DD6            .A4:
03825                                           ! Debug: list int = const $64 (used reg = )
03826 0DD6           B8                   0064  mov	ax,*$64
03827 0DD9           50                         push	ax
03828                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03829 0DDA           E8         F74C            call	_inb
03830 0DDD           44                         inc	sp
03831 0DDE           44                         inc	sp
03832                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03833 0DDF           24                     01  and	al,*1
03834                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03835 0DE1           84C0                       test	al,al
03836 0DE3           75           0B            jne 	.A6
03837                       00000DE5            .A7:
03838                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03839 0DE5           8B46         FE            mov	ax,-2[bp]
03840 0DE8           48                         dec	ax
03841 0DE9           8946         FE            mov	-2[bp],ax
03842                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03843 0DEC           85C0                       test	ax,ax
03844 0DEE           75           D8            jne	.A5
03845                       00000DF0            .A6:
03846                       00000DF0            .A3:
03847                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03848 0DF0           8B46         FE            mov	ax,-2[bp]
03849 0DF3           85C0                       test	ax,ax
03850 0DF5           75           09            jne 	.A8
03851                       00000DF7            .A9:
03852                                           ! Debug: list int = const $B (used reg = )
03853 0DF7           B8                   000B  mov	ax,*$B
03854 0DFA           50                         push	ax
03855                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03856 0DFB           E8         03A4            call	_keyboard_panic
03857 0DFE           44                         inc	sp
03858 0DFF           44                         inc	sp
03859                                           !BCC_EOS
03860                                           ! 1239     if ((inb(0x0060) != 0x00)) {
03861                       00000E00            .A8:
03862                                           ! Debug: list int = const $60 (used reg = )
03863 0E00           B8                   0060  mov	ax,*$60
03864 0E03           50                         push	ax
03865                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03866 0E04           E8         F722            call	_inb
03867 0E07           44                         inc	sp
03868 0E08           44                         inc	sp
03869                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03870 0E09           84C0                       test	al,al
03871 0E0B           74           09            je  	.AA
03872                       00000E0D            .AB:
03873                                           ! 1240         keyboard_panic(992);
03874                                           ! Debug: list int = const $3E0 (used reg = )
03875 0E0D           B8                   03E0  mov	ax,#$3E0
03876 0E10           50                         push	ax
03877                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03878 0E11           E8         038E            call	_keyboard_panic
03879 0E14           44                         inc	sp
03880 0E15           44                         inc	sp
03881                                           !BCC_EOS
03882                                           ! 1241     }
03883                                           ! 1242     outb(0x0064,0xae);
03884                       00000E16            .AA:
03885                                           ! Debug: list int = const $AE (used reg = )
03886 0E16           B8                   00AE  mov	ax,#$AE
03887 0E19           50                         push	ax
03888                                           ! Debug: list int = const $64 (used reg = )
03889 0E1A           B8                   0064  mov	ax,*$64
03890 0E1D           50                         push	ax
03891                                           ! Debug: func () void = outb+0 (used reg = )
03892 0E1E           E8         F71E            call	_outb
03893 0E21           83C4                   04  add	sp,*4
03894                                           !BCC_EOS
03895                                           ! 1243     max=0xffff;
03896                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03897 0E24           B8                   FFFF  mov	ax,#$FFFF
03898 0E27           8946         FE            mov	-2[bp],ax
03899                                           !BCC_EOS
03900                                           ! 1244     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03901 0E2A           EB           0E            jmp .AD
03902                       00000E2C            .AE:
03903                                           ! Debug: list int = const $10 (used reg = )
03904 0E2C           B8                   0010  mov	ax,*$10
03905 0E2F           50                         push	ax
03906                                           ! Debug: list int = const $80 (used reg = )
03907 0E30           B8                   0080  mov	ax,#$80
03908 0E33           50                         push	ax
03909                                           ! Debug: func () void = outb+0 (used reg = )
03910 0E34           E8         F708            call	_outb
03911 0E37           83C4                   04  add	sp,*4
03912                                           !BCC_EOS
03913                                           ! 1245     if (max==0x0) keyboard_panic(10);
03914                       00000E3A            .AD:
03915                                           ! Debug: list int = const $64 (used reg = )
03916 0E3A           B8                   0064  mov	ax,*$64
03917 0E3D           50                         push	ax
03918                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03919 0E3E           E8         F6E8            call	_inb
03920 0E41           44                         inc	sp
03921 0E42           44                         inc	sp
03922                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03923 0E43           24                     02  and	al,*2
03924 0E45           84C0                       test	al,al
03925 0E47           74           0B            je  	.AF
03926                       00000E49            .B0:
03927                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03928 0E49           8B46         FE            mov	ax,-2[bp]
03929 0E4C           48                         dec	ax
03930 0E4D           8946         FE            mov	-2[bp],ax
03931                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03932 0E50           85C0                       test	ax,ax
03933 0E52           75           D8            jne	.AE
03934                       00000E54            .AF:
03935                       00000E54            .AC:
03936                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03937 0E54           8B46         FE            mov	ax,-2[bp]
03938 0E57           85C0                       test	ax,ax
03939 0E59           75           09            jne 	.B1
03940                       00000E5B            .B2:
03941                                           ! Debug: list int = const $A (used reg = )
03942 0E5B           B8                   000A  mov	ax,*$A
03943 0E5E           50                         push	ax
03944                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03945 0E5F           E8         0340            call	_keyboard_panic
03946 0E62           44                         inc	sp
03947 0E63           44                         inc	sp
03948                                           !BCC_EOS
03949                                           ! 1246     o
03950                                           ! 1246 utb(0x0064,0xa8);
03951                       00000E64            .B1:
03952                                           ! Debug: list int = const $A8 (used reg = )
03953 0E64           B8                   00A8  mov	ax,#$A8
03954 0E67           50                         push	ax
03955                                           ! Debug: list int = const $64 (used reg = )
03956 0E68           B8                   0064  mov	ax,*$64
03957 0E6B           50                         push	ax
03958                                           ! Debug: func () void = outb+0 (used reg = )
03959 0E6C           E8         F6D0            call	_outb
03960 0E6F           83C4                   04  add	sp,*4
03961                                           !BCC_EOS
03962                                           ! 1247     max=0xffff;
03963                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03964 0E72           B8                   FFFF  mov	ax,#$FFFF
03965 0E75           8946         FE            mov	-2[bp],ax
03966                                           !BCC_EOS
03967                                           ! 1248     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03968 0E78           EB           0E            jmp .B4
03969                       00000E7A            .B5:
03970                                           ! Debug: list int = const $10 (used reg = )
03971 0E7A           B8                   0010  mov	ax,*$10
03972 0E7D           50                         push	ax
03973                                           ! Debug: list int = const $80 (used reg = )
03974 0E7E           B8                   0080  mov	ax,#$80
03975 0E81           50                         push	ax
03976                                           ! Debug: func () void = outb+0 (used reg = )
03977 0E82           E8         F6BA            call	_outb
03978 0E85           83C4                   04  add	sp,*4
03979                                           !BCC_EOS
03980                                           ! 1249     if (max==0x0) keyboard_panic(10);
03981                       00000E88            .B4:
03982                                           ! Debug: list int = const $64 (used reg = )
03983 0E88           B8                   0064  mov	ax,*$64
03984 0E8B           50                         push	ax
03985                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03986 0E8C           E8         F69A            call	_inb
03987 0E8F           44                         inc	sp
03988 0E90           44                         inc	sp
03989                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03990 0E91           24                     02  and	al,*2
03991 0E93           84C0                       test	al,al
03992 0E95           74           0B            je  	.B6
03993                       00000E97            .B7:
03994                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03995 0E97           8B46         FE            mov	ax,-2[bp]
03996 0E9A           48                         dec	ax
03997 0E9B           8946         FE            mov	-2[bp],ax
03998                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03999 0E9E           85C0                       test	ax,ax
04000 0EA0           75           D8            jne	.B5
04001                       00000EA2            .B6:
04002                       00000EA2            .B3:
04003                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04004 0EA2           8B46         FE            mov	ax,-2[bp]
04005 0EA5           85C0                       test	ax,ax
04006 0EA7           75           09            jne 	.B8
04007                       00000EA9            .B9:
04008                                           ! Debug: list int = const $A (used reg = )
04009 0EA9           B8                   000A  mov	ax,*$A
04010 0EAC           50                         push	ax
04011                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04012 0EAD           E8         02F2            call	_keyboard_panic
04013 0EB0           44                         inc	sp
04014 0EB1           44                         inc	sp
04015                                           !BCC_EOS
04016                                           ! 1250     outb(0x0060, 0xff);
04017                       00000EB2            .B8:
04018                                           ! Debug: list int = const $FF (used reg = )
04019 0EB2           B8                   00FF  mov	ax,#$FF
04020 0EB5           50                         push	ax
04021                                           ! Debug: list int = const $60 (used reg = )
04022 0EB6           B8                   0060  mov	ax,*$60
04023 0EB9           50                         push	ax
04024                                           ! Debug: func () void = outb+0 (used reg = )
04025 0EBA           E8         F682            call	_outb
04026 0EBD           83C4                   04  add	sp,*4
04027                                           !BCC_EOS
04028                                           ! 1251     max=0xffff;
04029                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04030 0EC0           B8                   FFFF  mov	ax,#$FFFF
04031 0EC3           8946         FE            mov	-2[bp],ax
04032                                           !BCC_EOS
04033                                           ! 1252     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x20);
04034 0EC6           EB           0E            jmp .BB
04035                       00000EC8            .BC:
04036                                           ! Debug: list int = const $20 (used reg = )
04037 0EC8           B8                   0020  mov	ax,*$20
04038 0ECB           50                         push	ax
04039                                           ! Debug: list int = const $80 (used reg = )
04040 0ECC           B8                   0080  mov	ax,#$80
04041 0ECF           50                         push	ax
04042                                           ! Debug: func () void = outb+0 (used reg = )
04043 0ED0           E8         F66C            call	_outb
04044 0ED3           83C4                   04  add	sp,*4
04045                                           !BCC_EOS
04046                                           ! 1253     if (max==0x0) keyboard_panic(20);
04047                       00000ED6            .BB:
04048                                           ! Debug: list int = const $64 (used reg = )
04049 0ED6           B8                   0064  mov	ax,*$64
04050 0ED9           50                         push	ax
04051                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04052 0EDA           E8         F64C            call	_inb
04053 0EDD           44                         inc	sp
04054 0EDE           44                         inc	sp
04055                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04056 0EDF           24                     02  and	al,*2
04057 0EE1           84C0                       test	al,al
04058 0EE3           74           0B            je  	.BD
04059                       00000EE5            .BE:
04060                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04061 0EE5           8B46         FE            mov	ax,-2[bp]
04062 0EE8           48                         dec	ax
04063 0EE9           8946         FE            mov	-2[bp],ax
04064                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04065 0EEC           85C0                       test	ax,ax
04066 0EEE           75           D8            jne	.BC
04067                       00000EF0            .BD:
04068                       00000EF0            .BA:
04069                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04070 0EF0           8B46         FE            mov	ax,-2[bp]
04071 0EF3           85C0                       test	ax,ax
04072 0EF5           75           09            jne 	.BF
04073                       00000EF7            .C0:
04074                                           ! Debug: list int = const $14 (used reg = )
04075 0EF7           B8                   0014  mov	ax,*$14
04076 0EFA           50                         push	ax
04077                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04078 0EFB           E8         02A4            call	_keyboard_panic
04079 0EFE           44                         inc	sp
04080 0EFF           44                         inc	sp
04081                                           !BCC_EOS
04082                                           ! 1254     max=0xffff;
04083                       00000F00            .BF:
04084                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04085 0F00           B8                   FFFF  mov	ax,#$FFFF
04086 0F03           8946         FE            mov	-2[bp],ax
04087                                           !BCC_EOS
04088                                           ! 1255     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x21);
04089 0F06           EB           0E            jmp .C2
04090                       00000F08            .C3:
04091                                           ! Debug: list int = const $21 (used reg = )
04092 0F08           B8                   0021  mov	ax,*$21
04093 0F0B           50                         push	ax
04094                                           ! Debug: list int = const $80 (used reg = )
04095 0F0C           B8                   0080  mov	ax,#$80
04096 0F0F           50                         push	ax
04097                                           ! Debug: func () void = outb+0 (used reg = )
04098 0F10           E8         F62C            call	_outb
04099 0F13           83C4                   04  add	sp,*4
04100                                           !BCC_EOS
04101                                           ! 1256     if (max==0x0) keyboard_panic(21);
04102                       00000F16            .C2:
04103                                           ! Debug: list int = const $64 (used reg = )
04104 0F16           B8                   0064  mov	ax,*$64
04105 0F19           50                         push	ax
04106                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04107 0F1A           E8         F60C            call	_inb
04108 0F1D           44                         inc	sp
04109 0F1E           44                         inc	sp
04110                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04111 0F1F           24                     01  and	al,*1
04112                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04113 0F21           84C0                       test	al,al
04114 0F23           75           0B            jne 	.C4
04115                       00000F25            .C5:
04116                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04117 0F25           8B46         FE            mov	ax,-2[bp]
04118 0F28           48                         dec	ax
04119 0F29           8946         FE            mov	-2[bp],ax
04120                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04121 0F2C           85C0                       test	ax,ax
04122 0F2E           75           D8            jne	.C3
04123                       00000F30            .C4:
04124                       00000F30            .C1:
04125                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04126 0F30           8B46         FE            mov	ax,-2[bp]
04127 0F33           85C0                       test	ax,ax
04128 0F35           75           09            jne 	.C6
04129                       00000F37            .C7:
04130                                           ! Debug: list int = const $15 (used reg = )
04131 0F37           B8                   0015  mov	ax,*$15
04132 0F3A           50                         push	ax
04133                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04134 0F3B           E8         0264            call	_keyboard_panic
04135 0F3E           44                         inc	sp
04136 0F3F           44                         inc	sp
04137                                           !BCC_EOS
04138                                           ! 1257     if ((inb(0x0060) != 0xfa)) {
04139                       00000F40            .C6:
04140                                           ! Debug: list int = const $60 (used reg = )
04141 0F40           B8                   0060  mov	ax,*$60
04142 0F43           50                         push	ax
04143                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04144 0F44           E8         F5E2            call	_inb
04145 0F47           44                         inc	sp
04146 0F48           44                         inc	sp
04147                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04148 0F49           3C                     FA  cmp	al,#$FA
04149 0F4B           74           09            je  	.C8
04150                       00000F4D            .C9:
04151                                           ! 1258         keyboard_panic(993);
04152                                           ! Debug: list int = const $3E1 (used reg = )
04153 0F4D           B8                   03E1  mov	ax,#$3E1
04154 0F50           50                         push	ax
04155                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04156 0F51           E8         024E            call	_keyboard_panic
04157 0F54           44                         inc	sp
04158 0F55           44                         inc	sp
04159                                           !BCC_EOS
04160                                           ! 1259     }
04161                                           ! 1260     max=0xffff;
04162                       00000F56            .C8:
04163                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04164 0F56           B8                   FFFF  mov	ax,#$FFFF
04165 0F59           8946         FE            mov	-2[bp],ax
04166                                           !BCC_EOS
04167                                           ! 1261     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x31);
04168 0F5C           EB           0E            jmp .CB
04169                       00000F5E            .CC:
04170                                           ! Debug: list int = const $31 (used reg = )
04171 0F5E           B8                   0031  mov	ax,*$31
04172 0F61           50                         push	ax
04173                                           ! Debug: list int = const $80 (used reg = )
04174 0F62           B8                   0080  mov	ax,#$80
04175 0F65           50                         push	ax
04176                                           ! Debug: func () void = outb+0 (used reg = )
04177 0F66           E8         F5D6            call	_outb
04178 0F69           83C4                   04  add	sp,*4
04179                                           !BCC_EOS
04180                                           ! 1262     if (max==0x0) keyboard_panic(31);
04181                       00000F6C            .CB:
04182                                           ! Debug: list int = const $64 (used reg = )
04183 0F6C           B8                   0064  mov	ax,*$64
04184 0F6F           50                         push	ax
04185                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04186 0F70           E8         F5B6            call	_inb
04187 0F73           44                         inc	sp
04188 0F74           44                         inc	sp
04189                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04190 0F75           24                     01  and	al,*1
04191                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04192 0F77           84C0                       test	al,al
04193 0F79           75           0B            jne 	.CD
04194                       00000F7B            .CE:
04195                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04196 0F7B           8B46         FE            mov	ax,-2[bp]
04197 0F7E           48                         dec	ax
04198 0F7F           8946         FE            mov	-2[bp],ax
04199                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04200 0F82           85C0                       test	ax,ax
04201 0F84           75           D8            jne	.CC
04202                       00000F86            .CD:
04203                       00000F86            .CA:
04204                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04205 0F86           8B46         FE            mov	ax,-2[bp]
04206 0F89           85C0                       test	ax,ax
04207 0F8B           75           09            jne 	.CF
04208                       00000F8D            .D0:
04209                                           ! Debug: list int = const $1F (used reg = )
04210 0F8D           B8                   001F  mov	ax,*$1F
04211 0F90           50                         push	ax
04212                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04213 0F91           E8         020E            call	_keyboard_panic
04214 0F94           44                         inc	sp
04215 0F95           44                         inc	sp
04216                                           !BCC_EOS
04217                                           ! 1263     if ((inb(0x0060) != 0xaa)) {
04218                       00000F96            .CF:
04219                                           ! Debug: list int = const $60 (used reg = )
04220 0F96           B8                   0060  mov	ax,*$60
04221 0F99           50                         push	ax
04222                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04223 0F9A           E8         F58C            call	_inb
04224 0F9D           44                         inc	sp
04225 0F9E           44                         inc	sp
04226                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04227 0F9F           3C                     AA  cmp	al,#$AA
04228 0FA1           74           09            je  	.D1
04229                       00000FA3            .D2:
04230                                           ! 1264         keyboard_panic(994);
04231                                           ! Debug: list int = const $3E2 (used reg = )
04232 0FA3           B8                   03E2  mov	ax,#$3E2
04233 0FA6           50                         push	ax
04234                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04235 0FA7           E8         01F8            call	_keyboard_panic
04236 0FAA           44                         inc	sp
04237 0FAB           44                         inc	sp
04238                                           !BCC_EOS
04239                                           ! 1265     }
04240                                           ! 1266     outb(0x0060, 0xf5);
04241                       00000FAC            .D1:
04242                                           ! Debug: list int = const $F5 (used reg = )
04243 0FAC           B8                   00F5  mov	ax,#$F5
04244 0FAF           50                         push	ax
04245                                           ! Debug: list int = const $60 (used reg = )
04246 0FB0           B8                   0060  mov	ax,*$60
04247 0FB3           50                         push	ax
04248                                           ! Debug: func () void = outb+0 (used reg = )
04249 0FB4           E8         F588            call	_outb
04250 0FB7           83C4                   04  add	sp,*4
04251                                           !BCC_EOS
04252                                           ! 1267     max=0xffff;
04253                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04254 0FBA           B8                   FFFF  mov	ax,#$FFFF
04255 0FBD           8946         FE            mov	-2[bp],ax
04256                                           !BCC_EOS
04257                                           ! 1268     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x40);
04258 0FC0           EB           0E            jmp .D4
04259                       00000FC2            .D5:
04260                                           ! Debug: list int = const $40 (used reg = )
04261 0FC2           B8                   0040  mov	ax,*$40
04262 0FC5           50                         push	ax
04263                                           ! Debug: list int = const $80 (used reg = )
04264 0FC6           B8                   0080  mov	ax,#$80
04265 0FC9           50                         push	ax
04266                                           ! Debug: func () void = outb+0 (used reg = )
04267 0FCA           E8         F572            call	_outb
04268 0FCD           83C4                   04  add	sp,*4
04269                                           !BCC_EOS
04270                                           ! 1269     if (max==0x0) keyboard_panic(40);
04271                       00000FD0            .D4:
04272                                           ! Debug: list int = const $64 (used reg = )
04273 0FD0           B8                   0064  mov	ax,*$64
04274 0FD3           50                         push	ax
04275                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04276 0FD4           E8         F552            call	_inb
04277 0FD7           44                         inc	sp
04278 0FD8           44                         inc	sp
04279                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04280 0FD9           24                     02  and	al,*2
04281 0FDB           84C0                       test	al,al
04282 0FDD           74           0B            je  	.D6
04283                       00000FDF            .D7:
04284                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04285 0FDF           8B46         FE            mov	ax,-2[bp]
04286 0FE2           48                         dec	ax
04287 0FE3           8946         FE            mov	-2[bp],ax
04288                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04289 0FE6           85C0                       test	ax,ax
04290 0FE8           75           D8            jne	.D5
04291                       00000FEA            .D6:
04292                       00000FEA            .D3:
04293                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04294 0FEA           8B46         FE            mov	ax,-2[bp]
04295 0FED           85C0                       test	ax,ax
04296 0FEF           75           09            jne 	.D8
04297                       00000FF1            .D9:
04298                                           ! Debug: list int = const $28 (used reg = )
04299 0FF1           B8                   0028  mov	ax,*$28
04300 0FF4           50                         push	ax
04301                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04302 0FF5           E8         01AA            call	_keyboard_panic
04303 0FF8           44                         inc	sp
04304 0FF9           44                         inc	sp
04305                                           !BCC_EOS
04306                                           ! 1270     max=0xffff;
04307                       00000FFA            .D8:
04308                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04309 0FFA           B8                   FFFF  mov	ax,#$FFFF
04310 0FFD           8946         FE            mov	-2[bp],ax
04311                                           !BCC_EOS
04312                                           ! 1271     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x41);
04313 1000           EB           0E            jmp .DB
04314                       00001002            .DC:
04315                                           ! Debug: list int = const $41 (used reg = )
04316 1002           B8                   0041  mov	ax,*$41
04317 1005           50                         push	ax
04318                                           ! Debug: list int = const $80 (used reg = )
04319 1006           B8                   0080  mov	ax,#$80
04320 1009           50                         push	ax
04321                                           ! Debug: func () void = outb+0 (used reg = )
04322 100A           E8         F532            call	_outb
04323 100D           83C4                   04  add	sp,*4
04324                                           !BCC_EOS
04325                                           ! 1272     if (max==0x0) keyboard_panic(41);
04326                       00001010            .DB:
04327                                           ! Debug: list int = const $64 (used reg = )
04328 1010           B8                   0064  mov	ax,*$64
04329 1013           50                         push	ax
04330                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04331 1014           E8         F512            call	_inb
04332 1017           44                         inc	sp
04333 1018           44                         inc	sp
04334                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04335 1019           24                     01  and	al,*1
04336                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04337 101B           84C0                       test	al,al
04338 101D           75           0B            jne 	.DD
04339                       0000101F            .DE:
04340                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04341 101F           8B46         FE            mov	ax,-2[bp]
04342 1022           48                         dec	ax
04343 1023           8946         FE            mov	-2[bp],ax
04344                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04345 1026           85C0                       test	ax,ax
04346 1028           75           D8            jne	.DC
04347                       0000102A            .DD:
04348                       0000102A            .DA:
04349                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04350 102A           8B46         FE            mov	ax,-2[bp]
04351 102D           85C0                       test	ax,ax
04352 102F           75           09            jne 	.DF
04353                       00001031            .E0:
04354                                           ! Debug: list int = const $29 (used reg = )
04355 1031           B8                   0029  mov	ax,*$29
04356 1034           50                         push	ax
04357                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04358 1035           E8         016A            call	_keyboard_panic
04359 1038           44                         inc	sp
04360 1039           44                         inc	sp
04361                                           !BCC_EOS
04362                                           ! 1273     if ((inb(0x0060) != 0xfa)) {
04363                       0000103A            .DF:
04364                                           ! Debug: list int = const $60 (used reg = )
04365 103A           B8                   0060  mov	ax,*$60
04366 103D           50                         push	ax
04367                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04368 103E           E8         F4E8            call	_inb
04369 1041           44                         inc	sp
04370 1042           44                         inc	sp
04371                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04372 1043           3C                     FA  cmp	al,#$FA
04373 1045           74           09            je  	.E1
04374                       00001047            .E2:
04375                                           ! 1274         keyboard_panic(995);
04376                                           ! Debug: list int = const $3E3 (used reg = )
04377 1047           B8                   03E3  mov	ax,#$3E3
04378 104A           50                         push	ax
04379                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04380 104B           E8         0154            call	_keyboard_panic
04381 104E           44                         inc	sp
04382 104F           44                         inc	sp
04383                                           !BCC_EOS
04384                                           ! 1275     }
04385                                           ! 1276     outb(0x0064, 0x60);
04386                       00001050            .E1:
04387                                           ! Debug: list int = const $60 (used reg = )
04388 1050           B8                   0060  mov	ax,*$60
04389 1053           50                         push	ax
04390                                           ! Debug: list int = const $64 (used reg = )
04391 1054           B8                   0064  mov	ax,*$64
04392 1057           50                         push	ax
04393                                           ! Debug: func () void = outb+0 (used reg = )
04394 1058           E8         F4E4            call	_outb
04395 105B           83C4                   04  add	sp,*4
04396                                           !BCC_EOS
04397                                           ! 1277     max=0xffff;
04398                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04399 105E           B8                   FFFF  mov	ax,#$FFFF
04400 1061           8946         FE            mov	-2[bp],ax
04401                                           !BCC_EOS
04402                                           ! 1278     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x50);
04403 1064           EB           0E            jmp .E4
04404                       00001066            .E5:
04405                                           ! Debug: list int = const $50 (used reg = )
04406 1066           B8                   0050  mov	ax,*$50
04407 1069           50                         push	ax
04408                                           ! Debug: list int = const $80 (used reg = )
04409 106A           B8                   0080  mov	ax,#$80
04410 106D           50                         push	ax
04411                                           ! Debug: func () void = outb+0 (used reg = )
04412 106E           E8         F4CE            call	_outb
04413 1071           83C4                   04  add	sp,*4
04414                                           !BCC_EOS
04415                                           ! 1279     if (max==0x0) keyboard_panic(50);
04416                       00001074            .E4:
04417                                           ! Debug: list int = const $64 (used reg = )
04418 1074           B8                   0064  mov	ax,*$64
04419 1077           50                         push	ax
04420                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04421 1078           E8         F4AE            call	_inb
04422 107B           44                         inc	sp
04423 107C           44                         inc	sp
04424                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04425 107D           24                     02  and	al,*2
04426 107F           84C0                       test	al,al
04427 1081           74           0B            je  	.E6
04428                       00001083            .E7:
04429                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04430 1083           8B46         FE            mov	ax,-2[bp]
04431 1086           48                         dec	ax
04432 1087           8946         FE            mov	-2[bp],ax
04433                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04434 108A           85C0                       test	ax,ax
04435 108C           75           D8            jne	.E5
04436                       0000108E            .E6:
04437                       0000108E            .E3:
04438                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04439 108E           8B46         FE            mov	ax,-2[bp]
04440 1091           85C0                       test	ax,ax
04441 1093           75           09            jne 	.E8
04442                       00001095            .E9:
04443                                           ! Debug: list int = const $32 (used reg = )
04444 1095           B8                   0032  mov	ax,*$32
04445 1098           50                         push	ax
04446                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04447 1099           E8         0106            call	_keyboard_panic
04448 109C           44                         inc	sp
04449 109D           44                         inc	sp
04450                                           !BCC_EOS
04451                                           ! 1280     outb(0x0060, 0x61);
04452                       0000109E            .E8:
04453                                           ! Debug: list int = const $61 (used reg = )
04454 109E           B8                   0061  mov	ax,*$61
04455 10A1           50                         push	ax
04456                                           ! Debug: list int = const $60 (used reg = )
04457 10A2           B8                   0060  mov	ax,*$60
04458 10A5           50                         push	ax
04459                                           ! Debug: func () void = outb+0 (used reg = )
04460 10A6           E8         F496            call	_outb
04461 10A9           83C4                   04  add	sp,*4
04462                                           !BCC_EOS
04463                                           ! 1281     max=0xffff;
04464                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04465 10AC           B8                   FFFF  mov	ax,#$FFFF
04466 10AF           8946         FE            mov	-2[bp],ax
04467                                           !BCC_EOS
04468                                           ! 1282     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x60);
04469 10B2           EB           0E            jmp .EB
04470                       000010B4            .EC:
04471                                           ! Debug: list int = const $60 (used reg = )
04472 10B4           B8                   0060  mov	ax,*$60
04473 10B7           50                         push	ax
04474                                           ! Debug: list int = const $80 (used reg = )
04475 10B8           B8                   0080  mov	ax,#$80
04476 10BB           50                         push	ax
04477                                           ! Debug: func () void = outb+0 (used reg = )
04478 10BC           E8         F480            call	_outb
04479 10BF           83C4                   04  add	sp,*4
04480                                           !BCC_EOS
04481                                           ! 1283     if (max==0x0) keyboard_panic(60);
04482                       000010C2            .EB:
04483                                           ! Debug: list int = const $64 (used reg = )
04484 10C2           B8                   0064  mov	ax,*$64
04485 10C5           50                         push	ax
04486                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04487 10C6           E8         F460            call	_inb
04488 10C9           44                         inc	sp
04489 10CA           44                         inc	sp
04490                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04491 10CB           24                     02  and	al,*2
04492 10CD           84C0                       test	al,al
04493 10CF           74           0B            je  	.ED
04494                       000010D1            .EE:
04495                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04496 10D1           8B46         FE            mov	ax,-2[bp]
04497 10D4           48                         dec	ax
04498 10D5           8946         FE            mov	-2[bp],ax
04499                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04500 10D8           85C0                       test	ax,ax
04501 10DA           75           D8            jne	.EC
04502                       000010DC            .ED:
04503                       000010DC            .EA:
04504                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04505 10DC           8B46         FE            mov	ax,-2[bp]
04506 10DF           85C0                       test	ax,ax
04507 10E1           75           09            jne 	.EF
04508                       000010E3            .F0:
04509                                           ! Debug: list int = const $3C (used reg = )
04510 10E3           B8                   003C  mov	ax,*$3C
04511 10E6           50                         push	ax
04512                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04513 10E7           E8         00B8            call	_keyboard_panic
04514 10EA           44                         inc	sp
04515 10EB           44                         inc	sp
04516                                           !BCC_EOS
04517                                           ! 1284     outb(0x0060, 0xf4);
04518                       000010EC            .EF:
04519                                           ! Debug: list int = const $F4 (used reg = )
04520 10EC           B8                   00F4  mov	ax,#$F4
04521 10EF           50                         push	ax
04522                                           ! Debug: list int = const $60 (used reg = )
04523 10F0           B8                   0060  mov	ax,*$60
04524 10F3           50                         push	ax
04525                                           ! Debug: func () void = outb+0 (used reg = )
04526 10F4           E8         F448            call	_outb
04527 10F7           83C4                   04  add	sp,*4
04528                                           !BCC_EOS
04529                                           ! 1285     max=0xffff;
04530                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04531 10FA           B8                   FFFF  mov	ax,#$FFFF
04532 10FD           8946         FE            mov	-2[bp],ax
04533                                           !BCC_EOS
04534                                           ! 1286     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x70);
04535 1100           EB           0E            jmp .F2
04536                       00001102            .F3:
04537                                           ! Debug: list int = const $70 (used reg = )
04538 1102           B8                   0070  mov	ax,*$70
04539 1105           50                         push	ax
04540                                           ! Debug: list int = const $80 (used reg = )
04541 1106           B8                   0080  mov	ax,#$80
04542 1109           50                         push	ax
04543                                           ! Debug: func () void = outb+0 (used reg = )
04544 110A           E8         F432            call	_outb
04545 110D           83C4                   04  add	sp,*4
04546                                           !BCC_EOS
04547                                           ! 1287     if (max==0x0) keyboard_panic(70);
04548                       00001110            .F2:
04549                                           ! Debug: list int = const $64 (used reg = )
04550 1110           B8                   0064  mov	ax,*$64
04551 1113           50                         push	ax
04552                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04553 1114           E8         F412            call	_inb
04554 1117           44                         inc	sp
04555 1118           44                         inc	sp
04556                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04557 1119           24                     02  and	al,*2
04558 111B           84C0                       test	al,al
04559 111D           74           0B            je  	.F4
04560                       0000111F            .F5:
04561                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04562 111F           8B46         FE            mov	ax,-2[bp]
04563 1122           48                         dec	ax
04564 1123           8946         FE            mov	-2[bp],ax
04565                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04566 1126           85C0                       test	ax,ax
04567 1128           75           D8            jne	.F3
04568                       0000112A            .F4:
04569                       0000112A            .F1:
04570                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04571 112A           8B46         FE            mov	ax,-2[bp]
04572 112D           85C0                       test	ax,ax
04573 112F           75           09            jne 	.F6
04574                       00001131            .F7:
04575                                           ! Debug: list int = const $46 (used reg = )
04576 1131           B8                   0046  mov	ax,*$46
04577 1134           50                         push	ax
04578                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04579 1135           E8         006A            call	_keyboard_panic
04580 1138           44                         inc	sp
04581 1139           44                         inc	sp
04582                                           !BCC_EOS
04583                                           ! 1288     max=0xffff;
04584                       0000113A            .F6:
04585                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04586 113A           B8                   FFFF  mov	ax,#$FFFF
04587 113D           8946         FE            mov	-2[bp],ax
04588                                           !BCC_EOS
04589                                           ! 1289     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x71);
04590 1140           EB           0E            jmp .F9
04591                       00001142            .FA:
04592                                           ! Debug: list int = const $71 (used reg = )
04593 1142           B8                   0071  mov	ax,*$71
04594 1145           50                         push	ax
04595                                           ! Debug: list int = const $80 (used reg = )
04596 1146           B8                   0080  mov	ax,#$80
04597 1149           50                         push	ax
04598                                           ! Debug: func () void = outb+0 (used reg = )
04599 114A           E8         F3F2            call	_outb
04600 114D           83C4                   04  add	sp,*4
04601                                           !BCC_EOS
04602                                           ! 1290     if (max==0x0) keyboard_panic(70);
04603                       00001150            .F9:
04604                                           ! Debug: list int = const $64 (used reg = )
04605 1150           B8                   0064  mov	ax,*$64
04606 1153           50                         push	ax
04607                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04608 1154           E8         F3D2            call	_inb
04609 1157           44                         inc	sp
04610 1158           44                         inc	sp
04611                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04612 1159           24                     01  and	al,*1
04613                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04614 115B           84C0                       test	al,al
04615 115D           75           0B            jne 	.FB
04616                       0000115F            .FC:
04617                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04618 115F           8B46         FE            mov	ax,-2[bp]
04619 1162           48                         dec	ax
04620 1163           8946         FE            mov	-2[bp],ax
04621                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04622 1166           85C0                       test	ax,ax
04623 1168           75           D8            jne	.FA
04624                       0000116A            .FB:
04625                       0000116A            .F8:
04626                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04627 116A           8B46         FE            mov	ax,-2[bp]
04628 116D           85C0                       test	ax,ax
04629 116F           75           09            jne 	.FD
04630                       00001171            .FE:
04631                                           ! Debug: list int = const $46 (used reg = )
04632 1171           B8                   0046  mov	ax,*$46
04633 1174           50                         push	ax
04634                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04635 1175           E8         002A            call	_keyboard_panic
04636 1178           44                         inc	sp
04637 1179           44                         inc	sp
04638                                           !BCC_EOS
04639                                           ! 1291     if ((inb(0x0060) != 0xfa)) {
04640                       0000117A            .FD:
04641                                           ! Debug: list int = const $60 (used reg = )
04642 117A           B8                   0060  mov	ax,*$60
04643 117D           50                         push	ax
04644                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04645 117E           E8         F3A8            call	_inb
04646 1181           44                         inc	sp
04647 1182           44                         inc	sp
04648                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04649 1183           3C                     FA  cmp	al,#$FA
04650 1185           74           09            je  	.FF
04651                       00001187            .100:
04652                                           ! 1292         keyboard_panic(996);
04653                                           ! Debug: list int = const $3E4 (used reg = )
04654 1187           B8                   03E4  mov	ax,#$3E4
04655 118A           50                         push	ax
04656                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04657 118B           E8         0014            call	_keyboard_panic
04658 118E           44                         inc	sp
04659 118F           44                         inc	sp
04660                                           !BCC_EOS
04661                                           ! 1293     }
04662                                           ! 1294     outb(0x0080, 0x77);
04663                       00001190            .FF:
04664                                           ! Debug: list int = const $77 (used reg = )
04665 1190           B8                   0077  mov	ax,*$77
04666 1193           50                         push	ax
04667                                           ! Debug: list int = const $80 (used reg = )
04668 1194           B8                   0080  mov	ax,#$80
04669 1197           50                         push	ax
04670                                           ! Debug: func () void = outb+0 (used reg = )
04671 1198           E8         F3A4            call	_outb
04672 119B           83C4                   04  add	sp,*4
04673                                           !BCC_EOS
04674                                           ! 1295 }
04675 119E           89EC                       mov	sp,bp
04676 11A0           5D                         pop	bp
04677 11A1           C3                         ret
04678                                           ! 1296   void
04679                                           ! 1297 keyboard_panic(status)
04680                                           ! 1298   Bit16u status;
04681                                           export	_keyboard_panic
04682                       000011A2            _keyboard_panic:
04683                                           !BCC_EOS
04684                                           ! 1299 {
04685                                           ! 1300   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04686 11A2           55                         push	bp
04687 11A3           89E5                       mov	bp,sp
04688                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04689 11A5           FF76         04            push	4[bp]
04690                                           ! Debug: list * char = .101+0 (used reg = )
04691 11A8           BB                   D9D2  mov	bx,#.101
04692 11AB           53                         push	bx
04693                                           ! Debug: list int = const 7 (used reg = )
04694 11AC           B8                   0007  mov	ax,*7
04695 11AF           50                         push	ax
04696                                           ! Debug: func () void = bios_printf+0 (used reg = )
04697 11B0           E8         F786            call	_bios_printf
04698 11B3           89EC                       mov	sp,bp
04699                                           !BCC_EOS
04700                                           ! 1301 }
04701 11B5           5D                         pop	bp
04702 11B6           C3                         ret
04703                                           ! 1302   void
04704                                           ! Register BX used in function keyboard_panic
04705                                           ! 1303 shutdown_status_panic(status)
04706                                           ! 1304   Bit16u status;
04707                                           export	_shutdown_status_panic
04708                       000011B7            _shutdown_status_panic:
04709                                           !BCC_EOS
04710                                           ! 1305 {
04711                                           ! 1306   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04712 11B7           55                         push	bp
04713 11B8           89E5                       mov	bp,sp
04714                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04715 11BA           8A46         04            mov	al,4[bp]
04716 11BD           30E4                       xor	ah,ah
04717 11BF           50                         push	ax
04718                                           ! Debug: list * char = .102+0 (used reg = )
04719 11C0           BB                   D9AD  mov	bx,#.102
04720 11C3           53                         push	bx
04721                                           ! Debug: list int = const 7 (used reg = )
04722 11C4           B8                   0007  mov	ax,*7
04723 11C7           50                         push	ax
04724                                           ! Debug: func () void = bios_printf+0 (used reg = )
04725 11C8           E8         F76E            call	_bios_printf
04726 11CB           89EC                       mov	sp,bp
04727                                           !BCC_EOS
04728                                           ! 1307 }
04729 11CD           5D                         pop	bp
04730 11CE           C3                         ret
04731                                           ! 1308 void s3_resume_panic()
04732                                           ! Register BX used in function shutdown_status_panic
04733                                           ! 1309 {
04734                                           export	_s3_resume_panic
04735                       000011CF            _s3_resume_panic:
04736                                           ! 1310   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04737 11CF           55                         push	bp
04738 11D0           89E5                       mov	bp,sp
04739                                           ! Debug: list * char = .103+0 (used reg = )
04740 11D2           BB                   D993  mov	bx,#.103
04741 11D5           53                         push	bx
04742                                           ! Debug: list int = const 7 (used reg = )
04743 11D6           B8                   0007  mov	ax,*7
04744 11D9           50                         push	ax
04745                                           ! Debug: func () void = bios_printf+0 (used reg = )
04746 11DA           E8         F75C            call	_bios_printf
04747 11DD           89EC                       mov	sp,bp
04748                                           !BCC_EOS
04749                                           ! 1311 }
04750 11DF           5D                         pop	bp
04751 11E0           C3                         ret
04752                                           ! 1312 void
04753                                           ! Register BX used in function s3_resume_panic
04754                                           ! 1313 print_bios_banner()
04755                                           ! 1314 {
04756                                           export	_print_bios_banner
04757                       000011E1            _print_bios_banner:
04758                                           ! 1315   bios_printf(
04759 11E1           55                         push	bp
04760 11E2           89E5                       mov	bp,sp
04761                                           ! 1315 2, "Bochs ""2.7"" BIOS - build: %s\n%s\nOptions: ", "08/01/21", bios_svn_version_string);
04762                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
04763 11E4           BB                   0165  mov	bx,#_bios_svn_version_string
04764 11E7           53                         push	bx
04765                                           ! Debug: list * char = .105+0 (used reg = )
04766 11E8           BB                   D962  mov	bx,#.105
04767 11EB           53                         push	bx
04768                                           ! Debug: list * char = .104+0 (used reg = )
04769 11EC           BB                   D96B  mov	bx,#.104
04770 11EF           53                         push	bx
04771                                           ! Debug: list int = const 2 (used reg = )
04772 11F0           B8                   0002  mov	ax,*2
04773 11F3           50                         push	ax
04774                                           ! Debug: func () void = bios_printf+0 (used reg = )
04775 11F4           E8         F742            call	_bios_printf
04776 11F7           89EC                       mov	sp,bp
04777                                           !BCC_EOS
04778                                           ! 1316   bios_printf(2, "apmbios " "pcibios " "pnpbios " "eltorito " "\n\n");
04779                                           ! Debug: list * char = .106+0 (used reg = )
04780 11F9           BB                   D93E  mov	bx,#.106
04781 11FC           53                         push	bx
04782                                           ! Debug: list int = const 2 (used reg = )
04783 11FD           B8                   0002  mov	ax,*2
04784 1200           50                         push	ax
04785                                           ! Debug: func () void = bios_printf+0 (used reg = )
04786 1201           E8         F735            call	_bios_printf
04787 1204           89EC                       mov	sp,bp
04788                                           !BCC_EOS
04789                                           ! 1317 }
04790 1206           5D                         pop	bp
04791 1207           C3                         ret
04792                                           ! 1318 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04793                                           ! Register BX used in function print_bios_banner
04794                                           
04795                       00001208            _drivetypes:
04796                       00001208            .107:
04797 1208                        00            .byte	0
04798 1209                  00000009            .blkb	9
04799                       00001212            .108:
04800 1212                        46            .ascii	"Floppy"
04801 1218                        00            .byte	0
04802 1219                  00000003            .blkb	3
04803                       0000121C            .109:
04804 121C                        48            .ascii	"Hard Disk"
04805 1225                        00            .byte	0
04806                       00001226            .10A:
04807 1226                        43            .ascii	"CD-Rom"
04808 122C                        00            .byte	0
04809 122D                  00000003            .blkb	3
04810                       00001230            .10B:
04811 1230                        4E            .ascii	"Network"
04812 1237                        00            .byte	0
04813 1238                  00000002            .blkb	2
04814                                           !BCC_EOS
04815                                           ! 1319 static void
04816                                           ! 1320 init_boot_vectors()
04817                                           ! 1321 {
04818                                           
04819                       0000123A            _init_boot_vectors:
04820                                           ! 1322   ipl_entry_t e;
04821                                           !BCC_EOS
04822                                           ! 1323   Bit16u count = 0;
04823 123A           55                         push	bp
04824 123B           89E5                       mov	bp,sp
04825 123D           83C4                   EE  add	sp,*-$12
04826                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04827 1240           31C0                       xor	ax,ax
04828 1242           8946         EE            mov	-$12[bp],ax
04829                                           !BCC_EOS
04830                                           ! 1324   Bit16u ss = get_SS();
04831 1245           4C                         dec	sp
04832 1246           4C                         dec	sp
04833                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04834 1247           E8         F410            call	_get_SS
04835                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04836 124A           8946         EC            mov	-$14[bp],ax
04837                                           !BCC_EOS
04838                                           ! 1325 #asm
04839                                           !BCC_EOS
04840                                           !BCC_ASM
04841                       00000002            _init_boot_vectors.count	set	2
04842                       FFFFFFEE            .init_boot_vectors.count	set	-$12
04843                       00000000            _init_boot_vectors.ss	set	0
04844                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
04845                       00000004            _init_boot_vectors.e	set	4
04846                       FFFFFFF0            .init_boot_vectors.e	set	-$10
04847 124D           1E                           push ds
04848                                           ! 1327 endasm
04849                                           !BCC_ENDASM
04850                                           !BCC_EOS
04851                                           ! 1328   set_DS(0x9ff0);
04852                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04853 124E           B8                   9FF0  mov	ax,#$9FF0
04854 1251           50                         push	ax
04855                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
04856 1252           E8         F408            call	_set_DS
04857 1255           44                         inc	sp
04858 1256           44                         inc	sp
04859                                           !BCC_EOS
04860                                           ! 1329   _memsetb(0,0x0000,0x9ff0,0x86);
04861                                           ! Debug: list int = const $86 (used reg = )
04862 1257           B8                   0086  mov	ax,#$86
04863 125A           50                         push	ax
04864                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04865 125B           B8                   9FF0  mov	ax,#$9FF0
04866 125E           50                         push	ax
04867                                           ! Debug: list int = const 0 (used reg = )
04868 125F           31C0                       xor	ax,ax
04869 1261           50                         push	ax
04870                                           ! Debug: list int = const 0 (used reg = )
04871 1262           31C0                       xor	ax,ax
04872 1264           50                         push	ax
04873                                           ! Debug: func () void = _memsetb+0 (used reg = )
04874 1265           E8         ED98            call	__memsetb
04875 1268           83C4                   08  add	sp,*8
04876                                           !BCC_EOS
04877                                           ! 1330   *((Bit16u *)(0x0084)) = (0xFFFF);
04878                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$84] (used reg = )
04879 126B           B8                   FFFF  mov	ax,#$FFFF
04880 126E           A3         0084            mov	[$84],ax
04881                                           !BCC_EOS
04882                                           ! 1331   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04883                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04884 1271           B8                   0001  mov	ax,*1
04885 1274           8946         F0            mov	-$10[bp],ax
04886                                           !BCC_EOS
04887                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04888 1277           31C0                       xor	ax,ax
04889 1279           8946         F2            mov	-$E[bp],ax
04890                                           !BCC_EOS
04891                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04892 127C           31C0                       xor	ax,ax
04893 127E           31DB                       xor	bx,bx
04894 1280           8946         F4            mov	-$C[bp],ax
04895 1283           895E         F6            mov	-$A[bp],bx
04896                                           !BCC_EOS
04897                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04898 1286           31C0                       xor	ax,ax
04899 1288           31DB                       xor	bx,bx
04900 128A           8946         F8            mov	-8[bp],ax
04901 128D           895E         FA            mov	-6[bp],bx
04902                                           !BCC_EOS
04903                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04904 1290           31C0                       xor	ax,ax
04905 1292           31DB                       xor	bx,bx
04906 1294           8946         FC            mov	-4[bp],ax
04907 1297           895E         FE            mov	-2[bp],bx
04908                                           !BCC_EOS
04909                                           ! 1332   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04910                                           ! Debug: list int = const $10 (used reg = )
04911 129A           B8                   0010  mov	ax,*$10
04912 129D           50                         push	ax
04913                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04914 129E           FF76         EC            push	-$14[bp]
04915                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04916 12A1           8D5E         F0            lea	bx,-$10[bp]
04917 12A4           53                         push	bx
04918                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04919 12A5           B8                   9FF0  mov	ax,#$9FF0
04920 12A8           50                         push	ax
04921                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04922 12A9           8B46         EE            mov	ax,-$12[bp]
04923 12AC           B1                     04  mov	cl,*4
04924 12AE           D3E0                       shl	ax,cl
04925                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04926                                           ! Debug: expression subtree swapping
04927                                           ! Debug: list unsigned int = ax+0 (used reg = )
04928 12B0           50                         push	ax
04929                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04930 12B1           E8         ED67            call	__memcpyb
04931 12B4           83C4                   0A  add	sp,*$A
04932                                           !BCC_EOS
04933                                           ! 1333   count++;
04934                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04935 12B7           8B46         EE            mov	ax,-$12[bp]
04936 12BA           40                         inc	ax
04937 12BB           8946         EE            mov	-$12[bp],ax
04938                                           !BCC_EOS
04939                                           ! 1334   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04940                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
04941 12BE           B8                   0002  mov	ax,*2
04942 12C1           8946         F0            mov	-$10[bp],ax
04943                                           !BCC_EOS
04944                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04945 12C4           31C0                       xor	ax,ax
04946 12C6           8946         F2            mov	-$E[bp],ax
04947                                           !BCC_EOS
04948                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04949 12C9           31C0                       xor	ax,ax
04950 12CB           31DB                       xor	bx,bx
04951 12CD           8946         F4            mov	-$C[bp],ax
04952 12D0           895E         F6            mov	-$A[bp],bx
04953                                           !BCC_EOS
04954                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04955 12D3           31C0                       xor	ax,ax
04956 12D5           31DB                       xor	bx,bx
04957 12D7           8946         F8            mov	-8[bp],ax
04958 12DA           895E         FA            mov	-6[bp],bx
04959                                           !BCC_EOS
04960                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04961 12DD           31C0                       xor	ax,ax
04962 12DF           31DB                       xor	bx,bx
04963 12E1           8946         FC            mov	-4[bp],ax
04964 12E4           895E         FE            mov	-2[bp],bx
04965                                           !BCC_EOS
04966                                           ! 1335   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04967                                           ! Debug: list int = const $10 (used reg = )
04968 12E7           B8                   0010  mov	ax,*$10
04969 12EA           50                         push	ax
04970                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04971 12EB           FF76         EC            push	-$14[bp]
04972                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04973 12EE           8D5E         F0            lea	bx,-$10[bp]
04974 12F1           53                         push	bx
04975                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04976 12F2           B8                   9FF0  mov	ax,#$9FF0
04977 12F5           50                         push	ax
04978                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04979 12F6           8B46         EE            mov	ax,-$12[bp]
04980 12F9           B1                     04  mov	cl,*4
04981 12FB           D3E0                       shl	ax,cl
04982                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04983                                           ! Debug: expression subtree swapping
04984                                           ! Debug: list unsigned int = ax+0 (used reg = )
04985 12FD           50                         push	ax
04986                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04987 12FE           E8         ED1A            call	__memcpyb
04988 1301           83C4                   0A  add	sp,*$A
04989                                           !BCC_EOS
04990                                           ! 1336   count++;
04991                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04992 1304           8B46         EE            mov	ax,-$12[bp]
04993 1307           40                         inc	ax
04994 1308           8946         EE            mov	-$12[bp],ax
04995                                           !BCC_EOS
04996                                           ! 1337   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04997                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
04998 130B           B8                   0003  mov	ax,*3
04999 130E           8946         F0            mov	-$10[bp],ax
05000                                           !BCC_EOS
05001                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05002 1311           31C0                       xor	ax,ax
05003 1313           8946         F2            mov	-$E[bp],ax
05004                                           !BCC_EOS
05005                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05006 1316           31C0                       xor	ax,ax
05007 1318           31DB                       xor	bx,bx
05008 131A           8946         F4            mov	-$C[bp],ax
05009 131D           895E         F6            mov	-$A[bp],bx
05010                                           !BCC_EOS
05011                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05012 1320           31C0                       xor	ax,ax
05013 1322           31DB                       xor	bx,bx
05014 1324           8946         F8            mov	-8[bp],ax
05015 1327           895E         FA            mov	-6[bp],bx
05016                                           !BCC_EOS
05017                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05018 132A           31C0                       xor	ax,ax
05019 132C           31DB                       xor	bx,bx
05020 132E           8946         FC            mov	-4[bp],ax
05021 1331           895E         FE            mov	-2[bp],bx
05022                                           !BCC_EOS
05023                                           ! 1338   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05024                                           ! Debug: list int = const $10 (used reg = )
05025 1334           B8                   0010  mov	ax,*$10
05026 1337           50                         push	ax
05027                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05028 1338           FF76         EC            push	-$14[bp]
05029                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05030 133B           8D5E         F0            lea	bx,-$10[bp]
05031 133E           53                         push	bx
05032                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05033 133F           B8                   9FF0  mov	ax,#$9FF0
05034 1342           50                         push	ax
05035                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05036 1343           8B46         EE            mov	ax,-$12[bp]
05037 1346           B1                     04  mov	cl,*4
05038 1348           D3E0                       shl	ax,cl
05039                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05040                                           ! Debug: expression subtree swapping
05041                                           ! Debug: list unsigned int = ax+0 (used reg = )
05042 134A           50                         push	ax
05043                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05044 134B           E8         ECCD            call	__memcpyb
05045 134E           83C4                   0A  add	sp,*$A
05046                                           !BCC_EOS
05047                                           ! 1339   count++;
05048                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05049 1351           8B46         EE            mov	ax,-$12[bp]
05050 1354           40                         inc	ax
05051 1355           8946         EE            mov	-$12[bp],ax
05052                                           !BCC_EOS
05053                                           ! 1340   *((Bit16u *)(0x0080)) = (count);
05054                                           ! Debug: eq unsigned short count = [S+$16-$14] to unsigned short = [+$80] (used reg = )
05055 1358           8B46         EE            mov	ax,-$12[bp]
05056 135B           A3         0080            mov	[$80],ax
05057                                           !BCC_EOS
05058                                           ! 1341   *((Bit16u *)(0x0082)) = (0xffff);
05059                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$82] (used reg = )
05060 135E           B8                   FFFF  mov	ax,#$FFFF
05061 1361           A3         0082            mov	[$82],ax
05062                                           !BCC_EOS
05063                                           ! 1342 #asm
05064                                           !BCC_EOS
05065                                           !BCC_ASM
05066                       00000002            _init_boot_vectors.count	set	2
05067                       FFFFFFEE            .init_boot_vectors.count	set	-$12
05068                       00000000            _init_boot_vectors.ss	set	0
05069                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
05070                       00000004            _init_boot_vectors.e	set	4
05071                       FFFFFFF0            .init_boot_vectors.e	set	-$10
05072 1364           1F                           pop ds
05073                                           ! 1344 endasm
05074                                           !BCC_ENDASM
05075                                           !BCC_EOS
05076                                           ! 1345 }
05077 1365           89EC                       mov	sp,bp
05078 1367           5D                         pop	bp
05079 1368           C3                         ret
05080                                           ! 1346 static Bit8u
05081                                           ! Register BX used in function init_boot_vectors
05082                                           ! 1347 get_boot_vector(i, e)
05083                                           ! 1348 Bit16u i; ipl_entry_t *e;
05084                       00001369            _get_boot_vector:
05085                                           !BCC_EOS
05086                                           !BCC_EOS
05087                                           ! 1349 {
05088                                           ! 1350   Bit16u count;
05089                                           !BCC_EOS
05090                                           ! 1351   Bit16u ss = get_SS();
05091 1369           55                         push	bp
05092 136A           89E5                       mov	bp,sp
05093 136C           83C4                   FC  add	sp,*-4
05094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05095 136F           E8         F2E8            call	_get_SS
05096                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05097 1372           8946         FC            mov	-4[bp],ax
05098                                           !BCC_EOS
05099                                           ! 1352   count = _read_word(0x0080, 0x9ff0);
05100                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05101 1375           B8                   9FF0  mov	ax,#$9FF0
05102 1378           50                         push	ax
05103                                           ! Debug: list int = const $80 (used reg = )
05104 1379           B8                   0080  mov	ax,#$80
05105 137C           50                         push	ax
05106                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05107 137D           E8         F26D            call	__read_word
05108 1380           83C4                   04  add	sp,*4
05109                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05110 1383           8946         FE            mov	-2[bp],ax
05111                                           !BCC_EOS
05112                                           ! 1353   if (i >= count) return 0;
05113                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05114 1386           8B46         04            mov	ax,4[bp]
05115 1389           3B46         FE            cmp	ax,-2[bp]
05116 138C           72           06            jb  	.10C
05117                       0000138E            .10D:
05118 138E           30C0                       xor	al,al
05119 1390           89EC                       mov	sp,bp
05120 1392           5D                         pop	bp
05121 1393           C3                         ret
05122                                           !BCC_EOS
05123                                           ! 1354   _memcpyb(e,ss,0x0000 + i * sizeof (*e),0x9ff0,sizeof (*e));
05124                       00001394            .10C:
05125                                           ! Debug: list int = const $10 (used reg = )
05126 1394           B8                   0010  mov	ax,*$10
05127 1397           50                         push	ax
05128                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05129 1398           B8                   9FF0  mov	ax,#$9FF0
05130 139B           50                         push	ax
05131                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05132 139C           8B46         04            mov	ax,4[bp]
05133 139F           B1                     04  mov	cl,*4
05134 13A1           D3E0                       shl	ax,cl
05135                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05136                                           ! Debug: expression subtree swapping
05137                                           ! Debug: list unsigned int = ax+0 (used reg = )
05138 13A3           50                         push	ax
05139                                           ! Debug: list unsigned short ss = [S+$C-6] (used reg = )
05140 13A4           FF76         FC            push	-4[bp]
05141                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05142 13A7           FF76         06            push	6[bp]
05143                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05144 13AA           E8         EC6E            call	__memcpyb
05145 13AD           83C4                   0A  add	sp,*$A
05146                                           !BCC_EOS
05147                                           ! 1355   return 1;
05148 13B0           B0                     01  mov	al,*1
05149 13B2           89EC                       mov	sp,bp
05150 13B4           5D                         pop	bp
05151 13B5           C3                         ret
05152                                           !BCC_EOS
05153                                           ! 1356 }
05154                                           ! 1357   void
05155                                           ! 1358 interactive_bootkey()
05156                                           ! 1359 {
05157                                           export	_interactive_bootkey
05158                       000013B6            _interactive_bootkey:
05159                                           ! 1360   ipl_entry_t e;
05160                                           !BCC_EOS
05161                                           ! 1361   Bit16u count;
05162                                           !BCC_EOS
05163                                           ! 1362   char description[33];
05164                                           !BCC_EOS
05165                                           ! 1363   Bit8u scan_code;
05166                                           !BCC_EOS
05167                                           ! 1364   Bit8u i;
05168                                           !BCC_EOS
05169                                           ! 1365   Bit16u ss = get_SS();
05170 13B6           55                         push	bp
05171 13B7           89E5                       mov	bp,sp
05172 13B9           83C4                   C8  add	sp,*-$38
05173                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05174 13BC           E8         F29B            call	_get_SS
05175                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05176 13BF           8946         C8            mov	-$38[bp],ax
05177                                           !BCC_EOS
05178                                           ! 1366   Bit16u valid_choice = 0;
05179 13C2           4C                         dec	sp
05180 13C3           4C                         dec	sp
05181                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05182 13C4           31C0                       xor	ax,ax
05183 13C6           8946         C6            mov	-$3A[bp],ax
05184                                           !BCC_EOS
05185                                           ! 1367   while (check_for_keystroke())
05186                                           ! 1368     get_keystroke();
05187 13C9           EB           03            jmp .10F
05188                       000013CB            .110:
05189                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05190 13CB           E8         F532            call	_get_keystroke
05191                                           !BCC_EOS
05192                                           ! 1369   if ((inb_cmos(0x3f) & 0x01) == 0x01)
05193                       000013CE            .10F:
05194                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05195 13CE           E8         F521            call	_check_for_keystroke
05196 13D1           84C0                       test	al,al
05197 13D3           75           F6            jne	.110
05198                       000013D5            .111:
05199                       000013D5            .10E:
05200                                           ! Debug: list int = const $3F (used reg = )
05201 13D5           B8                   003F  mov	ax,*$3F
05202 13D8           50                         push	ax
05203                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
05204 13D9           E8         F192            call	_inb_cmos
05205 13DC           44                         inc	sp
05206 13DD           44                         inc	sp
05207                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
05208 13DE           24                     01  and	al,*1
05209                                           ! Debug: logeq int = const 1 to unsigned char = al+0 (used reg = )
05210 13E0           3C                     01  cmp	al,*1
05211 13E2           75           04            jne 	.112
05212                       000013E4            .113:
05213                                           ! 1370     return;
05214 13E4           89EC                       mov	sp,bp
05215 13E6           5D                         pop	bp
05216 13E7           C3                         ret
05217                                           !BCC_EOS
05218                                           ! 1371   bios_printf(2, "Press F12 for boot menu.\n\n");
05219                       000013E8            .112:
05220                                           ! Debug: list * char = .114+0 (used reg = )
05221 13E8           BB                   D923  mov	bx,#.114
05222 13EB           53                         push	bx
05223                                           ! Debug: list int = const 2 (used reg = )
05224 13EC           B8                   0002  mov	ax,*2
05225 13EF           50                         push	ax
05226                                           ! Debug: func () void = bios_printf+0 (used reg = )
05227 13F0           E8         F546            call	_bios_printf
05228 13F3           83C4                   04  add	sp,*4
05229                                           !BCC_EOS
05230                                           ! 1372   delay_ticks_and_check_for_keystroke(11, 5);
05231                                           ! Debug: list int = const 5 (used reg = )
05232 13F6           B8                   0005  mov	ax,*5
05233 13F9           50                         push	ax
05234                                           ! Debug: list int = const $B (used reg = )
05235 13FA           B8                   000B  mov	ax,*$B
05236 13FD           50                         push	ax
05237                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05238 13FE           E8         F507            call	_delay_ticks_and_check_for_keystroke
05239 1401           83C4                   04  add	sp,*4
05240                                           !BCC_EOS
05241                                           ! 1373   if (check_for_keystroke())
05242                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05243 1404           E8         F4EB            call	_check_for_keystroke
05244 1407           84C0                       test	al,al
05245 1409         0F84         01A1            beq 	.115
05246                       0000140D            .116:
05247                                           ! 1374   {
05248                                           ! 1375     scan_code = get_keystroke();
05249                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05250 140D           E8         F4F0            call	_get_keystroke
05251                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05252 1410           8846         CC            mov	-$34[bp],al
05253                                           !BCC_EOS
05254                                           ! 1376     if (scan_code == 0x86)
05255                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05256 1413           8A46         CC            mov	al,-$34[bp]
05257 1416           3C                     86  cmp	al,#$86
05258 1418         0F85         0192            bne 	.117
05259                       0000141C            .118:
05260                                           ! 1377     {
05261                                           ! 1378       while (check_for_keystroke())
05262                                           ! 1379         get_keystroke();
05263 141C           EB           03            jmp .11A
05264                       0000141E            .11B:
05265                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05266 141E           E8         F4DF            call	_get_keystroke
05267                                           !BCC_EOS
05268                                           ! 1380       bios_printf(2, "Select boot device:\n\n");
05269                       00001421            .11A:
05270                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05271 1421           E8         F4CE            call	_check_for_keystroke
05272 1424           84C0                       test	al,al
05273 1426           75           F6            jne	.11B
05274                       00001428            .11C:
05275                       00001428            .119:
05276                                           ! Debug: list * char = .11D+0 (used reg = )
05277 1428           BB                   D90D  mov	bx,#.11D
05278 142B           53                         push	bx
05279                                           ! Debug: list int = const 2 (used reg = )
05280 142C           B8                   0002  mov	ax,*2
05281 142F           50                         push	ax
05282                                           ! Debug: func () void = bios_printf+0 (used reg = )
05283 1430           E8         F506            call	_bios_printf
05284 1433           83C4                   04  add	sp,*4
05285                                           !BCC_EOS
05286                                           ! 1381       count = _read_word(0x0080, 0x9ff0);
05287                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05288 1436           B8                   9FF0  mov	ax,#$9FF0
05289 1439           50                         push	ax
05290                                           ! Debug: list int = const $80 (used reg = )
05291 143A           B8                   0080  mov	ax,#$80
05292 143D           50                         push	ax
05293                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05294 143E           E8         F1AC            call	__read_word
05295 1441           83C4                   04  add	sp,*4
05296                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05297 1444           8946         EE            mov	-$12[bp],ax
05298                                           !BCC_EOS
05299                                           ! 1382       for (i = 0; i < count; i++)
05300                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05301 1447           30C0                       xor	al,al
05302 1449           8846         CB            mov	-$35[bp],al
05303                                           !BCC_EOS
05304                                           !BCC_EOS
05305                                           ! 1383       {
05306 144C           E9         00EC            br 	.120
05307                       0000144F            .121:
05308                                           ! 1384         _memcpyb(&e,ss,0x0000 + i * sizeof (e),0x9ff0,sizeof (e));
05309                                           ! Debug: list int = const $10 (used reg = )
05310 144F           B8                   0010  mov	ax,*$10
05311 1452           50                         push	ax
05312                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05313 1453           B8                   9FF0  mov	ax,#$9FF0
05314 1456           50                         push	ax
05315                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05316 1457           8A46         CB            mov	al,-$35[bp]
05317 145A           30E4                       xor	ah,ah
05318 145C           B1                     04  mov	cl,*4
05319 145E           D3E0                       shl	ax,cl
05320                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05321                                           ! Debug: expression subtree swapping
05322                                           ! Debug: list unsigned int = ax+0 (used reg = )
05323 1460           50                         push	ax
05324                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05325 1461           FF76         C8            push	-$38[bp]
05326                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05327 1464           8D5E         F0            lea	bx,-$10[bp]
05328 1467           53                         push	bx
05329                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05330 1468           E8         EBB0            call	__memcpyb
05331 146B           83C4                   0A  add	sp,*$A
05332                                           !BCC_EOS
05333                                           ! 1385         bios_printf(2, "%d. ", i+1);
05334                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05335 146E           8A46         CB            mov	al,-$35[bp]
05336 1471           30E4                       xor	ah,ah
05337                                           ! Debug: list unsigned int = ax+1 (used reg = )
05338 1473           40                         inc	ax
05339 1474           50                         push	ax
05340                                           ! Debug: list * char = .122+0 (used reg = )
05341 1475           BB                   D908  mov	bx,#.122
05342 1478           53                         push	bx
05343                                           ! Debug: list int = const 2 (used reg = )
05344 1479           B8                   0002  mov	ax,*2
05345 147C           50                         push	ax
05346                                           ! Debug: func () void = bios_printf+0 (used reg = )
05347 147D           E8         F4B9            call	_bios_printf
05348 1480           83C4                   06  add	sp,*6
05349                                           !BCC_EOS
05350                                           ! 1386         switch(e.type)
05351 1483           8B46         F0            mov	ax,-$10[bp]
05352                                           ! 1387         
05353                                           ! 1387 {
05354 1486           E9         008F            br 	.125
05355                                           ! 1388           case 0x01:
05356                                           ! 1389           case 0x02:
05357                       00001489            .126:
05358                                           ! 1390           case 0x03:
05359                       00001489            .127:
05360                                           ! 1391             bios_printf(2, "%s\n", drivetypes[e.type]);
05361                       00001489            .128:
05362                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05363 1489           8B5E         F0            mov	bx,-$10[bp]
05364 148C           89DA                       mov	dx,bx
05365 148E           D1E3                       shl	bx,*1
05366 1490           D1E3                       shl	bx,*1
05367 1492           01D3                       add	bx,dx
05368 1494           D1E3                       shl	bx,*1
05369                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05370                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05371 1496           81C3                 1208  add	bx,#_drivetypes
05372 149A           53                         push	bx
05373                                           ! Debug: list * char = .129+0 (used reg = )
05374 149B           BB                   D904  mov	bx,#.129
05375 149E           53                         push	bx
05376                                           ! Debug: list int = const 2 (used reg = )
05377 149F           B8                   0002  mov	ax,*2
05378 14A2           50                         push	ax
05379                                           ! Debug: func () void = bios_printf+0 (used reg = )
05380 14A3           E8         F493            call	_bios_printf
05381 14A6           83C4                   06  add	sp,*6
05382                                           !BCC_EOS
05383                                           ! 1392             break;
05384 14A9           E9         0088            br 	.123
05385                                           !BCC_EOS
05386                                           ! 1393           case 0x80:
05387                                           ! 1394             bios_printf(2, "%s", drivetypes[4]);
05388                       000014AC            .12A:
05389                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05390 14AC           BB                   1230  mov	bx,#_drivetypes+$28
05391 14AF           53                         push	bx
05392                                           ! Debug: list * char = .12B+0 (used reg = )
05393 14B0           BB                   D901  mov	bx,#.12B
05394 14B3           53                         push	bx
05395                                           ! Debug: list int = const 2 (used reg = )
05396 14B4           B8                   0002  mov	ax,*2
05397 14B7           50                         push	ax
05398                                           ! Debug: func () void = bios_printf+0 (used reg = )
05399 14B8           E8         F47E            call	_bios_printf
05400 14BB           83C4                   06  add	sp,*6
05401                                           !BCC_EOS
05402                                           ! 1395             if (e.description != 0)
05403                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05404                                           ! Debug: expression subtree swapping
05405 14BE           31C0                       xor	ax,ax
05406 14C0           31DB                       xor	bx,bx
05407 14C2           53                         push	bx
05408 14C3           50                         push	ax
05409 14C4           8B46         F8            mov	ax,-8[bp]
05410 14C7           8B5E         FA            mov	bx,-6[bp]
05411 14CA           8D7E         C2            lea	di,-2+..FFFF[bp]
05412 14CD           E8         EBCC            call	lcmpul
05413 14D0           8D66         C6            lea	sp,2+..FFFF[bp]
05414 14D3           74           31            je  	.12C
05415                       000014D5            .12D:
05416                                           ! 1396             {
05417                                           ! 1397               _memcpyb(&description,ss,*((Bit16u *)&e.description),*(((Bit16u *)&e.description)+1),32);
05418                                           ! Debug: list int = const $20 (used reg = )
05419 14D5           B8                   0020  mov	ax,*$20
05420 14D8           50                         push	ax
05421                                           ! Debug: list unsigned short e = [S+$3E-8] (used reg = )
05422 14D9           FF76         FA            push	-6[bp]
05423                                           ! Debug: list unsigned short e = [S+$40-$A] (used reg = )
05424 14DC           FF76         F8            push	-8[bp]
05425                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05426 14DF           FF76         C8            push	-$38[bp]
05427                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05428 14E2           8D5E         CD            lea	bx,-$33[bp]
05429 14E5           53                         push	bx
05430                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05431 14E6           E8         EB32            call	__memcpyb
05432 14E9           83C4                   0A  add	sp,*$A
05433                                           !BCC_EOS
05434                                           ! 1398               description[32] = 0;
05435                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05436 14EC           30C0                       xor	al,al
05437 14EE           8846         ED            mov	-$13[bp],al
05438                                           !BCC_EOS
05439                                           ! 1399               bios_printf(2, " [%S]", ss, description);
05440                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05441 14F1           8D5E         CD            lea	bx,-$33[bp]
05442 14F4           53                         push	bx
05443                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05444 14F5           FF76         C8            push	-$38[bp]
05445                                           ! Debug: list * char = .12E+0 (used reg = )
05446 14F8           BB                   D8FB  mov	bx,#.12E
05447 14FB           53                         push	bx
05448                                           ! Debug: list int = const 2 (used reg = )
05449 14FC           B8                   0002  mov	ax,*2
05450 14FF           50                         push	ax
05451                                           ! Debug: func () void = bios_printf+0 (used reg = )
05452 1500           E8         F436            call	_bios_printf
05453 1503           83C4                   08  add	sp,*8
05454                                           !BCC_EOS
05455                                           ! 1400            }
05456                                           ! 1401            bios_printf(2, "\n");
05457                       00001506            .12C:
05458                                           ! Debug: list * char = .12F+0 (used reg = )
05459 1506           BB                   D8F9  mov	bx,#.12F
05460 1509           53                         push	bx
05461                                           ! Debug: list int = const 2 (used reg = )
05462 150A           B8                   0002  mov	ax,*2
05463 150D           50                         push	ax
05464                                           ! Debug: func () void = bios_printf+0 (used reg = )
05465 150E           E8         F428            call	_bios_printf
05466 1511           83C4                   04  add	sp,*4
05467                                           !BCC_EOS
05468                                           ! 1402            break;
05469 1514           EB           1E            jmp .123
05470                                           !BCC_EOS
05471                                           ! 1403         }
05472                                           ! 1404       }
05473 1516           EB           1C            jmp .123
05474                       00001518            .125:
05475 1518           2D                   0001  sub	ax,*1
05476 151B         0F84         FF6A            beq 	.126
05477 151F           2D                   0001  sub	ax,*1
05478 1522         0F84         FF63            beq 	.127
05479 1526           2D                   0001  sub	ax,*1
05480 1529         0F84         FF5C            beq 	.128
05481 152D           2D                   007D  sub	ax,*$7D
05482 1530         0F84         FF78            beq 	.12A
05483                       00001534            .123:
05484                       FFFFFFC4            ..FFFF	=	-$3C
05485                                           ! 1405       count++;
05486                       00001534            .11F:
05487                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05488 1534           8A46         CB            mov	al,-$35[bp]
05489 1537           40                         inc	ax
05490 1538           8846         CB            mov	-$35[bp],al
05491                       0000153B            .120:
05492                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05493 153B           8A46         CB            mov	al,-$35[bp]
05494 153E           30E4                       xor	ah,ah
05495 1540           3B46         EE            cmp	ax,-$12[bp]
05496 1543         0F82         FF08            blo 	.121
05497                       00001547            .130:
05498                       00001547            .11E:
05499                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05500 1547           8B46         EE            mov	ax,-$12[bp]
05501 154A           40                         inc	ax
05502 154B           8946         EE            mov	-$12[bp],ax
05503                                           !BCC_EOS
05504                                           ! 1406       while (!valid_choice) {
05505 154E           EB           49            jmp .132
05506                       00001550            .133:
05507                                           ! 1407         scan_code = get_keystroke();
05508                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05509 1550           E8         F3AD            call	_get_keystroke
05510                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05511 1553           8846         CC            mov	-$34[bp],al
05512                                           !BCC_EOS
05513                                           ! 1408         if (scan_code == 0x01 || scan_code == 0x58)
05514                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05515 1556           8A46         CC            mov	al,-$34[bp]
05516 1559           3C                     01  cmp	al,*1
05517 155B           74           07            je  	.135
05518                       0000155D            .136:
05519                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05520 155D           8A46         CC            mov	al,-$34[bp]
05521 1560           3C                     58  cmp	al,*$58
05522 1562           75           08            jne 	.134
05523                       00001564            .135:
05524                                           ! 1409         {
05525                                           ! 1410           valid_choice = 1;
05526                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05527 1564           B8                   0001  mov	ax,*1
05528 1567           8946         C6            mov	-$3A[bp],ax
05529                                           !BCC_EOS
05530                                           ! 1411         }
05531                                           ! 1412         else if (scan_code <= count)
05532 156A           EB           2D            jmp .137
05533                       0000156C            .134:
05534                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05535 156C           8A46         CC            mov	al,-$34[bp]
05536 156F           30E4                       xor	ah,ah
05537 1571           3B46         EE            cmp	ax,-$12[bp]
05538 1574           77           23            ja  	.138
05539                       00001576            .139:
05540                                           ! 1413         {
05541                                           ! 1414           valid_choice = 1;
05542                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05543 1576           B8                   0001  mov	ax,*1
05544 1579           8946         C6            mov	-$3A[bp],ax
05545                                           !BCC_EOS
05546                                           ! 1415           scan_code -= 1;
05547                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05548 157C           8A46         CC            mov	al,-$34[bp]
05549 157F           30E4                       xor	ah,ah
05550 1581           48                         dec	ax
05551 1582           8846         CC            mov	-$34[bp],al
05552                                           !BCC_EOS
05553                                           ! 1416           _write_word(scan_code, 0x0084, 0x9ff0);
05554                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05555 1585           B8                   9FF0  mov	ax,#$9FF0
05556 1588           50                         push	ax
05557                                           ! Debug: list int = const $84 (used reg = )
05558 1589           B8                   0084  mov	ax,#$84
05559 158C           50                         push	ax
05560                                           ! Debug: list unsigned char scan_code = [S+$40-$36] (used reg = )
05561 158D           8A46         CC            mov	al,-$34[bp]
05562 1590           30E4                       xor	ah,ah
05563 1592           50                         push	ax
05564                                           ! Debug: func () void = _write_word+0 (used reg = )
05565 1593           E8         F078            call	__write_word
05566 1596           83C4                   06  add	sp,*6
05567                                           !BCC_EOS
05568                                           ! 1417         }
05569                                           ! 1418       }
05570                       00001599            .138:
05571                       00001599            .137:
05572                                           ! 1419       bios_printf(2, "\n");
05573                       00001599            .132:
05574 1599           8B46         C6            mov	ax,-$3A[bp]
05575 159C           85C0                       test	ax,ax
05576 159E           74           B0            je 	.133
05577                       000015A0            .13A:
05578                       000015A0            .131:
05579                                           ! Debug: list * char = .13B+0 (used reg = )
05580 15A0           BB                   D8F7  mov	bx,#.13B
05581 15A3           53                         push	bx
05582                                           ! Debug: list int = const 2 (used reg = )
05583 15A4           B8                   0002  mov	ax,*2
05584 15A7           50                         push	ax
05585                                           ! Debug: func () void = bios_printf+0 (used reg = )
05586 15A8           E8         F38E            call	_bios_printf
05587 15AB           83C4                   04  add	sp,*4
05588                                           !BCC_EOS
05589                                           ! 1420     }
05590                                           ! 1421   }
05591                       000015AE            .117:
05592                                           ! 1422 }
05593                       000015AE            .115:
05594 15AE           89EC                       mov	sp,bp
05595 15B0           5D                         pop	bp
05596 15B1           C3                         ret
05597                                           ! 1423 void
05598                                           ! Register BX used in function interactive_bootkey
05599                                           ! 1424 print_boot_device(e)
05600                                           ! 1425   ipl_entry_t *e;
05601                                           export	_print_boot_device
05602                       000015B2            _print_boot_device:
05603                                           !BCC_EOS
05604                                           ! 1426 {
05605                                           ! 1427   Bit16u type;
05606                                           !BCC_EOS
05607                                           ! 1428   char description[33];
05608                                           !BCC_EOS
05609                                           ! 1429   Bit16u ss = get_SS();
05610 15B2           55                         push	bp
05611 15B3           89E5                       mov	bp,sp
05612 15B5           83C4                   DA  add	sp,*-$26
05613                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05614 15B8           E8         F09F            call	_get_SS
05615                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05616 15BB           8946         DA            mov	-$26[bp],ax
05617                                           !BCC_EOS
05618                                           ! 1430   type = e->type;
05619 15BE           8B5E         04            mov	bx,4[bp]
05620                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05621 15C1           8B1F                       mov	bx,[bx]
05622 15C3           895E         FE            mov	-2[bp],bx
05623                                           !BCC_EOS
05624                                           ! 1431   if (type == 0x80) type = 0x4;
05625                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05626 15C6           8B46         FE            mov	ax,-2[bp]
05627 15C9           3D                   0080  cmp	ax,#$80
05628 15CC           75           06            jne 	.13C
05629                       000015CE            .13D:
05630                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05631 15CE           B8                   0004  mov	ax,*4
05632 15D1           8946         FE            mov	-2[bp],ax
05633                                           !BCC_EOS
05634                                           ! 1432   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05635                       000015D4            .13C:
05636                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05637 15D4           8B46         FE            mov	ax,-2[bp]
05638 15D7           85C0                       test	ax,ax
05639 15D9           74           08            je  	.13F
05640                       000015DB            .140:
05641                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05642 15DB           8B46         FE            mov	ax,-2[bp]
05643 15DE           3D                   0004  cmp	ax,*4
05644 15E1           76           0E            jbe 	.13E
05645                       000015E3            .13F:
05646                                           ! Debug: list * char = .141+0 (used reg = )
05647 15E3           BB                   D8E7  mov	bx,#.141
05648 15E6           53                         push	bx
05649                                           ! Debug: list int = const 7 (used reg = )
05650 15E7           B8                   0007  mov	ax,*7
05651 15EA           50                         push	ax
05652                                           ! Debug: func () void = bios_printf+0 (used reg = )
05653 15EB           E8         F34B            call	_bios_printf
05654 15EE           83C4                   04  add	sp,*4
05655                                           !BCC_EOS
05656                                           ! 1433   bios_printf(2, "Booting from %s", drivetypes[type]);
05657                       000015F1            .13E:
05658                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05659 15F1           8B5E         FE            mov	bx,-2[bp]
05660 15F4           89DA                       mov	dx,bx
05661 15F6           D1E3                       shl	bx,*1
05662 15F8           D1E3                       shl	bx,*1
05663 15FA           01D3                       add	bx,dx
05664 15FC           D1E3                       shl	bx,*1
05665                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05666                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05667 15FE           81C3                 1208  add	bx,#_drivetypes
05668 1602           53                         push	bx
05669                                           ! Debug: list * char = .142+0 (used reg = )
05670 1603           BB                   D8D7  mov	bx,#.142
05671 1606           53                         push	bx
05672                                           ! Debug: list int = const 2 (used reg = )
05673 1607           B8                   0002  mov	ax,*2
05674 160A           50                         push	ax
05675                                           ! Debug: func () void = bios_printf+0 (used reg = )
05676 160B           E8         F32B            call	_bios_printf
05677 160E           83C4                   06  add	sp,*6
05678                                           !BCC_EOS
05679                                           ! 1434   if (type == 4 && e->description != 0) {
05680                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05681 1611           8B46         FE            mov	ax,-2[bp]
05682 1614           3D                   0004  cmp	ax,*4
05683 1617           75           51            jne 	.143
05684                       00001619            .145:
05685 1619           8B5E         04            mov	bx,4[bp]
05686                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05687                                           ! Debug: expression subtree swapping
05688 161C           31C0                       xor	ax,ax
05689 161E           31F6                       xor	si,si
05690 1620           56                         push	si
05691 1621           50                         push	ax
05692 1622           8B47         08            mov	ax,8[bx]
05693 1625           8B5F         0A            mov	bx,$A[bx]
05694 1628           8D7E         D6            lea	di,-$2A[bp]
05695 162B           E8         EA6E            call	lcmpul
05696 162E           8D66         DA            lea	sp,-$26[bp]
05697 1631           74           37            je  	.143
05698                       00001633            .144:
05699                                           ! 1435     _memcpyb(&description,ss,*((Bit16u *)&e->description),*(((Bit16u *)&e->description)+1),32);
05700                                           ! Debug: list int = const $20 (used reg = )
05701 1633           B8                   0020  mov	ax,*$20
05702 1636           50                         push	ax
05703 1637           8B5E         04            mov	bx,4[bp]
05704                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05705                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05706                                           ! Debug: ptradd int = const 1 to * unsigned short = bx+8 (used reg = )
05707                                           ! Debug: list unsigned short = [bx+$A] (used reg = )
05708 163A           FF77         0A            push	$A[bx]
05709 163D           8B5E         04            mov	bx,4[bp]
05710                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05711                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05712                                           ! Debug: list unsigned short = [bx+8] (used reg = )
05713 1640           FF77         08            push	8[bx]
05714                                           ! Debug: list unsigned short ss = [S+$2E-$28] (used reg = )
05715 1643           FF76         DA            push	-$26[bp]
05716                                           ! Debug: list * [$21] char description = S+$30-$25 (used reg = )
05717 1646           8D5E         DD            lea	bx,-$23[bp]
05718 1649           53                         push	bx
05719                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05720 164A           E8         E9CE            call	__memcpyb
05721 164D           83C4                   0A  add	sp,*$A
05722                                           !BCC_EOS
05723                                           ! 1436     description[32] = 0;
05724                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05725 1650           30C0                       xor	al,al
05726 1652           8846         FD            mov	-3[bp],al
05727                                           !BCC_EOS
05728                                           ! 1437     bios_printf(2, " [%S]", ss, description);
05729                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05730 1655           8D5E         DD            lea	bx,-$23[bp]
05731 1658           53                         push	bx
05732                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05733 1659           FF76         DA            push	-$26[bp]
05734                                           ! Debug: list * char = .146+0 (used reg = )
05735 165C           BB                   D8D1  mov	bx,#.146
05736 165F           53                         push	bx
05737                                           ! Debug: list int = const 2 (used reg = )
05738 1660           B8                   0002  mov	ax,*2
05739 1663           50                         push	ax
05740                                           ! Debug: func () void = bios_printf+0 (used reg = )
05741 1664           E8         F2D2            call	_bios_printf
05742 1667           83C4                   08  add	sp,*8
05743                                           !BCC_EOS
05744                                           ! 1438   }
05745                                           ! 1439   bios_printf(2, "...\n");
05746                       0000166A            .143:
05747                                           ! Debug: list * char = .147+0 (used reg = )
05748 166A           BB                   D8CC  mov	bx,#.147
05749 166D           53                         push	bx
05750                                           ! Debug: list int = const 2 (used reg = )
05751 166E           B8                   0002  mov	ax,*2
05752 1671           50                         push	ax
05753                                           ! Debug: func () void = bios_printf+0 (used reg = )
05754 1672           E8         F2C4            call	_bios_printf
05755 1675           83C4                   04  add	sp,*4
05756                                           !BCC_EOS
05757                                           ! 1440 }
05758 1678           89EC                       mov	sp,bp
05759 167A           5D                         pop	bp
05760 167B           C3                         ret
05761                                           ! 1441   void
05762                                           ! Register BX used in function print_boot_device
05763                                           ! 1442 print_boot_failure(type, reason)
05764                                           ! 1443   Bit16u type; Bit8u reason;
05765                                           export	_print_boot_failure
05766                       0000167C            _print_boot_failure:
05767                                           !BCC_EOS
05768                                           !BCC_EOS
05769                                           ! 1444 {
05770                                           ! 1445   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05771 167C           55                         push	bp
05772 167D           89E5                       mov	bp,sp
05773                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05774 167F           8B46         04            mov	ax,4[bp]
05775 1682           85C0                       test	ax,ax
05776 1684           74           08            je  	.149
05777                       00001686            .14A:
05778                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05779 1686           8B46         04            mov	ax,4[bp]
05780 1689           3D                   0003  cmp	ax,*3
05781 168C           76           0D            jbe 	.148
05782                       0000168E            .149:
05783                                           ! Debug: list * char = .14B+0 (used reg = )
05784 168E           BB                   D8BC  mov	bx,#.14B
05785 1691           53                         push	bx
05786                                           ! Debug: list int = const 7 (used reg = )
05787 1692           B8                   0007  mov	ax,*7
05788 1695           50                         push	ax
05789                                           ! Debug: func () void = bios_printf+0 (used reg = )
05790 1696           E8         F2A0            call	_bios_printf
05791 1699           89EC                       mov	sp,bp
05792                                           !BCC_EOS
05793                                           ! 1446   bios_printf(2, "Boot failed");
05794                       0000169B            .148:
05795                                           ! Debug: list * char = .14C+0 (used reg = )
05796 169B           BB                   D8B0  mov	bx,#.14C
05797 169E           53                         push	bx
05798                                           ! Debug: list int = const 2 (used reg = )
05799 169F           B8                   0002  mov	ax,*2
05800 16A2           50                         push	ax
05801                                           ! Debug: func () void = bios_printf+0 (used reg = )
05802 16A3           E8         F293            call	_bios_printf
05803 16A6           89EC                       mov	sp,bp
05804                                           !BCC_EOS
05805                                           ! 1447   if (type < 4) {
05806                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05807 16A8           8B46         04            mov	ax,4[bp]
05808 16AB           3D                   0004  cmp	ax,*4
05809 16AE           73           23            jae 	.14D
05810                       000016B0            .14E:
05811                                           ! 1448     if (reason==0)
05812                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05813 16B0           8A46         06            mov	al,6[bp]
05814 16B3           84C0                       test	al,al
05815 16B5           75           0F            jne 	.14F
05816                       000016B7            .150:
05817                                           ! 1449       bios_printf(2, ": not a bootable disk");
05818                                           ! Debug: list * char = .151+0 (used reg = )
05819 16B7           BB                   D89A  mov	bx,#.151
05820 16BA           53                         push	bx
05821                                           ! Debug: list int = const 2 (used reg = )
05822 16BB           B8                   0002  mov	ax,*2
05823 16BE           50                         push	ax
05824                                           ! Debug: func () void = bios_printf+0 (used reg = )
05825 16BF           E8         F277            call	_bios_printf
05826 16C2           89EC                       mov	sp,bp
05827                                           !BCC_EOS
05828                                           ! 1450     else
05829                                           ! 1451       bios_printf(2, ": could not read the boot disk");
05830 16C4           EB           0D            jmp .152
05831                       000016C6            .14F:
05832                                           ! Debug: list * char = .153+0 (used reg = )
05833 16C6           BB                   D87B  mov	bx,#.153
05834 16C9           53                         push	bx
05835                                           ! Debug: list int = const 2 (used reg = )
05836 16CA           B8                   0002  mov	ax,*2
05837 16CD           50                         push	ax
05838                                           ! Debug: func () void = bios_printf+0 (used reg = )
05839 16CE           E8         F268            call	_bios_printf
05840 16D1           89EC                       mov	sp,bp
05841                                           !BCC_EOS
05842                                           ! 1452   }
05843                       000016D3            .152:
05844                                           ! 1453   bios_printf(2, "\n\n");
05845                       000016D3            .14D:
05846                                           ! Debug: list * char = .154+0 (used reg = )
05847 16D3           BB                   D878  mov	bx,#.154
05848 16D6           53                         push	bx
05849                                           ! Debug: list int = const 2 (used reg = )
05850 16D7           B8                   0002  mov	ax,*2
05851 16DA           50                         push	ax
05852                                           ! Debug: func () void = bios_printf+0 (used reg = )
05853 16DB           E8         F25B            call	_bios_printf
05854 16DE           89EC                       mov	sp,bp
05855                                           !BCC_EOS
05856                                           ! 1454 }
05857 16E0           5D                         pop	bp
05858 16E1           C3                         ret
05859                                           ! 1455   void
05860                                           ! Register BX used in function print_boot_failure
05861                                           ! 1456 print_cdromboot_failure( code )
05862                                           ! 1457   Bit16u code;
05863                                           export	_print_cdromboot_failure
05864                       000016E2            _print_cdromboot_failure:
05865                                           !BCC_EOS
05866                                           ! 1458 {
05867                                           ! 1459   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05868 16E2           55                         push	bp
05869 16E3           89E5                       mov	bp,sp
05870                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05871 16E5           FF76         04            push	4[bp]
05872                                           ! Debug: list * char = .155+0 (used reg = )
05873 16E8           BB                   D858  mov	bx,#.155
05874 16EB           53                         push	bx
05875                                           ! Debug: list int = const 6 (used reg = )
05876 16EC           B8                   0006  mov	ax,*6
05877 16EF           50                         push	ax
05878                                           ! Debug: func () void = bios_printf+0 (used reg = )
05879 16F0           E8         F246            call	_bios_printf
05880 16F3           89EC                       mov	sp,bp
05881                                           !BCC_EOS
05882                                           ! 1460   return;
05883 16F5           5D                         pop	bp
05884 16F6           C3                         ret
05885                                           !BCC_EOS
05886                                           ! 1461 }
05887                                           ! 1462 void
05888                                           ! Register BX used in function print_cdromboot_failure
05889                                           ! 1463 nmi_handler_msg()
05890                                           ! 1464 {
05891                                           export	_nmi_handler_msg
05892                       000016F7            _nmi_handler_msg:
05893                                           ! 1465   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05894 16F7           55                         push	bp
05895 16F8           89E5                       mov	bp,sp
05896                                           ! Debug: list * char = .156+0 (used reg = )
05897 16FA           BB                   D844  mov	bx,#.156
05898 16FD           53                         push	bx
05899                                           ! Debug: list int = const 7 (used reg = )
05900 16FE           B8                   0007  mov	ax,*7
05901 1701           50                         push	ax
05902                                           ! Debug: func () void = bios_printf+0 (used reg = )
05903 1702           E8         F234            call	_bios_printf
05904 1705           89EC                       mov	sp,bp
05905                                           !BCC_EOS
05906                                           ! 1466 }
05907 1707           5D                         pop	bp
05908 1708           C3                         ret
05909                                           ! 1467 void
05910                                           ! Register BX used in function nmi_handler_msg
05911                                           ! 1468 int18_pani
05912                                           ! 1468 c_msg()
05913                                           ! 1469 {
05914                                           export	_int18_panic_msg
05915                       00001709            _int18_panic_msg:
05916                                           ! 1470   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05917 1709           55                         push	bp
05918 170A           89E5                       mov	bp,sp
05919                                           ! Debug: list * char = .157+0 (used reg = )
05920 170C           BB                   D82F  mov	bx,#.157
05921 170F           53                         push	bx
05922                                           ! Debug: list int = const 7 (used reg = )
05923 1710           B8                   0007  mov	ax,*7
05924 1713           50                         push	ax
05925                                           ! Debug: func () void = bios_printf+0 (used reg = )
05926 1714           E8         F222            call	_bios_printf
05927 1717           89EC                       mov	sp,bp
05928                                           !BCC_EOS
05929                                           ! 1471 }
05930 1719           5D                         pop	bp
05931 171A           C3                         ret
05932                                           ! 1472 void
05933                                           ! Register BX used in function int18_panic_msg
05934                                           ! 1473 log_bios_start()
05935                                           ! 1474 {
05936                                           export	_log_bios_start
05937                       0000171B            _log_bios_start:
05938                                           ! 1475   bios_printf(4, "%s\n", bios_svn_version_string);
05939 171B           55                         push	bp
05940 171C           89E5                       mov	bp,sp
05941                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
05942 171E           BB                   0165  mov	bx,#_bios_svn_version_string
05943 1721           53                         push	bx
05944                                           ! Debug: list * char = .158+0 (used reg = )
05945 1722           BB                   D82B  mov	bx,#.158
05946 1725           53                         push	bx
05947                                           ! Debug: list int = const 4 (used reg = )
05948 1726           B8                   0004  mov	ax,*4
05949 1729           50                         push	ax
05950                                           ! Debug: func () void = bios_printf+0 (used reg = )
05951 172A           E8         F20C            call	_bios_printf
05952 172D           89EC                       mov	sp,bp
05953                                           !BCC_EOS
05954                                           ! 1476 }
05955 172F           5D                         pop	bp
05956 1730           C3                         ret
05957                                           ! 1477   bx_bool
05958                                           ! Register BX used in function log_bios_start
05959                                           ! 1478 set_enable_a20(val)
05960                                           ! 1479   bx_bool val;
05961                                           export	_set_enable_a20
05962                       00001731            _set_enable_a20:
05963                                           !BCC_EOS
05964                                           ! 1480 {
05965                                           ! 1481   Bit8u oldval;
05966                                           !BCC_EOS
05967                                           ! 1482   oldval = inb(0x0092);
05968 1731           55                         push	bp
05969 1732           89E5                       mov	bp,sp
05970 1734           4C                         dec	sp
05971 1735           4C                         dec	sp
05972                                           ! Debug: list int = const $92 (used reg = )
05973 1736           B8                   0092  mov	ax,#$92
05974 1739           50                         push	ax
05975                                           ! Debug: func () unsigned char = inb+0 (used reg = )
05976 173A           E8         EDEC            call	_inb
05977 173D           44                         inc	sp
05978 173E           44                         inc	sp
05979                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
05980 173F           8846         FF            mov	-1[bp],al
05981                                           !BCC_EOS
05982                                           ! 1483   if (val)
05983 1742           8B46         04            mov	ax,4[bp]
05984 1745           85C0                       test	ax,ax
05985 1747           74           14            je  	.159
05986                       00001749            .15A:
05987                                           ! 1484     outb(0x0092, oldval | 0x02);
05988                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05989 1749           8A46         FF            mov	al,-1[bp]
05990 174C           0C                     02  or	al,*2
05991                                           ! Debug: list unsigned char = al+0 (used reg = )
05992 174E           30E4                       xor	ah,ah
05993 1750           50                         push	ax
05994                                           ! Debug: list int = const $92 (used reg = )
05995 1751           B8                   0092  mov	ax,#$92
05996 1754           50                         push	ax
05997                                           ! Debug: func () void = outb+0 (used reg = )
05998 1755           E8         EDE7            call	_outb
05999 1758           83C4                   04  add	sp,*4
06000                                           !BCC_EOS
06001                                           ! 1485   else
06002                                           ! 1486     outb(0x0092, oldval & 0xfd);
06003 175B           EB           12            jmp .15B
06004                       0000175D            .159:
06005                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06006 175D           8A46         FF            mov	al,-1[bp]
06007 1760           24                     FD  and	al,#$FD
06008                                           ! Debug: list unsigned char = al+0 (used reg = )
06009 1762           30E4                       xor	ah,ah
06010 1764           50                         push	ax
06011                                           ! Debug: list int = const $92 (used reg = )
06012 1765           B8                   0092  mov	ax,#$92
06013 1768           50                         push	ax
06014                                           ! Debug: func () void = outb+0 (used reg = )
06015 1769           E8         EDD3            call	_outb
06016 176C           83C4                   04  add	sp,*4
06017                                           !BCC_EOS
06018                                           ! 1487   return((oldval & 0x02) != 0);
06019                       0000176F            .15B:
06020                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06021 176F           8A46         FF            mov	al,-1[bp]
06022 1772           24                     02  and	al,*2
06023                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06024 1774           84C0                       test	al,al
06025 1776           74           04            je 	.15C
06026 1778           B0                     01  mov	al,*1
06027 177A           EB           02            jmp	.15D
06028                       0000177C            .15C:
06029 177C           30C0                       xor	al,al
06030                       0000177E            .15D:
06031                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06032 177E           30E4                       xor	ah,ah
06033 1780           89EC                       mov	sp,bp
06034 1782           5D                         pop	bp
06035 1783           C3                         ret
06036                                           !BCC_EOS
06037                                           ! 1488 }
06038                                           ! 1489   void
06039                                           ! 1490 debugger_on()
06040                                           ! 1491 {
06041                                           export	_debugger_on
06042                       00001784            _debugger_on:
06043                                           ! 1492   outb(0xfedc, 0x01);
06044 1784           55                         push	bp
06045 1785           89E5                       mov	bp,sp
06046                                           ! Debug: list int = const 1 (used reg = )
06047 1787           B8                   0001  mov	ax,*1
06048 178A           50                         push	ax
06049                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06050 178B           B8                   FEDC  mov	ax,#$FEDC
06051 178E           50                         push	ax
06052                                           ! Debug: func () void = outb+0 (used reg = )
06053 178F           E8         EDAD            call	_outb
06054 1792           89EC                       mov	sp,bp
06055                                           !BCC_EOS
06056                                           ! 1493 }
06057 1794           5D                         pop	bp
06058 1795           C3                         ret
06059                                           ! 1494   void
06060                                           ! 1495 debugger_off()
06061                                           ! 1496 {
06062                                           export	_debugger_off
06063                       00001796            _debugger_off:
06064                                           ! 1497   outb(0xfedc, 0x00);
06065 1796           55                         push	bp
06066 1797           89E5                       mov	bp,sp
06067                                           ! Debug: list int = const 0 (used reg = )
06068 1799           31C0                       xor	ax,ax
06069 179B           50                         push	ax
06070                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06071 179C           B8                   FEDC  mov	ax,#$FEDC
06072 179F           50                         push	ax
06073                                           ! Debug: func () void = outb+0 (used reg = )
06074 17A0           E8         ED9C            call	_outb
06075 17A3           89EC                       mov	sp,bp
06076                                           !BCC_EOS
06077                                           ! 1498 }
06078 17A5           5D                         pop	bp
06079 17A6           C3                         ret
06080                                           ! 1499 int
06081                                           ! 1500 s3_resume()
06082                                           ! 1501 {
06083                                           export	_s3_resume
06084                       000017A7            _s3_resume:
06085                                           ! 1502     Bit32u s3_wakeup_vector;
06086                                           !BCC_EOS
06087                                           ! 1503     Bit8u s3_resume_flag;
06088                                           !BCC_EOS
06089                                           ! 1504     s3_resume_flag = *((Bit8u *)(0x04b0));
06090 17A7           55                         push	bp
06091 17A8           89E5                       mov	bp,sp
06092 17AA           83C4                   FA  add	sp,*-6
06093                                           ! Debug: eq unsigned char = [+$4B0] to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06094 17AD           A0         04B0            mov	al,[$4B0]
06095 17B0           8846         FB            mov	-5[bp],al
06096                                           !BCC_EOS
06097                                           ! 1505     s3_wakeup_vector = *((Bit32u *)(0x04b2));
06098                                           ! Debug: eq unsigned long = [+$4B2] to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06099 17B3           A1         04B2            mov	ax,[$4B2]
06100 17B6           8B1E       04B4            mov	bx,[$4B4]
06101 17BA           8946         FC            mov	-4[bp],ax
06102 17BD           895E         FE            mov	-2[bp],bx
06103                                           !BCC_EOS
06104                                           ! 1506     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06105                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06106 17C0           FF76         FE            push	-2[bp]
06107 17C3           FF76         FC            push	-4[bp]
06108                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06109 17C6           8A46         FB            mov	al,-5[bp]
06110 17C9           30E4                       xor	ah,ah
06111 17CB           50                         push	ax
06112                                           ! Debug: list * char = .15E+0 (used reg = )
06113 17CC           BB                   D810  mov	bx,#.15E
06114 17CF           53                         push	bx
06115                                           ! Debug: list int = const 4 (used reg = )
06116 17D0           B8                   0004  mov	ax,*4
06117 17D3           50                         push	ax
06118                                           ! Debug: func () void = bios_printf+0 (used reg = )
06119 17D4           E8         F162            call	_bios_printf
06120 17D7           83C4                   0A  add	sp,*$A
06121                                           !BCC_EOS
06122                                           ! 1507     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06123                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06124 17DA           8A46         FB            mov	al,-5[bp]
06125 17DD           3C                     FE  cmp	al,#$FE
06126 17DF           75           0B            jne 	.160
06127                       000017E1            .161:
06128 17E1           8B46         FC            mov	ax,-4[bp]
06129 17E4           8B5E         FE            mov	bx,-2[bp]
06130 17E7           E8         E8FB            call	ltstl
06131 17EA           75           06            jne 	.15F
06132                       000017EC            .160:
06133                                           ! 1508      return 0;
06134 17EC           31C0                       xor	ax,ax
06135 17EE           89EC                       mov	sp,bp
06136 17F0           5D                         pop	bp
06137 17F1           C3                         ret
06138                                           !BCC_EOS
06139                                           ! 1509     *((Bit8u *)(0x04b0)) = (0);
06140                       000017F2            .15F:
06141                                           ! Debug: eq int = const 0 to unsigned char = [+$4B0] (used reg = )
06142 17F2           30C0                       xor	al,al
06143 17F4           A2         04B0            mov	[$4B0],al
06144                                           !BCC_EOS
06145                                           ! 1510     *((Bit16u *)(0x04b6)) = ((s3_wakeup_vector & 0xF));
06146                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06147                                           ! Debug: expression subtree swapping
06148 17F7           B8                   000F  mov	ax,*$F
06149 17FA           31DB                       xor	bx,bx
06150 17FC           8D7E         FC            lea	di,-4[bp]
06151 17FF           E8         E88A            call	landul
06152                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B6] (used reg = )
06153 1802           A3         04B6            mov	[$4B6],ax
06154                                           !BCC_EOS
06155                                           ! 1511     *((Bit16u *)(0x04b8)) = ((s3_wakeup_vector >> 4));
06156                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06157 1805           8B46         FC            mov	ax,-4[bp]
06158 1808           8B5E         FE            mov	bx,-2[bp]
06159 180B           BF                   0004  mov	di,*4
06160 180E           E8         E8E9            call	lsrul
06161                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B8] (used reg = )
06162 1811           A3         04B8            mov	[$4B8],ax
06163                                           !BCC_EOS
06164                                           ! 1512     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06165                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06166                                           ! Debug: expression subtree swapping
06167 1814           B8                   000F  mov	ax,*$F
06168 1817           31DB                       xor	bx,bx
06169 1819           8D7E         FC            lea	di,-4[bp]
06170 181C           E8         E86D            call	landul
06171                                           ! Debug: list unsigned long = bx+0 (used reg = )
06172 181F           53                         push	bx
06173 1820           50                         push	ax
06174                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06175 1821           8B46         FC            mov	ax,-4[bp]
06176 1824           8B5E         FE            mov	bx,-2[bp]
06177 1827           BF                   0004  mov	di,*4
06178 182A           E8         E8CD            call	lsrul
06179                                           ! Debug: list unsigned long = bx+0 (used reg = )
06180 182D           53                         push	bx
06181 182E           50                         push	ax
06182                                           ! Debug: list * char = .162+0 (used reg = )
06183 182F           BB                   D7F7  mov	bx,#.162
06184 1832           53                         push	bx
06185                                           ! Debug: list int = const 4 (used reg = )
06186 1833           B8                   0004  mov	ax,*4
06187 1836           50                         push	ax
06188                                           ! Debug: func () void = bios_printf+0 (used reg = )
06189 1837           E8         F0FF            call	_bios_printf
06190 183A           83C4                   0C  add	sp,*$C
06191                                           !BCC_EOS
06192                                           ! 1513 #asm
06193                                           !BCC_EOS
06194                                           !BCC_ASM
06195                       00000001            _s3_resume.s3_resume_flag	set	1
06196                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06197                       00000002            _s3_resume.s3_wakeup_vector	set	2
06198                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06199 183D           FF2E       04B6                jmpf [0x04b6]
06200                                           ! 1515 endasm
06201                                           !BCC_ENDASM
06202                                           !BCC_EOS
06203                                           ! 1516     return 1;
06204 1841           B8                   0001  mov	ax,*1
06205 1844           89EC                       mov	sp,bp
06206 1846           5D                         pop	bp
06207 1847           C3                         ret
06208                                           !BCC_EOS
06209                                           ! 1517 }
06210                                           ! 1518 void ata_init( )
06211                                           ! Register BX used in function s3_resume
06212                                           ! 1519 {
06213                                           export	_ata_init
06214                       00001848            _ata_init:
06215                                           ! 1520   Bit8u channel, device;
06216                                           !BCC_EOS
06217                                           ! 1521   Bit16u old_ds = set_DS(get_ebda_seg());
06218 1848           55                         push	bp
06219 1849           89E5                       mov	bp,sp
06220 184B           83C4                   FC  add	sp,*-4
06221                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06222 184E           E8         EE16            call	_get_ebda_seg
06223                                           ! Debug: list unsigned short = ax+0 (used reg = )
06224 1851           50                         push	ax
06225                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06226 1852           E8         EE08            call	_set_DS
06227 1855           44                         inc	sp
06228 1856           44                         inc	sp
06229                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+6-6] (used reg = )
06230 1857           8946         FC            mov	-4[bp],ax
06231                                           !BCC_EOS
06232                                           ! 1522   for (channel=0; channel<4; channel++) {
06233                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-3] (used reg = )
06234 185A           30C0                       xor	al,al
06235 185C           8846         FF            mov	-1[bp],al
06236                                           !BCC_EOS
06237                                           !BCC_EOS
06238 185F           EB           4B            jmp .165
06239                       00001861            .166:
06240                                           ! 1523     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface)) = (0x00);
06241                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06242 1861           8A46         FF            mov	al,-1[bp]
06243 1864           30E4                       xor	ah,ah
06244 1866           B1                     03  mov	cl,*3
06245 1868           D3E0                       shl	ax,cl
06246 186A           89C3                       mov	bx,ax
06247                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06248                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
06249                                           ! Debug: eq int = const 0 to unsigned char = [bx+$122] (used reg = )
06250 186C           30C0                       xor	al,al
06251 186E           8887       0122            mov	$122[bx],al
06252                                           !BCC_EOS
06253                                           ! 1524     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1)) = (0x0);
06254                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06255 1872           8A46         FF            mov	al,-1[bp]
06256 1875           30E4                       xor	ah,ah
06257 1877           B1                     03  mov	cl,*3
06258 1879           D3E0                       shl	ax,cl
06259 187B           89C3                       mov	bx,ax
06260                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06261                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
06262                                           ! Debug: eq int = const 0 to unsigned short = [bx+$124] (used reg = )
06263 187D           31C0                       xor	ax,ax
06264 187F           8987       0124            mov	$124[bx],ax
06265                                           !BCC_EOS
06266                                           ! 1525     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2)) = (0x0);
06267                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06268 1883           8A46         FF            mov	al,-1[bp]
06269 1886           30E4                       xor	ah,ah
06270 1888           B1                     03  mov	cl,*3
06271 188A           D3E0                       shl	ax,cl
06272 188C           89C3                       mov	bx,ax
06273                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06274                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
06275                                           ! Debug: eq int = const 0 to unsigned short = [bx+$126] (used reg = )
06276 188E           31C0                       xor	ax,ax
06277 1890           8987       0126            mov	$126[bx],ax
06278                                           !BCC_EOS
06279                                           ! 1526     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq)) = (0);
06280                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06281 1894           8A46         FF            mov	al,-1[bp]
06282 1897           30E4                       xor	ah,ah
06283 1899           B1                     03  mov	cl,*3
06284 189B           D3E0                       shl	ax,cl
06285 189D           89C3                       mov	bx,ax
06286                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06287                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
06288                                           ! Debug: eq int = const 0 to unsigned char = [bx+$128] (used reg = )
06289 189F           30C0                       xor	al,al
06290 18A1           8887       0128            mov	$128[bx],al
06291                                           !BCC_EOS
06292                                           ! 1527   }
06293                                           ! 1528   for (device=0; device<(4*2); device++) {
06294                       000018A5            .164:
06295                                           ! Debug: postinc unsigned char channel = [S+6-3] (used reg = )
06296 18A5           8A46         FF            mov	al,-1[bp]
06297 18A8           40                         inc	ax
06298 18A9           8846         FF            mov	-1[bp],al
06299                       000018AC            .165:
06300                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-3] (used reg = )
06301 18AC           8A46         FF            mov	al,-1[bp]
06302 18AF           3C                     04  cmp	al,*4
06303 18B1           72           AE            jb 	.166
06304                       000018B3            .167:
06305                       000018B3            .163:
06306                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06307 18B3           30C0                       xor	al,al
06308 18B5           8846         FE            mov	-2[bp],al
06309                                           !BCC_EOS
06310                                           !BCC_EOS
06311 18B8           E9         0121            br 	.16A
06312                       000018BB            .16B:
06313                                           ! 1529     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
06314                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06315 18BB           8A46         FE            mov	al,-2[bp]
06316 18BE           30E4                       xor	ah,ah
06317 18C0           B9                   001E  mov	cx,*$1E
06318 18C3           F7E9                       imul	cx
06319 18C5           89C3                       mov	bx,ax
06320                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06321                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
06322                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
06323 18C7           30C0                       xor	al,al
06324 18C9           8887       0142            mov	$142[bx],al
06325                                           !BCC_EOS
06326                                           ! 1530     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x00);
06327                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06328 18CD           8A46         FE            mov	al,-2[bp]
06329 18D0           30E4                       xor	ah,ah
06330 18D2           B9                   001E  mov	cx,*$1E
06331 18D5           F7E9                       imul	cx
06332 18D7           89C3                       mov	bx,ax
06333                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06334                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
06335                                           ! Debug: eq int = const 0 to unsigned char = [bx+$143] (used reg = )
06336 18D9           30C0                       xor	al,al
06337 18DB           8887       0143            mov	$143[bx],al
06338                                           !BCC_EOS
06339                                           ! 1531     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (0);
06340                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06341 18DF           8A46         FE            mov	al,-2[bp]
06342 18E2           30E4                       xor	ah,ah
06343 18E4           B9                   001E  mov	cx,*$1E
06344 18E7           F7E9                       imul	cx
06345 18E9           89C3                       mov	bx,ax
06346                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06347                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
06348                                           ! Debug: eq int = const 0 to unsigned char = [bx+$144] (used reg = )
06349 18EB           30C0                       xor	al,al
06350 18ED           8887       0144            mov	$144[bx],al
06351                                           !BCC_EOS
06352                                           ! 1532     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (0);
06353                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06354 18F1           8A46         FE            mov	al,-2[bp]
06355 18F4           30E4                       xor	ah,ah
06356 18F6           B9                   001E  mov	cx,*$1E
06357 18F9           F7E9                       imul	cx
06358 18FB           89C3                       mov	bx,ax
06359                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06360                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
06361                                           ! Debug: eq int = const 0 to unsigned char = [bx+$145] (used reg = )
06362 18FD           30C0                       xor	al,al
06363 18FF           8887       0145            mov	$145[bx],al
06364                                           !BCC_EOS
06365                                           ! 1533     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
06366                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06367 1903           8A46         FE            mov	al,-2[bp]
06368 1906           30E4                       xor	ah,ah
06369 1908           B9                   001E  mov	cx,*$1E
06370 190B           F7E9                       imul	cx
06371 190D           89C3                       mov	bx,ax
06372                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06373                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
06374                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
06375 190F           30C0                       xor	al,al
06376 1911           8887       0146            mov	$146[bx],al
06377                                           !BCC_EOS
06378                                           ! 1534     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (0);
06379                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06380 1915           8A46         FE            mov	al,-2[bp]
06381 1918           30E4                       xor	ah,ah
06382 191A           B9                   001E  mov	cx,*$1E
06383 191D           F7E9                       imul	cx
06384 191F           89C3                       mov	bx,ax
06385                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06386                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
06387                                           ! Debug: eq int = const 0 to unsigned short = [bx+$148] (used reg = )
06388 1921           31C0                       xor	ax,ax
06389 1923           8987       0148            mov	$148[bx],ax
06390                                           !BCC_EOS
06391                                           ! 1535     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].trans
06392                                           ! 1535 lation)) = (0);
06393                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06394 1927           8A46         FE            mov	al,-2[bp]
06395 192A           30E4                       xor	ah,ah
06396 192C           B9                   001E  mov	cx,*$1E
06397 192F           F7E9                       imul	cx
06398 1931           89C3                       mov	bx,ax
06399                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06400                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
06401                                           ! Debug: eq int = const 0 to unsigned char = [bx+$14A] (used reg = )
06402 1933           30C0                       xor	al,al
06403 1935           8887       014A            mov	$14A[bx],al
06404                                           !BCC_EOS
06405                                           ! 1536     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (0);
06406                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06407 1939           8A46         FE            mov	al,-2[bp]
06408 193C           30E4                       xor	ah,ah
06409 193E           B9                   001E  mov	cx,*$1E
06410 1941           F7E9                       imul	cx
06411 1943           89C3                       mov	bx,ax
06412                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06413                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
06414                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14C] (used reg = )
06415 1945           31C0                       xor	ax,ax
06416 1947           8987       014C            mov	$14C[bx],ax
06417                                           !BCC_EOS
06418                                           ! 1537     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (0);
06419                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06420 194B           8A46         FE            mov	al,-2[bp]
06421 194E           30E4                       xor	ah,ah
06422 1950           B9                   001E  mov	cx,*$1E
06423 1953           F7E9                       imul	cx
06424 1955           89C3                       mov	bx,ax
06425                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06426                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
06427                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14E] (used reg = )
06428 1957           31C0                       xor	ax,ax
06429 1959           8987       014E            mov	$14E[bx],ax
06430                                           !BCC_EOS
06431                                           ! 1538     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (0);
06432                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06433 195D           8A46         FE            mov	al,-2[bp]
06434 1960           30E4                       xor	ah,ah
06435 1962           B9                   001E  mov	cx,*$1E
06436 1965           F7E9                       imul	cx
06437 1967           89C3                       mov	bx,ax
06438                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06439                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
06440                                           ! Debug: eq int = const 0 to unsigned short = [bx+$150] (used reg = )
06441 1969           31C0                       xor	ax,ax
06442 196B           8987       0150            mov	$150[bx],ax
06443                                           !BCC_EOS
06444                                           ! 1539     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (0);
06445                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06446 196F           8A46         FE            mov	al,-2[bp]
06447 1972           30E4                       xor	ah,ah
06448 1974           B9                   001E  mov	cx,*$1E
06449 1977           F7E9                       imul	cx
06450 1979           89C3                       mov	bx,ax
06451                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06452                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
06453                                           ! Debug: eq int = const 0 to unsigned short = [bx+$152] (used reg = )
06454 197B           31C0                       xor	ax,ax
06455 197D           8987       0152            mov	$152[bx],ax
06456                                           !BCC_EOS
06457                                           ! 1540     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (0);
06458                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06459 1981           8A46         FE            mov	al,-2[bp]
06460 1984           30E4                       xor	ah,ah
06461 1986           B9                   001E  mov	cx,*$1E
06462 1989           F7E9                       imul	cx
06463 198B           89C3                       mov	bx,ax
06464                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06465                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
06466                                           ! Debug: eq int = const 0 to unsigned short = [bx+$154] (used reg = )
06467 198D           31C0                       xor	ax,ax
06468 198F           8987       0154            mov	$154[bx],ax
06469                                           !BCC_EOS
06470                                           ! 1541     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (0);
06471                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06472 1993           8A46         FE            mov	al,-2[bp]
06473 1996           30E4                       xor	ah,ah
06474 1998           B9                   001E  mov	cx,*$1E
06475 199B           F7E9                       imul	cx
06476 199D           89C3                       mov	bx,ax
06477                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06478                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
06479                                           ! Debug: eq int = const 0 to unsigned short = [bx+$156] (used reg = )
06480 199F           31C0                       xor	ax,ax
06481 19A1           8987       0156            mov	$156[bx],ax
06482                                           !BCC_EOS
06483                                           ! 1542     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (0L);
06484                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06485 19A5           8A46         FE            mov	al,-2[bp]
06486 19A8           30E4                       xor	ah,ah
06487 19AA           B9                   001E  mov	cx,*$1E
06488 19AD           F7E9                       imul	cx
06489 19AF           89C3                       mov	bx,ax
06490                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06491                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
06492                                           ! Debug: eq long = const 0 to unsigned long = [bx+$158] (used reg = )
06493 19B1           31C0                       xor	ax,ax
06494 19B3           31F6                       xor	si,si
06495 19B5           8987       0158            mov	$158[bx],ax
06496 19B9           89B7       015A            mov	$15A[bx],si
06497                                           !BCC_EOS
06498                                           ! 1543     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (0L);
06499                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06500 19BD           8A46         FE            mov	al,-2[bp]
06501 19C0           30E4                       xor	ah,ah
06502 19C2           B9                   001E  mov	cx,*$1E
06503 19C5           F7E9                       imul	cx
06504 19C7           89C3                       mov	bx,ax
06505                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06506                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
06507                                           ! Debug: eq long = const 0 to unsigned long = [bx+$15C] (used reg = )
06508 19C9           31C0                       xor	ax,ax
06509 19CB           31F6                       xor	si,si
06510 19CD           8987       015C            mov	$15C[bx],ax
06511 19D1           89B7       015E            mov	$15E[bx],si
06512                                           !BCC_EOS
06513                                           ! 1544   }
06514                                           ! 1545   for (device=0; device<(4*2); device++) {
06515                       000019D5            .169:
06516                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06517 19D5           8A46         FE            mov	al,-2[bp]
06518 19D8           40                         inc	ax
06519 19D9           8846         FE            mov	-2[bp],al
06520                       000019DC            .16A:
06521                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06522 19DC           8A46         FE            mov	al,-2[bp]
06523 19DF           3C                     08  cmp	al,*8
06524 19E1         0F82         FED6            blo 	.16B
06525                       000019E5            .16C:
06526                       000019E5            .168:
06527                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06528 19E5           30C0                       xor	al,al
06529 19E7           8846         FE            mov	-2[bp],al
06530                                           !BCC_EOS
06531                                           !BCC_EOS
06532 19EA           EB           21            jmp .16F
06533                       000019EC            .170:
06534                                           ! 1546     *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[device])) = ((4*2));
06535                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $233 (used reg = )
06536 19EC           8A46         FE            mov	al,-2[bp]
06537 19EF           30E4                       xor	ah,ah
06538 19F1           89C3                       mov	bx,ax
06539                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06540                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
06541                                           ! Debug: eq int = const 8 to unsigned char = [bx+$233] (used reg = )
06542 19F3           B0                     08  mov	al,*8
06543 19F5           8887       0233            mov	$233[bx],al
06544                                           !BCC_EOS
06545                                           ! 1547     *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[device])) = ((4*2));
06546                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $23C (used reg = )
06547 19F9           8A46         FE            mov	al,-2[bp]
06548 19FC           30E4                       xor	ah,ah
06549 19FE           89C3                       mov	bx,ax
06550                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06551                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
06552                                           ! Debug: eq int = const 8 to unsigned char = [bx+$23C] (used reg = )
06553 1A00           B0                     08  mov	al,*8
06554 1A02           8887       023C            mov	$23C[bx],al
06555                                           !BCC_EOS
06556                                           ! 1548   }
06557                                           ! 1549   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (0);
06558                       00001A06            .16E:
06559                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06560 1A06           8A46         FE            mov	al,-2[bp]
06561 1A09           40                         inc	ax
06562 1A0A           8846         FE            mov	-2[bp],al
06563                       00001A0D            .16F:
06564                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06565 1A0D           8A46         FE            mov	al,-2[bp]
06566 1A10           3C                     08  cmp	al,*8
06567 1A12           72           D8            jb 	.170
06568                       00001A14            .171:
06569                       00001A14            .16D:
06570                                           ! Debug: eq int = const 0 to unsigned char = [+$232] (used reg = )
06571 1A14           30C0                       xor	al,al
06572 1A16           A2         0232            mov	[$232],al
06573                                           !BCC_EOS
06574                                           ! 1550   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (0);
06575                                           ! Debug: eq int = const 0 to unsigned char = [+$23B] (used reg = )
06576 1A19           30C0                       xor	al,al
06577 1A1B           A2         023B            mov	[$23B],al
06578                                           !BCC_EOS
06579                                           ! 1551   set_DS(old_ds);
06580                                           ! Debug: list unsigned short old_ds = [S+6-6] (used reg = )
06581 1A1E           FF76         FC            push	-4[bp]
06582                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06583 1A21           E8         EC39            call	_set_DS
06584 1A24           44                         inc	sp
06585 1A25           44                         inc	sp
06586                                           !BCC_EOS
06587                                           ! 1552 }
06588 1A26           89EC                       mov	sp,bp
06589 1A28           5D                         pop	bp
06590 1A29           C3                         ret
06591                                           ! 1553 int await_ide();
06592                                           ! Register BX used in function ata_init
06593                                           !BCC_EOS
06594                                           ! 1554 static int await_ide(when_done,base,timeout)
06595                                           ! 1555   Bit8u when_done;
06596                       00001A2A            _await_ide:
06597                                           !BCC_EOS
06598                                           ! 1556   Bit16u base;
06599                                           !BCC_EOS
06600                                           ! 1557   Bit16u timeout;
06601                                           !BCC_EOS
06602                                           ! 1558 {
06603                                           ! 1559   Bit32u time=0;
06604 1A2A           55                         push	bp
06605 1A2B           89E5                       mov	bp,sp
06606 1A2D           83C4                   FC  add	sp,*-4
06607                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06608 1A30           31C0                       xor	ax,ax
06609 1A32           31DB                       xor	bx,bx
06610 1A34           8946         FC            mov	-4[bp],ax
06611 1A37           895E         FE            mov	-2[bp],bx
06612                                           !BCC_EOS
06613                                           ! 1560   Bit16u status,last=0;
06614 1A3A           83C4                   FC  add	sp,*-4
06615                                           ! Debug: eq int = const 0 to unsigned short last = [S+$A-$A] (used reg = )
06616 1A3D           31C0                       xor	ax,ax
06617 1A3F           8946         F8            mov	-8[bp],ax
06618                                           !BCC_EOS
06619                                           ! 1561   Bit8u result;
06620                                           !BCC_EOS
06621                                           ! 1562   status = inb(base + 7);
06622 1A42           4C                         dec	sp
06623 1A43           4C                         dec	sp
06624                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06625 1A44           8B46         06            mov	ax,6[bp]
06626                                           ! Debug: list unsigned int = ax+7 (used reg = )
06627 1A47           05                   0007  add	ax,*7
06628 1A4A           50                         push	ax
06629                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06630 1A4B           E8         EADB            call	_inb
06631 1A4E           44                         inc	sp
06632 1A4F           44                         inc	sp
06633                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06634 1A50           30E4                       xor	ah,ah
06635 1A52           8946         FA            mov	-6[bp],ax
06636                                           !BCC_EOS
06637                                           ! 1563   for(;;) {
06638                                           !BCC_EOS
06639                                           !BCC_EOS
06640                       00001A55            .174:
06641                                           ! 1564     status = inb(base+7);
06642                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06643 1A55           8B46         06            mov	ax,6[bp]
06644                                           ! Debug: list unsigned int = ax+7 (used reg = )
06645 1A58           05                   0007  add	ax,*7
06646 1A5B           50                         push	ax
06647                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06648 1A5C           E8         EACA            call	_inb
06649 1A5F           44                         inc	sp
06650 1A60           44                         inc	sp
06651                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06652 1A61           30E4                       xor	ah,ah
06653 1A63           8946         FA            mov	-6[bp],ax
06654                                           !BCC_EOS
06655                                           ! 1565     time++;
06656                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
06657 1A66           8B46         FC            mov	ax,-4[bp]
06658 1A69           8B76         FE            mov	si,-2[bp]
06659 1A6C           8D5E         FC            lea	bx,-4[bp]
06660 1A6F           E8         E66E            call	lincl
06661                                           !BCC_EOS
06662                                           ! 1566     if (when_done == 1)
06663                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
06664 1A72           8A46         04            mov	al,4[bp]
06665 1A75           3C                     01  cmp	al,*1
06666 1A77           75           0B            jne 	.175
06667                       00001A79            .176:
06668                                           ! 1567       result = status & 0x80;
06669                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06670 1A79           8A46         FA            mov	al,-6[bp]
06671 1A7C           24                     80  and	al,#$80
06672                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06673 1A7E           8846         F7            mov	-9[bp],al
06674                                           !BCC_EOS
06675                                           ! 1568     else if (when_done == 2)
06676 1A81           E9         0094            br 	.177
06677                       00001A84            .175:
06678                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
06679 1A84           8A46         04            mov	al,4[bp]
06680 1A87           3C                     02  cmp	al,*2
06681 1A89           75           15            jne 	.178
06682                       00001A8B            .179:
06683                                           ! 1569       result = !(status & 0x80);
06684                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06685 1A8B           8A46         FA            mov	al,-6[bp]
06686 1A8E           24                     80  and	al,#$80
06687 1A90           84C0                       test	al,al
06688 1A92           75           04            jne 	.17A
06689                       00001A94            .17B:
06690 1A94           B0                     01  mov	al,*1
06691 1A96           EB           02            jmp	.17C
06692                       00001A98            .17A:
06693 1A98           30C0                       xor	al,al
06694                       00001A9A            .17C:
06695                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06696 1A9A           8846         F7            mov	-9[bp],al
06697                                           !BCC_EOS
06698                                           ! 1570     else if (when_done == 3)
06699 1A9D           E9         0078            br 	.17D
06700                       00001AA0            .178:
06701                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
06702 1AA0           8A46         04            mov	al,4[bp]
06703 1AA3           3C                     03  cmp	al,*3
06704 1AA5           75           1D            jne 	.17E
06705                       00001AA7            .17F:
06706                                           ! 1571       result = !(status & 0x80) && (status & 0x08);
06707                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06708 1AA7           8A46         FA            mov	al,-6[bp]
06709 1AAA           24                     80  and	al,#$80
06710 1AAC           84C0                       test	al,al
06711 1AAE           75           0D            jne 	.180
06712                       00001AB0            .182:
06713                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06714 1AB0           8A46         FA            mov	al,-6[bp]
06715 1AB3           24                     08  and	al,*8
06716 1AB5           84C0                       test	al,al
06717 1AB7           74           04            je  	.180
06718                       00001AB9            .181:
06719 1AB9           B0                     01  mov	al,*1
06720 1ABB           EB           02            jmp	.183
06721                       00001ABD            .180:
06722 1ABD           30C0                       xor	al,al
06723                       00001ABF            .183:
06724                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06725 1ABF           8846         F7            mov	-9[bp],al
06726                                           !BCC_EOS
06727                                           ! 1572     else if (when_done == 4)
06728 1AC2           EB           54            jmp .184
06729                       00001AC4            .17E:
06730                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
06731 1AC4           8A46         04            mov	al,4[bp]
06732 1AC7           3C                     04  cmp	al,*4
06733 1AC9           75           1D            jne 	.185
06734                       00001ACB            .186:
06735                                           ! 1573       result = !(status & 0x80) && !(status & 0x08);
06736                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06737 1ACB           8A46         FA            mov	al,-6[bp]
06738 1ACE           24                     80  and	al,#$80
06739 1AD0           84C0                       test	al,al
06740 1AD2           75           0D            jne 	.187
06741                       00001AD4            .189:
06742                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06743 1AD4           8A46         FA            mov	al,-6[bp]
06744 1AD7           24                     08  and	al,*8
06745 1AD9           84C0                       test	al,al
06746 1ADB           75           04            jne 	.187
06747                       00001ADD            .188:
06748 1ADD           B0                     01  mov	al,*1
06749 1ADF           EB           02            jmp	.18A
06750                       00001AE1            .187:
06751 1AE1           30C0                       xor	al,al
06752                       00001AE3            .18A:
06753                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06754 1AE3           8846         F7            mov	-9[bp],al
06755                                           !BCC_EOS
06756                                           ! 1574     else if (when_done == 5)
06757 1AE6           EB           30            jmp .18B
06758                       00001AE8            .185:
06759                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
06760 1AE8           8A46         04            mov	al,4[bp]
06761 1AEB           3C                     05  cmp	al,*5
06762 1AED           75           1D            jne 	.18C
06763                       00001AEF            .18D:
06764                                           ! 1575       result = !(status & 0x80) && (status & 0x40);
06765                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06766 1AEF           8A46         FA            mov	al,-6[bp]
06767 1AF2           24                     80  and	al,#$80
06768 1AF4           84C0                       test	al,al
06769 1AF6           75           0D            jne 	.18E
06770                       00001AF8            .190:
06771                                           ! Debug: and int = const $40 to unsigned short status = [S+$C-8] (used reg = )
06772 1AF8           8A46         FA            mov	al,-6[bp]
06773 1AFB           24                     40  and	al,*$40
06774 1AFD           84C0                       test	al,al
06775 1AFF           74           04            je  	.18E
06776                       00001B01            .18F:
06777 1B01           B0                     01  mov	al,*1
06778 1B03           EB           02            jmp	.191
06779                       00001B05            .18E:
06780 1B05           30C0                       xor	al,al
06781                       00001B07            .191:
06782                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06783 1B07           8846         F7            mov	-9[bp],al
06784                                           !BCC_EOS
06785                                           ! 1576     else if (when_done == 0)
06786 1B0A           EB           0C            jmp .192
06787                       00001B0C            .18C:
06788                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
06789 1B0C           8A46         04            mov	al,4[bp]
06790 1B0F           84C0                       test	al,al
06791 1B11           75           05            jne 	.193
06792                       00001B13            .194:
06793                                           ! 1577       result = 0;
06794                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$B] (used reg = )
06795 1B13           30C0                       xor	al,al
06796 1B15           8846         F7            mov	-9[bp],al
06797                                           !BCC_EOS
06798                                           ! 1578     if (result) return 0;
06799                       00001B18            .193:
06800                       00001B18            .192:
06801                       00001B18            .18B:
06802                       00001B18            .184:
06803                       00001B18            .17D:
06804                       00001B18            .177:
06805 1B18           8A46         F7            mov	al,-9[bp]
06806 1B1B           84C0                       test	al,al
06807 1B1D           74           06            je  	.195
06808                       00001B1F            .196:
06809 1B1F           31C0                       xor	ax,ax
06810 1B21           89EC                       mov	sp,bp
06811 1B23           5D                         pop	bp
06812 1B24           C3                         ret
06813                                           !BCC_EOS
06814                                           ! 1579     if (*(((Bit16u *)&time)+1) != last)
06815                       00001B25            .195:
06816                                           ! Debug: ne unsigned short last = [S+$C-$A] to unsigned short time = [S+$C-4] (used reg = )
06817 1B25           8B46         FE            mov	ax,-2[bp]
06818 1B28           3B46         F8            cmp	ax,-8[bp]
06819 1B2B           74           06            je  	.197
06820                       00001B2D            .198:
06821                                           ! 1580     {
06822                                           ! 1581       last = *(((Bit16u *)&time)+1);
06823                                           ! Debug: eq unsigned short time = [S+$C-4] to unsigned short last = [S+$C-$A] (used reg = )
06824 1B2D           8B46         FE            mov	ax,-2[bp]
06825 1B30           8946         F8            mov	-8[bp],ax
06826                                           !BCC_EOS
06827                                           ! 1582       ;
06828                                           !BCC_EOS
06829                                           ! 1583     }
06830                                           ! 1584     if (status & 0x01)
06831                       00001B33            .197:
06832                                           ! Debug: and int = const 1 to unsigned short status = [S+$C-8] (used reg = )
06833 1B33           8A46         FA            mov	al,-6[bp]
06834 1B36           24                     01  and	al,*1
06835 1B38           84C0                       test	al,al
06836 1B3A           74           07            je  	.199
06837                       00001B3C            .19A:
06838                                           ! 1585     {
06839                                           ! 1586       ;
06840                                           !BCC_EOS
06841                                           ! 1587       return -1;
06842 1B3C           B8                   FFFF  mov	ax,*-1
06843 1B3F           89EC                       mov	sp,bp
06844 1B41           5D                         pop	bp
06845 1B42           C3                         ret
06846                                           !BCC_EOS
06847                                           ! 1588     }
06848                                           ! 1589     if ((timeout == 0) || ((time>>11) > timeout)) break;
06849                       00001B43            .199:
06850                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06851 1B43           8B46         08            mov	ax,8[bp]
06852 1B46           85C0                       test	ax,ax
06853 1B48           74           26            je  	.19C
06854                       00001B4A            .19D:
06855                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06856 1B4A           8B46         08            mov	ax,8[bp]
06857 1B4D           31DB                       xor	bx,bx
06858 1B4F           53                         push	bx
06859 1B50           50                         push	ax
06860                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
06861 1B51           8B46         FC            mov	ax,-4[bp]
06862 1B54           8B5E         FE            mov	bx,-2[bp]
06863 1B57           88E0                       mov	al,ah
06864 1B59           88DC                       mov	ah,bl
06865 1B5B           88FB                       mov	bl,bh
06866 1B5D           28FF                       sub	bh,bh
06867 1B5F           BF                   0003  mov	di,*3
06868 1B62           E8         E595            call	lsrul
06869                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
06870 1B65           8D7E         F2            lea	di,-$E[bp]
06871 1B68           E8         E531            call	lcmpul
06872 1B6B           8D66         F6            lea	sp,-$A[bp]
06873 1B6E           76           02            jbe 	.19B
06874                       00001B70            .19C:
06875 1B70           EB           03            jmp .172
06876                                           !BCC_EOS
06877                                           ! 1590   }
06878                       00001B72            .19B:
06879                                           ! 1591   bios_printf(4, "IDE time out\n");
06880                       00001B72            .173:
06881 1B72           E9         FEE0            br 	.174
06882                       00001B75            .172:
06883                                           ! Debug: list * char = .19E+0 (used reg = )
06884 1B75           BB                   D7E9  mov	bx,#.19E
06885 1B78           53                         push	bx
06886                                           ! Debug: list int = const 4 (used reg = )
06887 1B79           B8                   0004  mov	ax,*4
06888 1B7C           50                         push	ax
06889                                           ! Debug: func () void = bios_printf+0 (used reg = )
06890 1B7D           E8         EDB9            call	_bios_printf
06891 1B80           83C4                   04  add	sp,*4
06892                                           !BCC_EOS
06893                                           ! 1592   return -1;
06894 1B83           B8                   FFFF  mov	ax,*-1
06895 1B86           89EC                       mov	sp,bp
06896 1B88           5D                         pop	bp
06897 1B89           C3                         ret
06898                                           !BCC_EOS
06899                                           ! 1593 }
06900                                           ! 1594 void ata_detect( )
06901                                           ! Register BX used in function await_ide
06902                                           ! 1595 {
06903                                           export	_ata_detect
06904                       00001B8A            _ata_detect:
06905                                           ! 1596   Bit8u hdcount, cdcount, device, type;
06906                                           !BCC_EOS
06907                                           ! 1597   Bit8u buffer[0x0200];
06908                                           !BCC_EOS
06909                                           ! 1598   Bit16u old_ds = set_DS(get
06910 1B8A           55                         push	bp
06911 1B8B           89E5                       mov	bp,sp
06912 1B8D           81C4                 FDFA  add	sp,#-$206
06913                                           ! 1598 _ebda_seg());
06914                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06915 1B91           E8         EAD3            call	_get_ebda_seg
06916                                           ! Debug: list unsigned short = ax+0 (used reg = )
06917 1B94           50                         push	ax
06918                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06919 1B95           E8         EAC5            call	_set_DS
06920 1B98           44                         inc	sp
06921 1B99           44                         inc	sp
06922                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$208-$208] (used reg = )
06923 1B9A           8986       FDFA            mov	-$206[bp],ax
06924                                           !BCC_EOS
06925                                           ! 1599   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].iface)) = (0x00);
06926                                           ! Debug: eq int = const 0 to unsigned char = [+$122] (used reg = )
06927 1B9E           30C0                       xor	al,al
06928 1BA0           A2         0122            mov	[$122],al
06929                                           !BCC_EOS
06930                                           ! 1600   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase1)) = (0x01f0);
06931                                           ! Debug: eq int = const $1F0 to unsigned short = [+$124] (used reg = )
06932 1BA3           B8                   01F0  mov	ax,#$1F0
06933 1BA6           A3         0124            mov	[$124],ax
06934                                           !BCC_EOS
06935                                           ! 1601   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase2)) = (0x3f0);
06936                                           ! Debug: eq int = const $3F0 to unsigned short = [+$126] (used reg = )
06937 1BA9           B8                   03F0  mov	ax,#$3F0
06938 1BAC           A3         0126            mov	[$126],ax
06939                                           !BCC_EOS
06940                                           ! 1602   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].irq)) = (14);
06941                                           ! Debug: eq int = const $E to unsigned char = [+$128] (used reg = )
06942 1BAF           B0                     0E  mov	al,*$E
06943 1BB1           A2         0128            mov	[$128],al
06944                                           !BCC_EOS
06945                                           ! 1603   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].iface)) = (0x00);
06946                                           ! Debug: eq int = const 0 to unsigned char = [+$12A] (used reg = )
06947 1BB4           30C0                       xor	al,al
06948 1BB6           A2         012A            mov	[$12A],al
06949                                           !BCC_EOS
06950                                           ! 1604   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase1)) = (0x0170);
06951                                           ! Debug: eq int = const $170 to unsigned short = [+$12C] (used reg = )
06952 1BB9           B8                   0170  mov	ax,#$170
06953 1BBC           A3         012C            mov	[$12C],ax
06954                                           !BCC_EOS
06955                                           ! 1605   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase2)) = (0x370);
06956                                           ! Debug: eq int = const $370 to unsigned short = [+$12E] (used reg = )
06957 1BBF           B8                   0370  mov	ax,#$370
06958 1BC2           A3         012E            mov	[$12E],ax
06959                                           !BCC_EOS
06960                                           ! 1606   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].irq)) = (15);
06961                                           ! Debug: eq int = const $F to unsigned char = [+$130] (used reg = )
06962 1BC5           B0                     0F  mov	al,*$F
06963 1BC7           A2         0130            mov	[$130],al
06964                                           !BCC_EOS
06965                                           ! 1607   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].iface)) = (0x00);
06966                                           ! Debug: eq int = const 0 to unsigned char = [+$132] (used reg = )
06967 1BCA           30C0                       xor	al,al
06968 1BCC           A2         0132            mov	[$132],al
06969                                           !BCC_EOS
06970                                           ! 1608   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase1)) = (0x1e8);
06971                                           ! Debug: eq int = const $1E8 to unsigned short = [+$134] (used reg = )
06972 1BCF           B8                   01E8  mov	ax,#$1E8
06973 1BD2           A3         0134            mov	[$134],ax
06974                                           !BCC_EOS
06975                                           ! 1609   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase2)) = (0x3e0);
06976                                           ! Debug: eq int = const $3E0 to unsigned short = [+$136] (used reg = )
06977 1BD5           B8                   03E0  mov	ax,#$3E0
06978 1BD8           A3         0136            mov	[$136],ax
06979                                           !BCC_EOS
06980                                           ! 1610   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].irq)) = (12);
06981                                           ! Debug: eq int = const $C to unsigned char = [+$138] (used reg = )
06982 1BDB           B0                     0C  mov	al,*$C
06983 1BDD           A2         0138            mov	[$138],al
06984                                           !BCC_EOS
06985                                           ! 1611   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].iface)) = (0x00);
06986                                           ! Debug: eq int = const 0 to unsigned char = [+$13A] (used reg = )
06987 1BE0           30C0                       xor	al,al
06988 1BE2           A2         013A            mov	[$13A],al
06989                                           !BCC_EOS
06990                                           ! 1612   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase1)) = (0x168);
06991                                           ! Debug: eq int = const $168 to unsigned short = [+$13C] (used reg = )
06992 1BE5           B8                   0168  mov	ax,#$168
06993 1BE8           A3         013C            mov	[$13C],ax
06994                                           !BCC_EOS
06995                                           ! 1613   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase2)) = (0x360);
06996                                           ! Debug: eq int = const $360 to unsigned short = [+$13E] (used reg = )
06997 1BEB           B8                   0360  mov	ax,#$360
06998 1BEE           A3         013E            mov	[$13E],ax
06999                                           !BCC_EOS
07000                                           ! 1614   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].irq)) = (11);
07001                                           ! Debug: eq int = const $B to unsigned char = [+$140] (used reg = )
07002 1BF1           B0                     0B  mov	al,*$B
07003 1BF3           A2         0140            mov	[$140],al
07004                                           !BCC_EOS
07005                                           ! 1615   hdcount=cdcount=0;
07006                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-4] (used reg = )
07007 1BF6           30C0                       xor	al,al
07008 1BF8           8846         FE            mov	-2[bp],al
07009                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-3] (used reg = )
07010 1BFB           8846         FF            mov	-1[bp],al
07011                                           !BCC_EOS
07012                                           ! 1616   for(device=0; device<(4*2); device++) {
07013                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-5] (used reg = )
07014 1BFE           30C0                       xor	al,al
07015 1C00           8846         FD            mov	-3[bp],al
07016                                           !BCC_EOS
07017                                           !BCC_EOS
07018 1C03           E9         0C10            br 	.1A1
07019                       00001C06            .1A2:
07020                                           ! 1617     Bit16u iobase1, iobase2, blksize;
07021                                           !BCC_EOS
07022                                           ! 1618     Bit8u channel, slave, shift;
07023                                           !BCC_EOS
07024                                           ! 1619     Bit8u sc, sn, cl, ch, st;
07025                                           !BCC_EOS
07026                                           ! 1620     channel = device / 2;
07027 1C06           83C4                   F2  add	sp,*-$E
07028                                           ! Debug: div int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07029 1C09           8A46         FD            mov	al,-3[bp]
07030 1C0C           30E4                       xor	ah,ah
07031 1C0E           D1E8                       shr	ax,*1
07032                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$216-$20F] (used reg = )
07033 1C10           8886       FDF3            mov	-$20D[bp],al
07034                                           !BCC_EOS
07035                                           ! 1621     slave = device % 2;
07036                                           ! Debug: mod int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07037 1C14           8A46         FD            mov	al,-3[bp]
07038 1C17           30E4                       xor	ah,ah
07039 1C19           24                     01  and	al,*1
07040                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$216-$210] (used reg = )
07041 1C1B           8886       FDF2            mov	-$20E[bp],al
07042                                           !BCC_EOS
07043                                           ! 1622     iobase1 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
07044                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07045 1C1F           8A86       FDF3            mov	al,-$20D[bp]
07046 1C23           30E4                       xor	ah,ah
07047 1C25           B1                     03  mov	cl,*3
07048 1C27           D3E0                       shl	ax,cl
07049 1C29           89C3                       mov	bx,ax
07050                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07051                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
07052                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07053 1C2B           8B9F       0124            mov	bx,$124[bx]
07054 1C2F           899E       FDF8            mov	-$208[bp],bx
07055                                           !BCC_EOS
07056                                           ! 1623     iobase2 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
07057                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07058 1C33           8A86       FDF3            mov	al,-$20D[bp]
07059 1C37           30E4                       xor	ah,ah
07060 1C39           B1                     03  mov	cl,*3
07061 1C3B           D3E0                       shl	ax,cl
07062 1C3D           89C3                       mov	bx,ax
07063                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07064                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
07065                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07066 1C3F           8B9F       0126            mov	bx,$126[bx]
07067 1C43           899E       FDF6            mov	-$20A[bp],bx
07068                                           !BCC_EOS
07069                                           ! 1624     outb(iobase2+6, 0x08 | 0x02);
07070                                           ! Debug: list int = const $A (used reg = )
07071 1C47           B8                   000A  mov	ax,*$A
07072 1C4A           50                         push	ax
07073                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$218-$20C] (used reg = )
07074 1C4B           8B86       FDF6            mov	ax,-$20A[bp]
07075                                           ! Debug: list unsigned int = ax+6 (used reg = )
07076 1C4F           05                   0006  add	ax,*6
07077 1C52           50                         push	ax
07078                                           ! Debug: func () void = outb+0 (used reg = )
07079 1C53           E8         E8E9            call	_outb
07080 1C56           83C4                   04  add	sp,*4
07081                                           !BCC_EOS
07082                                           ! 1625     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07083 1C59           8A86       FDF2            mov	al,-$20E[bp]
07084 1C5D           84C0                       test	al,al
07085 1C5F           74           04            je  	.1A3
07086                       00001C61            .1A4:
07087 1C61           B0                     B0  mov	al,#$B0
07088 1C63           EB           02            jmp .1A5
07089                       00001C65            .1A3:
07090 1C65           B0                     A0  mov	al,#$A0
07091                       00001C67            .1A5:
07092                                           ! Debug: list char = al+0 (used reg = )
07093 1C67           30E4                       xor	ah,ah
07094 1C69           50                         push	ax
07095                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07096 1C6A           8B86       FDF8            mov	ax,-$208[bp]
07097                                           ! Debug: list unsigned int = ax+6 (used reg = )
07098 1C6E           05                   0006  add	ax,*6
07099 1C71           50                         push	ax
07100                                           ! Debug: func () void = outb+0 (used reg = )
07101 1C72           E8         E8CA            call	_outb
07102 1C75           83C4                   04  add	sp,*4
07103                                           !BCC_EOS
07104                                           ! 1626     outb(iobase1+2, 0x55);
07105                                           ! Debug: list int = const $55 (used reg = )
07106 1C78           B8                   0055  mov	ax,*$55
07107 1C7B           50                         push	ax
07108                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07109 1C7C           8B86       FDF8            mov	ax,-$208[bp]
07110                                           ! Debug: list unsigned int = ax+2 (used reg = )
07111 1C80           40                         inc	ax
07112 1C81           40                         inc	ax
07113 1C82           50                         push	ax
07114                                           ! Debug: func () void = outb+0 (used reg = )
07115 1C83           E8         E8B9            call	_outb
07116 1C86           83C4                   04  add	sp,*4
07117                                           !BCC_EOS
07118                                           ! 1627     outb(iobase1+3, 0xaa);
07119                                           ! Debug: list int = const $AA (used reg = )
07120 1C89           B8                   00AA  mov	ax,#$AA
07121 1C8C           50                         push	ax
07122                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07123 1C8D           8B86       FDF8            mov	ax,-$208[bp]
07124                                           ! Debug: list unsigned int = ax+3 (used reg = )
07125 1C91           05                   0003  add	ax,*3
07126 1C94           50                         push	ax
07127                                           ! Debug: func () void = outb+0 (used reg = )
07128 1C95           E8         E8A7            call	_outb
07129 1C98           83C4                   04  add	sp,*4
07130                                           !BCC_EOS
07131                                           ! 1628     outb(iobase1+2, 0xaa);
07132                                           ! Debug: list int = const $AA (used reg = )
07133 1C9B           B8                   00AA  mov	ax,#$AA
07134 1C9E           50                         push	ax
07135                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07136 1C9F           8B86       FDF8            mov	ax,-$208[bp]
07137                                           ! Debug: list unsigned int = ax+2 (used reg = )
07138 1CA3           40                         inc	ax
07139 1CA4           40                         inc	ax
07140 1CA5           50                         push	ax
07141                                           ! Debug: func () void = outb+0 (used reg = )
07142 1CA6           E8         E896            call	_outb
07143 1CA9           83C4                   04  add	sp,*4
07144                                           !BCC_EOS
07145                                           ! 1629     outb(iobase1+3, 0x55);
07146                                           ! Debug: list int = const $55 (used reg = )
07147 1CAC           B8                   0055  mov	ax,*$55
07148 1CAF           50                         push	ax
07149                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07150 1CB0           8B86       FDF8            mov	ax,-$208[bp]
07151                                           ! Debug: list unsigned int = ax+3 (used reg = )
07152 1CB4           05                   0003  add	ax,*3
07153 1CB7           50                         push	ax
07154                                           ! Debug: func () void = outb+0 (used reg = )
07155 1CB8           E8         E884            call	_outb
07156 1CBB           83C4                   04  add	sp,*4
07157                                           !BCC_EOS
07158                                           ! 1630     outb(iobase1+2, 0x55);
07159                                           ! Debug: list int = const $55 (used reg = )
07160 1CBE           B8                   0055  mov	ax,*$55
07161 1CC1           50                         push	ax
07162                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07163 1CC2           8B86       FDF8            mov	ax,-$208[bp]
07164                                           ! Debug: list unsigned int = ax+2 (used reg = )
07165 1CC6           40                         inc	ax
07166 1CC7           40                         inc	ax
07167 1CC8           50                         push	ax
07168                                           ! Debug: func () void = outb+0 (used reg = )
07169 1CC9           E8         E873            call	_outb
07170 1CCC           83C4                   04  add	sp,*4
07171                                           !BCC_EOS
07172                                           ! 1631     outb(iobase1+3, 0xaa);
07173                                           ! Debug: list int = const $AA (used reg = )
07174 1CCF           B8                   00AA  mov	ax,#$AA
07175 1CD2           50                         push	ax
07176                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07177 1CD3           8B86       FDF8            mov	ax,-$208[bp]
07178                                           ! Debug: list unsigned int = ax+3 (used reg = )
07179 1CD7           05                   0003  add	ax,*3
07180 1CDA           50                         push	ax
07181                                           ! Debug: func () void = outb+0 (used reg = )
07182 1CDB           E8         E861            call	_outb
07183 1CDE           83C4                   04  add	sp,*4
07184                                           !BCC_EOS
07185                                           ! 1632     sc = inb(iobase1+2);
07186                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07187 1CE1           8B86       FDF8            mov	ax,-$208[bp]
07188                                           ! Debug: list unsigned int = ax+2 (used reg = )
07189 1CE5           40                         inc	ax
07190 1CE6           40                         inc	ax
07191 1CE7           50                         push	ax
07192                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07193 1CE8           E8         E83E            call	_inb
07194 1CEB           44                         inc	sp
07195 1CEC           44                         inc	sp
07196                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07197 1CED           8886       FDF0            mov	-$210[bp],al
07198                                           !BCC_EOS
07199                                           ! 1633     sn = inb(iobase1+3);
07200                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07201 1CF1           8B86       FDF8            mov	ax,-$208[bp]
07202                                           ! Debug: list unsigned int = ax+3 (used reg = )
07203 1CF5           05                   0003  add	ax,*3
07204 1CF8           50                         push	ax
07205                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07206 1CF9           E8         E82D            call	_inb
07207 1CFC           44                         inc	sp
07208 1CFD           44                         inc	sp
07209                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07210 1CFE           8886       FDEF            mov	-$211[bp],al
07211                                           !BCC_EOS
07212                                           ! 1634     if ( (sc == 0x55) && (sn == 0xaa) ) {
07213                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$216-$212] (used reg = )
07214 1D02           8A86       FDF0            mov	al,-$210[bp]
07215 1D06           3C                     55  cmp	al,*$55
07216 1D08         0F85         0120            bne 	.1A6
07217                       00001D0C            .1A8:
07218                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$216-$213] (used reg = )
07219 1D0C           8A86       FDEF            mov	al,-$211[bp]
07220 1D10           3C                     AA  cmp	al,#$AA
07221 1D12         0F85         0116            bne 	.1A6
07222                       00001D16            .1A7:
07223                                           ! 1635       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x01);
07224                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07225 1D16           8A46         FD            mov	al,-3[bp]
07226 1D19           30E4                       xor	ah,ah
07227 1D1B           B9                   001E  mov	cx,*$1E
07228 1D1E           F7E9                       imul	cx
07229 1D20           89C3                       mov	bx,ax
07230                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07231                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07232                                           ! Debug: eq int = const 1 to unsigned char = [bx+$142] (used reg = )
07233 1D22           B0                     01  mov	al,*1
07234 1D24           8887       0142            mov	$142[bx],al
07235                                           !BCC_EOS
07236                                           ! 1636       ata_reset(device);
07237                                           ! Debug: list unsigned char device = [S+$216-5] (used reg = )
07238 1D28           8A46         FD            mov	al,-3[bp]
07239 1D2B           30E4                       xor	ah,ah
07240 1D2D           50                         push	ax
07241                                           ! Debug: func () void = ata_reset+0 (used reg = )
07242 1D2E           E8         0B29            call	_ata_reset
07243 1D31           44                         inc	sp
07244 1D32           44                         inc	sp
07245                                           !BCC_EOS
07246                                           ! 1637       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07247 1D33           8A86       FDF2            mov	al,-$20E[bp]
07248 1D37           84C0                       test	al,al
07249 1D39           74           04            je  	.1A9
07250                       00001D3B            .1AA:
07251 1D3B           B0                     B0  mov	al,#$B0
07252 1D3D           EB           02            jmp .1AB
07253                       00001D3F            .1A9:
07254 1D3F           B0                     A0  mov	al,#$A0
07255                       00001D41            .1AB:
07256                                           ! Debug: list char = al+0 (used reg = )
07257 1D41           30E4                       xor	ah,ah
07258 1D43           50                         push	ax
07259                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07260 1D44           8B86       FDF8            mov	ax,-$208[bp]
07261                                           ! Debug: list unsigned int = ax+6 (used reg = )
07262 1D48           05                   0006  add	ax,*6
07263 1D4B           50                         push	ax
07264                                           ! Debug: func () void = outb+0 (used reg = )
07265 1D4C           E8         E7F0            call	_outb
07266 1D4F           83C4                   04  add	sp,*4
07267                                           !BCC_EOS
07268                                           ! 1638       sc = inb(iobase1+2);
07269                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07270 1D52           8B86       FDF8            mov	ax,-$208[bp]
07271                                           ! Debug: list unsigned int = ax+2 (used reg = )
07272 1D56           40                         inc	ax
07273 1D57           40                         inc	ax
07274 1D58           50                         push	ax
07275                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07276 1D59           E8         E7CD            call	_inb
07277 1D5C           44                         inc	sp
07278 1D5D           44                         inc	sp
07279                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07280 1D5E           8886       FDF0            mov	-$210[bp],al
07281                                           !BCC_EOS
07282                                           ! 1639       sn = inb(io
07283                                           ! 1639 base1+3);
07284                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07285 1D62           8B86       FDF8            mov	ax,-$208[bp]
07286                                           ! Debug: list unsigned int = ax+3 (used reg = )
07287 1D66           05                   0003  add	ax,*3
07288 1D69           50                         push	ax
07289                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07290 1D6A           E8         E7BC            call	_inb
07291 1D6D           44                         inc	sp
07292 1D6E           44                         inc	sp
07293                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07294 1D6F           8886       FDEF            mov	-$211[bp],al
07295                                           !BCC_EOS
07296                                           ! 1640       if ((sc==0x01) && (sn==0x01)) {
07297                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$216-$212] (used reg = )
07298 1D73           8A86       FDF0            mov	al,-$210[bp]
07299 1D77           3C                     01  cmp	al,*1
07300 1D79         0F85         00AF            bne 	.1AC
07301                       00001D7D            .1AE:
07302                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$216-$213] (used reg = )
07303 1D7D           8A86       FDEF            mov	al,-$211[bp]
07304 1D81           3C                     01  cmp	al,*1
07305 1D83         0F85         00A5            bne 	.1AC
07306                       00001D87            .1AD:
07307                                           ! 1641         cl = inb(iobase1+4);
07308                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07309 1D87           8B86       FDF8            mov	ax,-$208[bp]
07310                                           ! Debug: list unsigned int = ax+4 (used reg = )
07311 1D8B           05                   0004  add	ax,*4
07312 1D8E           50                         push	ax
07313                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07314 1D8F           E8         E797            call	_inb
07315 1D92           44                         inc	sp
07316 1D93           44                         inc	sp
07317                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$216-$214] (used reg = )
07318 1D94           8886       FDEE            mov	-$212[bp],al
07319                                           !BCC_EOS
07320                                           ! 1642         ch = inb(iobase1+5);
07321                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07322 1D98           8B86       FDF8            mov	ax,-$208[bp]
07323                                           ! Debug: list unsigned int = ax+5 (used reg = )
07324 1D9C           05                   0005  add	ax,*5
07325 1D9F           50                         push	ax
07326                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07327 1DA0           E8         E786            call	_inb
07328 1DA3           44                         inc	sp
07329 1DA4           44                         inc	sp
07330                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$216-$215] (used reg = )
07331 1DA5           8886       FDED            mov	-$213[bp],al
07332                                           !BCC_EOS
07333                                           ! 1643         st = inb(iobase1+7);
07334                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07335 1DA9           8B86       FDF8            mov	ax,-$208[bp]
07336                                           ! Debug: list unsigned int = ax+7 (used reg = )
07337 1DAD           05                   0007  add	ax,*7
07338 1DB0           50                         push	ax
07339                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07340 1DB1           E8         E775            call	_inb
07341 1DB4           44                         inc	sp
07342 1DB5           44                         inc	sp
07343                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$216-$216] (used reg = )
07344 1DB6           8886       FDEC            mov	-$214[bp],al
07345                                           !BCC_EOS
07346                                           ! 1644         if ((cl==0x14) && (ch==0xeb)) {
07347                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$216-$214] (used reg = )
07348 1DBA           8A86       FDEE            mov	al,-$212[bp]
07349 1DBE           3C                     14  cmp	al,*$14
07350 1DC0           75           1C            jne 	.1AF
07351                       00001DC2            .1B1:
07352                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$216-$215] (used reg = )
07353 1DC2           8A86       FDED            mov	al,-$213[bp]
07354 1DC6           3C                     EB  cmp	al,#$EB
07355 1DC8           75           14            jne 	.1AF
07356                       00001DCA            .1B0:
07357                                           ! 1645           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x03);
07358                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07359 1DCA           8A46         FD            mov	al,-3[bp]
07360 1DCD           30E4                       xor	ah,ah
07361 1DCF           B9                   001E  mov	cx,*$1E
07362 1DD2           F7E9                       imul	cx
07363 1DD4           89C3                       mov	bx,ax
07364                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07365                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07366                                           ! Debug: eq int = const 3 to unsigned char = [bx+$142] (used reg = )
07367 1DD6           B0                     03  mov	al,*3
07368 1DD8           8887       0142            mov	$142[bx],al
07369                                           !BCC_EOS
07370                                           ! 1646         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07371 1DDC           EB           4E            jmp .1B2
07372                       00001DDE            .1AF:
07373                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$216-$214] (used reg = )
07374 1DDE           8A86       FDEE            mov	al,-$212[bp]
07375 1DE2           84C0                       test	al,al
07376 1DE4           75           24            jne 	.1B3
07377                       00001DE6            .1B6:
07378                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$216-$215] (used reg = )
07379 1DE6           8A86       FDED            mov	al,-$213[bp]
07380 1DEA           84C0                       test	al,al
07381 1DEC           75           1C            jne 	.1B3
07382                       00001DEE            .1B5:
07383                                           ! Debug: ne int = const 0 to unsigned char st = [S+$216-$216] (used reg = )
07384 1DEE           8A86       FDEC            mov	al,-$214[bp]
07385 1DF2           84C0                       test	al,al
07386 1DF4           74           14            je  	.1B3
07387                       00001DF6            .1B4:
07388                                           ! 1647           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x02);
07389                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07390 1DF6           8A46         FD            mov	al,-3[bp]
07391 1DF9           30E4                       xor	ah,ah
07392 1DFB           B9                   001E  mov	cx,*$1E
07393 1DFE           F7E9                       imul	cx
07394 1E00           89C3                       mov	bx,ax
07395                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07396                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07397                                           ! Debug: eq int = const 2 to unsigned char = [bx+$142] (used reg = )
07398 1E02           B0                     02  mov	al,*2
07399 1E04           8887       0142            mov	$142[bx],al
07400                                           !BCC_EOS
07401                                           ! 1648         } else if ((cl==0xff) && (ch==0xff)) {
07402 1E08           EB           22            jmp .1B7
07403                       00001E0A            .1B3:
07404                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$216-$214] (used reg = )
07405 1E0A           8A86       FDEE            mov	al,-$212[bp]
07406 1E0E           3C                     FF  cmp	al,#$FF
07407 1E10           75           1A            jne 	.1B8
07408                       00001E12            .1BA:
07409                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$216-$215] (used reg = )
07410 1E12           8A86       FDED            mov	al,-$213[bp]
07411 1E16           3C                     FF  cmp	al,#$FF
07412 1E18           75           12            jne 	.1B8
07413                       00001E1A            .1B9:
07414                                           ! 1649           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
07415                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07416 1E1A           8A46         FD            mov	al,-3[bp]
07417 1E1D           30E4                       xor	ah,ah
07418 1E1F           B9                   001E  mov	cx,*$1E
07419 1E22           F7E9                       imul	cx
07420 1E24           89C3                       mov	bx,ax
07421                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07422                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07423                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
07424 1E26           30C0                       xor	al,al
07425 1E28           8887       0142            mov	$142[bx],al
07426                                           !BCC_EOS
07427                                           ! 1650         }
07428                                           ! 1651       }
07429                       00001E2C            .1B8:
07430                       00001E2C            .1B7:
07431                       00001E2C            .1B2:
07432                                           ! 1652     }
07433                       00001E2C            .1AC:
07434                                           ! 1653     type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
07435                       00001E2C            .1A6:
07436                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07437 1E2C           8A46         FD            mov	al,-3[bp]
07438 1E2F           30E4                       xor	ah,ah
07439 1E31           B9                   001E  mov	cx,*$1E
07440 1E34           F7E9                       imul	cx
07441 1E36           89C3                       mov	bx,ax
07442                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07443                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07444                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$216-6] (used reg = )
07445 1E38           8A87       0142            mov	al,$142[bx]
07446 1E3C           8846         FC            mov	-4[bp],al
07447                                           !BCC_EOS
07448                                           ! 1654     if(type == 0x02) {
07449                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$216-6] (used reg = )
07450 1E3F           8A46         FC            mov	al,-4[bp]
07451 1E42           3C                     02  cmp	al,*2
07452 1E44         0F85         04CD            bne 	.1BB
07453                       00001E48            .1BC:
07454                                           ! 1655       Bit32u sectors_low, sectors_high;
07455                                           !BCC_EOS
07456                                           ! 1656       Bit16u cylinders, heads, spt;
07457                                           !BCC_EOS
07458                                           ! 1657       Bit8u translation, removable, mode;
07459                                           !BCC_EOS
07460                                           ! 1658       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07461 1E48           83C4                   EE  add	sp,*-$12
07462                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07463 1E4B           8A46         FD            mov	al,-3[bp]
07464 1E4E           30E4                       xor	ah,ah
07465 1E50           B9                   001E  mov	cx,*$1E
07466 1E53           F7E9                       imul	cx
07467 1E55           89C3                       mov	bx,ax
07468                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07469                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07470                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07471 1E57           B0                     FF  mov	al,#$FF
07472 1E59           8887       0143            mov	$143[bx],al
07473                                           !BCC_EOS
07474                                           ! 1659       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
07475                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07476 1E5D           8A46         FD            mov	al,-3[bp]
07477 1E60           30E4                       xor	ah,ah
07478 1E62           B9                   001E  mov	cx,*$1E
07479 1E65           F7E9                       imul	cx
07480 1E67           89C3                       mov	bx,ax
07481                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07483                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
07484 1E69           30C0                       xor	al,al
07485 1E6B           8887       0146            mov	$146[bx],al
07486                                           !BCC_EOS
07487                                           ! 1660       if (ata_cmd_data_io(0, device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07488                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07489 1E6F           8D9E       FDFC            lea	bx,-$204[bp]
07490 1E73           53                         push	bx
07491                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07492 1E74           E8         E7E3            call	_get_SS
07493                                           ! Debug: list unsigned short = ax+0 (used reg = )
07494 1E77           50                         push	ax
07495                                           ! Debug: list long = const 0 (used reg = )
07496 1E78           31C0                       xor	ax,ax
07497 1E7A           31DB                       xor	bx,bx
07498 1E7C           53                         push	bx
07499 1E7D           50                         push	ax
07500                                           ! Debug: list long = const 0 (used reg = )
07501 1E7E           31C0                       xor	ax,ax
07502 1E80           31DB                       xor	bx,bx
07503 1E82           53                         push	bx
07504 1E83           50                         push	ax
07505                                           ! Debug: list int = const 0 (used reg = )
07506 1E84           31C0                       xor	ax,ax
07507 1E86           50                         push	ax
07508                                           ! Debug: list int = const 0 (used reg = )
07509 1E87           31C0                       xor	ax,ax
07510 1E89           50                         push	ax
07511                                           ! Debug: list int = const 0 (used reg = )
07512 1E8A           31C0                       xor	ax,ax
07513 1E8C           50                         push	ax
07514                                           ! Debug: list int = const 1 (used reg = )
07515 1E8D           B8                   0001  mov	ax,*1
07516 1E90           50                         push	ax
07517                                           ! Debug: list int = const $EC (used reg = )
07518 1E91           B8                   00EC  mov	ax,#$EC
07519 1E94           50                         push	ax
07520                                           ! Debug: list unsigned char device = [S+$23E-5] (used reg = )
07521 1E95           8A46         FD            mov	al,-3[bp]
07522 1E98           30E4                       xor	ah,ah
07523 1E9A           50                         push	ax
07524                                           ! Debug: list int = const 0 (used reg = )
07525 1E9B           31C0                       xor	ax,ax
07526 1E9D           50                         push	ax
07527                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
07528 1E9E           E8         0AE0            call	_ata_cmd_data_io
07529 1EA1           83C4                   1A  add	sp,*$1A
07530                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07531 1EA4           85C0                       test	ax,ax
07532 1EA6           74           0E            je  	.1BD
07533                       00001EA8            .1BE:
07534                                           ! 1661         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07535                                           ! Debug: list * char = .1BF+0 (used reg = )
07536 1EA8           BB                   D7C0  mov	bx,#.1BF
07537 1EAB           53                         push	bx
07538                                           ! Debug: list int = const 7 (used reg = )
07539 1EAC           B8                   0007  mov	ax,*7
07540 1EAF           50                         push	ax
07541                                           ! Debug: func () void = bios_printf+0 (used reg = )
07542 1EB0           E8         EA86            call	_bios_printf
07543 1EB3           83C4                   04  add	sp,*4
07544                                           !BCC_EOS
07545                                           ! 1662       removable = (read_byte_SS(buffer+0) & 0x80) >> 7;
07546                       00001EB6            .1BD:
07547                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07548 1EB6           8D9E       FDFC            lea	bx,-$204[bp]
07549 1EBA           53                         push	bx
07550                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07551 1EBB           E8         E763            call	_read_byte_SS
07552 1EBE           44                         inc	sp
07553 1EBF           44                         inc	sp
07554                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07555 1EC0           24                     80  and	al,#$80
07556                                           ! Debug: sr int = const 7 to unsigned char = al+0 (used reg = )
07557 1EC2           30E4                       xor	ah,ah
07558 1EC4           B1                     07  mov	cl,*7
07559 1EC6           D3E8                       shr	ax,cl
07560                                           ! Debug: eq unsigned int = ax+0 to unsigned char removable = [S+$228-$226] (used reg = )
07561 1EC8           8886       FDDC            mov	-$224[bp],al
07562                                           !BCC_EOS
07563                                           ! 1663       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
07564                                           ! Debug: list * unsigned char buffer = S+$228-$1A6 (used reg = )
07565 1ECC           8D9E       FE5C            lea	bx,-$1A4[bp]
07566 1ED0           53                         push	bx
07567                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07568 1ED1           E8         E74D            call	_read_byte_SS
07569 1ED4           44                         inc	sp
07570 1ED5           44                         inc	sp
07571 1ED6           84C0                       test	al,al
07572 1ED8           74           04            je  	.1C0
07573                       00001EDA            .1C1:
07574 1EDA           B0                     01  mov	al,*1
07575 1EDC           EB           02            jmp .1C2
07576                       00001EDE            .1C0:
07577 1EDE           30C0                       xor	al,al
07578                       00001EE0            .1C2:
07579                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07580 1EE0           8886       FDDB            mov	-$225[bp],al
07581                                           !BCC_EOS
07582                                           ! 1664       blksize = read_word_SS(buffer+10);
07583                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
07584 1EE4           8D9E       FE06            lea	bx,-$1FA[bp]
07585 1EE8           53                         push	bx
07586                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07587 1EE9           E8         E740            call	_read_word_SS
07588 1EEC           44                         inc	sp
07589 1EED           44                         inc	sp
07590                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$20E] (used reg = )
07591 1EEE           8986       FDF4            mov	-$20C[bp],ax
07592                                           !BCC_EOS
07593                                           ! 1665       cylinders = read_word_SS(buffer+(1*2));
07594                                           ! Debug: list * unsigned char buffer = S+$228-$204 (used reg = )
07595 1EF2           8D9E       FDFE            lea	bx,-$202[bp]
07596 1EF6           53                         push	bx
07597                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07598 1EF7           E8         E732            call	_read_word_SS
07599 1EFA           44                         inc	sp
07600 1EFB           44                         inc	sp
07601                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
07602 1EFC           8986       FDE2            mov	-$21E[bp],ax
07603                                           !BCC_EOS
07604                                           ! 1666       heads = read_word_SS(buffer+(3*2));
07605                                           ! Debug: list * unsigned char buffer = S+$228-$200 (used reg = )
07606 1F00           8D9E       FE02            lea	bx,-$1FE[bp]
07607 1F04           53                         push	bx
07608                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07609 1F05           E8         E724            call	_read_word_SS
07610 1F08           44                         inc	sp
07611 1F09           44                         inc	sp
07612                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$222] (used reg = )
07613 1F0A           8986       FDE0            mov	-$220[bp],ax
07614                                           !BCC_EOS
07615                                           ! 1667       spt = read_word_SS(buffer+(6*2));
07616                                           ! Debug: list * unsigned char buffer = S+$228-$1FA (used reg = )
07617 1F0E           8D9E       FE08            lea	bx,-$1F8[bp]
07618 1F12           53                         push	bx
07619                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07620 1F13           E8         E716            call	_read_word_SS
07621 1F16           44                         inc	sp
07622 1F17           44                         inc	sp
07623                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$224] (used reg = )
07624 1F18           8986       FDDE            mov	-$222[bp],ax
07625                                           !BCC_EOS
07626                                           ! 1668       if (read_word_SS(buffer+(83*2)) & (1 << 10)) {
07627                                           ! Debug: list * unsigned char buffer = S+$228-$160 (used reg = )
07628 1F1C           8D9E       FEA2            lea	bx,-$15E[bp]
07629 1F20           53                         push	bx
07630                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07631 1F21           E8         E708            call	_read_word_SS
07632 1F24           44                         inc	sp
07633 1F25           44                         inc	sp
07634                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
07635 1F26           25                   0400  and	ax,#$400
07636 1F29           85C0                       test	ax,ax
07637 1F2B           74           2A            je  	.1C3
07638                       00001F2D            .1C4:
07639                                           ! 1669         sectors_low = read_dword_SS(buffer+(100*2));
07640                                           ! Debug: list * unsigned char buffer = S+$228-$13E (used reg = )
07641 1F2D           8D9E       FEC4            lea	bx,-$13C[bp]
07642 1F31           53                         push	bx
07643                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07644 1F32           E8         E149            call	_read_dword_SS
07645 1F35           89D3                       mov	bx,dx
07646 1F37           44                         inc	sp
07647 1F38           44                         inc	sp
07648                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07649 1F39           8986       FDE8            mov	-$218[bp],ax
07650 1F3D           899E       FDEA            mov	-$216[bp],bx
07651                                           !BCC_EOS
07652                                           ! 1670         sectors_high = read_dword_SS(buffer+(102*2));
07653                                           ! Debug: list * unsigned char buffer = S+$228-$13A (used reg = )
07654 1F41           8D9E       FEC8            lea	bx,-$138[bp]
07655 1F45           53                         push	bx
07656                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07657 1F46           E8         E135            call	_read_dword_SS
07658 1F49           89D3                       mov	bx,dx
07659 1F4B           44                         inc	sp
07660 1F4C           44                         inc	sp
07661                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07662 1F4D           8986       FDE4            mov	-$21C[bp],ax
07663 1F51           899E       FDE6            mov	-$21A[bp],bx
07664                                           !BCC_EOS
07665                                           ! 1671       } else {
07666 1F55           EB           20            jmp .1C5
07667                       00001F57            .1C3:
07668                                           ! 1672         sectors_low = read_dword_SS(buffer+(60*2));
07669                                           ! Debug: list * unsigned char buffer = S+$228-$18E (used reg = )
07670 1F57           8D9E       FE74            lea	bx,-$18C[bp]
07671 1F5B           53                         push	bx
07672                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07673 1F5C           E8         E11F            call	_read_dword_SS
07674 1F5F           89D3                       mov	bx,dx
07675 1F61           44                         inc	sp
07676 1F62           44                         inc	sp
07677                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07678 1F63           8986       FDE8            mov	-$218[bp],ax
07679 1F67           899E       FDEA            mov	-$216[bp],bx
07680                                           !BCC_EOS
07681                                           ! 1673         sectors_high = 0;
07682                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07683 1F6B           31C0                       xor	ax,ax
07684 1F6D           31DB                       xor	bx,bx
07685 1F6F           8986       FDE4            mov	-$21C[bp],ax
07686 1F73           899E       FDE6            mov	-$21A[bp],bx
07687                                           !BCC_EOS
07688                                           ! 1674       }
07689                                           ! 1675       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07690                       00001F77            .1C5:
07691                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07692 1F77           8A46         FD            mov	al,-3[bp]
07693 1F7A           30E4                       xor	ah,ah
07694 1F7C           B9                   001E  mov	cx,*$1E
07695 1F7F           F7E9                       imul	cx
07696 1F81           89C3                       mov	bx,ax
07697                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07698                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07699                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07700 1F83           B0                     FF  mov	al,#$FF
07701 1F85           8887       0143            mov	$143[bx],al
07702                                           !BCC_EOS
07703                                           ! 1676       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
07704                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07705 1F89           8A46         FD            mov	al,-3[bp]
07706 1F8C           30E4                       xor	ah,ah
07707 1F8E           B9                   001E  mov	cx,*$1E
07708 1F91           F7E9                       imul	cx
07709 1F93           89C3                       mov	bx,ax
07710                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
07711                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
07712                                           ! Debug: eq unsigned char removable = [S+$228-$226] to unsigned char = [bx+$144] (used reg = )
07713 1F95           8A86       FDDC            mov	al,-$224[bp]
07714 1F99           8887       0144            mov	$144[bx],al
07715                                           !BCC_EOS
07716                                           ! 1677       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
07717                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07718 1F9D           8A46         FD            mov	al,-3[bp]
07719 1FA0           30E4                       xor	ah,ah
07720 1FA2           B9                   001E  mov	cx,*$1E
07721 1FA5           F7E9                       imul	cx
07722 1FA7           89C3                       mov	bx,ax
07723                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07724                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07725                                           ! Debug: eq unsigned char mode = [S+$228-$227] to unsigned char = [bx+$146] (used reg = )
07726 1FA9           8A86       FDDB            mov	al,-$225[bp]
07727 1FAD           8887       0146            mov	$146[bx],al
07728                                           !BCC_EOS
07729                                           ! 1678       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
07730                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07731 1FB1           8A46         FD            mov	al,-3[bp]
07732 1FB4           30E4                       xor	ah,ah
07733 1FB6           B9                   001E  mov	cx,*$1E
07734 1FB9           F7E9                       imul	cx
07735 1FBB           89C3                       mov	bx,ax
07736                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
07737                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
07738                                           ! Debug: eq unsigned short blksize = [S+$228-$20E] to unsigned short = [bx+$148] (used reg = )
07739 1FBD           8B86       FDF4            mov	ax,-$20C[bp]
07740 1FC1           8987       0148            mov	$148[bx],ax
07741                                           !BCC_EOS
07742                                           ! 1679       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (heads);
07743                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07744 1FC5           8A46         FD            mov	al,-3[bp]
07745 1FC8           30E4                       xor	ah,ah
07746 1FCA           B9                   001E  mov	cx,*$1E
07747 1FCD           F7E9                       imul	cx
07748 1FCF           89C3                       mov	bx,ax
07749                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
07750                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
07751                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$152] (used reg = )
07752 1FD1           8B86       FDE0            mov	ax,-$220[bp]
07753 1FD5           8987       0152            mov	$152[bx],ax
07754                                           !BCC_EOS
07755                                           ! 1680       *((Bit16u 
07756                                           ! 1680 *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (cylinders);
07757                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07758 1FD9           8A46         FD            mov	al,-3[bp]
07759 1FDC           30E4                       xor	ah,ah
07760 1FDE           B9                   001E  mov	cx,*$1E
07761 1FE1           F7E9                       imul	cx
07762 1FE3           89C3                       mov	bx,ax
07763                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
07764                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
07765                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$154] (used reg = )
07766 1FE5           8B86       FDE2            mov	ax,-$21E[bp]
07767 1FE9           8987       0154            mov	$154[bx],ax
07768                                           !BCC_EOS
07769                                           ! 1681       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (spt);
07770                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07771 1FED           8A46         FD            mov	al,-3[bp]
07772 1FF0           30E4                       xor	ah,ah
07773 1FF2           B9                   001E  mov	cx,*$1E
07774 1FF5           F7E9                       imul	cx
07775 1FF7           89C3                       mov	bx,ax
07776                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
07777                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
07778                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$156] (used reg = )
07779 1FF9           8B86       FDDE            mov	ax,-$222[bp]
07780 1FFD           8987       0156            mov	$156[bx],ax
07781                                           !BCC_EOS
07782                                           ! 1682       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (sectors_low);
07783                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07784 2001           8A46         FD            mov	al,-3[bp]
07785 2004           30E4                       xor	ah,ah
07786 2006           B9                   001E  mov	cx,*$1E
07787 2009           F7E9                       imul	cx
07788 200B           89C3                       mov	bx,ax
07789                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
07790                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
07791                                           ! Debug: eq unsigned long sectors_low = [S+$228-$21A] to unsigned long = [bx+$158] (used reg = )
07792 200D           8B86       FDE8            mov	ax,-$218[bp]
07793 2011           8BB6       FDEA            mov	si,-$216[bp]
07794 2015           8987       0158            mov	$158[bx],ax
07795 2019           89B7       015A            mov	$15A[bx],si
07796                                           !BCC_EOS
07797                                           ! 1683       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (sectors_high);
07798                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07799 201D           8A46         FD            mov	al,-3[bp]
07800 2020           30E4                       xor	ah,ah
07801 2022           B9                   001E  mov	cx,*$1E
07802 2025           F7E9                       imul	cx
07803 2027           89C3                       mov	bx,ax
07804                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
07805                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
07806                                           ! Debug: eq unsigned long sectors_high = [S+$228-$21E] to unsigned long = [bx+$15C] (used reg = )
07807 2029           8B86       FDE4            mov	ax,-$21C[bp]
07808 202D           8BB6       FDE6            mov	si,-$21A[bp]
07809 2031           8987       015C            mov	$15C[bx],ax
07810 2035           89B7       015E            mov	$15E[bx],si
07811                                           !BCC_EOS
07812                                           ! 1684       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
07813                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
07814 2039           FFB6       FDDE            push	-$222[bp]
07815                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
07816 203D           FFB6       FDE0            push	-$220[bp]
07817                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
07818 2041           FFB6       FDE2            push	-$21E[bp]
07819                                           ! Debug: list unsigned char slave = [S+$22E-$210] (used reg = )
07820 2045           8A86       FDF2            mov	al,-$20E[bp]
07821 2049           30E4                       xor	ah,ah
07822 204B           50                         push	ax
07823                                           ! Debug: list unsigned char channel = [S+$230-$20F] (used reg = )
07824 204C           8A86       FDF3            mov	al,-$20D[bp]
07825 2050           30E4                       xor	ah,ah
07826 2052           50                         push	ax
07827                                           ! Debug: list * char = .1C6+0 (used reg = )
07828 2053           BB                   D79B  mov	bx,#.1C6
07829 2056           53                         push	bx
07830                                           ! Debug: list int = const 4 (used reg = )
07831 2057           B8                   0004  mov	ax,*4
07832 205A           50                         push	ax
07833                                           ! Debug: func () void = bios_printf+0 (used reg = )
07834 205B           E8         E8DB            call	_bios_printf
07835 205E           83C4                   0E  add	sp,*$E
07836                                           !BCC_EOS
07837                                           ! 1685       translation = inb_cmos(0x39 + channel/2);
07838                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20F] (used reg = )
07839 2061           8A86       FDF3            mov	al,-$20D[bp]
07840 2065           30E4                       xor	ah,ah
07841 2067           D1E8                       shr	ax,*1
07842                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
07843                                           ! Debug: expression subtree swapping
07844                                           ! Debug: list unsigned int = ax+$39 (used reg = )
07845 2069           05                   0039  add	ax,*$39
07846 206C           50                         push	ax
07847                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
07848 206D           E8         E4FE            call	_inb_cmos
07849 2070           44                         inc	sp
07850 2071           44                         inc	sp
07851                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
07852 2072           8886       FDDD            mov	-$223[bp],al
07853                                           !BCC_EOS
07854                                           ! 1686       for (shift=device%4; shift>0; shift--) translation >>= 2;
07855                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-5] (used reg = )
07856 2076           8A46         FD            mov	al,-3[bp]
07857 2079           30E4                       xor	ah,ah
07858 207B           24                     03  and	al,*3
07859                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$211] (used reg = )
07860 207D           8886       FDF1            mov	-$20F[bp],al
07861                                           !BCC_EOS
07862                                           !BCC_EOS
07863 2081           E9         0017            br 	.1C9
07864                       00002084            .1CA:
07865                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
07866 2084           8A86       FDDD            mov	al,-$223[bp]
07867 2088           30E4                       xor	ah,ah
07868 208A           D1E8                       shr	ax,*1
07869 208C           D1E8                       shr	ax,*1
07870 208E           8886       FDDD            mov	-$223[bp],al
07871                                           !BCC_EOS
07872                                           ! 1687       translation &= 0x03;
07873                       00002092            .1C8:
07874                                           ! Debug: postdec unsigned char shift = [S+$228-$211] (used reg = )
07875 2092           8A86       FDF1            mov	al,-$20F[bp]
07876 2096           48                         dec	ax
07877 2097           8886       FDF1            mov	-$20F[bp],al
07878                       0000209B            .1C9:
07879                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$211] (used reg = )
07880 209B           8A86       FDF1            mov	al,-$20F[bp]
07881 209F           84C0                       test	al,al
07882 20A1           75           E1            jne	.1CA
07883                       000020A3            .1CB:
07884                       000020A3            .1C7:
07885                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
07886 20A3           8A86       FDDD            mov	al,-$223[bp]
07887 20A7           24                     03  and	al,*3
07888 20A9           8886       FDDD            mov	-$223[bp],al
07889                                           !BCC_EOS
07890                                           ! 1688       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (translation);
07891                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07892 20AD           8A46         FD            mov	al,-3[bp]
07893 20B0           30E4                       xor	ah,ah
07894 20B2           B9                   001E  mov	cx,*$1E
07895 20B5           F7E9                       imul	cx
07896 20B7           89C3                       mov	bx,ax
07897                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
07898                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
07899                                           ! Debug: eq unsigned char translation = [S+$228-$225] to unsigned char = [bx+$14A] (used reg = )
07900 20B9           8A86       FDDD            mov	al,-$223[bp]
07901 20BD           8887       014A            mov	$14A[bx],al
07902                                           !BCC_EOS
07903                                           ! 1689       switch (translation) {
07904 20C1           8A86       FDDD            mov	al,-$223[bp]
07905 20C5           EB           42            jmp .1CE
07906                                           ! 1690         case 0:
07907                                           ! 1691           bios_printf(4, "none");
07908                       000020C7            .1CF:
07909                                           ! Debug: list * char = .1D0+0 (used reg = )
07910 20C7           BB                   D796  mov	bx,#.1D0
07911 20CA           53                         push	bx
07912                                           ! Debug: list int = const 4 (used reg = )
07913 20CB           B8                   0004  mov	ax,*4
07914 20CE           50                         push	ax
07915                                           ! Debug: func () void = bios_printf+0 (used reg = )
07916 20CF           E8         E867            call	_bios_printf
07917 20D2           83C4                   04  add	sp,*4
07918                                           !BCC_EOS
07919                                           ! 1692           break;
07920 20D5           EB           42            jmp .1CC
07921                                           !BCC_EOS
07922                                           ! 1693         case 1:
07923                                           ! 1694           bios_printf(4, "lba");
07924                       000020D7            .1D1:
07925                                           ! Debug: list * char = .1D2+0 (used reg = )
07926 20D7           BB                   D792  mov	bx,#.1D2
07927 20DA           53                         push	bx
07928                                           ! Debug: list int = const 4 (used reg = )
07929 20DB           B8                   0004  mov	ax,*4
07930 20DE           50                         push	ax
07931                                           ! Debug: func () void = bios_printf+0 (used reg = )
07932 20DF           E8         E857            call	_bios_printf
07933 20E2           83C4                   04  add	sp,*4
07934                                           !BCC_EOS
07935                                           ! 1695           break;
07936 20E5           EB           32            jmp .1CC
07937                                           !BCC_EOS
07938                                           ! 1696         case 2:
07939                                           ! 1697           bios_printf(4, "large");
07940                       000020E7            .1D3:
07941                                           ! Debug: list * char = .1D4+0 (used reg = )
07942 20E7           BB                   D78C  mov	bx,#.1D4
07943 20EA           53                         push	bx
07944                                           ! Debug: list int = const 4 (used reg = )
07945 20EB           B8                   0004  mov	ax,*4
07946 20EE           50                         push	ax
07947                                           ! Debug: func () void = bios_printf+0 (used reg = )
07948 20EF           E8         E847            call	_bios_printf
07949 20F2           83C4                   04  add	sp,*4
07950                                           !BCC_EOS
07951                                           ! 1698           break;
07952 20F5           EB           22            jmp .1CC
07953                                           !BCC_EOS
07954                                           ! 1699         case 3:
07955                                           ! 1700           bios_printf(4, "r-echs");
07956                       000020F7            .1D5:
07957                                           ! Debug: list * char = .1D6+0 (used reg = )
07958 20F7           BB                   D785  mov	bx,#.1D6
07959 20FA           53                         push	bx
07960                                           ! Debug: list int = const 4 (used reg = )
07961 20FB           B8                   0004  mov	ax,*4
07962 20FE           50                         push	ax
07963                                           ! Debug: func () void = bios_printf+0 (used reg = )
07964 20FF           E8         E837            call	_bios_printf
07965 2102           83C4                   04  add	sp,*4
07966                                           !BCC_EOS
07967                                           ! 1701           break;
07968 2105           EB           12            jmp .1CC
07969                                           !BCC_EOS
07970                                           ! 1702       }
07971                                           ! 1703       switch (translation) {
07972 2107           EB           10            jmp .1CC
07973                       00002109            .1CE:
07974 2109           2C                     00  sub	al,*0
07975 210B           74           BA            je 	.1CF
07976 210D           2C                     01  sub	al,*1
07977 210F           74           C6            je 	.1D1
07978 2111           2C                     01  sub	al,*1
07979 2113           74           D2            je 	.1D3
07980 2115           2C                     01  sub	al,*1
07981 2117           74           DE            je 	.1D5
07982                       00002119            .1CC:
07983                       FFFFFDD8            ..FFFE	=	-$228
07984 2119           8A86       FDDD            mov	al,-$223[bp]
07985 211D           E9         0161            br 	.1D9
07986                                           ! 1704         case 0:
07987                                           ! 1705           break;
07988                       00002120            .1DA:
07989 2120           E9         0174            br 	.1D7
07990                                           !BCC_EOS
07991                                           ! 1706         case 1:
07992                                           ! 1707           spt = 63;
07993                       00002123            .1DB:
07994                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$224] (used reg = )
07995 2123           B8                   003F  mov	ax,*$3F
07996 2126           8986       FDDE            mov	-$222[bp],ax
07997                                           !BCC_EOS
07998                                           ! 1708           sectors_low /= 63;
07999                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08000 212A           B8                   003F  mov	ax,*$3F
08001 212D           31DB                       xor	bx,bx
08002 212F           53                         push	bx
08003 2130           50                         push	ax
08004 2131           8B86       FDE8            mov	ax,-$218[bp]
08005 2135           8B9E       FDEA            mov	bx,-$216[bp]
08006 2139           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08007 213D           E8         DFFF            call	ldivul
08008 2140           8986       FDE8            mov	-$218[bp],ax
08009 2144           899E       FDEA            mov	-$216[bp],bx
08010 2148           83C4                   04  add	sp,*4
08011                                           !BCC_EOS
08012                                           ! 1709           heads = sectors_low / 1024;
08013                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08014 214B           B8                   0400  mov	ax,#$400
08015 214E           31DB                       xor	bx,bx
08016 2150           53                         push	bx
08017 2151           50                         push	ax
08018 2152           8B86       FDE8            mov	ax,-$218[bp]
08019 2156           8B9E       FDEA            mov	bx,-$216[bp]
08020 215A           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08021 215E           E8         DFDE            call	ldivul
08022 2161           83C4                   04  add	sp,*4
08023                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$222] (used reg = )
08024 2164           8986       FDE0            mov	-$220[bp],ax
08025                                           !BCC_EOS
08026                                           ! 1710           if (heads>128) heads = 255;
08027                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08028 2168           8B86       FDE0            mov	ax,-$220[bp]
08029 216C           3D                   0080  cmp	ax,#$80
08030 216F           76           09            jbe 	.1DC
08031                       00002171            .1DD:
08032                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$222] (used reg = )
08033 2171           B8                   00FF  mov	ax,#$FF
08034 2174           8986       FDE0            mov	-$220[bp],ax
08035                                           !BCC_EOS
08036                                           ! 1711           else if (heads>64) heads = 128;
08037 2178           EB           3D            jmp .1DE
08038                       0000217A            .1DC:
08039                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08040 217A           8B86       FDE0            mov	ax,-$220[bp]
08041 217E           3D                   0040  cmp	ax,*$40
08042 2181           76           09            jbe 	.1DF
08043                       00002183            .1E0:
08044                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08045 2183           B8                   0080  mov	ax,#$80
08046 2186           8986       FDE0            mov	-$220[bp],ax
08047                                           !BCC_EOS
08048                                           ! 1712           else if (heads>32) heads = 64;
08049 218A           EB           2B            jmp .1E1
08050                       0000218C            .1DF:
08051                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08052 218C           8B86       FDE0            mov	ax,-$220[bp]
08053 2190           3D                   0020  cmp	ax,*$20
08054 2193           76           09            jbe 	.1E2
08055                       00002195            .1E3:
08056                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08057 2195           B8                   0040  mov	ax,*$40
08058 2198           8986       FDE0            mov	-$220[bp],ax
08059                                           !BCC_EOS
08060                                           ! 1713           else if (heads>16) heads = 32;
08061 219C           EB           19            jmp .1E4
08062                       0000219E            .1E2:
08063                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08064 219E           8B86       FDE0            mov	ax,-$220[bp]
08065 21A2           3D                   0010  cmp	ax,*$10
08066 21A5           76           09            jbe 	.1E5
08067                       000021A7            .1E6:
08068                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08069 21A7           B8                   0020  mov	ax,*$20
08070 21AA           8986       FDE0            mov	-$220[bp],ax
08071                                           !BCC_EOS
08072                                           ! 1714           else heads=16;
08073 21AE           EB           07            jmp .1E7
08074                       000021B0            .1E5:
08075                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08076 21B0           B8                   0010  mov	ax,*$10
08077 21B3           8986       FDE0            mov	-$220[bp],ax
08078                                           !BCC_EOS
08079                                           ! 1715           cylinders = sectors_low / heads;
08080                       000021B7            .1E7:
08081                       000021B7            .1E4:
08082                       000021B7            .1E1:
08083                       000021B7            .1DE:
08084                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$222] (used reg = )
08085 21B7           8B86       FDE0            mov	ax,-$220[bp]
08086 21BB           31DB                       xor	bx,bx
08087                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08088 21BD           53                         push	bx
08089 21BE           50                         push	ax
08090 21BF           8B86       FDE8            mov	ax,-$218[bp]
08091 21C3           8B9E       FDEA            mov	bx,-$216[bp]
08092 21C7           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08093 21CB           E8         DF71            call	ldivul
08094 21CE           83C4                   04  add	sp,*4
08095                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08096 21D1           8986       FDE2            mov	-$21E[bp],ax
08097                                           !BCC_EOS
08098                                           ! 1716           break;
08099 21D5           E9         00BF            br 	.1D7
08100                                           !BCC_EOS
08101                                           ! 1717         case 3:
08102                                           ! 1718           if (heads==16) {
08103                       000021D8            .1E8:
08104                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08105 21D8           8B86       FDE0            mov	ax,-$220[bp]
08106 21DC           3D                   0010  cmp	ax,*$10
08107 21DF           75           72            jne 	.1E9
08108                       000021E1            .1EA:
08109                                           ! 1719             if(cylinders>61439) cylinders=61439;
08110                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08111 21E1           8B86       FDE2            mov	ax,-$21E[bp]
08112 21E5           31DB                       xor	bx,bx
08113                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08114 21E7           53                         push	bx
08115 21E8           50                         push	ax
08116 21E9           B8                   EFFF  mov	ax,#$EFFF
08117 21EC           31DB                       xor	bx,bx
08118 21EE           53                         push	bx
08119 21EF           50                         push	ax
08120 21F0           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08121 21F4           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08122 21F8           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08123 21FC           E8         DE9D            call	lcmpul
08124 21FF           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08125 2203           76           07            jbe 	.1EB
08126                       00002205            .1EC:
08127                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$220] (used reg = )
08128 2205           B8                   EFFF  mov	ax,#$EFFF
08129 2208           8986       FDE2            mov	-$21E[bp],ax
08130                                           !BCC_EOS
08131                                           ! 1720             heads=15;
08132                       0000220C            .1EB:
08133                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$222] (used reg = )
08134 220C           B8                   000F  mov	ax,*$F
08135 220F           8986       FDE0            mov	-$220[bp],ax
08136                                           !BCC_EOS
08137                                           ! 1721             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08138                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08139 2213           8B86       FDE2            mov	ax,-$21E[bp]
08140 2217           31DB                       xor	bx,bx
08141                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08142 2219           53                         push	bx
08143 221A           50                         push	ax
08144 221B           B8                   0010  mov	ax,*$10
08145 221E           31DB                       xor	bx,bx
08146 2220           53                         push	bx
08147 2221           50                         push	ax
08148 2222           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08149 2226           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08150 222A           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08151 222E           E8         DE89            call	lmulul
08152 2231           83C4                   08  add	sp,*8
08153                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08154 2234           53                         push	bx
08155 2235           50                         push	ax
08156 2236           B8                   000F  mov	ax,*$F
08157 2239           31DB                       xor	bx,bx
08158 223B           53                         push	bx
08159 223C           50                         push	ax
08160 223D           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08161 2241           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08162 2245           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08163 2249           E8         DEF3            call	ldivul
08164 224C           83C4                   08  add	sp,*8
08165                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08166                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08167 224F           8986       FDE2            mov	-$21E[bp],ax
08168                                           !BCC_EOS
08169                                           ! 1722           }
08170                                           ! 1723         case 2:
08171                       00002253            .1E9:
08172                                           ! 1724           while(cylinders > 1024) {
08173                       00002253            .1ED:
08174 2253           EB           1F            jmp .1EF
08175                       00002255            .1F0:
08176                                           ! 1725             cylinders >>= 1;
08177                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$220] (used reg = )
08178 2255           8B86       FDE2            mov	ax,-$21E[bp]
08179 2259           D1E8                       shr	ax,*1
08180 225B           8986       FDE2            mov	-$21E[bp],ax
08181                                           !BCC_EOS
08182                                           ! 1726             heads <<= 1;
08183                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$222] (used reg = )
08184 225F           8B86       FDE0            mov	ax,-$220[bp]
08185 2263           D1E0                       shl	ax,*1
08186 2265           8986       FDE0            mov	-$220[bp],ax
08187                                           !BCC_EOS
08188                                           ! 1727             if (heads > 127) break;
08189                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$222] (used reg = )
08190 2269           8B86       FDE0            mov	ax,-$220[bp]
08191 226D           3D                   007F  cmp	ax,*$7F
08192 2270           76           02            jbe 	.1F1
08193                       00002272            .1F2:
08194 2272           EB           09            jmp .1EE
08195                                           !BCC_EOS
08196                                           ! 1728           }
08197                       00002274            .1F1:
08198                                           ! 1729           break;
08199                       00002274            .1EF:
08200                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08201 2274           8B86       FDE2            mov	ax,-$21E[bp]
08202 2278           3D                   0400  cmp	ax,#$400
08203 227B           77           D8            ja 	.1F0
08204                       0000227D            .1F3:
08205                       0000227D            .1EE:
08206 227D           EB           18            jmp .1D7
08207                                           !BCC_EOS
08208                                           ! 1730       }
08209                                           ! 1731       if (cylinders > 1024) cylinders=1024;
08210 227F           EB           16            jmp .1D7
08211                       00002281            .1D9:
08212 2281           2C                     00  sub	al,*0
08213 2283         0F84         FE99            beq 	.1DA
08214 2287           2C                     01  sub	al,*1
08215 2289         0F84         FE96            beq 	.1DB
08216 228D           2C                     01  sub	al,*1
08217 228F           74           C2            je 	.1ED
08218 2291           2C                     01  sub	al,*1
08219 2293         0F84         FF41            beq 	.1E8
08220                       00002297            .1D7:
08221                       FFFFFDD8            ..FFFD	=	-$228
08222                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08223 2297           8B86       FDE2            mov	ax,-$21E[bp]
08224 229B           3D                   0400  cmp	ax,#$400
08225 229E           76           07            jbe 	.1F4
08226                       000022A0            .1F5:
08227                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08228 22A0           B8                   0400  mov	ax,#$400
08229 22A3           8986       FDE2            mov	-$21E[bp],ax
08230                                           !BCC_EOS
08231                                           ! 1732       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08232                       000022A7            .1F4:
08233                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
08234 22A7           FFB6       FDDE            push	-$222[bp]
08235                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
08236 22AB           FFB6       FDE0            push	-$220[bp]
08237                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
08238 22AF           FFB6       FDE2            push	-$21E[bp]
08239                                           ! Debug: list * char = .1F6+0 (used reg = )
08240 22B3           BB                   D775  mov	bx,#.1F6
08241 22B6           53                         push	bx
08242                                           ! Debug: list int = const 4 (used reg = )
08243 22B7           B8                   0004  mov	ax,*4
08244 22BA           50                         push	ax
08245                                           ! Debug: func () void = bios_printf+0 (used reg = )
08246 22BB           E8         E67B            call	_bios_printf
08247 22BE           83C4                   0A  add	sp,*$A
08248                                           !BCC_EOS
08249                                           ! 1733       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (heads);
08250                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08251 22C1           8A46         FD            mov	al,-3[bp]
08252 22C4           30E4                       xor	ah,ah
08253 22C6           B9                   001E  mov	cx,*$1E
08254 22C9           F7E9                       imul	cx
08255 22CB           89C3                       mov	bx,ax
08256                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08257                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
08258                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$14C] (used reg = )
08259 22CD           8B86       FDE0            mov	ax,-$220[bp]
08260 22D1           8987       014C            mov	$14C[bx],ax
08261                                           !BCC_EOS
08262                                           ! 1734       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (cylinders);
08263                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08264 22D5           8A46         FD            mov	al,-3[bp]
08265 22D8           30E4                       xor	ah,ah
08266 22DA           B9                   001E  mov	cx,*$1E
08267 22DD           F7E9                       imul	cx
08268 22DF           89C3                       mov	bx,ax
08269                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08270                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
08271                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$14E] (used reg = )
08272 22E1           8B86       FDE2            mov	ax,-$21E[bp]
08273 22E5           8987       014E            mov	$14E[bx],ax
08274                                           !BCC_EOS
08275                                           ! 1735   
08276                                           ! 1735     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (spt);
08277                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08278 22E9           8A46         FD            mov	al,-3[bp]
08279 22EC           30E4                       xor	ah,ah
08280 22EE           B9                   001E  mov	cx,*$1E
08281 22F1           F7E9                       imul	cx
08282 22F3           89C3                       mov	bx,ax
08283                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08284                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
08285                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$150] (used reg = )
08286 22F5           8B86       FDDE            mov	ax,-$222[bp]
08287 22F9           8987       0150            mov	$150[bx],ax
08288                                           !BCC_EOS
08289                                           ! 1736       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[hdcount])) = (device);
08290                                           ! Debug: ptradd unsigned char hdcount = [S+$228-3] to [8] unsigned char = const $233 (used reg = )
08291 22FD           8A46         FF            mov	al,-1[bp]
08292 2300           30E4                       xor	ah,ah
08293 2302           89C3                       mov	bx,ax
08294                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08295                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
08296                                           ! Debug: eq unsigned char device = [S+$228-5] to unsigned char = [bx+$233] (used reg = )
08297 2304           8A46         FD            mov	al,-3[bp]
08298 2307           8887       0233            mov	$233[bx],al
08299                                           !BCC_EOS
08300                                           ! 1737       hdcount++;
08301                                           ! Debug: postinc unsigned char hdcount = [S+$228-3] (used reg = )
08302 230B           8A46         FF            mov	al,-1[bp]
08303 230E           40                         inc	ax
08304 230F           8846         FF            mov	-1[bp],al
08305                                           !BCC_EOS
08306                                           ! 1738     }
08307 2312           83C4                   12  add	sp,*$12
08308                                           ! 1739     if(type == 0x03) {
08309                       00002315            .1BB:
08310                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$216-6] (used reg = )
08311 2315           8A46         FC            mov	al,-4[bp]
08312 2318           3C                     03  cmp	al,*3
08313 231A         0F85         011F            bne 	.1F7
08314                       0000231E            .1F8:
08315                                           ! 1740       Bit8u type, removable, mode;
08316                                           !BCC_EOS
08317                                           ! 1741       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x05);
08318 231E           83C4                   FC  add	sp,*-4
08319                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08320 2321           8A46         FD            mov	al,-3[bp]
08321 2324           30E4                       xor	ah,ah
08322 2326           B9                   001E  mov	cx,*$1E
08323 2329           F7E9                       imul	cx
08324 232B           89C3                       mov	bx,ax
08325                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08326                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08327                                           ! Debug: eq int = const 5 to unsigned char = [bx+$143] (used reg = )
08328 232D           B0                     05  mov	al,*5
08329 232F           8887       0143            mov	$143[bx],al
08330                                           !BCC_EOS
08331                                           ! 1742       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
08332                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08333 2333           8A46         FD            mov	al,-3[bp]
08334 2336           30E4                       xor	ah,ah
08335 2338           B9                   001E  mov	cx,*$1E
08336 233B           F7E9                       imul	cx
08337 233D           89C3                       mov	bx,ax
08338                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08339                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08340                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
08341 233F           30C0                       xor	al,al
08342 2341           8887       0146            mov	$146[bx],al
08343                                           !BCC_EOS
08344                                           ! 1743       if (ata_cmd_data_io(0, device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08345                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08346 2345           8D9E       FDFC            lea	bx,-$204[bp]
08347 2349           53                         push	bx
08348                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08349 234A           E8         E30D            call	_get_SS
08350                                           ! Debug: list unsigned short = ax+0 (used reg = )
08351 234D           50                         push	ax
08352                                           ! Debug: list long = const 0 (used reg = )
08353 234E           31C0                       xor	ax,ax
08354 2350           31DB                       xor	bx,bx
08355 2352           53                         push	bx
08356 2353           50                         push	ax
08357                                           ! Debug: list long = const 0 (used reg = )
08358 2354           31C0                       xor	ax,ax
08359 2356           31DB                       xor	bx,bx
08360 2358           53                         push	bx
08361 2359           50                         push	ax
08362                                           ! Debug: list int = const 0 (used reg = )
08363 235A           31C0                       xor	ax,ax
08364 235C           50                         push	ax
08365                                           ! Debug: list int = const 0 (used reg = )
08366 235D           31C0                       xor	ax,ax
08367 235F           50                         push	ax
08368                                           ! Debug: list int = const 0 (used reg = )
08369 2360           31C0                       xor	ax,ax
08370 2362           50                         push	ax
08371                                           ! Debug: list int = const 1 (used reg = )
08372 2363           B8                   0001  mov	ax,*1
08373 2366           50                         push	ax
08374                                           ! Debug: list int = const $A1 (used reg = )
08375 2367           B8                   00A1  mov	ax,#$A1
08376 236A           50                         push	ax
08377                                           ! Debug: list unsigned char device = [S+$230-5] (used reg = )
08378 236B           8A46         FD            mov	al,-3[bp]
08379 236E           30E4                       xor	ah,ah
08380 2370           50                         push	ax
08381                                           ! Debug: list int = const 0 (used reg = )
08382 2371           31C0                       xor	ax,ax
08383 2373           50                         push	ax
08384                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
08385 2374           E8         060A            call	_ata_cmd_data_io
08386 2377           83C4                   1A  add	sp,*$1A
08387                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08388 237A           85C0                       test	ax,ax
08389 237C           74           0E            je  	.1F9
08390                       0000237E            .1FA:
08391                                           ! 1744         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08392                                           ! Debug: list * char = .1FB+0 (used reg = )
08393 237E           BB                   D74A  mov	bx,#.1FB
08394 2381           53                         push	bx
08395                                           ! Debug: list int = const 7 (used reg = )
08396 2382           B8                   0007  mov	ax,*7
08397 2385           50                         push	ax
08398                                           ! Debug: func () void = bios_printf+0 (used reg = )
08399 2386           E8         E5B0            call	_bios_printf
08400 2389           83C4                   04  add	sp,*4
08401                                           !BCC_EOS
08402                                           ! 1745       type = read_byte_SS(buffer+1) & 0x1f;
08403                       0000238C            .1F9:
08404                                           ! Debug: list * unsigned char buffer = S+$21A-$205 (used reg = )
08405 238C           8D9E       FDFD            lea	bx,-$203[bp]
08406 2390           53                         push	bx
08407                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08408 2391           E8         E28D            call	_read_byte_SS
08409 2394           44                         inc	sp
08410 2395           44                         inc	sp
08411                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08412 2396           24                     1F  and	al,*$1F
08413                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$217] (used reg = )
08414 2398           8886       FDEB            mov	-$215[bp],al
08415                                           !BCC_EOS
08416                                           ! 1746       removable = (read_byte_SS(buffer+0) & 0x80) ? 1 : 0;
08417                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08418 239C           8D9E       FDFC            lea	bx,-$204[bp]
08419 23A0           53                         push	bx
08420                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08421 23A1           E8         E27D            call	_read_byte_SS
08422 23A4           44                         inc	sp
08423 23A5           44                         inc	sp
08424                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08425 23A6           24                     80  and	al,#$80
08426 23A8           84C0                       test	al,al
08427 23AA           74           04            je  	.1FC
08428                       000023AC            .1FD:
08429 23AC           B0                     01  mov	al,*1
08430 23AE           EB           02            jmp .1FE
08431                       000023B0            .1FC:
08432 23B0           30C0                       xor	al,al
08433                       000023B2            .1FE:
08434                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$218] (used reg = )
08435 23B2           8886       FDEA            mov	-$216[bp],al
08436                                           !BCC_EOS
08437                                           ! 1747       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
08438                                           ! Debug: list * unsigned char buffer = S+$21A-$1A6 (used reg = )
08439 23B6           8D9E       FE5C            lea	bx,-$1A4[bp]
08440 23BA           53                         push	bx
08441                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08442 23BB           E8         E263            call	_read_byte_SS
08443 23BE           44                         inc	sp
08444 23BF           44                         inc	sp
08445 23C0           84C0                       test	al,al
08446 23C2           74           04            je  	.1FF
08447                       000023C4            .200:
08448 23C4           B0                     01  mov	al,*1
08449 23C6           EB           02            jmp .201
08450                       000023C8            .1FF:
08451 23C8           30C0                       xor	al,al
08452                       000023CA            .201:
08453                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$219] (used reg = )
08454 23CA           8886       FDE9            mov	-$217[bp],al
08455                                           !BCC_EOS
08456                                           ! 1748       blksize = 2048;
08457                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$20E] (used reg = )
08458 23CE           B8                   0800  mov	ax,#$800
08459 23D1           8986       FDF4            mov	-$20C[bp],ax
08460                                           !BCC_EOS
08461                                           ! 1749       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (type);
08462                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08463 23D5           8A46         FD            mov	al,-3[bp]
08464 23D8           30E4                       xor	ah,ah
08465 23DA           B9                   001E  mov	cx,*$1E
08466 23DD           F7E9                       imul	cx
08467 23DF           89C3                       mov	bx,ax
08468                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08469                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08470                                           ! Debug: eq unsigned char type = [S+$21A-$217] to unsigned char = [bx+$143] (used reg = )
08471 23E1           8A86       FDEB            mov	al,-$215[bp]
08472 23E5           8887       0143            mov	$143[bx],al
08473                                           !BCC_EOS
08474                                           ! 1750       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
08475                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08476 23E9           8A46         FD            mov	al,-3[bp]
08477 23EC           30E4                       xor	ah,ah
08478 23EE           B9                   001E  mov	cx,*$1E
08479 23F1           F7E9                       imul	cx
08480 23F3           89C3                       mov	bx,ax
08481                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
08483                                           ! Debug: eq unsigned char removable = [S+$21A-$218] to unsigned char = [bx+$144] (used reg = )
08484 23F5           8A86       FDEA            mov	al,-$216[bp]
08485 23F9           8887       0144            mov	$144[bx],al
08486                                           !BCC_EOS
08487                                           ! 1751       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
08488                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08489 23FD           8A46         FD            mov	al,-3[bp]
08490 2400           30E4                       xor	ah,ah
08491 2402           B9                   001E  mov	cx,*$1E
08492 2405           F7E9                       imul	cx
08493 2407           89C3                       mov	bx,ax
08494                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08495                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08496                                           ! Debug: eq unsigned char mode = [S+$21A-$219] to unsigned char = [bx+$146] (used reg = )
08497 2409           8A86       FDE9            mov	al,-$217[bp]
08498 240D           8887       0146            mov	$146[bx],al
08499                                           !BCC_EOS
08500                                           ! 1752       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
08501                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08502 2411           8A46         FD            mov	al,-3[bp]
08503 2414           30E4                       xor	ah,ah
08504 2416           B9                   001E  mov	cx,*$1E
08505 2419           F7E9                       imul	cx
08506 241B           89C3                       mov	bx,ax
08507                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08508                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
08509                                           ! Debug: eq unsigned short blksize = [S+$21A-$20E] to unsigned short = [bx+$148] (used reg = )
08510 241D           8B86       FDF4            mov	ax,-$20C[bp]
08511 2421           8987       0148            mov	$148[bx],ax
08512                                           !BCC_EOS
08513                                           ! 1753       *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[cdcount])) = (device);
08514                                           ! Debug: ptradd unsigned char cdcount = [S+$21A-4] to [8] unsigned char = const $23C (used reg = )
08515 2425           8A46         FE            mov	al,-2[bp]
08516 2428           30E4                       xor	ah,ah
08517 242A           89C3                       mov	bx,ax
08518                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
08519                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
08520                                           ! Debug: eq unsigned char device = [S+$21A-5] to unsigned char = [bx+$23C] (used reg = )
08521 242C           8A46         FD            mov	al,-3[bp]
08522 242F           8887       023C            mov	$23C[bx],al
08523                                           !BCC_EOS
08524                                           ! 1754       cdcount++;
08525                                           ! Debug: postinc unsigned char cdcount = [S+$21A-4] (used reg = )
08526 2433           8A46         FE            mov	al,-2[bp]
08527 2436           40                         inc	ax
08528 2437           8846         FE            mov	-2[bp],al
08529                                           !BCC_EOS
08530                                           ! 1755     }
08531 243A           83C4                   04  add	sp,*4
08532                                           ! 1756     {
08533                       0000243D            .1F7:
08534                                           ! 1757       Bit32u sizeinmb;
08535                                           !BCC_EOS
08536                                           ! 1758       Bit16u ataversion;
08537                                           !BCC_EOS
08538                                           ! 1759       Bit8u c, i, lshift, rshift, version, model[41];
08539                                           !BCC_EOS
08540                                           ! 1760       switch (type) {
08541 243D           83C4                   CC  add	sp,*-$34
08542 2440           8A46         FC            mov	al,-4[bp]
08543 2443           E9         0213            br 	.204
08544                                           ! 1761         case 0x02:
08545                                           ! 1762           switch (blksize) {
08546                       00002446            .205:
08547 2446           8B86       FDF4            mov	ax,-$20C[bp]
08548 244A           EB           2A            jmp .208
08549                                           ! 1763             case 1024:
08550                                           ! 1764               lshift = 22;
08551                       0000244C            .209:
08552                                           ! Debug: eq int = const $16 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08553 244C           B0                     16  mov	al,*$16
08554 244E           8886       FDE3            mov	-$21D[bp],al
08555                                           !BCC_EOS
08556                                           ! 1765               rshift = 10;
08557                                           ! Debug: eq int = const $A to unsigned char rshift = [S+$24A-$220] (used reg = )
08558 2452           B0                     0A  mov	al,*$A
08559 2454           8886       FDE2            mov	-$21E[bp],al
08560                                           !BCC_EOS
08561                                           ! 1766               break;
08562 2458           EB           28            jmp .206
08563                                           !BCC_EOS
08564                                           ! 1767             case 4096:
08565                                           ! 1768               lshift = 24;
08566                       0000245A            .20A:
08567                                           ! Debug: eq int = const $18 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08568 245A           B0                     18  mov	al,*$18
08569 245C           8886       FDE3            mov	-$21D[bp],al
08570                                           !BCC_EOS
08571                                           ! 1769               rshift = 8;
08572                                           ! Debug: eq int = const 8 to unsigned char rshift = [S+$24A-$220] (used reg = )
08573 2460           B0                     08  mov	al,*8
08574 2462           8886       FDE2            mov	-$21E[bp],al
08575                                           !BCC_EOS
08576                                           ! 1770               break;
08577 2466           EB           1A            jmp .206
08578                                           !BCC_EOS
08579                                           ! 1771             default:
08580                                           ! 1772               lshift = 21;
08581                       00002468            .20B:
08582                                           ! Debug: eq int = const $15 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08583 2468           B0                     15  mov	al,*$15
08584 246A           8886       FDE3            mov	-$21D[bp],al
08585                                           !BCC_EOS
08586                                           ! 1773               rshift = 11;
08587                                           ! Debug: eq int = const $B to unsigned char rshift = [S+$24A-$220] (used reg = )
08588 246E           B0                     0B  mov	al,*$B
08589 2470           8886       FDE2            mov	-$21E[bp],al
08590                                           !BCC_EOS
08591                                           ! 1774           }
08592                                           ! 1775           sizeinmb = (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) << lshift)
08593 2474           EB           0C            jmp .206
08594                       00002476            .208:
08595 2476           2D                   0400  sub	ax,#$400
08596 2479           74           D1            je 	.209
08597 247B           2D                   0C00  sub	ax,#$C00
08598 247E           74           DA            je 	.20A
08599 2480           EB           E6            jmp	.20B
08600                       00002482            .206:
08601                                           ! 1776             | (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) >> rshift);
08602                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
08603 2482           8A46         FD            mov	al,-3[bp]
08604 2485           30E4                       xor	ah,ah
08605 2487           B9                   001E  mov	cx,*$1E
08606 248A           F7E9                       imul	cx
08607 248C           89C3                       mov	bx,ax
08608                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08609                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
08610                                           ! Debug: sr unsigned char rshift = [S+$24A-$220] to unsigned long = [bx+$158] (used reg = )
08611 248E           8A86       FDE2            mov	al,-$21E[bp]
08612 2492           50                         push	ax
08613 2493           8B87       0158            mov	ax,$158[bx]
08614 2497           8B9F       015A            mov	bx,$15A[bx]
08615 249B           8A8E       FDB6            mov	cl,0+..FFFC[bp]
08616 249F           30ED                       xor	ch,ch
08617 24A1           89CF                       mov	di,cx
08618 24A3           E8         DC54            call	lsrul
08619 24A6           44                         inc	sp
08620 24A7           44                         inc	sp
08621 24A8           53                         push	bx
08622 24A9           50                         push	ax
08623                                           ! Debug: ptradd unsigned char device = [S+$24E-5] to [8] struct  = const $142 (used reg = )
08624 24AA           8A46         FD            mov	al,-3[bp]
08625 24AD           30E4                       xor	ah,ah
08626 24AF           B9                   001E  mov	cx,*$1E
08627 24B2           F7E9                       imul	cx
08628 24B4           89C3                       mov	bx,ax
08629                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08630                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
08631                                           ! Debug: sl unsigned char lshift = [S+$24E-$21F] to unsigned long = [bx+$15C] (used reg = )
08632 24B6           8A86       FDE3            mov	al,-$21D[bp]
08633 24BA           50                         push	ax
08634 24BB           8B87       015C            mov	ax,$15C[bx]
08635 24BF           8B9F       015E            mov	bx,$15E[bx]
08636 24C3           8A8E       FDB2            mov	cl,-4+..FFFC[bp]
08637 24C7           30ED                       xor	ch,ch
08638 24C9           89CF                       mov	di,cx
08639 24CB           E8         DC4A            call	lslul
08640 24CE           44                         inc	sp
08641 24CF           44                         inc	sp
08642                                           ! Debug: or unsigned long (temp) = [S+$24E-$24E] to unsigned long = bx+0 (used reg = )
08643 24D0           8DBE       FDB4            lea	di,-2+..FFFC[bp]
08644 24D4           E8         DC01            call	lorul
08645 24D7           83C4                   04  add	sp,*4
08646                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
08647 24DA           8986       FDE8            mov	-$218[bp],ax
08648 24DE           899E       FDEA            mov	-$216[bp],bx
08649                                           !BCC_EOS
08650                                           ! 1777         case 0x03:
08651                                           ! 1778           ataversion=((Bit16u)(read_byte_SS(buffer+161))<<8)|read_byte_SS(buffer+160);
08652                       000024E2            .20C:
08653                                           ! Debug: list * unsigned char buffer = S+$24A-$166 (used reg = )
08654 24E2           8D9E       FE9C            lea	bx,-$164[bp]
08655 24E6           53                         push	bx
08656                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08657 24E7           E8         E137            call	_read_byte_SS
08658 24EA           44                         inc	sp
08659 24EB           44                         inc	sp
08660 24EC           50                         push	ax
08661                                           ! Debug: list * unsigned char buffer = S+$24C-$165 (used reg = )
08662 24ED           8D9E       FE9D            lea	bx,-$163[bp]
08663 24F1           53                         push	bx
08664                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08665 24F2           E8         E12C            call	_read_byte_SS
08666 24F5           44                         inc	sp
08667 24F6           44                         inc	sp
08668                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
08669 24F7           30E4                       xor	ah,ah
08670                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
08671 24F9           88C4                       mov	ah,al
08672 24FB           30C0                       xor	al,al
08673                                           ! Debug: or unsigned char (temp) = [S+$24C-$24C] to unsigned int = ax+0 (used reg = )
08674 24FD           0A86       FDB6            or	al,0+..FFFC[bp]
08675 2501           44                         inc	sp
08676 2502           44                         inc	sp
08677                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08678 2503           8986       FDE6            mov	-$21A[bp],ax
08679                                           !BCC_EOS
08680                                           ! 1779           for(version=15;version>0;version--) {
08681                                           ! Debug: eq int = const $F to unsigned char version = [S+$24A-$221] (used reg = )
08682 2507           B0                     0F  mov	al,*$F
08683 2509           8886       FDE1            mov	-$21F[bp],al
08684                                           !BCC_EOS
08685                                           !BCC_EOS
08686 250D           EB           22            jmp .20F
08687                       0000250F            .210:
08688                                           ! 1780             if((ataversion&(1<<version))!=0)
08689                                           ! Debug: sl unsigned char version = [S+$24A-$221] to int = const 1 (used reg = )
08690 250F           8A86       FDE1            mov	al,-$21F[bp]
08691 2513           30E4                       xor	ah,ah
08692 2515           89C3                       mov	bx,ax
08693 2517           B8                   0001  mov	ax,*1
08694 251A           89D9                       mov	cx,bx
08695 251C           D3E0                       shl	ax,cl
08696                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08697                                           ! Debug: expression subtree swapping
08698 251E           2386       FDE6            and	ax,-$21A[bp]
08699                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
08700 2522           85C0                       test	ax,ax
08701 2524           74           02            je  	.211
08702                       00002526            .212:
08703                                           ! 1781             break;
08704 2526           EB           11            jmp .20D
08705                                           !BCC_EOS
08706                                           ! 1782           }
08707                       00002528            .211:
08708                                           ! 1783 
08709                                           ! 1783           for(i=0;i<20;i++) {
08710                       00002528            .20E:
08711                                           ! Debug: postdec unsigned char version = [S+$24A-$221] (used reg = )
08712 2528           8A86       FDE1            mov	al,-$21F[bp]
08713 252C           48                         dec	ax
08714 252D           8886       FDE1            mov	-$21F[bp],al
08715                       00002531            .20F:
08716                                           ! Debug: gt int = const 0 to unsigned char version = [S+$24A-$221] (used reg = )
08717 2531           8A86       FDE1            mov	al,-$21F[bp]
08718 2535           84C0                       test	al,al
08719 2537           75           D6            jne	.210
08720                       00002539            .213:
08721                       00002539            .20D:
08722                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08723 2539           30C0                       xor	al,al
08724 253B           8886       FDE4            mov	-$21C[bp],al
08725                                           !BCC_EOS
08726                                           !BCC_EOS
08727 253F           EB           69            jmp .216
08728                       00002541            .217:
08729                                           ! 1784             _write_byte_SS(read_byte_SS(buffer+(i*2)+54+1), model+(i*2));
08730                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08731 2541           8A86       FDE4            mov	al,-$21C[bp]
08732 2545           30E4                       xor	ah,ah
08733 2547           D1E0                       shl	ax,*1
08734                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08735 2549           89EB                       mov	bx,bp
08736 254B           01C3                       add	bx,ax
08737                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08738                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08739 254D           81C3                 FDB8  add	bx,#-$248
08740 2551           53                         push	bx
08741                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08742 2552           8A86       FDE4            mov	al,-$21C[bp]
08743 2556           30E4                       xor	ah,ah
08744 2558           D1E0                       shl	ax,*1
08745                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08746 255A           89EB                       mov	bx,bp
08747 255C           01C3                       add	bx,ax
08748                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08749                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1CE (used reg = )
08750                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CD (used reg = )
08751                                           ! Debug: list * unsigned char = bx-$1CD (used reg = )
08752 255E           81C3                 FE33  add	bx,#-$1CD
08753 2562           53                         push	bx
08754                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08755 2563           E8         E0BB            call	_read_byte_SS
08756 2566           44                         inc	sp
08757 2567           44                         inc	sp
08758                                           ! Debug: list unsigned char = al+0 (used reg = )
08759 2568           30E4                       xor	ah,ah
08760 256A           50                         push	ax
08761                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08762 256B           E8         E0C9            call	__write_byte_SS
08763 256E           83C4                   04  add	sp,*4
08764                                           !BCC_EOS
08765                                           ! 1785             _write_byte_SS(read_byte_SS(buffer+(i*2)+54), model+(i*2)+1);
08766                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08767 2571           8A86       FDE4            mov	al,-$21C[bp]
08768 2575           30E4                       xor	ah,ah
08769 2577           D1E0                       shl	ax,*1
08770                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08771 2579           89EB                       mov	bx,bp
08772 257B           01C3                       add	bx,ax
08773                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$248 (used reg = )
08774                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$247 (used reg = )
08775                                           ! Debug: list * unsigned char = bx-$247 (used reg = )
08776 257D           81C3                 FDB9  add	bx,#-$247
08777 2581           53                         push	bx
08778                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08779 2582           8A86       FDE4            mov	al,-$21C[bp]
08780 2586           30E4                       xor	ah,ah
08781 2588           D1E0                       shl	ax,*1
08782                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08783 258A           89EB                       mov	bx,bp
08784 258C           01C3                       add	bx,ax
08785                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08786                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CE (used reg = )
08787                                           ! Debug: list * unsigned char = bx-$1CE (used reg = )
08788 258E           81C3                 FE32  add	bx,#-$1CE
08789 2592           53                         push	bx
08790                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08791 2593           E8         E08B            call	_read_byte_SS
08792 2596           44                         inc	sp
08793 2597           44                         inc	sp
08794                                           ! Debug: list unsigned char = al+0 (used reg = )
08795 2598           30E4                       xor	ah,ah
08796 259A           50                         push	ax
08797                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08798 259B           E8         E099            call	__write_byte_SS
08799 259E           83C4                   04  add	sp,*4
08800                                           !BCC_EOS
08801                                           ! 1786           }
08802                                           ! 1787           _write_byte_SS(0x00, model+40);
08803                       000025A1            .215:
08804                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
08805 25A1           8A86       FDE4            mov	al,-$21C[bp]
08806 25A5           40                         inc	ax
08807 25A6           8886       FDE4            mov	-$21C[bp],al
08808                       000025AA            .216:
08809                                           ! Debug: lt int = const $14 to unsigned char i = [S+$24A-$21E] (used reg = )
08810 25AA           8A86       FDE4            mov	al,-$21C[bp]
08811 25AE           3C                     14  cmp	al,*$14
08812 25B0           72           8F            jb 	.217
08813                       000025B2            .218:
08814                       000025B2            .214:
08815                                           ! Debug: list * unsigned char model = S+$24A-$222 (used reg = )
08816 25B2           8D9E       FDE0            lea	bx,-$220[bp]
08817 25B6           53                         push	bx
08818                                           ! Debug: list int = const 0 (used reg = )
08819 25B7           31C0                       xor	ax,ax
08820 25B9           50                         push	ax
08821                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08822 25BA           E8         E07A            call	__write_byte_SS
08823 25BD           83C4                   04  add	sp,*4
08824                                           !BCC_EOS
08825                                           ! 1788           for(i=39;i>0;i--){
08826                                           ! Debug: eq int = const $27 to unsigned char i = [S+$24A-$21E] (used reg = )
08827 25C0           B0                     27  mov	al,*$27
08828 25C2           8886       FDE4            mov	-$21C[bp],al
08829                                           !BCC_EOS
08830                                           !BCC_EOS
08831 25C6           EB           3D            jmp .21B
08832                       000025C8            .21C:
08833                                           ! 1789             if(read_byte_SS(model+i)==0x20)
08834                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08835 25C8           8A86       FDE4            mov	al,-$21C[bp]
08836 25CC           30E4                       xor	ah,ah
08837 25CE           89EB                       mov	bx,bp
08838 25D0           01C3                       add	bx,ax
08839                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08840                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08841 25D2           81C3                 FDB8  add	bx,#-$248
08842 25D6           53                         push	bx
08843                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08844 25D7           E8         E047            call	_read_byte_SS
08845 25DA           44                         inc	sp
08846 25DB           44                         inc	sp
08847                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
08848 25DC           3C                     20  cmp	al,*$20
08849 25DE           75           1A            jne 	.21D
08850                       000025E0            .21E:
08851                                           ! 1790               _write_byte_SS(0x00, model+i);
08852                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08853 25E0           8A86       FDE4            mov	al,-$21C[bp]
08854 25E4           30E4                       xor	ah,ah
08855 25E6           89EB                       mov	bx,bp
08856 25E8           01C3                       add	bx,ax
08857                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08858                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08859 25EA           81C3                 FDB8  add	bx,#-$248
08860 25EE           53                         push	bx
08861                                           ! Debug: list int = const 0 (used reg = )
08862 25EF           31C0                       xor	ax,ax
08863 25F1           50                         push	ax
08864                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08865 25F2           E8         E042            call	__write_byte_SS
08866 25F5           83C4                   04  add	sp,*4
08867                                           !BCC_EOS
08868                                           ! 1791             else break;
08869 25F8           EB           02            jmp .21F
08870                       000025FA            .21D:
08871 25FA           EB           11            jmp .219
08872                                           !BCC_EOS
08873                                           ! 1792           }
08874                       000025FC            .21F:
08875                                           ! 1793           if (i>36) {
08876                       000025FC            .21A:
08877                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08878 25FC           8A86       FDE4            mov	al,-$21C[bp]
08879 2600           48                         dec	ax
08880 2601           8886       FDE4            mov	-$21C[bp],al
08881                       00002605            .21B:
08882                                           ! Debug: gt int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08883 2605           8A86       FDE4            mov	al,-$21C[bp]
08884 2609           84C0                       test	al,al
08885 260B           75           BB            jne	.21C
08886                       0000260D            .220:
08887                       0000260D            .219:
08888                                           ! Debug: gt int = const $24 to unsigned char i = [S+$24A-$21E] (used reg = )
08889 260D           8A86       FDE4            mov	al,-$21C[bp]
08890 2611           3C                     24  cmp	al,*$24
08891 2613           76           40            jbe 	.221
08892                       00002615            .222:
08893                                           ! 1794             _write_byte_SS(0x00, model+36);
08894                                           ! Debug: list * unsigned char model = S+$24A-$226 (used reg = )
08895 2615           8D9E       FDDC            lea	bx,-$224[bp]
08896 2619           53                         push	bx
08897                                           ! Debug: list int = const 0 (used reg = )
08898 261A           31C0                       xor	ax,ax
08899 261C           50                         push	ax
08900                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08901 261D           E8         E017            call	__write_byte_SS
08902 2620           83C4                   04  add	sp,*4
08903                                           !BCC_EOS
08904                                           ! 1795             for(i=35;i>32;i--){
08905                                           ! Debug: eq int = const $23 to unsigned char i = [S+$24A-$21E] (used reg = )
08906 2623           B0                     23  mov	al,*$23
08907 2625           8886       FDE4            mov	-$21C[bp],al
08908                                           !BCC_EOS
08909                                           !BCC_EOS
08910 2629           EB           22            jmp .225
08911                       0000262B            .226:
08912                                           ! 1796               _write_byte_SS(0x2E, model+i);
08913                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08914 262B           8A86       FDE4            mov	al,-$21C[bp]
08915 262F           30E4                       xor	ah,ah
08916 2631           89EB                       mov	bx,bp
08917 2633           01C3                       add	bx,ax
08918                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08919                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08920 2635           81C3                 FDB8  add	bx,#-$248
08921 2639           53                         push	bx
08922                                           ! Debug: list int = const $2E (used reg = )
08923 263A           B8                   002E  mov	ax,*$2E
08924 263D           50                         push	ax
08925                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08926 263E           E8         DFF6            call	__write_byte_SS
08927 2641           83C4                   04  add	sp,*4
08928                                           !BCC_EOS
08929                                           ! 1797             }
08930                                           ! 1798           }
08931                       00002644            .224:
08932                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08933 2644           8A86       FDE4            mov	al,-$21C[bp]
08934 2648           48                         dec	ax
08935 2649           8886       FDE4            mov	-$21C[bp],al
08936                       0000264D            .225:
08937                                           ! Debug: gt int = const $20 to unsigned char i = [S+$24A-$21E] (used reg = )
08938 264D           8A86       FDE4            mov	al,-$21C[bp]
08939 2651           3C                     20  cmp	al,*$20
08940 2653           77           D6            ja 	.226
08941                       00002655            .227:
08942                       00002655            .223:
08943                                           ! 1799           break;
08944                       00002655            .221:
08945 2655           EB           0E            jmp .202
08946                                           !BCC_EOS
08947                                           ! 1800       }
08948                                           ! 1801       switch (type) {
08949 2657           EB           0C            jmp .202
08950                       00002659            .204:
08951 2659           2C                     02  sub	al,*2
08952 265B         0F84         FDE7            beq 	.205
08953 265F           2C                     01  sub	al,*1
08954 2661         0F84         FE7D            beq 	.20C
08955                       00002665            .202:
08956                       FFFFFDB6            ..FFFC	=	-$24A
08957 2665           8A46         FC            mov	al,-4[bp]
08958 2668           E9         018E            br 	.22A
08959                                           ! 1802         case 0x02:
08960                                           ! 1803           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
08961                       0000266B            .22B:
08962 266B           8A86       FDF2            mov	al,-$20E[bp]
08963 266F           84C0                       test	al,al
08964 2671           74           05            je  	.22F
08965                       00002673            .230:
08966 2673           BB                   D738  mov	bx,#.22D
08967 2676           EB           03            jmp .231
08968                       00002678            .22F:
08969 2678           BB                   D731  mov	bx,#.22E
08970                       0000267B            .231:
08971                                           ! Debug: list * char = bx+0 (used reg = )
08972 267B           53                         push	bx
08973                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
08974 267C           8A86       FDF3            mov	al,-$20D[bp]
08975 2680           30E4                       xor	ah,ah
08976 2682           50                         push	ax
08977                                           ! Debug: list * char = .22C+0 (used reg = )
08978 2683           BB                   D73F  mov	bx,#.22C
08979 2686           53                         push	bx
08980                                           ! Debug: list int = const 2 (used reg = )
08981 2687           B8                   0002  mov	ax,*2
08982 268A           50                         push	ax
08983                                           ! Debug: func () void = bios_printf+0 (used reg = )
08984 268B           E8         E2AB            call	_bios_printf
08985 268E           83C4                   08  add	sp,*8
08986                                           !BCC_EOS
08987                                           ! 1804           i=0;
08988                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08989 2691           30C0                       xor	al,al
08990 2693           8886       FDE4            mov	-$21C[bp],al
08991                                           !BCC_EOS
08992                                           ! 1805           while(c=read_byte_SS(model+i++))
08993                                           ! 1806             bios_printf(2, "%c",c);
08994 2697           EB           15            jmp .233
08995                       00002699            .234:
08996                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
08997 2699           8A86       FDE5            mov	al,-$21B[bp]
08998 269D           30E4                       xor	ah,ah
08999 269F           50                         push	ax
09000                                           ! Debug: list * char = .235+0 (used reg = )
09001 26A0           BB                   D72E  mov	bx,#.235
09002 26A3           53                         push	bx
09003                                           ! Debug: list int = const 2 (used reg = )
09004 26A4           B8                   0002  mov	ax,*2
09005 26A7           50                         push	ax
09006                                           ! Debug: func () void = bios_printf+0 (used reg = )
09007 26A8           E8         E28E            call	_bios_printf
09008 26AB           83C4                   06  add	sp,*6
09009                                           !BCC_EOS
09010                                           ! 1807           if (sizeinmb < (1UL<<16))
09011                       000026AE            .233:
09012                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09013 26AE           8A86       FDE4            mov	al,-$21C[bp]
09014 26B2           40                         inc	ax
09015 26B3           8886       FDE4            mov	-$21C[bp],al
09016                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09017 26B7           48                         dec	ax
09018 26B8           30E4                       xor	ah,ah
09019 26BA           89EB                       mov	bx,bp
09020 26BC           01C3                       add	bx,ax
09021                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09022                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09023 26BE           81C3                 FDB8  add	bx,#-$248
09024 26C2           53                         push	bx
09025                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09026 26C3           E8         DF5B            call	_read_byte_SS
09027 26C6           44                         inc	sp
09028 26C7           44                         inc	sp
09029                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09030 26C8           8886       FDE5            mov	-$21B[bp],al
09031 26CC           84C0                       test	al,al
09032 26CE           75           C9            jne	.234
09033                       000026D0            .236:
09034                       000026D0            .232:
09035                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09036 26D0           31C0                       xor	ax,ax
09037 26D2           BB                   0001  mov	bx,*1
09038 26D5           8DBE       FDE8            lea	di,-$218[bp]
09039 26D9           E8         D9C0            call	lcmpul
09040 26DC           76           1B            jbe 	.237
09041                       000026DE            .238:
09042                                           ! 1808             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09043                                           ! Debug: list unsigned short sizeinmb = [S+$24A-$21A] (used reg = )
09044 26DE           FFB6       FDE8            push	-$218[bp]
09045                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09046 26E2           8A86       FDE1            mov	al,-$21F[bp]
09047 26E6           30E4                       xor	ah,ah
09048 26E8           50                         push	ax
09049                                           ! Debug: list * char = .239+0 (used reg = )
09050 26E9           BB                   D70E  mov	bx,#.239
09051 26EC           53                         push	bx
09052                                           ! Debug: list int = const 2 (used reg = )
09053 26ED           B8                   0002  mov	ax,*2
09054 26F0           50                         push	ax
09055                                           ! Debug: func () void = bios_printf+0 (used reg = )
09056 26F1           E8         E245            call	_bios_printf
09057 26F4           83C4                   08  add	sp,*8
09058                                           !BCC_EOS
09059                                           ! 1809           else
09060                                           ! 1810             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09061 26F7           EB           2C            jmp .23A
09062                       000026F9            .237:
09063                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09064 26F9           8B86       FDE8            mov	ax,-$218[bp]
09065 26FD           8B9E       FDEA            mov	bx,-$216[bp]
09066 2701           88E0                       mov	al,ah
09067 2703           88DC                       mov	ah,bl
09068 2705           88FB                       mov	bl,bh
09069 2707           28FF                       sub	bh,bh
09070 2709           BF                   0002  mov	di,*2
09071 270C           E8         D9EB            call	lsrul
09072                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09073                                           ! Debug: list unsigned short = ax+0 (used reg = )
09074 270F           50                         push	ax
09075                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09076 2710           8A86       FDE1            mov	al,-$21F[bp]
09077 2714           30E4                       xor	ah,ah
09078 2716           50                         push	ax
09079                                           ! Debug: list * char = .23B+0 (used reg = )
09080 2717           BB                   D6EE  mov	bx,#.23B
09081 271A           53                         push	bx
09082                                           ! Debug: list int = const 2 (used reg = )
09083 271B           B8                   0002  mov	ax,*2
09084 271E           50                         push	ax
09085                                           ! Debug: func () void = bios_printf+0 (used reg = )
09086 271F           E8         E217            call	_bios_printf
09087 2722           83C4                   08  add	sp,*8
09088                                           !BCC_EOS
09089                                           ! 1811           break;
09090                       00002725            .23A:
09091 2725           E9         00E1            br 	.228
09092                                           !BCC_EOS
09093                                           ! 1812         case 0x03:
09094                                           ! 1813           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09095                       00002728            .23C:
09096 2728           8A86       FDF2            mov	al,-$20E[bp]
09097 272C           84C0                       test	al,al
09098 272E           74           05            je  	.240
09099                       00002730            .241:
09100 2730           BB                   D6DC  mov	bx,#.23E
09101 2733           EB           03            jmp .242
09102                       00002735            .240:
09103 2735           BB                   D6D5  mov	bx,#.23F
09104                       00002738            .242:
09105                                           ! Debug: list * char = bx+0 (used reg = )
09106 2738           53                         push	bx
09107                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09108 2739           8A86       FDF3            mov	al,-$20D[bp]
09109 273D           30E4                       xor	ah,ah
09110 273F           50                         push	ax
09111                                           ! Debug: list * char = .23D+0 (used reg = )
09112 2740           BB                   D6E3  mov	bx,#.23D
09113 2743           53                         push	bx
09114                                           ! Debug: list int = const 2 (used reg = )
09115 2744           B8                   0002  mov	ax,*2
09116 2747           50                         push	ax
09117                                           ! Debug: func () void = bios_printf+0 (used reg = )
09118 2748           E8         E1EE            call	_bios_printf
09119 274B           83C4                   08  add	sp,*8
09120                                           !BCC_EOS
09121                                           ! 1814           i=0; while(c=read_byte_SS(model+i++)) bios_printf(2, "%c",c);
09122                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09123 274E           30C0                       xor	al,al
09124 2750           8886       FDE4            mov	-$21C[bp],al
09125                                           !BCC_EOS
09126 2754           EB           15            jmp .244
09127                       00002756            .245:
09128                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09129 2756           8A86       FDE5            mov	al,-$21B[bp]
09130 275A           30E4                       xor	ah,ah
09131 275C           50                         push	ax
09132                                           ! Debug: list * char = .246+0 (used reg = )
09133 275D           BB                   D6D2  mov	bx,#.246
09134 2760           53                         push	bx
09135                                           ! Debug: list int = const 2 (used reg = )
09136 2761           B8                   0002  mov	ax,*2
09137 2764           50                         push	ax
09138                                           ! Debug: func () void = bios_printf+0 (used reg = )
09139 2765           E8         E1D1            call	_bios_printf
09140 2768           83C4                   06  add	sp,*6
09141                                           !BCC_EOS
09142                                           ! 1815           if(*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device))==0x05)
09143                       0000276B            .244:
09144                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09145 276B           8A86       FDE4            mov	al,-$21C[bp]
09146 276F           40                         inc	ax
09147 2770           8886       FDE4            mov	-$21C[bp],al
09148                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09149 2774           48                         dec	ax
09150 2775           30E4                       xor	ah,ah
09151 2777           89EB                       mov	bx,bp
09152 2779           01C3                       add	bx,ax
09153                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09154                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09155 277B           81C3                 FDB8  add	bx,#-$248
09156 277F           53                         push	bx
09157                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09158 2780           E8         DE9E            call	_read_byte_SS
09159 2783           44                         inc	sp
09160 2784           44                         inc	sp
09161                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09162 2785           8886       FDE5            mov	-$21B[bp],al
09163 2789           84C0                       test	al,al
09164 278B           75           C9            jne	.245
09165                       0000278D            .247:
09166                       0000278D            .243:
09167                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
09168 278D           8A46         FD            mov	al,-3[bp]
09169 2790           30E4                       xor	ah,ah
09170 2792           B9                   001E  mov	cx,*$1E
09171 2795           F7E9                       imul	cx
09172 2797           89C3                       mov	bx,ax
09173                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09174                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
09175                                           ! Debug: logeq int = const 5 to unsigned char = [bx+$143] (used reg = )
09176 2799           8A87       0143            mov	al,$143[bx]
09177 279D           3C                     05  cmp	al,*5
09178 279F           75           17            jne 	.248
09179                       000027A1            .249:
09180                                           ! 1816             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09181                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09182 27A1           8A86       FDE1            mov	al,-$21F[bp]
09183 27A5           30E4                       xor	ah,ah
09184 27A7           50                         push	ax
09185                                           ! Debug: list * char = .24A+0 (used reg = )
09186 27A8           BB                   D6B8  mov	bx,#.24A
09187 27AB           53                         push	bx
09188                                           ! Debug: list int = const 2 (used reg = )
09189 27AC           B8                   0002  mov	ax,*2
09190 27AF           50                         push	ax
09191                                           ! Debug: func () void = bios_printf+0 (used reg = )
09192 27B0           E8         E186            call	_bios_printf
09193 27B3           83C4                   06  add	sp,*6
09194                                           !BCC_EOS
09195                                           ! 1817           else
09196                                           ! 1818             bios_printf(2, " ATAPI-%d Device\n",version);
09197 27B6           EB           15            jmp .24B
09198                       000027B8            .248:
09199                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09200 27B8           8A86       FDE1            mov	al,-$21F[bp]
09201 27BC           30E4                       xor	ah,ah
09202 27BE           50                         push	ax
09203                                           ! Debug: list * char = .24C+0 (used reg = )
09204 27BF           BB                   D6A6  mov	bx,#.24C
09205 27C2           53                         push	bx
09206                                           ! Debug: list int = const 2 (used reg = )
09207 27C3           B8                   0002  mov	ax,*2
09208 27C6           50                         push	ax
09209                                           ! Debug: func () void = bios_printf+0 (used reg = )
09210 27C7           E8         E16F            call	_bios_printf
09211 27CA           83C4                   06  add	sp,*6
09212                                           !BCC_EOS
09213                                           ! 1819           break;
09214                       000027CD            .24B:
09215 27CD           EB           3A            jmp .228
09216                                           !BCC_EOS
09217                                           ! 1820         case 0x01:
09218                                           ! 1821           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09219                       000027CF            .24D:
09220 27CF           8A86       FDF2            mov	al,-$20E[bp]
09221 27D3           84C0                       test	al,al
09222 27D5           74           05            je  	.251
09223                       000027D7            .252:
09224 27D7           BB                   D685  mov	bx,#.24F
09225 27DA           EB           03            jmp .253
09226                       000027DC            .251:
09227 27DC           BB                   D67E  mov	bx,#.250
09228                       000027DF            .253:
09229                                           ! Debug: list * char = bx+0 (used reg = )
09230 27DF           53                         push	bx
09231                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09232 27E0           8A86       FDF3            mov	al,-$20D[bp]
09233 27E4           30E4                       xor	ah,ah
09234 27E6           50                         push	ax
09235                                           ! Debug: list * char = .24E+0 (used reg = )
09236 27E7           BB                   D68C  mov	bx,#.24E
09237 27EA           53                         push	bx
09238                                           ! Debug: list int = const 2 (used reg = )
09239 27EB           B8                   0002  mov	ax,*2
09240 27EE           50                         push	ax
09241                                           ! Debug: func () void = bios_printf+0 (used reg = )
09242 27EF           E8         E147            call	_bios_printf
09243 27F2           83C4                   08  add	sp,*8
09244                                           !BCC_EOS
09245                                           ! 1822           break;
09246 27F5           EB           12            jmp .228
09247                                           !BCC_EOS
09248                                           ! 1823       }
09249                                           ! 1824     }
09250 27F7           EB           10            jmp .228
09251                       000027F9            .22A:
09252 27F9           2C                     01  sub	al,*1
09253 27FB           74           D2            je 	.24D
09254 27FD           2C                     01  sub	al,*1
09255 27FF         0F84         FE68            beq 	.22B
09256 2803           2C                     01  sub	al,*1
09257 2805         0F84         FF1F            beq 	.23C
09258                       00002809            .228:
09259                       FFFFFDB6            ..FFFB	=	-$24A
09260 2809           83C4                   34  add	sp,*$34
09261                                           ! 1825   }
09262 280C           83C4                   0E  add	sp,*$E
09263                                           ! 1826   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (hdcount);
09264                       0000280F            .1A0:
09265                                           ! Debug: postinc unsigned char device = [S+$208-5] (used reg = )
09266 280F           8A46         FD            mov	al,-3[bp]
09267 2812           40                         inc	ax
09268 2813           8846         FD            mov	-3[bp],al
09269                       00002816            .1A1:
09270                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-5] (used reg = )
09271 2816           8A46         FD            mov	al,-3[bp]
09272 2819           3C                     08  cmp	al,*8
09273 281B         0F82         F3E7            blo 	.1A2
09274                       0000281F            .254:
09275                       0000281F            .19F:
09276                                           ! Debug: eq unsigned char hdcount = [S+$208-3] to unsigned char = [+$232] (used reg = )
09277 281F           8A46         FF            mov	al,-1[bp]
09278 2822           A2         0232            mov	[$232],al
09279                                           !BCC_EOS
09280                                           ! 1827   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (cdcount);
09281                                           ! Debug: eq unsigned char cdcount = [S+$208-4] to unsigned char = [+$23B] (used reg = )
09282 2825           8A46         FE            mov	al,-2[bp]
09283 2828           A2         023B            mov	[$23B],al
09284                                           !BCC_EOS
09285                                           ! 1828   _write_byte(hdcount, 0x75, 0x40);
09286                                           ! Debug: list int = const $40 (used reg = )
09287 282B           B8                   0040  mov	ax,*$40
09288 282E           50                         push	ax
09289                                           ! Debug: list int = const $75 (used reg = )
09290 282F           B8                   0075  mov	ax,*$75
09291 2832           50                         push	ax
09292                                           ! Debug: list unsigned char hdcount = [S+$20C-3] (used reg = )
09293 2833           8A46         FF            mov	al,-1[bp]
09294 2836           30E4                       xor	ah,ah
09295 2838           50                         push	ax
09296                                           ! Debug: func () void = _write_byte+0 (used reg = )
09297 2839           E8         DDBF            call	__write_byte
09298 283C           83C4                   06  add	sp,*6
09299                                           !BCC_EOS
09300                                           ! 1829   bios_printf(2, "\n");
09301                                           ! Debug: list * char = .255+0 (used reg = )
09302 283F           BB                   D67C  mov	bx,#.255
09303 2842           53                         push	bx
09304                                           ! Debug: list int = const 2 (used reg = )
09305 2843           B8                   0002  mov	ax,*2
09306 2846           50                         push	ax
09307                                           ! Debug: func () void = bios_printf+0 (used reg = )
09308 2847           E8         E0EF            call	_bios_printf
09309 284A           83C4                   04  add	sp,*4
09310                                           !BCC_EOS
09311                                           ! 1830   set_DS(old_ds);
09312                                           ! Debug: list unsigned short old_ds = [S+$208-$208] (used reg = )
09313 284D           FFB6       FDFA            push	-$206[bp]
09314                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
09315 2851           E8         DE09            call	_set_DS
09316 2854           44                         inc	sp
09317 2855           44                         inc	sp
09318                                           !BCC_EOS
09319                                           ! 1831 }
09320 2856           89EC                       mov	sp,bp
09321 2858           5D                         pop	bp
09322 2859           C3                         ret
09323                                           ! 1832 void ata_reset(device)
09324                                           ! Register BX used in function ata_detect
09325                                           ! 1833 Bit16u device;
09326                                           export	_ata_reset
09327                       0000285A            _ata_reset:
09328                                           !BCC_EOS
09329                                           ! 1834 {
09330                                           ! 1835   Bit16u iobase1, iobase2;
09331                                           !BCC_EOS
09332                                           ! 1836   Bit8u channel, slave, sn, sc;
09333                                           !BCC_EOS
09334                                           ! 1837   Bit8u type;
09335                                           !BCC_EOS
09336                                           ! 1838   Bit16u max;
09337                                           !BCC_EOS
09338                                           ! 1839   channel = device / 2;
09339 285A           55                         push	bp
09340 285B           89E5                       mov	bp,sp
09341 285D           83C4                   F4  add	sp,*-$C
09342                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09343 2860           8B46         04            mov	ax,4[bp]
09344 2863           D1E8                       shr	ax,*1
09345                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-7] (used reg = )
09346 2865           8846         FB            mov	-5[bp],al
09347                                           !BCC_EOS
09348                                           ! 1840   slave = device % 2;
09349                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09350 2868           8B46         04            mov	ax,4[bp]
09351 286B           24                     01  and	al,*1
09352                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-8] (used reg = )
09353 286D           8846         FA            mov	-6[bp],al
09354                                           !BCC_EOS
09355                                           ! 1841   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09356                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09357 2870           8A46         FB            mov	al,-5[bp]
09358 2873           30E4                       xor	ah,ah
09359 2875           B1                     03  mov	cl,*3
09360 2877           D3E0                       shl	ax,cl
09361 2879           89C3                       mov	bx,ax
09362                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09363                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09364                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09365 287B           8B9F       0124            mov	bx,$124[bx]
09366 287F           895E         FE            mov	-2[bp],bx
09367                                           !BCC_EOS
09368                                           ! 1842   
09369                                           ! 1842 iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09370                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09371 2882           8A46         FB            mov	al,-5[bp]
09372 2885           30E4                       xor	ah,ah
09373 2887           B1                     03  mov	cl,*3
09374 2889           D3E0                       shl	ax,cl
09375 288B           89C3                       mov	bx,ax
09376                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09377                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09378                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09379 288D           8B9F       0126            mov	bx,$126[bx]
09380 2891           895E         FC            mov	-4[bp],bx
09381                                           !BCC_EOS
09382                                           ! 1843   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09383                                           ! Debug: list int = const $E (used reg = )
09384 2894           B8                   000E  mov	ax,*$E
09385 2897           50                         push	ax
09386                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09387 2898           8B46         FC            mov	ax,-4[bp]
09388                                           ! Debug: list unsigned int = ax+6 (used reg = )
09389 289B           05                   0006  add	ax,*6
09390 289E           50                         push	ax
09391                                           ! Debug: func () void = outb+0 (used reg = )
09392 289F           E8         DC9D            call	_outb
09393 28A2           83C4                   04  add	sp,*4
09394                                           !BCC_EOS
09395                                           ! 1844   await_ide(1, iobase1, 20);
09396                                           ! Debug: list int = const $14 (used reg = )
09397 28A5           B8                   0014  mov	ax,*$14
09398 28A8           50                         push	ax
09399                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09400 28A9           FF76         FE            push	-2[bp]
09401                                           ! Debug: list int = const 1 (used reg = )
09402 28AC           B8                   0001  mov	ax,*1
09403 28AF           50                         push	ax
09404                                           ! Debug: func () int = await_ide+0 (used reg = )
09405 28B0           E8         F177            call	_await_ide
09406 28B3           83C4                   06  add	sp,*6
09407                                           !BCC_EOS
09408                                           ! 1845   outb(iobase2+6, 0x08 | 0x02);
09409                                           ! Debug: list int = const $A (used reg = )
09410 28B6           B8                   000A  mov	ax,*$A
09411 28B9           50                         push	ax
09412                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09413 28BA           8B46         FC            mov	ax,-4[bp]
09414                                           ! Debug: list unsigned int = ax+6 (used reg = )
09415 28BD           05                   0006  add	ax,*6
09416 28C0           50                         push	ax
09417                                           ! Debug: func () void = outb+0 (used reg = )
09418 28C1           E8         DC7B            call	_outb
09419 28C4           83C4                   04  add	sp,*4
09420                                           !BCC_EOS
09421                                           ! 1846   type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
09422                                           ! Debug: ptradd unsigned short device = [S+$E+2] to [8] struct  = const $142 (used reg = )
09423 28C7           8B46         04            mov	ax,4[bp]
09424 28CA           B9                   001E  mov	cx,*$1E
09425 28CD           F7E9                       imul	cx
09426 28CF           89C3                       mov	bx,ax
09427                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09428                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
09429                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$E-$B] (used reg = )
09430 28D1           8A87       0142            mov	al,$142[bx]
09431 28D5           8846         F7            mov	-9[bp],al
09432                                           !BCC_EOS
09433                                           ! 1847   if (type != 0x00) {
09434                                           ! Debug: ne int = const 0 to unsigned char type = [S+$E-$B] (used reg = )
09435 28D8           8A46         F7            mov	al,-9[bp]
09436 28DB           84C0                       test	al,al
09437 28DD         0F84         0084            beq 	.256
09438                       000028E1            .257:
09439                                           ! 1848     outb(iobase1+6, slave?0xb0:0xa0);
09440 28E1           8A46         FA            mov	al,-6[bp]
09441 28E4           84C0                       test	al,al
09442 28E6           74           04            je  	.258
09443                       000028E8            .259:
09444 28E8           B0                     B0  mov	al,#$B0
09445 28EA           EB           02            jmp .25A
09446                       000028EC            .258:
09447 28EC           B0                     A0  mov	al,#$A0
09448                       000028EE            .25A:
09449                                           ! Debug: list char = al+0 (used reg = )
09450 28EE           30E4                       xor	ah,ah
09451 28F0           50                         push	ax
09452                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
09453 28F1           8B46         FE            mov	ax,-2[bp]
09454                                           ! Debug: list unsigned int = ax+6 (used reg = )
09455 28F4           05                   0006  add	ax,*6
09456 28F7           50                         push	ax
09457                                           ! Debug: func () void = outb+0 (used reg = )
09458 28F8           E8         DC44            call	_outb
09459 28FB           83C4                   04  add	sp,*4
09460                                           !BCC_EOS
09461                                           ! 1849     sc = inb(iobase1+2);
09462                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$E-4] (used reg = )
09463 28FE           8B46         FE            mov	ax,-2[bp]
09464                                           ! Debug: list unsigned int = ax+2 (used reg = )
09465 2901           40                         inc	ax
09466 2902           40                         inc	ax
09467 2903           50                         push	ax
09468                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09469 2904           E8         DC22            call	_inb
09470 2907           44                         inc	sp
09471 2908           44                         inc	sp
09472                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$E-$A] (used reg = )
09473 2909           8846         F8            mov	-8[bp],al
09474                                           !BCC_EOS
09475                                           ! 1850     sn = inb(iobase1+3);
09476                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$E-4] (used reg = )
09477 290C           8B46         FE            mov	ax,-2[bp]
09478                                           ! Debug: list unsigned int = ax+3 (used reg = )
09479 290F           05                   0003  add	ax,*3
09480 2912           50                         push	ax
09481                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09482 2913           E8         DC13            call	_inb
09483 2916           44                         inc	sp
09484 2917           44                         inc	sp
09485                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$E-9] (used reg = )
09486 2918           8846         F9            mov	-7[bp],al
09487                                           !BCC_EOS
09488                                           ! 1851     if ( (sc==0x01) && (sn==0x01) ) {
09489                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$E-$A] (used reg = )
09490 291B           8A46         F8            mov	al,-8[bp]
09491 291E           3C                     01  cmp	al,*1
09492 2920           75           32            jne 	.25B
09493                       00002922            .25D:
09494                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$E-9] (used reg = )
09495 2922           8A46         F9            mov	al,-7[bp]
09496 2925           3C                     01  cmp	al,*1
09497 2927           75           2B            jne 	.25B
09498                       00002929            .25C:
09499                                           ! 1852       if (type == 0x02)
09500                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$E-$B] (used reg = )
09501 2929           8A46         F7            mov	al,-9[bp]
09502 292C           3C                     02  cmp	al,*2
09503 292E           75           13            jne 	.25E
09504                       00002930            .25F:
09505                                           ! 1853         await_ide(5, iobase1, 32000u);
09506                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09507 2930           B8                   7D00  mov	ax,#$7D00
09508 2933           50                         push	ax
09509                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09510 2934           FF76         FE            push	-2[bp]
09511                                           ! Debug: list int = const 5 (used reg = )
09512 2937           B8                   0005  mov	ax,*5
09513 293A           50                         push	ax
09514                                           ! Debug: func () int = await_ide+0 (used reg = )
09515 293B           E8         F0EC            call	_await_ide
09516 293E           83C4                   06  add	sp,*6
09517                                           !BCC_EOS
09518                                           ! 1854       else
09519                                           ! 1855         await_ide(2, iobase1, 32000u);
09520 2941           EB           11            jmp .260
09521                       00002943            .25E:
09522                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09523 2943           B8                   7D00  mov	ax,#$7D00
09524 2946           50                         push	ax
09525                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09526 2947           FF76         FE            push	-2[bp]
09527                                           ! Debug: list int = const 2 (used reg = )
09528 294A           B8                   0002  mov	ax,*2
09529 294D           50                         push	ax
09530                                           ! Debug: func () int = await_ide+0 (used reg = )
09531 294E           E8         F0D9            call	_await_ide
09532 2951           83C4                   06  add	sp,*6
09533                                           !BCC_EOS
09534                                           ! 1856     }
09535                       00002954            .260:
09536                                           ! 1857     await_ide(2, iobase1, 32000u);
09537                       00002954            .25B:
09538                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09539 2954           B8                   7D00  mov	ax,#$7D00
09540 2957           50                         push	ax
09541                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09542 2958           FF76         FE            push	-2[bp]
09543                                           ! Debug: list int = const 2 (used reg = )
09544 295B           B8                   0002  mov	ax,*2
09545 295E           50                         push	ax
09546                                           ! Debug: func () int = await_ide+0 (used reg = )
09547 295F           E8         F0C8            call	_await_ide
09548 2962           83C4                   06  add	sp,*6
09549                                           !BCC_EOS
09550                                           ! 1858   }
09551                                           ! 1859   outb(iobase2+6, 0x08);
09552                       00002965            .256:
09553                                           ! Debug: list int = const 8 (used reg = )
09554 2965           B8                   0008  mov	ax,*8
09555 2968           50                         push	ax
09556                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09557 2969           8B46         FC            mov	ax,-4[bp]
09558                                           ! Debug: list unsigned int = ax+6 (used reg = )
09559 296C           05                   0006  add	ax,*6
09560 296F           50                         push	ax
09561                                           ! Debug: func () void = outb+0 (used reg = )
09562 2970           E8         DBCC            call	_outb
09563 2973           83C4                   04  add	sp,*4
09564                                           !BCC_EOS
09565                                           ! 1860 }
09566 2976           89EC                       mov	sp,bp
09567 2978           5D                         pop	bp
09568 2979           C3                         ret
09569                                           ! 1861 Bit16u ata_cmd_non_data()
09570                                           ! Register BX used in function ata_reset
09571                                           ! 1862 {return 0;}
09572                                           export	_ata_cmd_non_data
09573                       0000297A            _ata_cmd_non_data:
09574 297A           55                         push	bp
09575 297B           89E5                       mov	bp,sp
09576 297D           31C0                       xor	ax,ax
09577 297F           5D                         pop	bp
09578 2980           C3                         ret
09579                                           !BCC_EOS
09580                                           ! 1863 Bit16u ata_cmd_data_io(ioflag, device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
09581                                           ! 1864 Bit16u ioflag, device, command, count, cylinder, head, sector, segment, offset;
09582                                           export	_ata_cmd_data_io
09583                       00002981            _ata_cmd_data_io:
09584                                           !BCC_EOS
09585                                           ! 1865 Bit32u lba_low, lba_high;
09586                                           !BCC_EOS
09587                                           ! 1866 {
09588                                           ! 1867   Bit16u iobase1, iobase2, blksize;
09589                                           !BCC_EOS
09590                                           ! 1868   Bit8u channel, slave;
09591                                           !BCC_EOS
09592                                           ! 1869   Bit8u status, current, mode;
09593                                           !BCC_EOS
09594                                           ! 1870   channel = device / 2;
09595 2981           55                         push	bp
09596 2982           89E5                       mov	bp,sp
09597 2984           83C4                   F4  add	sp,*-$C
09598                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09599 2987           8B46         06            mov	ax,6[bp]
09600 298A           D1E8                       shr	ax,*1
09601                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-9] (used reg = )
09602 298C           8846         F9            mov	-7[bp],al
09603                                           !BCC_EOS
09604                                           ! 1871   slave = device % 2;
09605                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09606 298F           8B46         06            mov	ax,6[bp]
09607 2992           24                     01  and	al,*1
09608                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-$A] (used reg = )
09609 2994           8846         F8            mov	-8[bp],al
09610                                           !BCC_EOS
09611                                           ! 1872   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09612                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09613 2997           8A46         F9            mov	al,-7[bp]
09614 299A           30E4                       xor	ah,ah
09615 299C           B1                     03  mov	cl,*3
09616 299E           D3E0                       shl	ax,cl
09617 29A0           89C3                       mov	bx,ax
09618                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09619                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09620                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09621 29A2           8B9F       0124            mov	bx,$124[bx]
09622 29A6           895E         FE            mov	-2[bp],bx
09623                                           !BCC_EOS
09624                                           ! 1873   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09625                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09626 29A9           8A46         F9            mov	al,-7[bp]
09627 29AC           30E4                       xor	ah,ah
09628 29AE           B1                     03  mov	cl,*3
09629 29B0           D3E0                       shl	ax,cl
09630 29B2           89C3                       mov	bx,ax
09631                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09632                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09633                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09634 29B4           8B9F       0126            mov	bx,$126[bx]
09635 29B8           895E         FC            mov	-4[bp],bx
09636                                           !BCC_EOS
09637                                           ! 1874   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
09638                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09639 29BB           8B46         06            mov	ax,6[bp]
09640 29BE           B9                   001E  mov	cx,*$1E
09641 29C1           F7E9                       imul	cx
09642 29C3           89C3                       mov	bx,ax
09643                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09644                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
09645                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$E-$D] (used reg = )
09646 29C5           8A87       0146            mov	al,$146[bx]
09647 29C9           8846         F5            mov	-$B[bp],al
09648                                           !BCC_EOS
09649                                           ! 1875   if ((command == 0xEC) ||
09650                                           ! 1876       (command == 0xA1)) {
09651                                           ! Debug: logeq int = const $EC to unsigned short command = [S+$E+6] (used reg = )
09652 29CC           8B46         08            mov	ax,8[bp]
09653 29CF           3D                   00EC  cmp	ax,#$EC
09654 29D2           74           08            je  	.262
09655                       000029D4            .263:
09656                                           ! Debug: logeq int = const $A1 to unsigned short command = [S+$E+6] (used reg = )
09657 29D4           8B46         08            mov	ax,8[bp]
09658 29D7           3D                   00A1  cmp	ax,#$A1
09659 29DA           75           08            jne 	.261
09660                       000029DC            .262:
09661                                           ! 1877     blksize = 0x200;
09662                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$E-8] (used reg = )
09663 29DC           B8                   0200  mov	ax,#$200
09664 29DF           8946         FA            mov	-6[bp],ax
09665                                           !BCC_EOS
09666                                           ! 1878   } else {
09667 29E2           EB           11            jmp .264
09668                       000029E4            .261:
09669                                           ! 1879     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
09670                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09671 29E4           8B46         06            mov	ax,6[bp]
09672 29E7           B9                   001E  mov	cx,*$1E
09673 29EA           F7E9                       imul	cx
09674 29EC           89C3                       mov	bx,ax
09675                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09676                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
09677                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$E-8] (used reg = )
09678 29EE           8B9F       0148            mov	bx,$148[bx]
09679 29F2           895E         FA            mov	-6[bp],bx
09680                                           !BCC_EOS
09681                                           ! 1880   }
09682                                           ! 1881   if (mode == 0x01) blksize>>=2;
09683                       000029F5            .264:
09684                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$E-$D] (used reg = )
09685 29F5           8A46         F5            mov	al,-$B[bp]
09686 29F8           3C                     01  cmp	al,*1
09687 29FA           75           0C            jne 	.265
09688                       000029FC            .266:
09689                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$E-8] (used reg = )
09690 29FC           8B46         FA            mov	ax,-6[bp]
09691 29FF           D1E8                       shr	ax,*1
09692 2A01           D1E8                       shr	ax,*1
09693 2A03           8946         FA            mov	-6[bp],ax
09694                                           !BCC_EOS
09695                                           ! 1882   else blksize>>=1;
09696 2A06           EB           08            jmp .267
09697                       00002A08            .265:
09698                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$E-8] (used reg = )
09699 2A08           8B46         FA            mov	ax,-6[bp]
09700 2A0B           D1E8                       shr	ax,*1
09701 2A0D           8946         FA            mov	-6[bp],ax
09702                                           !BCC_EOS
09703                                           ! 1883   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
09704                       00002A10            .267:
09705                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
09706 2A10           31C0                       xor	ax,ax
09707 2A12           A3         0254            mov	[$254],ax
09708                                           !BCC_EOS
09709                                           ! 1884   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
09710                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
09711 2A15           31C0                       xor	ax,ax
09712 2A17           31DB                       xor	bx,bx
09713 2A19           A3         0256            mov	[$256],ax
09714 2A1C           891E       0258            mov	[$258],bx
09715                                           !BCC_EOS
09716                                           ! 1885   current = 0;
09717                                           ! Debug: eq int = const 0 to unsigned char current = [S+$E-$C] (used reg = )
09718 2A20           30C0                       xor	al,al
09719 2A22           8846         F6            mov	-$A[bp],al
09720                                           !BCC_EOS
09721                                           ! 1886   status = inb(iobase1 + 7);
09722                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
09723 2A25           8B46         FE            mov	ax,-2[bp]
09724                                           ! Debug: list unsigned int = ax+7 (used reg = )
09725 2A28           05                   0007  add	ax,*7
09726 2A2B           50                         push	ax
09727                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09728 2A2C           E8         DAFA            call	_inb
09729 2A2F           44                         inc	sp
09730 2A30           44                         inc	sp
09731                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
09732 2A31           8846         F7            mov	-9[bp],al
09733                                           !BCC_EOS
09734                                           ! 1887   if (status & 0x80) return 1;
09735                                           ! Debug: and int = const $80 to unsigned char status = [S+$E-$B] (used reg = )
09736 2A34           8A46         F7            mov	al,-9[bp]
09737 2A37           24                     80  and	al,#$80
09738 2A39           84C0                       test	al,al
09739 2A3B           74           07            je  	.268
09740                       00002A3D            .269:
09741 2A3D           B8                   0001  mov	ax,*1
09742 2A40           89EC                       mov	sp,bp
09743 2A42           5D                         pop	bp
09744 2A43           C3                         ret
09745                                           !BCC_EOS
09746                                           ! 1888   outb(iobase2 + 6, 0x08 | 0x02);
09747                       00002A44            .268:
09748                                           ! Debug: list int = const $A (used reg = )
09749 2A44           B8                   000A  mov	ax,*$A
09750 2A47           50                         push	ax
09751                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09752 2A48           8B46         FC            mov	ax,-4[bp]
09753                                           ! Debug: list unsigned int = ax+6 (used reg = )
09754 2A4B           05                   0006  add	ax,*6
09755 2A4E           50                         push	ax
09756                                           ! Debug: func () void = outb+0 (used reg = )
09757 2A4F           E8         DAED            call	_outb
09758 2A52           83C4                   04  add	sp,*4
09759                                           !BCC_EOS
09760                                           ! 1889   if (sector == 0) {
09761                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$E+$E] (used reg = )
09762 2A55           8B46         10            mov	ax,$10[bp]
09763 2A58           85C0                       test	ax,ax
09764 2A5A         0F85         00F5            bne 	.26A
09765                       00002A5E            .26B:
09766                                           ! 1890     if (*(((Bit8u *)&count)+1) >= 1 || lba_high || (lba_low >= ((1UL << 28) - count))) {
09767                                           ! Debug: ge int = const 1 to unsigned char count = [S+$E+9] (used reg = )
09768 2A5E           8A46         0B            mov	al,$B[bp]
09769 2A61           3C                     01  cmp	al,*1
09770 2A63           72           04            jb 	.270
09771 2A65           B0                     01  mov	al,*1
09772 2A67           EB           02            jmp	.271
09773                       00002A69            .270:
09774 2A69           30C0                       xor	al,al
09775                       00002A6B            .271:
09776                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
09777 2A6B           30E4                       xor	ah,ah
09778 2A6D           99                         cwd
09779 2A6E           89D3                       mov	bx,dx
09780 2A70           E8         D672            call	ltstl
09781 2A73           75           2A            jne 	.26D
09782                       00002A75            .26F:
09783 2A75           8B46         16            mov	ax,$16[bp]
09784 2A78           8B5E         18            mov	bx,$18[bp]
09785 2A7B           E8         D667            call	ltstl
09786 2A7E           75           1F            jne 	.26D
09787                       00002A80            .26E:
09788                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$E+8] (used reg = )
09789 2A80           8B46         0A            mov	ax,$A[bp]
09790 2A83           31DB                       xor	bx,bx
09791                                           ! Debug: sub unsigned long = bx+0 to unsigned long = const $10000000 (used reg = )
09792 2A85           53                         push	bx
09793 2A86           50                         push	ax
09794 2A87           31C0                       xor	ax,ax
09795 2A89           BB                   1000  mov	bx,#$1000
09796 2A8C           8D7E         F0            lea	di,-$10[bp]
09797 2A8F           E8         D620            call	lsubul
09798 2A92           83C4                   04  add	sp,*4
09799                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$E+$10] (used reg = )
09800 2A95           8D7E         12            lea	di,$12[bp]
09801 2A98           E8         D601            call	lcmpul
09802 2A9B         0F87         0086            bhi 	.26C
09803                       00002A9F            .26D:
09804                                           ! 1891       outb(iobase1 + 1, 0x00);
09805                                           ! Debug: list int = const 0 (used reg = )
09806 2A9F           31C0                       xor	ax,ax
09807 2AA1           50                         push	ax
09808                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09809 2AA2           8B46         FE            mov	ax,-2[bp]
09810                                           ! Debug: list unsigned int = ax+1 (used reg = )
09811 2AA5           40                         inc	ax
09812 2AA6           50                         push	ax
09813                                           ! Debug: func () void = outb+0 (used reg = )
09814 2AA7           E8         DA95            call	_outb
09815 2AAA           83C4                   04  add	sp,*4
09816                                           !BCC_EOS
09817                                           ! 1892       outb(iobase1 + 2, *(((Bit8u *)&count)+1));
09818                                           ! Debug: list unsigned char count = [S+$E+9] (used reg = )
09819 2AAD           8A46         0B            mov	al,$B[bp]
09820 2AB0           30E4                       xor	ah,ah
09821 2AB2           50                         push	ax
09822                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09823 2AB3           8B46         FE            mov	ax,-2[bp]
09824                                           ! Debug: list unsigned int = ax+2 (used reg = )
09825 2AB6           40                         inc	ax
09826 2AB7           40                         inc	ax
09827 2AB8           50                         push	ax
09828                                           ! Debug: func () void = outb+0 (used reg = )
09829 2AB9           E8         DA83            call	_outb
09830 2ABC           83C4                   04  add	sp,*4
09831                                           !BCC_EOS
09832                                           ! 1893       outb(iobase1 + 3, *(((Bit8u *)&*(((Bit16u *)&lba_low)+1))+1));
09833                                           ! Debug: list unsigned char lba_low = [S+$E+$13] (used reg = )
09834 2ABF           8A46         15            mov	al,$15[bp]
09835 2AC2           30E4                       xor	ah,ah
09836 2AC4           50                         push	ax
09837                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09838 2AC5           8B46         FE            mov	ax,-2[bp]
09839                                           ! Debug: list unsigned int = ax+3 (used reg = )
09840 2AC8           05                   0003  add	ax,*3
09841 2ACB           50                         push	ax
09842                                           ! Debug: func () void = outb+0 (used reg = )
09843 2ACC           E8         DA70            call	_outb
09844 2ACF           83C4                   04  add	sp,*4
09845                                           !BCC_EOS
09846                                           ! 1894       outb(iobase1 + 4, *((Bit8u *)&lba_high));
09847                                           ! Debug: list unsigned char lba_high = [S+$E+$14] (used reg = )
09848 2AD2           8A46         16            mov	al,$16[bp]
09849 2AD5           30E4                       xor	ah,ah
09850 2AD7           50                         push	ax
09851                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09852 2AD8           8B46         FE            mov	ax,-2[bp]
09853                                           ! Debug: list unsigned int = ax+4 (used reg = )
09854 2ADB           05                   0004  add	ax,*4
09855 2ADE           50                         push	ax
09856                                           ! Debug: func () void = outb+0 (used reg = )
09857 2ADF           E8         DA5D            call	_outb
09858 2AE2           83C4                   04  add	sp,*4
09859                                           !BCC_EOS
09860                                           ! 1895       outb(iobase1 + 5, *(((Bit8u *)&*((Bit16u *)&lba_high))+1));
09861                                           ! Debug: list unsigned char lba_high = [S+$E+$15] (used reg = )
09862 2AE5           8A46         17            mov	al,$17[bp]
09863 2AE8           30E4                       xor	ah,ah
09864 2AEA           50                         push	ax
09865                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09866 2AEB           8B46         FE            mov	ax,-2[bp]
09867                                           ! Debug: list unsigned int = ax+5 (used reg = )
09868 2AEE           05                   0005  add	ax,*5
09869 2AF1           50                         push	ax
09870                                           ! Debug: func () void = outb+0 (used reg = )
09871 2AF2           E8         DA4A            call	_outb
09872 2AF5           83C4                   04  add	sp,*4
09873                                           !BCC_EOS
09874                                           ! 1896       comma
09875                                           ! 1896 nd |= 0x04;
09876                                           ! Debug: orab int = const 4 to unsigned short command = [S+$E+6] (used reg = )
09877 2AF8           8B46         08            mov	ax,8[bp]
09878 2AFB           0C                     04  or	al,*4
09879 2AFD           8946         08            mov	8[bp],ax
09880                                           !BCC_EOS
09881                                           ! 1897       count &= (1 << 8) - 1;
09882                                           ! Debug: andab int = const $FF to unsigned short count = [S+$E+8] (used reg = )
09883 2B00           8A46         0A            mov	al,$A[bp]
09884 2B03           30E4                       xor	ah,ah
09885 2B05           8946         0A            mov	$A[bp],ax
09886                                           !BCC_EOS
09887                                           ! 1898       lba_low &= (1UL << 24) - 1;
09888                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$E+$10] (used reg = )
09889 2B08           B8                   FFFF  mov	ax,#$FFFF
09890 2B0B           BB                   00FF  mov	bx,#$FF
09891 2B0E           53                         push	bx
09892 2B0F           50                         push	ax
09893 2B10           8B46         12            mov	ax,$12[bp]
09894 2B13           8B5E         14            mov	bx,$14[bp]
09895 2B16           8D7E         F0            lea	di,-$10[bp]
09896 2B19           E8         D570            call	landul
09897 2B1C           8946         12            mov	$12[bp],ax
09898 2B1F           895E         14            mov	$14[bp],bx
09899 2B22           83C4                   04  add	sp,*4
09900                                           !BCC_EOS
09901                                           ! 1899     }
09902                                           ! 1900     sector = (Bit16u) *((Bit8u *)&lba_low);
09903                       00002B25            .26C:
09904                                           ! Debug: cast unsigned short = const 0 to unsigned char lba_low = [S+$E+$10] (used reg = )
09905 2B25           8A46         12            mov	al,$12[bp]
09906 2B28           30E4                       xor	ah,ah
09907                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$E+$E] (used reg = )
09908 2B2A           8946         10            mov	$10[bp],ax
09909                                           !BCC_EOS
09910                                           ! 1901     lba_low >>= 8;
09911                                           ! Debug: srab int = const 8 to unsigned long lba_low = [S+$E+$10] (used reg = )
09912 2B2D           8B46         12            mov	ax,$12[bp]
09913 2B30           8B5E         14            mov	bx,$14[bp]
09914 2B33           88E0                       mov	al,ah
09915 2B35           88DC                       mov	ah,bl
09916 2B37           88FB                       mov	bl,bh
09917 2B39           28FF                       sub	bh,bh
09918 2B3B           8946         12            mov	$12[bp],ax
09919 2B3E           895E         14            mov	$14[bp],bx
09920                                           !BCC_EOS
09921                                           ! 1902     cylinder = *((Bit16u *)&lba_low);
09922                                           ! Debug: eq unsigned short lba_low = [S+$E+$10] to unsigned short cylinder = [S+$E+$A] (used reg = )
09923 2B41           8B46         12            mov	ax,$12[bp]
09924 2B44           8946         0C            mov	$C[bp],ax
09925                                           !BCC_EOS
09926                                           ! 1903     head = (*(((Bit16u *)&lba_low)+1) & 0x000f) | 0x40;
09927                                           ! Debug: and int = const $F to unsigned short lba_low = [S+$E+$12] (used reg = )
09928 2B47           8A46         14            mov	al,$14[bp]
09929 2B4A           24                     0F  and	al,*$F
09930                                           ! Debug: or int = const $40 to unsigned char = al+0 (used reg = )
09931 2B4C           0C                     40  or	al,*$40
09932                                           ! Debug: eq unsigned char = al+0 to unsigned short head = [S+$E+$C] (used reg = )
09933 2B4E           30E4                       xor	ah,ah
09934 2B50           8946         0E            mov	$E[bp],ax
09935                                           !BCC_EOS
09936                                           ! 1904   }
09937                                           ! 1905   outb(iobase1 + 1, 0x00);
09938                       00002B53            .26A:
09939                                           ! Debug: list int = const 0 (used reg = )
09940 2B53           31C0                       xor	ax,ax
09941 2B55           50                         push	ax
09942                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09943 2B56           8B46         FE            mov	ax,-2[bp]
09944                                           ! Debug: list unsigned int = ax+1 (used reg = )
09945 2B59           40                         inc	ax
09946 2B5A           50                         push	ax
09947                                           ! Debug: func () void = outb+0 (used reg = )
09948 2B5B           E8         D9E1            call	_outb
09949 2B5E           83C4                   04  add	sp,*4
09950                                           !BCC_EOS
09951                                           ! 1906   outb(iobase1 + 2, count);
09952                                           ! Debug: list unsigned short count = [S+$E+8] (used reg = )
09953 2B61           FF76         0A            push	$A[bp]
09954                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09955 2B64           8B46         FE            mov	ax,-2[bp]
09956                                           ! Debug: list unsigned int = ax+2 (used reg = )
09957 2B67           40                         inc	ax
09958 2B68           40                         inc	ax
09959 2B69           50                         push	ax
09960                                           ! Debug: func () void = outb+0 (used reg = )
09961 2B6A           E8         D9D2            call	_outb
09962 2B6D           83C4                   04  add	sp,*4
09963                                           !BCC_EOS
09964                                           ! 1907   outb(iobase1 + 3, sector);
09965                                           ! Debug: list unsigned short sector = [S+$E+$E] (used reg = )
09966 2B70           FF76         10            push	$10[bp]
09967                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09968 2B73           8B46         FE            mov	ax,-2[bp]
09969                                           ! Debug: list unsigned int = ax+3 (used reg = )
09970 2B76           05                   0003  add	ax,*3
09971 2B79           50                         push	ax
09972                                           ! Debug: func () void = outb+0 (used reg = )
09973 2B7A           E8         D9C2            call	_outb
09974 2B7D           83C4                   04  add	sp,*4
09975                                           !BCC_EOS
09976                                           ! 1908   outb(iobase1 + 4, *((Bit8u *)&cylinder));
09977                                           ! Debug: list unsigned char cylinder = [S+$E+$A] (used reg = )
09978 2B80           8A46         0C            mov	al,$C[bp]
09979 2B83           30E4                       xor	ah,ah
09980 2B85           50                         push	ax
09981                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09982 2B86           8B46         FE            mov	ax,-2[bp]
09983                                           ! Debug: list unsigned int = ax+4 (used reg = )
09984 2B89           05                   0004  add	ax,*4
09985 2B8C           50                         push	ax
09986                                           ! Debug: func () void = outb+0 (used reg = )
09987 2B8D           E8         D9AF            call	_outb
09988 2B90           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1909   outb(iobase1 + 5, *(((Bit8u *)&cylinder)+1));
09991                                           ! Debug: list unsigned char cylinder = [S+$E+$B] (used reg = )
09992 2B93           8A46         0D            mov	al,$D[bp]
09993 2B96           30E4                       xor	ah,ah
09994 2B98           50                         push	ax
09995                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09996 2B99           8B46         FE            mov	ax,-2[bp]
09997                                           ! Debug: list unsigned int = ax+5 (used reg = )
09998 2B9C           05                   0005  add	ax,*5
09999 2B9F           50                         push	ax
10000                                           ! Debug: func () void = outb+0 (used reg = )
10001 2BA0           E8         D99C            call	_outb
10002 2BA3           83C4                   04  add	sp,*4
10003                                           !BCC_EOS
10004                                           ! 1910   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10005 2BA6           8A46         F8            mov	al,-8[bp]
10006 2BA9           84C0                       test	al,al
10007 2BAB           74           04            je  	.273
10008                       00002BAD            .274:
10009 2BAD           B0                     B0  mov	al,#$B0
10010 2BAF           EB           02            jmp .275
10011                       00002BB1            .273:
10012 2BB1           B0                     A0  mov	al,#$A0
10013                       00002BB3            .275:
10014                                           ! Debug: or unsigned char head = [S+$E+$C] to char = al+0 (used reg = )
10015 2BB3           0A46         0E            or	al,$E[bp]
10016                                           ! Debug: list unsigned char = al+0 (used reg = )
10017 2BB6           30E4                       xor	ah,ah
10018 2BB8           50                         push	ax
10019                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
10020 2BB9           8B46         FE            mov	ax,-2[bp]
10021                                           ! Debug: list unsigned int = ax+6 (used reg = )
10022 2BBC           05                   0006  add	ax,*6
10023 2BBF           50                         push	ax
10024                                           ! Debug: func () void = outb+0 (used reg = )
10025 2BC0           E8         D97C            call	_outb
10026 2BC3           83C4                   04  add	sp,*4
10027                                           !BCC_EOS
10028                                           ! 1911   outb(iobase1 + 7, command);
10029                                           ! Debug: list unsigned short command = [S+$E+6] (used reg = )
10030 2BC6           FF76         08            push	8[bp]
10031                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-4] (used reg = )
10032 2BC9           8B46         FE            mov	ax,-2[bp]
10033                                           ! Debug: list unsigned int = ax+7 (used reg = )
10034 2BCC           05                   0007  add	ax,*7
10035 2BCF           50                         push	ax
10036                                           ! Debug: func () void = outb+0 (used reg = )
10037 2BD0           E8         D96C            call	_outb
10038 2BD3           83C4                   04  add	sp,*4
10039                                           !BCC_EOS
10040                                           ! 1912   await_ide(3, iobase1, 32000u);
10041                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10042 2BD6           B8                   7D00  mov	ax,#$7D00
10043 2BD9           50                         push	ax
10044                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10045 2BDA           FF76         FE            push	-2[bp]
10046                                           ! Debug: list int = const 3 (used reg = )
10047 2BDD           B8                   0003  mov	ax,*3
10048 2BE0           50                         push	ax
10049                                           ! Debug: func () int = await_ide+0 (used reg = )
10050 2BE1           E8         EE46            call	_await_ide
10051 2BE4           83C4                   06  add	sp,*6
10052                                           !BCC_EOS
10053                                           ! 1913   status = inb(iobase1 + 7);
10054                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10055 2BE7           8B46         FE            mov	ax,-2[bp]
10056                                           ! Debug: list unsigned int = ax+7 (used reg = )
10057 2BEA           05                   0007  add	ax,*7
10058 2BED           50                         push	ax
10059                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10060 2BEE           E8         D938            call	_inb
10061 2BF1           44                         inc	sp
10062 2BF2           44                         inc	sp
10063                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10064 2BF3           8846         F7            mov	-9[bp],al
10065                                           !BCC_EOS
10066                                           ! 1914   if (status & 0x01) {
10067                                           ! Debug: and int = const 1 to unsigned char status = [S+$E-$B] (used reg = )
10068 2BF6           8A46         F7            mov	al,-9[bp]
10069 2BF9           24                     01  and	al,*1
10070 2BFB           84C0                       test	al,al
10071 2BFD           74           09            je  	.276
10072                       00002BFF            .277:
10073                                           ! 1915     ;
10074                                           !BCC_EOS
10075                                           ! 1916     return 2;
10076 2BFF           B8                   0002  mov	ax,*2
10077 2C02           89EC                       mov	sp,bp
10078 2C04           5D                         pop	bp
10079 2C05           C3                         ret
10080                                           !BCC_EOS
10081                                           ! 1917   } else if ( !(status & 0x08) ) {
10082 2C06           EB           10            jmp .278
10083                       00002C08            .276:
10084                                           ! Debug: and int = const 8 to unsigned char status = [S+$E-$B] (used reg = )
10085 2C08           8A46         F7            mov	al,-9[bp]
10086 2C0B           24                     08  and	al,*8
10087 2C0D           84C0                       test	al,al
10088 2C0F           75           07            jne 	.279
10089                       00002C11            .27A:
10090                                           ! 1918     ;
10091                                           !BCC_EOS
10092                                           ! 1919     return 3;
10093 2C11           B8                   0003  mov	ax,*3
10094 2C14           89EC                       mov	sp,bp
10095 2C16           5D                         pop	bp
10096 2C17           C3                         ret
10097                                           !BCC_EOS
10098                                           ! 1920   }
10099                                           ! 1921 #asm
10100                       00002C18            .279:
10101                       00002C18            .278:
10102                                           !BCC_EOS
10103                                           !BCC_ASM
10104                       00000016            _ata_cmd_data_io.count	set	$16
10105                       0000000A            .ata_cmd_data_io.count	set	$A
10106                       00000026            _ata_cmd_data_io.segment	set	$26
10107                       0000001A            .ata_cmd_data_io.segment	set	$1A
10108                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10109                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10110                       00000005            _ata_cmd_data_io.channel	set	5
10111                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10112                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10113                       00000012            .ata_cmd_data_io.lba_low	set	$12
10114                       00000022            _ata_cmd_data_io.lba_high	set	$22
10115                       00000016            .ata_cmd_data_io.lba_high	set	$16
10116                       0000001C            _ata_cmd_data_io.sector	set	$1C
10117                       00000010            .ata_cmd_data_io.sector	set	$10
10118                       00000006            _ata_cmd_data_io.blksize	set	6
10119                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10120                       0000001A            _ata_cmd_data_io.head	set	$1A
10121                       0000000E            .ata_cmd_data_io.head	set	$E
10122                       00000010            _ata_cmd_data_io.ioflag	set	$10
10123                       00000004            .ata_cmd_data_io.ioflag	set	4
10124                       00000018            _ata_cmd_data_io.cylinder	set	$18
10125                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10126                       00000012            _ata_cmd_data_io.device	set	$12
10127                       00000006            .ata_cmd_data_io.device	set	6
10128                       00000003            _ata_cmd_data_io.status	set	3
10129                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10130                       00000002            _ata_cmd_data_io.current	set	2
10131                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10132                       00000014            _ata_cmd_data_io.command	set	$14
10133                       00000008            .ata_cmd_data_io.command	set	8
10134                       00000001            _ata_cmd_data_io.mode	set	1
10135                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10136                       00000008            _ata_cmd_data_io.iobase2	set	8
10137                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10138                       00000028            _ata_cmd_data_io.offset	set	$28
10139                       0000001C            .ata_cmd_data_io.offset	set	$1C
10140                       00000004            _ata_cmd_data_io.slave	set	4
10141                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10142 2C18           FB                                 sti ;; enable higher priority interrupts
10143                                           ! 1923 endasm
10144                                           !BCC_ENDASM
10145                                           !BCC_EOS
10146                                           ! 1924   while (1) {
10147                       00002C19            .27D:
10148                                           ! 1925     if(ioflag == 0)
10149                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10150 2C19           8B46         04            mov	ax,4[bp]
10151 2C1C           85C0                       test	ax,ax
10152 2C1E           75           36            jne 	.27E
10153                       00002C20            .27F:
10154                                           ! 1926     {
10155                                           ! 1927 #asm
10156                                           !BCC_EOS
10157                                           !BCC_ASM
10158                       00000016            _ata_cmd_data_io.count	set	$16
10159                       0000000A            .ata_cmd_data_io.count	set	$A
10160                       00000026            _ata_cmd_data_io.segment	set	$26
10161                       0000001A            .ata_cmd_data_io.segment	set	$1A
10162                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10163                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10164                       00000005            _ata_cmd_data_io.channel	set	5
10165                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10166                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10167                       00000012            .ata_cmd_data_io.lba_low	set	$12
10168                       00000022            _ata_cmd_data_io.lba_high	set	$22
10169                       00000016            .ata_cmd_data_io.lba_high	set	$16
10170                       0000001C            _ata_cmd_data_io.sector	set	$1C
10171                       00000010            .ata_cmd_data_io.sector	set	$10
10172                       00000006            _ata_cmd_data_io.blksize	set	6
10173                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10174                       0000001A            _ata_cmd_data_io.head	set	$1A
10175                       0000000E            .ata_cmd_data_io.head	set	$E
10176                       00000010            _ata_cmd_data_io.ioflag	set	$10
10177                       00000004            .ata_cmd_data_io.ioflag	set	4
10178                       00000018            _ata_cmd_data_io.cylinder	set	$18
10179                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10180                       00000012            _ata_cmd_data_io.device	set	$12
10181                       00000006            .ata_cmd_data_io.device	set	6
10182                       00000003            _ata_cmd_data_io.status	set	3
10183                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10184                       00000002            _ata_cmd_data_io.current	set	2
10185                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10186                       00000014            _ata_cmd_data_io.command	set	$14
10187                       00000008            .ata_cmd_data_io.command	set	8
10188                       00000001            _ata_cmd_data_io.mode	set	1
10189                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10190                       00000008            _ata_cmd_data_io.iobase2	set	8
10191                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10192                       00000028            _ata_cmd_data_io.offset	set	$28
10193                       0000001C            .ata_cmd_data_io.offset	set	$1C
10194                       00000004            _ata_cmd_data_io.slave	set	4
10195                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10196 2C20           55                                 push bp
10197 2C21           89E5                               mov bp, sp
10198 2C23           8B7E         2A                    mov di, _ata_cmd_data_io.offset + 2[bp]
10199 2C26           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10200 2C29           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10201                                                   ;; adjust if there will be an overrun. 2K max sector size
10202 2C2C           81FF                 F800          cmp di, #0xf800 ;;
10203 2C30           76           07                    jbe ata_in_no_adjust
10204                       00002C32            ata_in_adjust:
10205 2C32           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10206 2C36           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10207                       00002C39            ata_in_no_adjust:
10208 2C39           8EC0                               mov es, ax ;; segment in es
10209 2C3B           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data read port
10210 2C3E           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10211 2C41           80FC                   01          cmp ah, #0x01
10212 2C44           74           04                    je ata_in_32
10213                       00002C46            ata_in_16:
10214 2C46           F3                                 rep
10215 2C47           6D                                   insw ;; CX words transferred from port(DX) to ES:[DI]
10216 2C48           EB           03                    jmp ata_in_done
10217                       00002C4A            ata_in_32:
10218 2C4A           F3                                 rep
10219 2C4B     66    6D                                   insd ;; CX dwords transferred from port(DX) to ES:[DI]
10220                       00002C4D            ata_in_done:
10221 2C4D           897E         2A                    mov _ata_cmd_data_io.offset + 2[bp], di
10222 2C50           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10223 2C53           5D                                 pop bp
10224                                           ! 1956 endasm
10225                                           !BCC_ENDASM
10226                                           !BCC_EOS
10227                                           ! 1957     }
10228                                           ! 1958     else
10229                                           ! 1959     {
10230 2C54           EB           36            jmp .280
10231                       00002C56            .27E:
10232                                           ! 1960 #asm
10233                                           !BCC_EOS
10234                                           !BCC_ASM
10235                       00000016            _ata_cmd_data_io.count	set	$16
10236                       0000000A            .ata_cmd_data_io.count	set	$A
10237                       00000026            _ata_cmd_data_io.segment	set	$26
10238                       0000001A            .ata_cmd_data_io.segment	set	$1A
10239                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10240                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10241                       00000005            _ata_cmd_data_io.channel	set	5
10242                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10243                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10244                       00000012            .ata_cmd_data_io.lba_low	set	$12
10245                       00000022            _ata_cmd_data_io.lba_high	set	$22
10246                       00000016            .ata_cmd_data_io.lba_high	set	$16
10247                       0000001C            _ata_cmd_data_io.sector	set	$1C
10248                       00000010            .ata_cmd_data_io.sector	set	$10
10249                       00000006            _ata_cmd_data_io.blksize	set	6
10250                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10251                       0000001A            _ata_cmd_data_io.head	set	$1A
10252                       0000000E            .ata_cmd_data_io.head	set	$E
10253                       00000010            _ata_cmd_data_io.ioflag	set	$10
10254                       00000004            .ata_cmd_data_io.ioflag	set	4
10255                       00000018            _ata_cmd_data_io.cylinder	set	$18
10256                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10257                       00000012            _ata_cmd_data_io.device	set	$12
10258                       00000006            .ata_cmd_data_io.device	set	6
10259                       00000003            _ata_cmd_data_io.status	set	3
10260                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10261                       00000002            _ata_cmd_data_io.current	set	2
10262                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10263                       00000014            _ata_cmd_data_io.command	set	$14
10264                       00000008            .ata_cmd_data_io.command	set	8
10265                       00000001            _ata_cmd_data_io.mode	set	1
10266                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10267                       00000008            _ata_cmd_data_io.iobase2	set	8
10268                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10269                       00000028            _ata_cmd_data_io.offset	set	$28
10270                       0000001C            .ata_cmd_data_io.offset	set	$1C
10271                       00000004            _ata_cmd_data_io.slave	set	4
10272                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10273 2C56           55                                 push bp
10274 2C57           89E5                               mov bp, sp
10275 2C59           8B76         2A                    mov si, _ata_cmd_data_io.offset + 2[bp]
10276 2C5C           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10277 2C5F           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10278                                                   ;; adjust if there will be an overrun. 2K max sector size
10279 2C62           81FE                 F800          cmp si, #0xf800 ;;
10280 2C66           76           07                    jbe ata_out_no_adjust
10281                       00002C68            ata_out_adjust:
10282 2C68           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
10283 2C6C           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10284                       00002C6F            ata_out_no_adjust:
10285 2C6F           8EC0                               mov es, ax ;; segment in es
10286 2C71           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data write port
10287 2C74           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10288 2C77           80FC                   01          cmp ah, #0x01
10289 2C7A           74           05                    je ata_out_32
10290                       00002C7C            ata_out_16:
10291 2C7C           26                                 seg ES
10292 2C7D           F3                                 rep
10293 2C7E           6F                                   outsw ;; CX words transferred from port(DX) to ES:[SI]
10294 2C7F           EB           04                    jmp ata_out_done
10295                       00002C81            ata_out_32:
10296 2C81           26                                 seg ES
10297 2C82           F3                                 rep
10298 2C83     66    6F                                   outsd ;; CX dwords transferred from port(DX) to ES:[SI]
10299                       00002C85            ata_out_done:
10300 2C85           8976         2A                    mov _ata_cmd_data_io.offset + 2[bp], si
10301 2C88           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10302 2C8B           5D                                 pop bp
10303                                           ! 1991 endasm
10304                                           !BCC_ENDASM
10305                                           !BCC_EOS
10306                                           ! 1992     }
10307                                           ! 1993     current++;
10308                       00002C8C            .280:
10309                                           ! Debug: postinc unsigned char current = [S+$E-$C] (used reg = )
10310 2C8C           8A46         F6            mov	al,-$A[bp]
10311 2C8F           40                         inc	ax
10312 2C90           8846         F6            mov	-$A[bp],al
10313                                           !BCC_EOS
10314                                           ! 1994     *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (current);
10315                                           ! Debug: eq unsigned char current = [S+$E-$C] to unsigned short = [+$254] (used reg = )
10316 2C93           8A46         F6            mov	al,-$A[bp]
10317 2C96           30E4                       xor	ah,ah
10318 2C98           A3         0254            mov	[$254],ax
10319                                           !BCC_EOS
10320                                           ! 1995     count--;
10321                                           ! Debug: postdec unsigned short count = [S+$E+8] (used reg = )
10322 2C9B           8B46         0A            mov	ax,$A[bp]
10323 2C9E           48                         dec	ax
10324 2C9F           8946         0A            mov	$A[bp],ax
10325                                           !BCC_EOS
10326                                           ! 1996     if(ioflag == 0) await_ide(2, iobase1, 32000u);
10327                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10328 2CA2           8B46         04            mov	ax,4[bp]
10329 2CA5           85C0                       test	ax,ax
10330 2CA7           75           11            jne 	.281
10331                       00002CA9            .282:
10332                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10333 2CA9           B8                   7D00  mov	ax,#$7D00
10334 2CAC           50                         push	ax
10335                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10336 2CAD           FF76         FE            push	-2[bp]
10337                                           ! Debug: list int = const 2 (used reg = )
10338 2CB0           B8                   0002  mov	ax,*2
10339 2CB3           50                         push	ax
10340                                           ! Debug: func () int = await_ide+0 (used reg = )
10341 2CB4           E8         ED73            call	_await_ide
10342 2CB7           83C4                   06  add	sp,*6
10343                                           !BCC_EOS
10344                                           ! 1997     status = inb(iobase1 + 7);
10345                       00002CBA            .281:
10346                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10347 2CBA           8B46         FE            mov	ax,-2[bp]
10348                                           ! Debug: list unsigned int = ax+7 (used reg = )
10349 2CBD           05                   0007  add	ax,*7
10350 2CC0           50                         push	ax
10351                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10352 2CC1           E8         D865            call	_inb
10353 2CC4           44                         inc	sp
10354 2CC5           44                         inc	sp
10355                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10356 2CC6           8846         F7            mov	-9[bp],al
10357                                           !BCC_EOS
10358                                           ! 1998     if(ioflag == 0)
10359                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10360 2CC9           8B46         04            mov	ax,4[bp]
10361 2CCC           85C0                       test	ax,ax
10362 2CCE           75           2F            jne 	.283
10363                       00002CD0            .284:
10364                                           ! 1999     {
10365                                           ! 2000       if (count == 0) {
10366                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10367 2CD0           8B46         0A            mov	ax,$A[bp]
10368 2CD3           85C0                       test	ax,ax
10369 2CD5           75           14            jne 	.285
10370                       00002CD7            .286:
10371                                           ! 2001         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10372                                           ! 2002             != 0x40 ) {
10373                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10374 2CD7           8A46         F7            mov	al,-9[bp]
10375 2CDA           24                     C9  and	al,#$C9
10376                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10377 2CDC           3C                     40  cmp	al,*$40
10378 2CDE           74           07            je  	.287
10379                       00002CE0            .288:
10380                                           ! 2003           ;
10381                                           !BCC_EOS
10382                                           ! 2004           return 4;
10383 2CE0           B8                   0004  mov	ax,*4
10384 2CE3           89EC                       mov	sp,bp
10385 2CE5           5D                         pop	bp
10386 2CE6           C3                         ret
10387                                           !BCC_EOS
10388                                           ! 2005         }
10389                                           ! 2006         break;
10390                       00002CE7            .287:
10391 2CE7           EB           46            jmp .27B
10392                                           !BCC_EOS
10393                                           ! 2007       }
10394                                           ! 2008       else {
10395 2CE9           EB           12            jmp .289
10396                       00002CEB            .285:
10397                                           ! 2009         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10398                                           ! 2010             != (0x40 | 0x08) ) {
10399                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10400 2CEB           8A46         F7            mov	al,-9[bp]
10401 2CEE           24                     C9  and	al,#$C9
10402                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10403 2CF0           3C                     48  cmp	al,*$48
10404 2CF2           74           07            je  	.28A
10405                       00002CF4            .28B:
10406                                           ! 2011           ;
10407                                           !BCC_EOS
10408                                           ! 2012           return 5;
10409 2CF4           B8                   0005  mov	ax,*5
10410 2CF7           89EC                       mov	sp,bp
10411 2CF9           5D                         pop	bp
10412 2CFA           C3                         ret
10413                                           !BCC_EOS
10414                                           ! 2013         }
10415                                           ! 2014         continue;
10416                       00002CFB            .28A:
10417 2CFB           EB           2F            jmp .27C
10418                                           !BCC_EOS
10419                                           ! 2015       }
10420                                           ! 2016     }
10421                       00002CFD            .289:
10422                                           ! 2017     else
10423                                           ! 2018     {
10424 2CFD           EB           2D            jmp .28C
10425                       00002CFF            .283:
10426                                           ! 2019       if (count == 0) {
10427                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10428 2CFF           8B46         0A            mov	ax,$A[bp]
10429 2D02           85C0                       test	ax,ax
10430 2D04           75           14            jne 	.28D
10431                       00002D06            .28E:
10432                                           ! 2020         if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
10433                                           ! 2021             != 0x40 ) {
10434                                           ! Debug: and int = const $E9 to unsigned char status = [S+$E-$B] (used reg = )
10435 2D06           8A46         F7            mov	al,-9[bp]
10436 2D09           24                     E9  and	al,#$E9
10437                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10438 2D0B           3C                     40  cmp	al,*$40
10439 2D0D           74           07            je  	.28F
10440                       00002D0F            .290:
10441                                           ! 2022           ;
10442                                           !BCC_EOS
10443                                           ! 2023           return 6;
10444 2D0F           B8                   0006  mov	ax,*6
10445 2D12           89EC                       mov	sp,bp
10446 2D14           5D                         pop	bp
10447 2D15           C3                         ret
10448                                           !BCC_EOS
10449                                           ! 2024         }
10450                                           ! 2025         break;
10451                       00002D16            .28F:
10452 2D16           EB           17            jmp .27B
10453                                           !BCC_EOS
10454                                           ! 2026       }
10455                                           ! 2027       else {
10456 2D18           EB           12            jmp .291
10457                       00002D1A            .28D:
10458                                           ! 2028         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10459                                           ! 2029             != (0x40 | 0x08) ) {
10460                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10461 2D1A           8A46         F7            mov	al,-9[bp]
10462 2D1D           24                     C9  and	al,#$C9
10463                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10464 2D1F           3C                     48  cmp	al,*$48
10465 2D21           74           07            je  	.292
10466                       00002D23            .293:
10467                                           ! 2030           ;
10468                                           !BCC_EOS
10469                                           ! 2031           return 7;
10470 2D23           B8                   0007  mov	ax,*7
10471 2D26           89EC                       mov	sp,bp
10472 2D28           5D                         pop	bp
10473 2D29           C3                         ret
10474                                           !BCC_EOS
10475                                           ! 2032         }
10476                                           ! 2033         continue;
10477                       00002D2A            .292:
10478 2D2A           EB           00            jmp .27C
10479                                           !BCC_EOS
10480                                           ! 2034       }
10481                                           ! 2035     }
10482                       00002D2C            .291:
10483                                           ! 2036   }
10484                       00002D2C            .28C:
10485                                           ! 2037   outb(iobase2+6, 0x08);
10486                       00002D2C            .27C:
10487 2D2C           E9         FEEA            br 	.27D
10488                       00002D2F            .294:
10489                       00002D2F            .27B:
10490                                           ! Debug: list int = const 8 (used reg = )
10491 2D2F           B8                   0008  mov	ax,*8
10492 2D32           50                         push	ax
10493                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
10494 2D33           8B46         FC            mov	ax,-4[bp]
10495                                           ! Debug: list unsigned int = ax+6 (used reg = )
10496 2D36           05                   0006  add	ax,*6
10497 2D39           50                         push	ax
10498                                           ! Debug: func () void = outb+0 (used reg = )
10499 2D3A           E8         D802            call	_outb
10500 2D3D           83C4                   04  add	sp,*4
10501                                           !BCC_EOS
10502                                           ! 2038   return 0;
10503 2D40           31C0                       xor	ax,ax
10504 2D42           89EC                       mov	sp,bp
10505 2D44           5D                         pop	bp
10506 2D45           C3                         ret
10507                                           !BCC_EOS
10508                                           ! 2039 }
10509                                           ! 2040 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
10510                                           ! Register BX used in function ata_cmd_data_io
10511                                           ! 2041 Bit8u cmdlen,inout;
10512                                           export	_ata_cmd_packet
10513                       00002D46            _ata_cmd_packet:
10514                                           !BCC_EOS
10515                                           ! 2042 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
10516                                           !BCC_EOS
10517                                           ! 2043 Bit16u header;
10518                                           !BCC_EOS
10519                                           ! 2044 Bit32u length;
10520                                           !BCC_EOS
10521                                           ! 2045 {
10522                                           ! 2046   Bit16u ebda_seg=get_ebda_seg(), old_ds;
10523 2D46           55                         push	bp
10524 2D47           89E5                       mov	bp,sp
10525 2D49           4C                         dec	sp
10526 2D4A           4C                         dec	sp
10527                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
10528 2D4B           E8         D919            call	_get_ebda_seg
10529                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10530 2D4E           8946         FE            mov	-2[bp],ax
10531                                           !BCC_EOS
10532                                           ! 2047   Bit16u iobase1, iobase2;
10533                                           !BCC_EOS
10534                                           ! 2048   Bit16u lcount, lbefore, lafter, count;
10535                                           !BCC_EOS
10536                                           ! 2049   Bit8u channel, slave;
10537                                           !BCC_EOS
10538                                           ! 2050   Bit8u status, mode, lmode;
10539                                           !BCC_EOS
10540                                           ! 2051   Bit32
10541                                           ! 2051 u total, transfer;
10542                                           !BCC_EOS
10543                                           ! 2052   channel = device / 2;
10544 2D51           83C4                   E4  add	sp,*-$1C
10545                                           ! Debug: div int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10546 2D54           8B46         04            mov	ax,4[bp]
10547 2D57           D1E8                       shr	ax,*1
10548                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$20-$13] (used reg = )
10549 2D59           8846         EF            mov	-$11[bp],al
10550                                           !BCC_EOS
10551                                           ! 2053   slave = device % 2;
10552                                           ! Debug: mod int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10553 2D5C           8B46         04            mov	ax,4[bp]
10554 2D5F           24                     01  and	al,*1
10555                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$20-$14] (used reg = )
10556 2D61           8846         EE            mov	-$12[bp],al
10557                                           !BCC_EOS
10558                                           ! 2054   if (inout == 0x02) {
10559                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$20+$10] (used reg = )
10560 2D64           8A46         12            mov	al,$12[bp]
10561 2D67           3C                     02  cmp	al,*2
10562 2D69           75           15            jne 	.295
10563                       00002D6B            .296:
10564                                           ! 2055     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
10565                                           ! Debug: list * char = .297+0 (used reg = )
10566 2D6B           BB                   D650  mov	bx,#.297
10567 2D6E           53                         push	bx
10568                                           ! Debug: list int = const 4 (used reg = )
10569 2D6F           B8                   0004  mov	ax,*4
10570 2D72           50                         push	ax
10571                                           ! Debug: func () void = bios_printf+0 (used reg = )
10572 2D73           E8         DBC3            call	_bios_printf
10573 2D76           83C4                   04  add	sp,*4
10574                                           !BCC_EOS
10575                                           ! 2056     return 1;
10576 2D79           B8                   0001  mov	ax,*1
10577 2D7C           89EC                       mov	sp,bp
10578 2D7E           5D                         pop	bp
10579 2D7F           C3                         ret
10580                                           !BCC_EOS
10581                                           ! 2057   }
10582                                           ! 2058   if (header & 1) {
10583                       00002D80            .295:
10584                                           ! Debug: and int = const 1 to unsigned short header = [S+$20+$A] (used reg = )
10585 2D80           8A46         0C            mov	al,$C[bp]
10586 2D83           24                     01  and	al,*1
10587 2D85           84C0                       test	al,al
10588 2D87           74           07            je  	.298
10589                       00002D89            .299:
10590                                           ! 2059     ;
10591                                           !BCC_EOS
10592                                           ! 2060     return 1;
10593 2D89           B8                   0001  mov	ax,*1
10594 2D8C           89EC                       mov	sp,bp
10595 2D8E           5D                         pop	bp
10596 2D8F           C3                         ret
10597                                           !BCC_EOS
10598                                           ! 2061   }
10599                                           ! 2062   old_ds = set_DS(ebda_seg);
10600                       00002D90            .298:
10601                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
10602 2D90           FF76         FE            push	-2[bp]
10603                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10604 2D93           E8         D8C7            call	_set_DS
10605 2D96           44                         inc	sp
10606 2D97           44                         inc	sp
10607                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$20-6] (used reg = )
10608 2D98           8946         FC            mov	-4[bp],ax
10609                                           !BCC_EOS
10610                                           ! 2063   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
10611                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10612 2D9B           8A46         EF            mov	al,-$11[bp]
10613 2D9E           30E4                       xor	ah,ah
10614 2DA0           B1                     03  mov	cl,*3
10615 2DA2           D3E0                       shl	ax,cl
10616 2DA4           89C3                       mov	bx,ax
10617                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10618                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
10619                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$20-8] (used reg = )
10620 2DA6           8B9F       0124            mov	bx,$124[bx]
10621 2DAA           895E         FA            mov	-6[bp],bx
10622                                           !BCC_EOS
10623                                           ! 2064   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
10624                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10625 2DAD           8A46         EF            mov	al,-$11[bp]
10626 2DB0           30E4                       xor	ah,ah
10627 2DB2           B1                     03  mov	cl,*3
10628 2DB4           D3E0                       shl	ax,cl
10629 2DB6           89C3                       mov	bx,ax
10630                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10631                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
10632                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$20-$A] (used reg = )
10633 2DB8           8B9F       0126            mov	bx,$126[bx]
10634 2DBC           895E         F8            mov	-8[bp],bx
10635                                           !BCC_EOS
10636                                           ! 2065   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
10637                                           ! Debug: ptradd unsigned short device = [S+$20+2] to [8] struct  = const $142 (used reg = )
10638 2DBF           8B46         04            mov	ax,4[bp]
10639 2DC2           B9                   001E  mov	cx,*$1E
10640 2DC5           F7E9                       imul	cx
10641 2DC7           89C3                       mov	bx,ax
10642                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10643                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
10644                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$20-$16] (used reg = )
10645 2DC9           8A87       0146            mov	al,$146[bx]
10646 2DCD           8846         EC            mov	-$14[bp],al
10647                                           !BCC_EOS
10648                                           ! 2066   transfer= 0L;
10649                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$20-$20] (used reg = )
10650 2DD0           31C0                       xor	ax,ax
10651 2DD2           31DB                       xor	bx,bx
10652 2DD4           8946         E2            mov	-$1E[bp],ax
10653 2DD7           895E         E4            mov	-$1C[bp],bx
10654                                           !BCC_EOS
10655                                           ! 2067   if (cmdlen < 12) cmdlen=12;
10656                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10657 2DDA           8A46         06            mov	al,6[bp]
10658 2DDD           3C                     0C  cmp	al,*$C
10659 2DDF           73           05            jae 	.29A
10660                       00002DE1            .29B:
10661                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10662 2DE1           B0                     0C  mov	al,*$C
10663 2DE3           8846         06            mov	6[bp],al
10664                                           !BCC_EOS
10665                                           ! 2068   if (cmdlen > 12) cmdlen=16;
10666                       00002DE6            .29A:
10667                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10668 2DE6           8A46         06            mov	al,6[bp]
10669 2DE9           3C                     0C  cmp	al,*$C
10670 2DEB           76           05            jbe 	.29C
10671                       00002DED            .29D:
10672                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$20+4] (used reg = )
10673 2DED           B0                     10  mov	al,*$10
10674 2DEF           8846         06            mov	6[bp],al
10675                                           !BCC_EOS
10676                                           ! 2069   cmdlen>>=1;
10677                       00002DF2            .29C:
10678                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$20+4] (used reg = )
10679 2DF2           8A46         06            mov	al,6[bp]
10680 2DF5           30E4                       xor	ah,ah
10681 2DF7           D1E8                       shr	ax,*1
10682 2DF9           8846         06            mov	6[bp],al
10683                                           !BCC_EOS
10684                                           ! 2070   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
10685                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
10686 2DFC           31C0                       xor	ax,ax
10687 2DFE           A3         0254            mov	[$254],ax
10688                                           !BCC_EOS
10689                                           ! 2071   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
10690                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
10691 2E01           31C0                       xor	ax,ax
10692 2E03           31DB                       xor	bx,bx
10693 2E05           A3         0256            mov	[$256],ax
10694 2E08           891E       0258            mov	[$258],bx
10695                                           !BCC_EOS
10696                                           ! 2072   set_DS(old_ds);
10697                                           ! Debug: list unsigned short old_ds = [S+$20-6] (used reg = )
10698 2E0C           FF76         FC            push	-4[bp]
10699                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10700 2E0F           E8         D84B            call	_set_DS
10701 2E12           44                         inc	sp
10702 2E13           44                         inc	sp
10703                                           !BCC_EOS
10704                                           ! 2073   status = inb(iobase1 + 7);
10705                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10706 2E14           8B46         FA            mov	ax,-6[bp]
10707                                           ! Debug: list unsigned int = ax+7 (used reg = )
10708 2E17           05                   0007  add	ax,*7
10709 2E1A           50                         push	ax
10710                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10711 2E1B           E8         D70B            call	_inb
10712 2E1E           44                         inc	sp
10713 2E1F           44                         inc	sp
10714                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10715 2E20           8846         ED            mov	-$13[bp],al
10716                                           !BCC_EOS
10717                                           ! 2074   if (status & 0x80) return 2;
10718                                           ! Debug: and int = const $80 to unsigned char status = [S+$20-$15] (used reg = )
10719 2E23           8A46         ED            mov	al,-$13[bp]
10720 2E26           24                     80  and	al,#$80
10721 2E28           84C0                       test	al,al
10722 2E2A           74           07            je  	.29E
10723                       00002E2C            .29F:
10724 2E2C           B8                   0002  mov	ax,*2
10725 2E2F           89EC                       mov	sp,bp
10726 2E31           5D                         pop	bp
10727 2E32           C3                         ret
10728                                           !BCC_EOS
10729                                           ! 2075   outb(iobase2 + 6, 0x08 | 0x02);
10730                       00002E33            .29E:
10731                                           ! Debug: list int = const $A (used reg = )
10732 2E33           B8                   000A  mov	ax,*$A
10733 2E36           50                         push	ax
10734                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
10735 2E37           8B46         F8            mov	ax,-8[bp]
10736                                           ! Debug: list unsigned int = ax+6 (used reg = )
10737 2E3A           05                   0006  add	ax,*6
10738 2E3D           50                         push	ax
10739                                           ! Debug: func () void = outb+0 (used reg = )
10740 2E3E           E8         D6FE            call	_outb
10741 2E41           83C4                   04  add	sp,*4
10742                                           !BCC_EOS
10743                                           ! 2076   outb(iobase1 + 1, 0x00);
10744                                           ! Debug: list int = const 0 (used reg = )
10745 2E44           31C0                       xor	ax,ax
10746 2E46           50                         push	ax
10747                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$22-8] (used reg = )
10748 2E47           8B46         FA            mov	ax,-6[bp]
10749                                           ! Debug: list unsigned int = ax+1 (used reg = )
10750 2E4A           40                         inc	ax
10751 2E4B           50                         push	ax
10752                                           ! Debug: func () void = outb+0 (used reg = )
10753 2E4C           E8         D6F0            call	_outb
10754 2E4F           83C4                   04  add	sp,*4
10755                                           !BCC_EOS
10756                                           ! 2077   outb(iobase1 + 2, 0x00);
10757                                           ! Debug: list int = const 0 (used reg = )
10758 2E52           31C0                       xor	ax,ax
10759 2E54           50                         push	ax
10760                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-8] (used reg = )
10761 2E55           8B46         FA            mov	ax,-6[bp]
10762                                           ! Debug: list unsigned int = ax+2 (used reg = )
10763 2E58           40                         inc	ax
10764 2E59           40                         inc	ax
10765 2E5A           50                         push	ax
10766                                           ! Debug: func () void = outb+0 (used reg = )
10767 2E5B           E8         D6E1            call	_outb
10768 2E5E           83C4                   04  add	sp,*4
10769                                           !BCC_EOS
10770                                           ! 2078   outb(iobase1 + 3, 0x00);
10771                                           ! Debug: list int = const 0 (used reg = )
10772 2E61           31C0                       xor	ax,ax
10773 2E63           50                         push	ax
10774                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$22-8] (used reg = )
10775 2E64           8B46         FA            mov	ax,-6[bp]
10776                                           ! Debug: list unsigned int = ax+3 (used reg = )
10777 2E67           05                   0003  add	ax,*3
10778 2E6A           50                         push	ax
10779                                           ! Debug: func () void = outb+0 (used reg = )
10780 2E6B           E8         D6D1            call	_outb
10781 2E6E           83C4                   04  add	sp,*4
10782                                           !BCC_EOS
10783                                           ! 2079   outb(iobase1 + 4, 0xfff0 & 0x00ff);
10784                                           ! Debug: list unsigned int = const $F0 (used reg = )
10785 2E71           B8                   00F0  mov	ax,#$F0
10786 2E74           50                         push	ax
10787                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-8] (used reg = )
10788 2E75           8B46         FA            mov	ax,-6[bp]
10789                                           ! Debug: list unsigned int = ax+4 (used reg = )
10790 2E78           05                   0004  add	ax,*4
10791 2E7B           50                         push	ax
10792                                           ! Debug: func () void = outb+0 (used reg = )
10793 2E7C           E8         D6C0            call	_outb
10794 2E7F           83C4                   04  add	sp,*4
10795                                           !BCC_EOS
10796                                           ! 2080   outb(iobase1 + 5, 0xfff0 >> 8);
10797                                           ! Debug: list unsigned int = const $FF (used reg = )
10798 2E82           B8                   00FF  mov	ax,#$FF
10799 2E85           50                         push	ax
10800                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$22-8] (used reg = )
10801 2E86           8B46         FA            mov	ax,-6[bp]
10802                                           ! Debug: list unsigned int = ax+5 (used reg = )
10803 2E89           05                   0005  add	ax,*5
10804 2E8C           50                         push	ax
10805                                           ! Debug: func () void = outb+0 (used reg = )
10806 2E8D           E8         D6AF            call	_outb
10807 2E90           83C4                   04  add	sp,*4
10808                                           !BCC_EOS
10809                                           ! 2081   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
10810 2E93           8A46         EE            mov	al,-$12[bp]
10811 2E96           84C0                       test	al,al
10812 2E98           74           04            je  	.2A0
10813                       00002E9A            .2A1:
10814 2E9A           B0                     B0  mov	al,#$B0
10815 2E9C           EB           02            jmp .2A2
10816                       00002E9E            .2A0:
10817 2E9E           B0                     A0  mov	al,#$A0
10818                       00002EA0            .2A2:
10819                                           ! Debug: list char = al+0 (used reg = )
10820 2EA0           30E4                       xor	ah,ah
10821 2EA2           50                         push	ax
10822                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$22-8] (used reg = )
10823 2EA3           8B46         FA            mov	ax,-6[bp]
10824                                           ! Debug: list unsigned int = ax+6 (used reg = )
10825 2EA6           05                   0006  add	ax,*6
10826 2EA9           50                         push	ax
10827                                           ! Debug: func () void = outb+0 (used reg = )
10828 2EAA           E8         D692            call	_outb
10829 2EAD           83C4                   04  add	sp,*4
10830                                           !BCC_EOS
10831                                           ! 2082   outb(iobase1 + 7, 0xA0);
10832                                           ! Debug: list int = const $A0 (used reg = )
10833 2EB0           B8                   00A0  mov	ax,#$A0
10834 2EB3           50                         push	ax
10835                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-8] (used reg = )
10836 2EB4           8B46         FA            mov	ax,-6[bp]
10837                                           ! Debug: list unsigned int = ax+7 (used reg = )
10838 2EB7           05                   0007  add	ax,*7
10839 2EBA           50                         push	ax
10840                                           ! Debug: func () void = outb+0 (used reg = )
10841 2EBB           E8         D681            call	_outb
10842 2EBE           83C4                   04  add	sp,*4
10843                                           !BCC_EOS
10844                                           ! 2083   await_ide(3, iobase1, 32000u);
10845                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10846 2EC1           B8                   7D00  mov	ax,#$7D00
10847 2EC4           50                         push	ax
10848                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10849 2EC5           FF76         FA            push	-6[bp]
10850                                           ! Debug: list int = const 3 (used reg = )
10851 2EC8           B8                   0003  mov	ax,*3
10852 2ECB           50                         push	ax
10853                                           ! Debug: func () int = await_ide+0 (used reg = )
10854 2ECC           E8         EB5B            call	_await_ide
10855 2ECF           83C4                   06  add	sp,*6
10856                                           !BCC_EOS
10857                                           ! 2084   status = inb(iobase1 + 7);
10858                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10859 2ED2           8B46         FA            mov	ax,-6[bp]
10860                                           ! Debug: list unsigned int = ax+7 (used reg = )
10861 2ED5           05                   0007  add	ax,*7
10862 2ED8           50                         push	ax
10863                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10864 2ED9           E8         D64D            call	_inb
10865 2EDC           44                         inc	sp
10866 2EDD           44                         inc	sp
10867                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10868 2EDE           8846         ED            mov	-$13[bp],al
10869                                           !BCC_EOS
10870                                           ! 2085   if (status & 0x01) {
10871                                           ! Debug: and int = const 1 to unsigned char status = [S+$20-$15] (used reg = )
10872 2EE1           8A46         ED            mov	al,-$13[bp]
10873 2EE4           24                     01  and	al,*1
10874 2EE6           84C0                       test	al,al
10875 2EE8           74           09            je  	.2A3
10876                       00002EEA            .2A4:
10877                                           ! 2086     ;
10878                                           !BCC_EOS
10879                                           ! 2087     return 3;
10880 2EEA           B8                   0003  mov	ax,*3
10881 2EED           89EC                       mov	sp,bp
10882 2EEF           5D                         pop	bp
10883 2EF0           C3                         ret
10884                                           !BCC_EOS
10885                                           ! 2088   } else if ( !(status & 0x08) ) {
10886 2EF1           EB           10            jmp .2A5
10887                       00002EF3            .2A3:
10888                                           ! Debug: and int = const 8 to unsigned char status = [S+$20-$15] (used reg = )
10889 2EF3           8A46         ED            mov	al,-$13[bp]
10890 2EF6           24                     08  and	al,*8
10891 2EF8           84C0                       test	al,al
10892 2EFA           75           07            jne 	.2A6
10893                       00002EFC            .2A7:
10894                                           ! 2089     ;
10895                                           !BCC_EOS
10896                                           ! 2090     return 4;
10897 2EFC           B8                   0004  mov	ax,*4
10898 2EFF           89EC                       mov	sp,bp
10899 2F01           5D                         pop	bp
10900 2F02           C3                         ret
10901                                           !BCC_EOS
10902                                           ! 2091   }
10903                                           ! 2092   cmdseg += (cmdoff / 16);
10904                       00002F03            .2A6:
10905                       00002F03            .2A5:
10906                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10907 2F03           8B46         0A            mov	ax,$A[bp]
10908 2F06           B1                     04  mov	cl,*4
10909 2F08           D3E8                       shr	ax,cl
10910                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$20+6] (used reg = )
10911 2F0A           0346         08            add	ax,8[bp]
10912 2F0D           8946         08            mov	8[bp],ax
10913                                           !BCC_EOS
10914                                           ! 2093   cmdoff %= 16;
10915                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10916 2F10           8B46         0A            mov	ax,$A[bp]
10917 2F13           24                     0F  and	al,*$F
10918 2F15           30E4                       xor	ah,ah
10919 2F17           8946         0A            mov	$A[bp],ax
10920                                           !BCC_EOS
10921                                           ! 2094 #asm
10922                                           !BCC_EOS
10923                                           !BCC_ASM
10924                       00000028            _ata_cmd_packet.cmdoff	set	$28
10925                       0000000A            .ata_cmd_packet.cmdoff	set	$A
10926                       0000002A            _ata_cmd_packet.header	set	$2A
10927                       0000000C            .ata_cmd_packet.header	set	$C
10928                       0000000E            _ata_cmd_packet.count	set	$E
10929                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
10930                       00000010            _ata_cmd_packet.lafter	set	$10
10931                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
10932                       00000018            _ata_cmd_packet.iobase1	set	$18
10933                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
10934                       0000000D            _ata_cmd_packet.channel	set	$D
10935                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
10936                       00000026            _ata_cmd_packet.cmdseg	set	$26
10937                       00000008            .ata_cmd_packet.cmdseg	set	8
10938                       00000024            _ata_cmd_packet.cmdlen	set	$24
10939                       00000006            .ata_cmd_packet.cmdlen	set	6
10940                       00000009            _ata_cmd_packet.lmode	set	9
10941                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
10942                       00000022            _ata_cmd_packet.device	set	$22
10943                       00000004            .ata_cmd_packet.device	set	4
10944                       0000001C            _ata_cmd_packet.ebda_seg	set	$1C
10945                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
10946                       00000014            _ata_cmd_packet.lcount	set	$14
10947                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
10948                       00000004            _ata_cmd_packet.total	set	4
10949                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
10950                       0000000B            _ata_cmd_packet.status	set	$B
10951                       FFFFFFED            .ata_cmd_packet.status	set	-$13
10952                       0000000A            _ata_cmd_packet.mode	set	$A
10953                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
10954                       00000034            _ata_cmd_packet.bufoff	set	$34
10955                       00000016            .ata_cmd_packet.bufoff	set	$16
10956                       00000000            _ata_cmd_packet.transfer	set	0
10957                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
10958                       00000016            _ata_cmd_packet.iobase2	set	$16
10959                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
10960                       00000012            _ata_cmd_packet.lbefore	set	$12
10961                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
10962                       00000032            _ata_cmd_packet.bufseg	set	$32
10963                       00000014            .ata_cmd_packet.bufseg	set	$14
10964                       0000000C            _ata_cmd_packet.slave	set	$C
10965                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
10966                       00000030            _ata_cmd_packet.inout	set	$30
10967                       00000012            .ata_cmd_packet.inout	set	$12
10968                       0000001A            _ata_cmd_packet.old_ds	set	$1A
10969                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
10970                       0000002C            _ata_cmd_packet.length	set	$2C
10971                       0000000E            .ata_cmd_packet.length	set	$E
10972 2F1A           FB                               sti ;; enable higher priority interrupts
10973 2F1B           55                               push bp
10974 2F1C           89E5                             mov bp, sp
10975 2F1E           8B76         2A                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
10976 2F21           8B46         28                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
10977 2F24           8B4E         26                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
10978 2F27           8EC0                             mov es, ax ;; segment in es
10979 2F29           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
10980 2F2C           26                               seg ES
10981 2F2D           F3                               rep
10982 2F2E           6F                                 outsw ;; CX words transferred from port(DX) to ES:[SI]
10983 2F2F           5D                               pop bp
10984                                           ! 2107 endasm
10985                                           !BCC_ENDASM
10986                                           !BCC_EOS
10987                                           ! 2108   if (inout == 0x00) {
10988                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$20+$10] (used reg = )
10989 2F30           8A46         12            mov	al,$12[bp]
10990 2F33           84C0                       test	al,al
10991 2F35           75           23            jne 	.2A8
10992                       00002F37            .2A9:
10993                                           ! 2109     await_ide(2, iobase1, 32000u);
10994                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10995 2F37           B8                   7D00  mov	ax,#$7D00
10996 2F3A           50                         push	ax
10997                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10998 2F3B           FF76         FA            push	-6[bp]
10999                                           ! Debug: list int = const 2 (used reg = )
11000 2F3E           B8                   0002  mov	ax,*2
11001 2F41           50                         push	ax
11002                                           ! Debug: func () int = await_ide+0 (used reg = )
11003 2F42           E8         EAE5            call	_await_ide
11004 2F45           83C4                   06  add	sp,*6
11005                                           !BCC_EOS
11006                                           ! 2110     status = inb(iobase1 + 7);
11007                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
11008 2F48           8B46         FA            mov	ax,-6[bp]
11009                                           ! Debug: list unsigned int = ax+7 (used reg = )
11010 2F4B           05                   0007  add	ax,*7
11011 2F4E           50                         push	ax
11012                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11013 2F4F           E8         D5D7            call	_inb
11014 2F52           44                         inc	sp
11015 2F53           44                         inc	sp
11016                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
11017 2F54           8846         ED            mov	-$13[bp],al
11018                                           !BCC_EOS
11019                                           ! 2111   }
11020                                           ! 2112   else {
11021 2F57           E9         026F            br 	.2AA
11022                       00002F5A            .2A8:
11023                                           ! 2113     Bit16u loops = 0;
11024 2F5A           4C                         dec	sp
11025 2F5B           4C                         dec	sp
11026                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$22-$22] (used reg = )
11027 2F5C           31C0                       xor	ax,ax
11028 2F5E           8946         E0            mov	-$20[bp],ax
11029                                           !BCC_EOS
11030                                           ! 2114     Bit8u sc;
11031                                           !BCC_EOS
11032                                           ! 2115     while (1) {
11033 2F61           4C                         dec	sp
11034 2F62           4C                         dec	sp
11035                       00002F63            .2AD:
11036                                           ! 2116       if (loops == 0) {
11037                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$24-$22] (used reg = )
11038 2F63           8B46         E0            mov	ax,-$20[bp]
11039 2F66           85C0                       test	ax,ax
11040 2F68           75           22            jne 	.2AE
11041                       00002F6A            .2AF:
11042                                           ! 2117         status = inb(iobase2 + 6);
11043                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$24-$A] (used reg = )
11044 2F6A           8B46         F8            mov	ax,-8[bp]
11045                                           ! Debug: list unsigned int = ax+6 (used reg = )
11046 2F6D           05                   0006  add	ax,*6
11047 2F70           50                         push	ax
11048                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11049 2F71           E8         D5B5            call	_inb
11050 2F74           44                         inc	sp
11051 2F75           44                         inc	sp
11052                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11053 2F76           8846         ED            mov	-$13[bp],al
11054                                           !BCC_EOS
11055                                           ! 2118         await_ide(3, iobase1, 32000u);
11056                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11057 2F79           B8                   7D00  mov	ax,#$7D00
11058 2F7C           50                         push	ax
11059                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11060 2F7D           FF76         FA            push	-6[bp]
11061                                           ! Debug: list int = const 3 (used reg = )
11062 2F80           B8                   0003  mov	ax,*3
11063 2F83           50                         push	ax
11064                                           ! Debug: func () int = await_ide+0 (used reg = )
11065 2F84           E8         EAA3            call	_await_ide
11066 2F87           83C4                   06  add	sp,*6
11067                                           !BCC_EOS
11068                                           ! 2119       }
11069                                           ! 2120       else
11070                                           ! 2121         await_ide(2, iobase1, 32000u);
11071 2F8A           EB           11            jmp .2B0
11072                       00002F8C            .2AE:
11073                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11074 2F8C           B8                   7D00  mov	ax,#$7D00
11075 2F8F           50                         push	ax
11076                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11077 2F90           FF76         FA            push	-6[bp]
11078                                           ! Debug: list int = const 2 (used reg = )
11079 2F93           B8                   0002  mov	ax,*2
11080 2F96           50                         push	ax
11081                                           ! Debug: func () int = await_ide+0 (used reg = )
11082 2F97           E8         EA90            call	_await_ide
11083 2F9A           83C4                   06  add	sp,*6
11084                                           !BCC_EOS
11085                                           ! 2122       loops++;
11086                       00002F9D            .2B0:
11087                                           ! Debug: postinc unsigned short loops = [S+$24-$22] (used reg = )
11088 2F9D           8B46         E0            mov	ax,-$20[bp]
11089 2FA0           40                         inc	ax
11090 2FA1           8946         E0            mov	-$20[bp],ax
11091                                           !BCC_EOS
11092                                           ! 2123       status = inb(iobase1 + 7);
11093                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$24-8] (used reg = )
11094 2FA4           8B46         FA            mov	ax,-6[bp]
11095                                           ! Debug: list unsigned int = ax+7 (used reg = )
11096 2FA7           05                   0007  add	ax,*7
11097 2FAA           50                         push	ax
11098                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11099 2FAB           E8         D57B            call	_inb
11100 2FAE           44                         inc	sp
11101 2FAF           44                         inc	sp
11102                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11103 2FB0           8846         ED            mov	-$13[bp],al
11104                                           !BCC_EOS
11105                                           ! 2124       sc = inb(iobase1 + 2);
11106                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11107 2FB3           8B46         FA            mov	ax,-6[bp]
11108                                           ! Debug: list unsigned int = ax+2 (used reg = )
11109 2FB6           40                         inc	ax
11110 2FB7           40                         inc	ax
11111 2FB8           50                         push	ax
11112                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11113 2FB9           E8         D56D            call	_inb
11114 2FBC           44                         inc	sp
11115 2FBD           44                         inc	sp
11116                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$24-$23] (used reg = )
11117 2FBE           8846         DF            mov	-$21[bp],al
11118                                           !BCC_EOS
11119                                           ! 2125  
11120                                           ! 2125      if(((inb(iobase1 + 2)&0x7)==0x3) &&
11121                                           ! 2126          ((status & (0x40 | 0x01)) == 0x40)) break;
11122                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11123 2FC1           8B46         FA            mov	ax,-6[bp]
11124                                           ! Debug: list unsigned int = ax+2 (used reg = )
11125 2FC4           40                         inc	ax
11126 2FC5           40                         inc	ax
11127 2FC6           50                         push	ax
11128                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11129 2FC7           E8         D55F            call	_inb
11130 2FCA           44                         inc	sp
11131 2FCB           44                         inc	sp
11132                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
11133 2FCC           24                     07  and	al,*7
11134                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
11135 2FCE           3C                     03  cmp	al,*3
11136 2FD0           75           0C            jne 	.2B1
11137                       00002FD2            .2B3:
11138                                           ! Debug: and int = const $41 to unsigned char status = [S+$24-$15] (used reg = )
11139 2FD2           8A46         ED            mov	al,-$13[bp]
11140 2FD5           24                     41  and	al,*$41
11141                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
11142 2FD7           3C                     40  cmp	al,*$40
11143 2FD9           75           03            jne 	.2B1
11144                       00002FDB            .2B2:
11145 2FDB           E9         01E8            br 	.2AB
11146                                           !BCC_EOS
11147                                           ! 2127       if (status & 0x01) {
11148                       00002FDE            .2B1:
11149                                           ! Debug: and int = const 1 to unsigned char status = [S+$24-$15] (used reg = )
11150 2FDE           8A46         ED            mov	al,-$13[bp]
11151 2FE1           24                     01  and	al,*1
11152 2FE3           84C0                       test	al,al
11153 2FE5           74           07            je  	.2B4
11154                       00002FE7            .2B5:
11155                                           ! 2128         ;
11156                                           !BCC_EOS
11157                                           ! 2129         return 3;
11158 2FE7           B8                   0003  mov	ax,*3
11159 2FEA           89EC                       mov	sp,bp
11160 2FEC           5D                         pop	bp
11161 2FED           C3                         ret
11162                                           !BCC_EOS
11163                                           ! 2130       }
11164                                           ! 2131       bufseg += (bufoff / 16);
11165                       00002FEE            .2B4:
11166                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11167 2FEE           8B46         16            mov	ax,$16[bp]
11168 2FF1           B1                     04  mov	cl,*4
11169 2FF3           D3E8                       shr	ax,cl
11170                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$24+$12] (used reg = )
11171 2FF5           0346         14            add	ax,$14[bp]
11172 2FF8           8946         14            mov	$14[bp],ax
11173                                           !BCC_EOS
11174                                           ! 2132       bufoff %= 16;
11175                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11176 2FFB           8B46         16            mov	ax,$16[bp]
11177 2FFE           24                     0F  and	al,*$F
11178 3000           30E4                       xor	ah,ah
11179 3002           8946         16            mov	$16[bp],ax
11180                                           !BCC_EOS
11181                                           ! 2133       *((Bit8u *)&lcount) = inb(iobase1 + 4);
11182                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$24-8] (used reg = )
11183 3005           8B46         FA            mov	ax,-6[bp]
11184                                           ! Debug: list unsigned int = ax+4 (used reg = )
11185 3008           05                   0004  add	ax,*4
11186 300B           50                         push	ax
11187                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11188 300C           E8         D51A            call	_inb
11189 300F           44                         inc	sp
11190 3010           44                         inc	sp
11191                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$C] (used reg = )
11192 3011           8846         F6            mov	-$A[bp],al
11193                                           !BCC_EOS
11194                                           ! 2134       *(((Bit8u *)&lcount)+1) = inb(iobase1 + 5);
11195                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-8] (used reg = )
11196 3014           8B46         FA            mov	ax,-6[bp]
11197                                           ! Debug: list unsigned int = ax+5 (used reg = )
11198 3017           05                   0005  add	ax,*5
11199 301A           50                         push	ax
11200                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11201 301B           E8         D50B            call	_inb
11202 301E           44                         inc	sp
11203 301F           44                         inc	sp
11204                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$B] (used reg = )
11205 3020           8846         F7            mov	-9[bp],al
11206                                           !BCC_EOS
11207                                           ! 2135       if(header>lcount) {
11208                                           ! Debug: gt unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11209 3023           8B46         0C            mov	ax,$C[bp]
11210 3026           3B46         F6            cmp	ax,-$A[bp]
11211 3029           76           16            jbe 	.2B6
11212                       0000302B            .2B7:
11213                                           ! 2136          lbefore=lcount;
11214                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short lbefore = [S+$24-$E] (used reg = )
11215 302B           8B46         F6            mov	ax,-$A[bp]
11216 302E           8946         F4            mov	-$C[bp],ax
11217                                           !BCC_EOS
11218                                           ! 2137          header-=lcount;
11219                                           ! Debug: subab unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11220 3031           8B46         0C            mov	ax,$C[bp]
11221 3034           2B46         F6            sub	ax,-$A[bp]
11222 3037           8946         0C            mov	$C[bp],ax
11223                                           !BCC_EOS
11224                                           ! 2138          lcount=0;
11225                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11226 303A           31C0                       xor	ax,ax
11227 303C           8946         F6            mov	-$A[bp],ax
11228                                           !BCC_EOS
11229                                           ! 2139       }
11230                                           ! 2140       else {
11231 303F           EB           14            jmp .2B8
11232                       00003041            .2B6:
11233                                           ! 2141         lbefore=header;
11234                                           ! Debug: eq unsigned short header = [S+$24+$A] to unsigned short lbefore = [S+$24-$E] (used reg = )
11235 3041           8B46         0C            mov	ax,$C[bp]
11236 3044           8946         F4            mov	-$C[bp],ax
11237                                           !BCC_EOS
11238                                           ! 2142         header=0;
11239                                           ! Debug: eq int = const 0 to unsigned short header = [S+$24+$A] (used reg = )
11240 3047           31C0                       xor	ax,ax
11241 3049           8946         0C            mov	$C[bp],ax
11242                                           !BCC_EOS
11243                                           ! 2143         lcount-=lbefore;
11244                                           ! Debug: subab unsigned short lbefore = [S+$24-$E] to unsigned short lcount = [S+$24-$C] (used reg = )
11245 304C           8B46         F6            mov	ax,-$A[bp]
11246 304F           2B46         F4            sub	ax,-$C[bp]
11247 3052           8946         F6            mov	-$A[bp],ax
11248                                           !BCC_EOS
11249                                           ! 2144       }
11250                                           ! 2145       if(lcount>length) {
11251                       00003055            .2B8:
11252                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11253 3055           8B46         F6            mov	ax,-$A[bp]
11254 3058           31DB                       xor	bx,bx
11255                                           ! Debug: gt unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11256 305A           8D7E         0E            lea	di,$E[bp]
11257 305D           E8         D03C            call	lcmpul
11258 3060           76           20            jbe 	.2B9
11259                       00003062            .2BA:
11260                                           ! 2146         lafter=lcount-length;
11261                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11262 3062           8B46         F6            mov	ax,-$A[bp]
11263 3065           31DB                       xor	bx,bx
11264                                           ! Debug: sub unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11265 3067           8D7E         0E            lea	di,$E[bp]
11266 306A           E8         D045            call	lsubul
11267                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$24-$10] (used reg = )
11268 306D           8946         F2            mov	-$E[bp],ax
11269                                           !BCC_EOS
11270                                           ! 2147         lcount=length;
11271                                           ! Debug: eq unsigned long length = [S+$24+$C] to unsigned short lcount = [S+$24-$C] (used reg = )
11272 3070           8B46         0E            mov	ax,$E[bp]
11273 3073           8946         F6            mov	-$A[bp],ax
11274                                           !BCC_EOS
11275                                           ! 2148         length=0;
11276                                           ! Debug: eq int = const 0 to unsigned long length = [S+$24+$C] (used reg = )
11277 3076           31C0                       xor	ax,ax
11278 3078           31DB                       xor	bx,bx
11279 307A           8946         0E            mov	$E[bp],ax
11280 307D           895E         10            mov	$10[bp],bx
11281                                           !BCC_EOS
11282                                           ! 2149       }
11283                                           ! 2150       else {
11284 3080           EB           21            jmp .2BB
11285                       00003082            .2B9:
11286                                           ! 2151         lafter=0;
11287                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11288 3082           31C0                       xor	ax,ax
11289 3084           8946         F2            mov	-$E[bp],ax
11290                                           !BCC_EOS
11291                                           ! 2152         length-=lcount;
11292                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11293 3087           8B46         F6            mov	ax,-$A[bp]
11294 308A           31DB                       xor	bx,bx
11295                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$24+$C] (used reg = )
11296 308C           53                         push	bx
11297 308D           50                         push	ax
11298 308E           8B46         0E            mov	ax,$E[bp]
11299 3091           8B5E         10            mov	bx,$10[bp]
11300 3094           8D7E         DA            lea	di,-$26[bp]
11301 3097           E8         D018            call	lsubul
11302 309A           8946         0E            mov	$E[bp],ax
11303 309D           895E         10            mov	$10[bp],bx
11304 30A0           83C4                   04  add	sp,*4
11305                                           !BCC_EOS
11306                                           ! 2153       }
11307                                           ! 2154       count = lcount;
11308                       000030A3            .2BB:
11309                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short count = [S+$24-$12] (used reg = )
11310 30A3           8B46         F6            mov	ax,-$A[bp]
11311 30A6           8946         F0            mov	-$10[bp],ax
11312                                           !BCC_EOS
11313                                           ! 2155       ;
11314                                           !BCC_EOS
11315                                           ! 2156       ;
11316                                           !BCC_EOS
11317                                           ! 2157       lmode = mode;
11318                                           ! Debug: eq unsigned char mode = [S+$24-$16] to unsigned char lmode = [S+$24-$17] (used reg = )
11319 30A9           8A46         EC            mov	al,-$14[bp]
11320 30AC           8846         EB            mov	-$15[bp],al
11321                                           !BCC_EOS
11322                                           ! 2158       if (lbefore & 0x03) lmode=0x00;
11323                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$24-$E] (used reg = )
11324 30AF           8A46         F4            mov	al,-$C[bp]
11325 30B2           24                     03  and	al,*3
11326 30B4           84C0                       test	al,al
11327 30B6           74           05            je  	.2BC
11328                       000030B8            .2BD:
11329                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11330 30B8           30C0                       xor	al,al
11331 30BA           8846         EB            mov	-$15[bp],al
11332                                           !BCC_EOS
11333                                           ! 2159       if (lcount & 0x03) lmode=0x00;
11334                       000030BD            .2BC:
11335                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$24-$C] (used reg = )
11336 30BD           8A46         F6            mov	al,-$A[bp]
11337 30C0           24                     03  and	al,*3
11338 30C2           84C0                       test	al,al
11339 30C4           74           05            je  	.2BE
11340                       000030C6            .2BF:
11341                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11342 30C6           30C0                       xor	al,al
11343 30C8           8846         EB            mov	-$15[bp],al
11344                                           !BCC_EOS
11345                                           ! 2160       if (lafter & 0x03) lmode=0x00;
11346                       000030CB            .2BE:
11347                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$24-$10] (used reg = )
11348 30CB           8A46         F2            mov	al,-$E[bp]
11349 30CE           24                     03  and	al,*3
11350 30D0           84C0                       test	al,al
11351 30D2           74           05            je  	.2C0
11352                       000030D4            .2C1:
11353                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11354 30D4           30C0                       xor	al,al
11355 30D6           8846         EB            mov	-$15[bp],al
11356                                           !BCC_EOS
11357                                           ! 2161       if (lcount & 0x01) {
11358                       000030D9            .2C0:
11359                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11360 30D9           8A46         F6            mov	al,-$A[bp]
11361 30DC           24                     01  and	al,*1
11362 30DE           84C0                       test	al,al
11363 30E0           74           1E            je  	.2C2
11364                       000030E2            .2C3:
11365                                           ! 2162         lcount+=1;
11366                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11367 30E2           8B46         F6            mov	ax,-$A[bp]
11368 30E5           40                         inc	ax
11369 30E6           8946         F6            mov	-$A[bp],ax
11370                                           !BCC_EOS
11371                                           ! 2163         if ((lafter > 0) && (lafter & 0x01)) {
11372                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11373 30E9           8B46         F2            mov	ax,-$E[bp]
11374 30EC           85C0                       test	ax,ax
11375 30EE           74           10            je  	.2C4
11376                       000030F0            .2C6:
11377                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11378 30F0           8A46         F2            mov	al,-$E[bp]
11379 30F3           24                     01  and	al,*1
11380 30F5           84C0                       test	al,al
11381 30F7           74           07            je  	.2C4
11382                       000030F9            .2C5:
11383                                           ! 2164           lafter-=1;
11384                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11385 30F9           8B46         F2            mov	ax,-$E[bp]
11386 30FC           48                         dec	ax
11387 30FD           8946         F2            mov	-$E[bp],ax
11388                                           !BCC_EOS
11389                                           ! 2165         }
11390                                           ! 2166       }
11391                       00003100            .2C4:
11392                                           ! 2167       if (lmode == 0x01) {
11393                       00003100            .2C2:
11394                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$24-$17] (used reg = )
11395 3100           8A46         EB            mov	al,-$15[bp]
11396 3103           3C                     01  cmp	al,*1
11397 3105           75           20            jne 	.2C7
11398                       00003107            .2C8:
11399                                           ! 2168         lcount>>=2; lbefore>>=2; lafter>>=2;
11400                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$24-$C] (used reg = )
11401 3107           8B46         F6            mov	ax,-$A[bp]
11402 310A           D1E8                       shr	ax,*1
11403 310C           D1E8                       shr	ax,*1
11404 310E           8946         F6            mov	-$A[bp],ax
11405                                           !BCC_EOS
11406                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$24-$E] (used reg = )
11407 3111           8B46         F4            mov	ax,-$C[bp]
11408 3114           D1E8                       shr	ax,*1
11409 3116           D1E8                       shr	ax,*1
11410 3118           8946         F4            mov	-$C[bp],ax
11411                                           !BCC_EOS
11412                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$24-$10] (used reg = )
11413 311B           8B46         F2            mov	ax,-$E[bp]
11414 311E           D1E8                       shr	ax,*1
11415 3120           D1E8                       shr	ax,*1
11416 3122           8946         F2            mov	-$E[bp],ax
11417                                           !BCC_EOS
11418                                           ! 2169       }
11419                                           ! 2170       else {
11420 3125           EB           18            jmp .2C9
11421                       00003127            .2C7:
11422                                           ! 2171         lcount>>=1; lbefore>>=1; lafter>>=1;
11423                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11424 3127           8B46         F6            mov	ax,-$A[bp]
11425 312A           D1E8                       shr	ax,*1
11426 312C           8946         F6            mov	-$A[bp],ax
11427                                           !BCC_EOS
11428                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$24-$E] (used reg = )
11429 312F           8B46         F4            mov	ax,-$C[bp]
11430 3132           D1E8                       shr	ax,*1
11431 3134           8946         F4            mov	-$C[bp],ax
11432                                           !BCC_EOS
11433                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11434 3137           8B46         F2            mov	ax,-$E[bp]
11435 313A           D1E8                       shr	ax,*1
11436 313C           8946         F2            mov	-$E[bp],ax
11437                                           !BCC_EOS
11438                                           ! 2172       }
11439                                           ! 2173        ;
11440                       0000313F            .2C9:
11441                                           !BCC_EOS
11442                                           ! 2174 #asm
11443                                           !BCC_EOS
11444                                           !BCC_ASM
11445                       0000002C            _ata_cmd_packet.cmdoff	set	$2C
11446                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11447                       0000002E            _ata_cmd_packet.header	set	$2E
11448                       0000000C            .ata_cmd_packet.header	set	$C
11449                       00000012            _ata_cmd_packet.count	set	$12
11450                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
11451                       00000014            _ata_cmd_packet.lafter	set	$14
11452                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
11453                       0000001C            _ata_cmd_packet.iobase1	set	$1C
11454                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
11455                       00000011            _ata_cmd_packet.channel	set	$11
11456                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
11457                       0000002A            _ata_cmd_packet.cmdseg	set	$2A
11458                       00000008            .ata_cmd_packet.cmdseg	set	8
11459                       00000028            _ata_cmd_packet.cmdlen	set	$28
11460                       00000006            .ata_cmd_packet.cmdlen	set	6
11461                       0000000D            _ata_cmd_packet.lmode	set	$D
11462                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11463                       00000026            _ata_cmd_packet.device	set	$26
11464                       00000004            .ata_cmd_packet.device	set	4
11465                       00000002            _ata_cmd_packet.loops	set	2
11466                       FFFFFFE0            .ata_cmd_packet.loops	set	-$20
11467                       00000020            _ata_cmd_packet.ebda_seg	set	$20
11468                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11469                       00000018            _ata_cmd_packet.lcount	set	$18
11470                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11471                       00000008            _ata_cmd_packet.total	set	8
11472                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11473                       0000000F            _ata_cmd_packet.status	set	$F
11474                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11475                       0000000E            _ata_cmd_packet.mode	set	$E
11476                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11477                       00000038            _ata_cmd_packet.bufoff	set	$38
11478                       00000016            .ata_cmd_packet.bufoff	set	$16
11479                       00000004            _ata_cmd_packet.transfer	set	4
11480                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11481                       00000001            _ata_cmd_packet.sc	set	1
11482                       FFFFFFDF            .ata_cmd_packet.sc	set	-$21
11483                       0000001A            _ata_cmd_packet.iobase2	set	$1A
11484                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11485                       00000016            _ata_cmd_packet.lbefore	set	$16
11486                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11487                       00000036            _ata_cmd_packet.bufseg	set	$36
11488                       00000014            .ata_cmd_packet.bufseg	set	$14
11489                       00000010            _ata_cmd_packet.slave	set	$10
11490                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11491                       00000034            _ata_cmd_packet.inout	set	$34
11492                       00000012            .ata_cmd_packet.inout	set	$12
11493                       0000001E            _ata_cmd_packet.old_ds	set	$1E
11494                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11495                       00000030            _ata_cmd_packet.length	set	$30
11496                       0000000E            .ata_cmd_packet.length	set	$E
11497 313F           55                                 push bp
11498 3140           89E5                               mov bp, sp
11499 3142           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
11500 3145           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
11501 3148           E3           15                    jcxz ata_packet_no_before
11502 314A           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11503 314D           80FC                   01          cmp ah, #0x01
11504 3150           74           05                    je ata_packet_in_before_32
11505                       00003152            ata_packet_in_before_16:
11506 3152           ED                                 in ax, dx
11507 3153           E2           FD                    loop ata_packet_in_before_16
11508 3155           EB           08                    jmp ata_packet_no_before
11509                       00003157            ata_packet_in_before_32:
11510 3157     66    50                                 push eax
11511                       00003159            ata_packet_in_before_32_loop:
11512 3159     66    ED                                 in eax, dx
11513 315B           E2           FC                    loop ata_packet_in_before_32_loop
11514 315D     66    58                                 pop eax
11515                       0000315F            ata_packet_no_before:
11516 315F           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
11517 3162           E3           17                    jcxz ata_packet_after
11518 3164           8B7E         3A                    mov di, _ata_cmd_packet.bufoff + 2[bp]
11519 3167           8B46         38                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
11520 316A           8EC0                               mov es, ax
11521 316C           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11522 316F           80FC                   01          cmp ah, #0x01
11523 3172           74           04                    je ata_packet_in_32
11524                       00003174            ata_packet_in_16:
11525 3174           F3                                 rep
11526 3175           6D                                   insw ;; CX words transferred to port(DX) to ES:[DI]
11527 3176           EB           03                    jmp ata_packet_after
11528                       00003178            ata_packet_in_32:
11529 3178           F3                                 rep
11530 3179     66    6D                                   insd ;; CX dwords transferred to port(DX) to ES:[DI]
11531                       0000317B            ata_packet_after:
11532 317B           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
11533 317E           E3           15                    jcxz ata_packet_done
11534 3180           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11535 3183           80FC                   01          cmp ah, #0x01
11536 3186           74           05                    je ata_packet_in_after_32
11537                       00003188            ata_packet_in_after_16:
11538 3188           ED                                 in ax, dx
11539 3189           E2           FD                    loop ata_packet_in_after_16
11540 318B           EB           08                    jmp ata_packet_done
11541                       0000318D            ata_packet_in_after_32:
11542 318D     66    50                                 push eax
11543                       0000318F            ata_packet_in_after_32_loop:
11544 318F     66    ED                                 in eax, dx
11545 3191           E2           FC                    loop ata_packet_in_after_32_loop
11546 3193     66    58                                 pop eax
11547                       00003195            ata_packet_done:
11548 3195           5D                                 pop bp
11549                                           ! 2227 endasm
11550                                           !BCC_ENDASM
11551                                           !BCC_EOS
11552                                           ! 2228       bufoff += count;
11553                                           ! Debug: addab unsigned short count = [S+$24-$12] to unsigned short bufoff = [S+$24+$14] (used reg = )
11554 3196           8B46         16            mov	ax,$16[bp]
11555 3199           0346         F0            add	ax,-$10[bp]
11556 319C           8946         16            mov	$16[bp],ax
11557                                           !BCC_EOS
11558                                           ! 2229       transfer += count;
11559                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$24-$12] (used reg = )
11560 319F           8B46         F0            mov	ax,-$10[bp]
11561 31A2           31DB                       xor	bx,bx
11562                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$24-$20] (used reg = )
11563 31A4           8D7E         E2            lea	di,-$1E[bp]
11564 31A7           E8         CEEA            call	laddul
11565 31AA           8946         E2            mov	-$1E[bp],ax
11566 31AD           895E         E4            mov	-$1C[bp],bx
11567                                           !BCC_EOS
11568                                           ! 2230       _write_dword(transfer, &((ebda_data_t *) 0)->ata.trsfbytes, ebda_seg);
11569                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11570 31B0           FF76         FE            push	-2[bp]
11571                                           ! Debug: list * unsigned long = const $256 (used reg = )
11572 31B3           B8                   0256  mov	ax,#$256
11573 31B6           50                         push	ax
11574                                           ! Debug: list unsigned long transfer = [S+$28-$20] (used reg = )
11575 31B7           FF76         E4            push	-$1C[bp]
11576 31BA           FF76         E2            push	-$1E[bp]
11577                                           ! Debug: func () void = _write_dword+0 (used reg = )
11578 31BD           E8         CEA7            call	__write_dword
11579 31C0           83C4                   08  add	sp,*8
11580                                           !BCC_EOS
11581                                           ! 2231     }
11582                                           ! 2232   }
11583                       000031C3            .2AC:
11584 31C3           E9         FD9D            br 	.2AD
11585                       000031C6            .2CA:
11586                       000031C6            .2AB:
11587 31C6           83C4                   04  add	sp,*4
11588                                           ! 2233   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11589                       000031C9            .2AA:
11590                                           ! 2234          != 0x40 ) {
11591                                           ! Debug: and int = const $E9 to unsigned char status = [S+$20-$15] (used reg = )
11592 31C9           8A46         ED            mov	al,-$13[bp]
11593 31CC           24                     E9  and	al,#$E9
11594                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11595 31CE           3C                     40  cmp	al,*$40
11596 31D0           74           07            je  	.2CB
11597                       000031D2            .2CC:
11598                                           ! 2235     ;
11599                                           !BCC_EOS
11600                                           ! 2236     return 4;
11601 31D2           B8                   0004  mov	ax,*4
11602 31D5           89EC                       mov	sp,bp
11603 31D7           5D                         pop	bp
11604 31D8           C3                         ret
11605                                           !BCC_EOS
11606                                           ! 2237   }
11607                                           ! 2238   outb(iobase2+6, 0x08);
11608                       000031D9            .2CB:
11609                                           ! Debug: list int = const 8 (used reg = )
11610 31D9           B8                   0008  mov	ax,*8
11611 31DC           50                         push	ax
11612                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
11613 31DD           8B46         F8            mov	ax,-8[bp]
11614                                           ! Debug: list unsigned int = ax+6 (used reg = )
11615 31E0           05                   0006  add	ax,*6
11616 31E3           50                         push	ax
11617                                           ! Debug: func () void = outb+0 (used reg = )
11618 31E4           E8         D358            call	_outb
11619 31E7           83C4                   04  add	sp,*4
11620                                           !BCC_EOS
11621                                           ! 2239   return 0;
11622 31EA           31C0                       xor	ax,ax
11623 31EC           89EC                       mov	sp,bp
11624 31EE           5D                         pop	bp
11625 31EF           C3                         ret
11626                                           !BCC_EOS
11627                                           ! 2240 }
11628                                           ! 2241   Bit16u
11629                                           ! Register BX used in function ata_cmd_packet
11630                                           ! 2242 atapi_get_sense(device, seg, asc, ascq)
11631                                           ! 2243   Bit16u device;
11632                                           export	_atapi_get_sense
11633                       000031F0            _atapi_get_sense:
11634                                           !BCC_EOS
11635                                           ! 2244 {
11636                                           ! 2245   Bit8u atacmd[12];
11637                                           !BCC_EOS
11638                                           ! 2246   Bit8u buffer[18];
11639                                           !BCC_EOS
11640                                           ! 2247   Bit8u i;
11641                                           !BCC_EOS
11642                                           ! 2248   _memsetb(0,atacmd,get_SS(),12);
11643 31F0           55                         push	bp
11644 31F1           89E5                       mov	bp,sp
11645 31F3           83C4                   E0  add	sp,*-$20
11646                                           ! Debug: list int = const $C (used reg = )
11647 31F6           B8                   000C  mov	ax,*$C
11648 31F9           50                         push	ax
11649                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11650 31FA           E8         D45D            call	_get_SS
11651                                           ! Debug: list unsigned short = ax+0 (used reg = )
11652 31FD           50                         push	ax
11653                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
11654 31FE           8D5E         F4            lea	bx,-$C[bp]
11655 3201           53                         push	bx
11656                                           ! Debug: list int = const 0 (used reg = )
11657 3202           31C0                       xor	ax,ax
11658 3204           50                         push	ax
11659                                           ! Debug: func () void = _memsetb+0 (used reg = )
11660 3205           E8         CDF8            call	__memsetb
11661 3208           83C4                   08  add	sp,*8
11662                                           !BCC_EOS
11663                                           ! 2249   atacmd[0]=0x03;
11664                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
11665 320B           B0                     03  mov	al,*3
11666 320D           8846         F4            mov	-$C[bp],al
11667                                           !BCC_EOS
11668                                           ! 2250   atacmd[4]=sizeof(buffer);
11669                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
11670 3210           B0                     12  mov	al,*$12
11671 3212           8846         F8            mov	-8[bp],al
11672                                           !BCC_EOS
11673                                           ! 2251   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
11674                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
11675 3215           8D5E         E2            lea	bx,-$1E[bp]
11676 3218           53                         push	bx
11677                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11678 3219           E8         D43E            call	_get_SS
11679                                           ! Debug: list unsigned short = ax+0 (used reg = )
11680 321C           50                         push	ax
11681                                           ! Debug: list int = const 1 (used reg = )
11682 321D           B8                   0001  mov	ax,*1
11683 3220           50                         push	ax
11684                                           ! Debug: list long = const $12 (used reg = )
11685 3221           B8                   0012  mov	ax,*$12
11686 3224           31DB                       xor	bx,bx
11687 3226           53                         push	bx
11688 3227           50                         push	ax
11689                                           ! Debug: list int = const 0 (used reg = )
11690 3228           31C0                       xor	ax,ax
11691 322A           50                         push	ax
11692                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
11693 322B           8D5E         F4            lea	bx,-$C[bp]
11694 322E           53                         push	bx
11695                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11696 322F           E8         D428            call	_get_SS
11697                                           ! Debug: list unsigned short = ax+0 (used reg = )
11698 3232           50                         push	ax
11699                                           ! Debug: list int = const $C (used reg = )
11700 3233           B8                   000C  mov	ax,*$C
11701 3236           50                         push	ax
11702                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
11703 3237           FF76         04            push	4[bp]
11704                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11705 323A           E8         FB09            call	_ata_cmd_packet
11706 323D           83C4                   14  add	sp,*$14
11707                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
11708 3240           85C0                       test	ax,ax
11709 3242           74           07            je  	.2CD
11710                       00003244            .2CE:
11711                                           ! 2252     return 0x0002;
11712 3244           B8                   0002  mov	ax,*2
11713 3247           89EC                       mov	sp,bp
11714 3249           5D                         pop	bp
11715 324A           C3                         ret
11716                                           !BCC_EOS
11717                                           ! 2253   _write_byte(buffer[12], asc, seg);
11718                       0000324B            .2CD:
11719                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11720 324B           FF76         06            push	6[bp]
11721                                           ! Debug: list int asc = [S+$24+6] (used reg = )
11722 324E           FF76         08            push	8[bp]
11723                                           ! Debug: list unsigned char buffer = [S+$26-$14] (used reg = )
11724 3251           8A46         EE            mov	al,-$12[bp]
11725 3254           30E4                       xor	ah,ah
11726 3256           50                         push	ax
11727                                           ! Debug: func () void = _write_byte+0 (used reg = )
11728 3257           E8         D3A1            call	__write_byte
11729 325A           83C4                   06  add	sp,*6
11730                                           !BCC_EOS
11731                                           ! 2254   _write_byte(buffer[13], ascq, seg);
11732                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11733 325D           FF76         06            push	6[bp]
11734                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
11735 3260           FF76         0A            push	$A[bp]
11736                                           ! Debug: list unsigned char buffer = [S+$26-$13] (used reg = )
11737 3263           8A46         EF            mov	al,-$11[bp]
11738 3266           30E4                       xor	ah,ah
11739 3268           50                         push	ax
11740                                           ! Debug: func () void = _write_byte+0 (used reg = )
11741 3269           E8         D38F            call	__write_byte
11742 326C           83C4                   06  add	sp,*6
11743                                           !BCC_EOS
11744                                           ! 2255   return 0;
11745 326F           31C0                       xor	ax,ax
11746 3271           89EC                       mov	sp,bp
11747 3273           5D                         pop	bp
11748 3274           C3                         ret
11749                                           !BCC_EOS
11750                                           ! 2256 }
11751                                           ! 2257   Bit16u
11752                                           ! Register BX used in function atapi_get_sense
11753                                           ! 2258 atapi_is_ready(device)
11754                                           ! 2259   Bit16u device;
11755                                           export	_atapi_is_ready
11756                       00003275            _atapi_is_ready:
11757                                           !BCC_EOS
11758                                           ! 2260 {
11759                                           ! 2261   Bit8u packet[12];
11760                                           !BCC_EOS
11761                                           ! 2262   Bit8u buf[8];
11762                                           !BCC_EOS
11763                                           ! 2263   Bit32u block_len;
11764                                           !BCC_EOS
11765                                           ! 2264   Bit32u sectors;
11766                                           !BCC_EOS
11767                                           ! 2265   Bit32u timeout;
11768                                           !BCC_EOS
11769                                           ! 2266   Bit32u time;
11770                                           !BCC_EOS
11771                                           ! 2267   Bit8u asc, ascq;
11772                                           !BCC_EOS
11773                                           ! 2268   Bit8u in_progress;
11774                                           !BCC_EOS
11775                                           ! 2269   Bit16u ebda_seg = get_ebda_seg();
11776 3275           55                         push	bp
11777 3276           89E5                       mov	bp,sp
11778 3278           83C4                   D6  add	sp,*-$2A
11779                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
11780 327B           E8         D3E9            call	_get_ebda_seg
11781                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11782 327E           8946         D6            mov	-$2A[bp],ax
11783                                           !BCC_EOS
11784                                           ! 2270   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03) {
11785                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11786 3281           FF76         D6            push	-$2A[bp]
11787                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
11788 3284           8B46         04            mov	ax,4[bp]
11789 3287           B9                   001E  mov	cx,*$1E
11790 328A           F7E9                       imul	cx
11791 328C           89C3                       mov	bx,ax
11792                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
11793                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
11794 328E           81C3                 0142  add	bx,#$142
11795 3292           53                         push	bx
11796                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
11797 3293           E8         D349            call	__read_byte
11798 3296           83C4                   04  add	sp,*4
11799                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
11800 3299           3C                     03  cmp	al,*3
11801 329B           74           15            je  	.2CF
11802                       0000329D            .2D0:
11803                                           ! 2271     bios_printf(2, "not implemented for non-ATAPI device\n");
11804                                           ! Debug: list * char = .2D1+0 (used reg = )
11805 329D           BB                   D62A  mov	bx,#.2D1
11806 32A0           53                         push	bx
11807                                           ! Debug: list int = const 2 (used reg = )
11808 32A1           B8                   0002  mov	ax,*2
11809 32A4           50                         push	ax
11810                                           ! Debug: func () void = bios_printf+0 (used reg = )
11811 32A5           E8         D691            call	_bios_printf
11812 32A8           83C4                   04  add	sp,*4
11813                                           !BCC_EOS
11814                                           ! 2272     return -1;
11815 32AB           B8                   FFFF  mov	ax,#$FFFF
11816 32AE           89EC                       mov	sp,bp
11817 32B0           5D                         pop	bp
11818 32B1           C3                         ret
11819                                           !BCC_EOS
11820                                           ! 2273   }
11821                                           ! 2274   ;
11822                       000032B2            .2CF:
11823                                           !BCC_EOS
11824                                           ! 2275   _memsetb(0,packet,get_SS(),sizeof packet);
11825                                           ! Debug: list int = const $C (used reg = )
11826 32B2           B8                   000C  mov	ax,*$C
11827 32B5           50                         push	ax
11828                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11829 32B6           E8         D3A1            call	_get_SS
11830                                           ! Debug: list unsigned short = ax+0 (used reg = )
11831 32B9           50                         push	ax
11832                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
11833 32BA           8D5E         F4            lea	bx,-$C[bp]
11834 32BD           53                         push	bx
11835                                           ! Debug: list int = const 0 (used reg = )
11836 32BE           31C0                       xor	ax,ax
11837 32C0           50                         push	ax
11838                                           ! Debug: func () void = _memsetb+0 (used reg = )
11839 32C1           E8         CD3C            call	__memsetb
11840 32C4           83C4                   08  add	sp,*8
11841                                           !BCC_EOS
11842                                           ! 2276   packet[0] = 0x25;
11843                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
11844 32C7           B0                     25  mov	al,*$25
11845 32C9           8846         F4            mov	-$C[bp],al
11846                                           !BCC_EOS
11847                                           ! 2277   timeout = 5000;
11848                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
11849 32CC           B8                   1388  mov	ax,#$1388
11850 32CF           31DB                       xor	bx,bx
11851 32D1           8946         E0            mov	-$20[bp],ax
11852 32D4           895E         E2            mov	-$1E[bp],bx
11853                                           !BCC_EOS
11854                                           ! 2278   time = 0;
11855                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
11856 32D7           31C0                       xor	ax,ax
11857 32D9           31DB                       xor	bx,bx
11858 32DB           8946         DC            mov	-$24[bp],ax
11859 32DE           895E         DE            mov	-$22[bp],bx
11860                                           !BCC_EOS
11861                                           ! 2279   in_progress = 0;
11862                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11863 32E1           30C0                       xor	al,al
11864 32E3           8846         D9            mov	-$27[bp],al
11865                                           !BCC_EOS
11866                                           ! 2280   while (time < timeout) {
11867 32E6           E9         00AB            br 	.2D3
11868                       000032E9            .2D4:
11869                                           ! 2281     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
11870                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
11871 32E9           8D5E         EC            lea	bx,-$14[bp]
11872 32EC           53                         push	bx
11873                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11874 32ED           E8         D36A            call	_get_SS
11875                                           ! Debug: list unsigned short = ax+0 (used reg = )
11876 32F0           50                         push	ax
11877                                           ! Debug: list int = const 1 (used reg = )
11878 32F1           B8                   0001  mov	ax,*1
11879 32F4           50                         push	ax
11880                                           ! Debug: list long = const 8 (used reg = )
11881 32F5           B8                   0008  mov	ax,*8
11882 32F8           31DB                       xor	bx,bx
11883 32FA           53                         push	bx
11884 32FB           50                         push	ax
11885                                           ! Debug: list int = const 0 (used reg = )
11886 32FC           31C0                       xor	ax,ax
11887 32FE           50                         push	ax
11888                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
11889 32FF           8D5E         F4            lea	bx,-$C[bp]
11890 3302           53                         push	bx
11891                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11892 3303           E8         D354            call	_get_SS
11893                                           ! Debug: list unsigned short = ax+0 (used reg = )
11894 3306           50                         push	ax
11895                                           ! Debug: list int = const $C (used reg = )
11896 3307           B8                   000C  mov	ax,*$C
11897 330A           50                         push	ax
11898                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
11899 330B           FF76         04            push	4[bp]
11900                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11901 330E           E8         FA35            call	_ata_cmd_packet
11902 3311           83C4                   14  add	sp,*$14
11903                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11904 3314           85C0                       test	ax,ax
11905 3316           75           06            jne 	.2D5
11906                       00003318            .2D6:
11907                                           ! 2282       goto ok;
11908 3318           83C4                   00  add	sp,#..FFFA+$2C
11909 331B           E9         008D            br 	.FFFA
11910                                           !BCC_EOS
11911                                           ! 2283     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
11912                       0000331E            .2D5:
11913                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
11914 331E           8D5E         DA            lea	bx,-$26[bp]
11915 3321           53                         push	bx
11916                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
11917 3322           8D5E         DB            lea	bx,-$25[bp]
11918 3325           53                         push	bx
11919                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11920 3326           E8         D331            call	_get_SS
11921                                           ! Debug: list unsigned short = ax+0 (used reg = )
11922 3329           50                         push	ax
11923                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
11924 332A           FF76         04            push	4[bp]
11925                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
11926 332D           E8         FEC0            call	_atapi_get_sense
11927 3330           83C4                   08  add	sp,*8
11928                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11929 3333           85C0                       test	ax,ax
11930 3335           75           41            jne 	.2D7
11931                       00003337            .2D8:
11932                                           ! 2284       if (asc == 0
11933                                           ! 2284 x3a) {
11934                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
11935 3337           8A46         DB            mov	al,-$25[bp]
11936 333A           3C                     3A  cmp	al,*$3A
11937 333C           75           07            jne 	.2D9
11938                       0000333E            .2DA:
11939                                           ! 2285         ;
11940                                           !BCC_EOS
11941                                           ! 2286         return -1;
11942 333E           B8                   FFFF  mov	ax,#$FFFF
11943 3341           89EC                       mov	sp,bp
11944 3343           5D                         pop	bp
11945 3344           C3                         ret
11946                                           !BCC_EOS
11947                                           ! 2287       }
11948                                           ! 2288       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
11949                       00003345            .2D9:
11950                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
11951 3345           8A46         DB            mov	al,-$25[bp]
11952 3348           3C                     04  cmp	al,*4
11953 334A           75           2C            jne 	.2DB
11954                       0000334C            .2DE:
11955                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
11956 334C           8A46         DA            mov	al,-$26[bp]
11957 334F           3C                     01  cmp	al,*1
11958 3351           75           25            jne 	.2DB
11959                       00003353            .2DD:
11960 3353           8A46         D9            mov	al,-$27[bp]
11961 3356           84C0                       test	al,al
11962 3358           75           1E            jne 	.2DB
11963                       0000335A            .2DC:
11964                                           ! 2289         bios_printf(2, "Waiting for device to detect medium... ");
11965                                           ! Debug: list * char = .2DF+0 (used reg = )
11966 335A           BB                   D602  mov	bx,#.2DF
11967 335D           53                         push	bx
11968                                           ! Debug: list int = const 2 (used reg = )
11969 335E           B8                   0002  mov	ax,*2
11970 3361           50                         push	ax
11971                                           ! Debug: func () void = bios_printf+0 (used reg = )
11972 3362           E8         D5D4            call	_bios_printf
11973 3365           83C4                   04  add	sp,*4
11974                                           !BCC_EOS
11975                                           ! 2290         timeout = 30000;
11976                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
11977 3368           B8                   7530  mov	ax,#$7530
11978 336B           31DB                       xor	bx,bx
11979 336D           8946         E0            mov	-$20[bp],ax
11980 3370           895E         E2            mov	-$1E[bp],bx
11981                                           !BCC_EOS
11982                                           ! 2291         in_progress = 1;
11983                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11984 3373           B0                     01  mov	al,*1
11985 3375           8846         D9            mov	-$27[bp],al
11986                                           !BCC_EOS
11987                                           ! 2292       }
11988                                           ! 2293     }
11989                       00003378            .2DB:
11990                                           ! 2294     time += 100;
11991                       00003378            .2D7:
11992                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
11993 3378           B8                   0064  mov	ax,*$64
11994 337B           31DB                       xor	bx,bx
11995 337D           53                         push	bx
11996 337E           50                         push	ax
11997 337F           8B46         DC            mov	ax,-$24[bp]
11998 3382           8B5E         DE            mov	bx,-$22[bp]
11999 3385           8D7E         D2            lea	di,-$2E[bp]
12000 3388           E8         CD09            call	laddul
12001 338B           8946         DC            mov	-$24[bp],ax
12002 338E           895E         DE            mov	-$22[bp],bx
12003 3391           83C4                   04  add	sp,*4
12004                                           !BCC_EOS
12005                                           ! 2295   }
12006                                           ! 2296   ;
12007                       00003394            .2D3:
12008                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
12009 3394           8B46         E0            mov	ax,-$20[bp]
12010 3397           8B5E         E2            mov	bx,-$1E[bp]
12011 339A           8D7E         DC            lea	di,-$24[bp]
12012 339D           E8         CCFC            call	lcmpul
12013 33A0         0F87         FF45            bhi 	.2D4
12014                       000033A4            .2E0:
12015                       000033A4            .2D2:
12016                                           !BCC_EOS
12017                                           ! 2297   return -1;
12018 33A4           B8                   FFFF  mov	ax,#$FFFF
12019 33A7           89EC                       mov	sp,bp
12020 33A9           5D                         pop	bp
12021 33AA           C3                         ret
12022                                           !BCC_EOS
12023                                           ! 2298 ok:
12024                       000033AB            .FFFA:
12025                       FFFFFFD4            ..FFFA	=	-$2C
12026                                           ! 2299   *(((Bit8u *)&*(((Bit16u *)&block_len)+1))+1) = buf[4];
12027                                           ! Debug: eq unsigned char buf = [S+$2C-$12] to unsigned char block_len = [S+$2C-$17] (used reg = )
12028 33AB           8A46         F0            mov	al,-$10[bp]
12029 33AE           8846         EB            mov	-$15[bp],al
12030                                           !BCC_EOS
12031                                           ! 2300   *((Bit8u *)&*(((Bit16u *)&block_len)+1)) = buf[5];
12032                                           ! Debug: eq unsigned char buf = [S+$2C-$11] to unsigned char block_len = [S+$2C-$18] (used reg = )
12033 33B1           8A46         F1            mov	al,-$F[bp]
12034 33B4           8846         EA            mov	-$16[bp],al
12035                                           !BCC_EOS
12036                                           ! 2301   *(((Bit8u *)&*((Bit16u *)&block_len))+1) = buf[6];
12037                                           ! Debug: eq unsigned char buf = [S+$2C-$10] to unsigned char block_len = [S+$2C-$19] (used reg = )
12038 33B7           8A46         F2            mov	al,-$E[bp]
12039 33BA           8846         E9            mov	-$17[bp],al
12040                                           !BCC_EOS
12041                                           ! 2302   *((Bit8u *)&block_len) = buf[7];
12042                                           ! Debug: eq unsigned char buf = [S+$2C-$F] to unsigned char block_len = [S+$2C-$1A] (used reg = )
12043 33BD           8A46         F3            mov	al,-$D[bp]
12044 33C0           8846         E8            mov	-$18[bp],al
12045                                           !BCC_EOS
12046                                           ! 2303   ;
12047                                           !BCC_EOS
12048                                           ! 2304   if (block_len!= 2048 && block_len!= 512)
12049                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12050                                           ! Debug: expression subtree swapping
12051 33C3           B8                   0800  mov	ax,#$800
12052 33C6           31DB                       xor	bx,bx
12053 33C8           53                         push	bx
12054 33C9           50                         push	ax
12055 33CA           8B46         E8            mov	ax,-$18[bp]
12056 33CD           8B5E         EA            mov	bx,-$16[bp]
12057 33D0           8D7E         D2            lea	di,-$2E[bp]
12058 33D3           E8         CCC6            call	lcmpul
12059 33D6           8D66         D6            lea	sp,-$2A[bp]
12060 33D9           74           33            je  	.2E1
12061                       000033DB            .2E3:
12062                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12063                                           ! Debug: expression subtree swapping
12064 33DB           B8                   0200  mov	ax,#$200
12065 33DE           31DB                       xor	bx,bx
12066 33E0           53                         push	bx
12067 33E1           50                         push	ax
12068 33E2           8B46         E8            mov	ax,-$18[bp]
12069 33E5           8B5E         EA            mov	bx,-$16[bp]
12070 33E8           8D7E         D2            lea	di,-$2E[bp]
12071 33EB           E8         CCAE            call	lcmpul
12072 33EE           8D66         D6            lea	sp,-$2A[bp]
12073 33F1           74           1B            je  	.2E1
12074                       000033F3            .2E2:
12075                                           ! 2305   {
12076                                           ! 2306     bios_printf(2, "Unsupported sector size %u\n", block_len);
12077                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
12078 33F3           FF76         EA            push	-$16[bp]
12079 33F6           FF76         E8            push	-$18[bp]
12080                                           ! Debug: list * char = .2E4+0 (used reg = )
12081 33F9           BB                   D5E6  mov	bx,#.2E4
12082 33FC           53                         push	bx
12083                                           ! Debug: list int = const 2 (used reg = )
12084 33FD           B8                   0002  mov	ax,*2
12085 3400           50                         push	ax
12086                                           ! Debug: func () void = bios_printf+0 (used reg = )
12087 3401           E8         D535            call	_bios_printf
12088 3404           83C4                   08  add	sp,*8
12089                                           !BCC_EOS
12090                                           ! 2307     return -1;
12091 3407           B8                   FFFF  mov	ax,#$FFFF
12092 340A           89EC                       mov	sp,bp
12093 340C           5D                         pop	bp
12094 340D           C3                         ret
12095                                           !BCC_EOS
12096                                           ! 2308   }
12097                                           ! 2309   _write_dword(block_len, &((ebda_data_t *) 0)->ata.devices[device].blksize, ebda_seg);
12098                       0000340E            .2E1:
12099                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12100 340E           FF76         D6            push	-$2A[bp]
12101                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12102 3411           8B46         04            mov	ax,4[bp]
12103 3414           B9                   001E  mov	cx,*$1E
12104 3417           F7E9                       imul	cx
12105 3419           89C3                       mov	bx,ax
12106                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
12107                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
12108 341B           81C3                 0148  add	bx,#$148
12109 341F           53                         push	bx
12110                                           ! Debug: list unsigned long block_len = [S+$30-$1A] (used reg = )
12111 3420           FF76         EA            push	-$16[bp]
12112 3423           FF76         E8            push	-$18[bp]
12113                                           ! Debug: func () void = _write_dword+0 (used reg = )
12114 3426           E8         CC3E            call	__write_dword
12115 3429           83C4                   08  add	sp,*8
12116                                           !BCC_EOS
12117                                           ! 2310   *(((Bit8u *)&*(((Bit16u *)&sectors)+1))+1) = buf[0];
12118                                           ! Debug: eq unsigned char buf = [S+$2C-$16] to unsigned char sectors = [S+$2C-$1B] (used reg = )
12119 342C           8A46         EC            mov	al,-$14[bp]
12120 342F           8846         E7            mov	-$19[bp],al
12121                                           !BCC_EOS
12122                                           ! 2311   *((Bit8u *)&*(((Bit16u *)&sectors)+1)) = buf[1];
12123                                           ! Debug: eq unsigned char buf = [S+$2C-$15] to unsigned char sectors = [S+$2C-$1C] (used reg = )
12124 3432           8A46         ED            mov	al,-$13[bp]
12125 3435           8846         E6            mov	-$1A[bp],al
12126                                           !BCC_EOS
12127                                           ! 2312   *(((Bit8u *)&*((Bit16u *)&sectors))+1) = buf[2];
12128                                           ! Debug: eq unsigned char buf = [S+$2C-$14] to unsigned char sectors = [S+$2C-$1D] (used reg = )
12129 3438           8A46         EE            mov	al,-$12[bp]
12130 343B           8846         E5            mov	-$1B[bp],al
12131                                           !BCC_EOS
12132                                           ! 2313   *((Bit8u *)&sectors) = buf[3];
12133                                           ! Debug: eq unsigned char buf = [S+$2C-$13] to unsigned char sectors = [S+$2C-$1E] (used reg = )
12134 343E           8A46         EF            mov	al,-$11[bp]
12135 3441           8846         E4            mov	-$1C[bp],al
12136                                           !BCC_EOS
12137                                           ! 2314   ;
12138                                           !BCC_EOS
12139                                           ! 2315   if (block_len == 2048)
12140                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12141                                           ! Debug: expression subtree swapping
12142 3444           B8                   0800  mov	ax,#$800
12143 3447           31DB                       xor	bx,bx
12144 3449           53                         push	bx
12145 344A           50                         push	ax
12146 344B           8B46         E8            mov	ax,-$18[bp]
12147 344E           8B5E         EA            mov	bx,-$16[bp]
12148 3451           8D7E         D2            lea	di,-$2E[bp]
12149 3454           E8         CC45            call	lcmpul
12150 3457           8D66         D6            lea	sp,-$2A[bp]
12151 345A           75           12            jne 	.2E5
12152                       0000345C            .2E6:
12153                                           ! 2316     sectors <<= 2;
12154                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12155 345C           8B46         E4            mov	ax,-$1C[bp]
12156 345F           8B5E         E6            mov	bx,-$1A[bp]
12157 3462           BF                   0002  mov	di,*2
12158 3465           E8         CCB0            call	lslul
12159 3468           8946         E4            mov	-$1C[bp],ax
12160 346B           895E         E6            mov	-$1A[bp],bx
12161                                           !BCC_EOS
12162                                           ! 2317   if (sectors != _read_dword(&((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg))
12163                       0000346E            .2E5:
12164                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12165 346E           FF76         D6            push	-$2A[bp]
12166                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12167 3471           8B46         04            mov	ax,4[bp]
12168 3474           B9                   001E  mov	cx,*$1E
12169 3477           F7E9                       imul	cx
12170 3479           89C3                       mov	bx,ax
12171                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12172                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12173 347B           81C3                 0158  add	bx,#$158
12174 347F           53                         push	bx
12175                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
12176 3480           E8         CBD3            call	__read_dword
12177 3483           89D3                       mov	bx,dx
12178 3485           83C4                   04  add	sp,*4
12179                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12180                                           ! Debug: expression subtree swapping
12181 3488           8D7E         E4            lea	di,-$1C[bp]
12182 348B           E8         CC0E            call	lcmpul
12183 348E           74           24            je  	.2E7
12184                       00003490            .2E8:
12185                                           ! 2318     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
12186                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
12187 3490           8B46         E4            mov	ax,-$1C[bp]
12188 3493           8B5E         E6            mov	bx,-$1A[bp]
12189 3496           88E0                       mov	al,ah
12190 3498           88DC                       mov	ah,bl
12191 349A           88FB                       mov	bl,bh
12192 349C           28FF                       sub	bh,bh
12193 349E           BF                   0003  mov	di,*3
12194 34A1           E8         CC56            call	lsrul
12195                                           ! Debug: list unsigned long = bx+0 (used reg = )
12196 34A4           53                         push	bx
12197 34A5           50                         push	ax
12198                                           ! Debug: list * char = .2E9+0 (used reg = )
12199 34A6           BB                   D5D0  mov	bx,#.2E9
12200 34A9           53                         push	bx
12201                                           ! Debug: list int = const 2 (used reg = )
12202 34AA           B8                   0002  mov	ax,*2
12203 34AD           50                         push	ax
12204                                           ! Debug: func () void = bios_printf+0 (used reg = )
12205 34AE           E8         D488            call	_bios_printf
12206 34B1           83C4                   08  add	sp,*8
12207                                           !BCC_EOS
12208                                           ! 2319   _write_dword(sectors, &((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg);
12209                       000034B4            .2E7:
12210                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12211 34B4           FF76         D6            push	-$2A[bp]
12212                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12213 34B7           8B46         04            mov	ax,4[bp]
12214 34BA           B9                   001E  mov	cx,*$1E
12215 34BD           F7E9                       imul	cx
12216 34BF           89C3                       mov	bx,ax
12217                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12218                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12219 34C1           81C3                 0158  add	bx,#$158
12220 34C5           53                         push	bx
12221                                           ! Debug: list unsigned long sectors = [S+$30-$1E] (used reg = )
12222 34C6           FF76         E6            push	-$1A[bp]
12223 34C9           FF76         E4            push	-$1C[bp]
12224                                           ! Debug: func () void = _write_dword+0 (used reg = )
12225 34CC           E8         CB98            call	__write_dword
12226 34CF           83C4                   08  add	sp,*8
12227                                           !BCC_EOS
12228                                           ! 2320   return 0;
12229 34D2           31C0                       xor	ax,ax
12230 34D4           89EC                       mov	sp,bp
12231 34D6           5D                         pop	bp
12232 34D7           C3                         ret
12233                                           !BCC_EOS
12234                                           ! 2321 }
12235                                           ! 2322   Bit16u
12236                                           ! Register BX used in function atapi_is_ready
12237                                           ! 2323 atapi_is_cdrom(device)
12238                                           ! 2324   Bit8u device;
12239                                           export	_atapi_is_cdrom
12240                       000034D8            _atapi_is_cdrom:
12241                                           !BCC_EOS
12242                                           ! 2325 {
12243                                           ! 2326   Bit16u ebda_seg=get_ebda_seg();
12244 34D8           55                         push	bp
12245 34D9           89E5                       mov	bp,sp
12246 34DB           4C                         dec	sp
12247 34DC           4C                         dec	sp
12248                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12249 34DD           E8         D187            call	_get_ebda_seg
12250                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12251 34E0           8946         FE            mov	-2[bp],ax
12252                                           !BCC_EOS
12253                                           ! 2327   if (device >= (4*2))
12254                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
12255 34E3           8A46         04            mov	al,4[bp]
12256 34E6           3C                     08  cmp	al,*8
12257 34E8           72           06            jb  	.2EA
12258                       000034EA            .2EB:
12259                                           ! 2328     return 0;
12260 34EA           31C0                       xor	ax,ax
12261 34EC           89EC                       mov	sp,bp
12262 34EE           5D                         pop	bp
12263 34EF           C3                         ret
12264                                           !BCC_EOS
12265                                           ! 2329   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03)
12266                       000034F0            .2EA:
12267                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12268 34F0           FF76         FE            push	-2[bp]
12269                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12270 34F3           8A46         04            mov	al,4[bp]
12271 34F6           30E4                       xor	ah,ah
12272 34F8           B9                   001E  mov	cx,*$1E
12273 34FB           F7E9                       imul	cx
12274 34FD           89C3                       mov	bx,ax
12275                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
12276                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
12277 34FF           81C3                 0142  add	bx,#$142
12278 3503           53                         push	bx
12279                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12280 3504           E8         D0D8            call	__read_byte
12281 3507           83C4                   04  add	sp,*4
12282                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
12283 350A           3C                     03  cmp	al,*3
12284 350C           74           06            je  	.2EC
12285                       0000350E            .2ED:
12286                                           ! 2330     return 0;
12287 350E           31C0                       xor	ax,ax
12288 3510           89EC                       mov	sp,bp
12289 3512           5D                         pop	bp
12290 3513           C3                         ret
12291                                           !BCC_EOS
12292                                           ! 2331   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].device, ebda_seg) != 0x05)
12293                       00003514            .2EC:
12294                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12295 3514           FF76         FE            push	-2[bp]
12296                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12297 3517           8A46         04            mov	al,4[bp]
12298 351A           30E4                       xor	ah,ah
12299 351C           B9                   001E  mov	cx,*$1E
12300 351F           F7E9                       imul	cx
12301 3521           89C3                       mov	bx,ax
12302                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
12303                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
12304 3523           81C3                 0143  add	bx,#$143
12305 3527           53                         push	bx
12306                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12307 3528           E8         D0B4            call	__read_byte
12308 352B           83C4                   04  add	sp,*4
12309                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
12310 352E           3C                     05  cmp	al,*5
12311 3530           74           06            je  	.2EE
12312                       00003532            .2EF:
12313                                           ! 2332     return 0;
12314 3532           31C0                       xor	ax,ax
12315 3534           89EC                       mov	sp,bp
12316 3536           5D                         pop	bp
12317 3537           C3                         ret
12318                                           !BCC_EOS
12319                                           ! 2333   return 1;
12320                       00003538            .2EE:
12321 3538           B8                   0001  mov	ax,*1
12322 353B           89EC                       mov	sp,bp
12323 353D           5D                         pop	bp
12324 353E           C3                         ret
12325                                           !BCC_EOS
12326                                           ! 2334 }
12327                                           ! 2335   void
12328                                           ! Register BX used in function atapi_is_cdrom
12329                                           ! 2336 cdemu_init()
12330                                           ! 2337 {
12331                                           export	_cdemu_init
12332                       0000353F            _cdemu_init:
12333                                           ! 2338   Bit16u ebda_seg=get_ebda_seg();
12334 353F           55                         push	bp
12335 3540           89E5                       mov	bp,sp
12336 3542           4C                         dec	sp
12337 3543           4C                         dec	sp
12338                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12339 3544           E8         D120            call	_get_ebda_seg
12340                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12341 3547           8946         FE            mov	-2[bp],ax
12342                                           !BCC_EOS
12343                                           ! 2339   _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
12344                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12345 354A           FF76         FE            push	-2[bp]
12346                                           ! Debug: list * unsigned char = const $25A (used reg = )
12347 354D           B8                   025A  mov	ax,#$25A
12348 3550           50                         push	ax
12349                                           ! Debug: list int = const 0 (used reg = )
12350 3551           31C0                       xor	ax,ax
12351 3553           50                         push	ax
12352                                           ! Debug: func () void = _write_byte+0 (used reg = )
12353 3554           E8         D0A4            call	__write_byte
12354 3557           83C4                   06  add	sp,*6
12355                                           !BCC_EOS
12356                                           ! 2340 }
12357 355A           89EC                       mov	sp,bp
12358 355C           5D                         pop	bp
12359 355D           C3                         ret
12360                                           ! 2341   Bit8u
12361                                           ! 2342 cdemu_isactive()
12362                                           ! 2343 {
12363                                           export	_cdemu_isactive
12364                       0000355E            _cdemu_isactive:
12365                                           ! 2344   Bit16u ebda_seg=get_ebda_seg();
12366 355E           55                         push	bp
12367 355F           89E5                       mov	bp,sp
12368 3561           4C                         dec	sp
12369 3562           4C                         dec	sp
12370                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12371 3563           E8         D101            call	_get_ebda_seg
12372                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12373 3566           8946         FE            mov	-2[bp],ax
12374                                           !BCC_EOS
12375                                           ! 2345   return(_read_byte(&((ebda_data_t *) 0)->cdemu.active, ebda_seg));
12376                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12377 3569           FF76         FE            push	-2[bp]
12378                                           ! Debug: list * unsigned char = const $25A (used reg = )
12379 356C           B8                   025A  mov	ax,#$25A
12380 356F           50                         push	ax
12381                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12382 3570           E8         D06C            call	__read_byte
12383 3573           83C4                   04  add	sp,*4
12384                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12385 3576           89EC                       mov	sp,bp
12386 3578           5D                         pop	bp
12387 3579           C3                         ret
12388                                           !BCC_EOS
12389                                           ! 2346 }
12390                                           ! 2347   Bit8u
12391                                           ! 2348 cdemu_emulated_drive()
12392                                           ! 2349 {
12393                                           export	_cdemu_emulated_drive
12394                       0000357A            _cdemu_emulated_drive:
12395                                           ! 2350   Bit16u ebda_seg=get_ebda_seg();
12396 357A           55                         push	bp
12397 357B           89E5                       mov	bp,sp
12398 357D           4C                         dec	sp
12399 357E           4C                         dec	sp
12400                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12401 357F           E8         D0E5            call	_get_ebda_seg
12402                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12403 3582           8946         FE            mov	-2[bp],ax
12404                                           !BCC_EOS
12405                                           ! 2351   return(_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
12406                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12407 3585           FF76         FE            push	-2[bp]
12408                                           ! Debug: list * unsigned char = const $25C (used reg = )
12409 3588           B8                   025C  mov	ax,#$25C
12410 358B           50                         push	ax
12411                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12412 358C           E8         D050            call	__read_byte
12413 358F           83C4                   04  add	sp,*4
12414                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12415 3592           89EC                       mov	sp,bp
12416 3594           5D                         pop	bp
12417 3595           C3                         ret
12418                                           !BCC_EOS
12419                                           ! 2352 }
12420                                           ! 2353 static char isotag[6]="CD001";
12421                                           
12422                       00003596            _isotag:
12423                       00003596            .2F0:
12424 3596                        43            .ascii	"CD001"
12425 359B                        00            .byte	0
12426                                           !BCC_EOS
12427                                           ! 2354 static char eltorito[24]="EL TORITO SPECIFICATION";
12428                       0000359C            _eltorito:
12429                       0000359C            .2F1:
12430 359C                        45            .ascii	"EL TORITO SPECIFICATION"
12431 35B3                        00            .byte	0
12432                                           !BCC_EOS
12433                                           ! 2355   Bit16u
12434                                           ! 2356 cdrom_boot()
12435                                           ! 2357 {
12436                                           
12437                                           export	_cdrom_boot
12438                       000035B4            _cdrom_boot:
12439                                           ! 2358   Bit16u ebda_
12440                                           ! 2358 seg=get_ebda_seg(), old_ds;
12441 35B4           55                         push	bp
12442 35B5           89E5                       mov	bp,sp
12443 35B7           4C                         dec	sp
12444 35B8           4C                         dec	sp
12445                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12446 35B9           E8         D0AB            call	_get_ebda_seg
12447                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12448 35BC           8946         FE            mov	-2[bp],ax
12449                                           !BCC_EOS
12450                                           ! 2359   Bit8u atacmd[12], buffer[2048];
12451                                           !BCC_EOS
12452                                           ! 2360   Bit32u lba;
12453                                           !BCC_EOS
12454                                           ! 2361   Bit16u boot_segment, nbsectors, i, error;
12455                                           !BCC_EOS
12456                                           ! 2362   Bit8u device;
12457                                           !BCC_EOS
12458                                           ! 2363   for (device=0; device<(4*2);device++) {
12459 35BF           81C4                 F7E4  add	sp,#-$81C
12460                                           ! Debug: eq int = const 0 to unsigned char device = [S+$820-$81F] (used reg = )
12461 35C3           30C0                       xor	al,al
12462 35C5           8886       F7E3            mov	-$81D[bp],al
12463                                           !BCC_EOS
12464                                           !BCC_EOS
12465 35C9           EB           1B            jmp .2F4
12466                       000035CB            .2F5:
12467                                           ! 2364     if (atapi_is_cdrom(device)) break;
12468                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12469 35CB           8A86       F7E3            mov	al,-$81D[bp]
12470 35CF           30E4                       xor	ah,ah
12471 35D1           50                         push	ax
12472                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
12473 35D2           E8         FF03            call	_atapi_is_cdrom
12474 35D5           44                         inc	sp
12475 35D6           44                         inc	sp
12476 35D7           85C0                       test	ax,ax
12477 35D9           74           02            je  	.2F6
12478                       000035DB            .2F7:
12479 35DB           EB           11            jmp .2F2
12480                                           !BCC_EOS
12481                                           ! 2365   }
12482                       000035DD            .2F6:
12483                                           ! 2366   if(device >= (4*2)) return 2;
12484                       000035DD            .2F3:
12485                                           ! Debug: postinc unsigned char device = [S+$820-$81F] (used reg = )
12486 35DD           8A86       F7E3            mov	al,-$81D[bp]
12487 35E1           40                         inc	ax
12488 35E2           8886       F7E3            mov	-$81D[bp],al
12489                       000035E6            .2F4:
12490                                           ! Debug: lt int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12491 35E6           8A86       F7E3            mov	al,-$81D[bp]
12492 35EA           3C                     08  cmp	al,*8
12493 35EC           72           DD            jb 	.2F5
12494                       000035EE            .2F8:
12495                       000035EE            .2F2:
12496                                           ! Debug: ge int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12497 35EE           8A86       F7E3            mov	al,-$81D[bp]
12498 35F2           3C                     08  cmp	al,*8
12499 35F4           72           07            jb  	.2F9
12500                       000035F6            .2FA:
12501 35F6           B8                   0002  mov	ax,*2
12502 35F9           89EC                       mov	sp,bp
12503 35FB           5D                         pop	bp
12504 35FC           C3                         ret
12505                                           !BCC_EOS
12506                                           ! 2367   if(error = atapi_is_ready(device) != 0)
12507                       000035FD            .2F9:
12508                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12509 35FD           8A86       F7E3            mov	al,-$81D[bp]
12510 3601           30E4                       xor	ah,ah
12511 3603           50                         push	ax
12512                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
12513 3604           E8         FC6E            call	_atapi_is_ready
12514 3607           44                         inc	sp
12515 3608           44                         inc	sp
12516                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12517 3609           85C0                       test	ax,ax
12518 360B           74           04            je 	.2FD
12519 360D           B0                     01  mov	al,*1
12520 360F           EB           02            jmp	.2FE
12521                       00003611            .2FD:
12522 3611           30C0                       xor	al,al
12523                       00003613            .2FE:
12524                                           ! Debug: eq char = al+0 to unsigned short error = [S+$820-$81E] (used reg = )
12525 3613           30E4                       xor	ah,ah
12526 3615           8986       F7E4            mov	-$81C[bp],ax
12527 3619           85C0                       test	ax,ax
12528 361B           74           12            je  	.2FB
12529                       0000361D            .2FC:
12530                                           ! 2368     bios_printf(4, "ata_is_ready returned %d\n",error);
12531                                           ! Debug: list unsigned short error = [S+$820-$81E] (used reg = )
12532 361D           FFB6       F7E4            push	-$81C[bp]
12533                                           ! Debug: list * char = .2FF+0 (used reg = )
12534 3621           BB                   D5B6  mov	bx,#.2FF
12535 3624           53                         push	bx
12536                                           ! Debug: list int = const 4 (used reg = )
12537 3625           B8                   0004  mov	ax,*4
12538 3628           50                         push	ax
12539                                           ! Debug: func () void = bios_printf+0 (used reg = )
12540 3629           E8         D30D            call	_bios_printf
12541 362C           83C4                   06  add	sp,*6
12542                                           !BCC_EOS
12543                                           ! 2369   _memsetb(0,atacmd,get_SS(),12);
12544                       0000362F            .2FB:
12545                                           ! Debug: list int = const $C (used reg = )
12546 362F           B8                   000C  mov	ax,*$C
12547 3632           50                         push	ax
12548                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12549 3633           E8         D024            call	_get_SS
12550                                           ! Debug: list unsigned short = ax+0 (used reg = )
12551 3636           50                         push	ax
12552                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12553 3637           8D5E         F0            lea	bx,-$10[bp]
12554 363A           53                         push	bx
12555                                           ! Debug: list int = const 0 (used reg = )
12556 363B           31C0                       xor	ax,ax
12557 363D           50                         push	ax
12558                                           ! Debug: func () void = _memsetb+0 (used reg = )
12559 363E           E8         C9BF            call	__memsetb
12560 3641           83C4                   08  add	sp,*8
12561                                           !BCC_EOS
12562                                           ! 2370   atacmd[0]=0x28;
12563                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12564 3644           B0                     28  mov	al,*$28
12565 3646           8846         F0            mov	-$10[bp],al
12566                                           !BCC_EOS
12567                                           ! 2371   atacmd[7]=(0x01 & 0xff00) >> 8;
12568                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12569 3649           30C0                       xor	al,al
12570 364B           8846         F7            mov	-9[bp],al
12571                                           !BCC_EOS
12572                                           ! 2372   atacmd[8]=(0x01 & 0x00ff);
12573                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12574 364E           B0                     01  mov	al,*1
12575 3650           8846         F8            mov	-8[bp],al
12576                                           !BCC_EOS
12577                                           ! 2373   atacmd[2]=(0x11 & 0xff000000) >> 24;
12578                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$820-$10] (used reg = )
12579 3653           30C0                       xor	al,al
12580 3655           8846         F2            mov	-$E[bp],al
12581                                           !BCC_EOS
12582                                           ! 2374   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
12583                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$820-$F] (used reg = )
12584 3658           30C0                       xor	al,al
12585 365A           8846         F3            mov	-$D[bp],al
12586                                           !BCC_EOS
12587                                           ! 2375   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
12588                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$E] (used reg = )
12589 365D           30C0                       xor	al,al
12590 365F           8846         F4            mov	-$C[bp],al
12591                                           !BCC_EOS
12592                                           ! 2376   atacmd[5]=(0x11 & 0x000000ff);
12593                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$820-$D] (used reg = )
12594 3662           B0                     11  mov	al,*$11
12595 3664           8846         F5            mov	-$B[bp],al
12596                                           !BCC_EOS
12597                                           ! 2377   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12598                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12599 3667           8D9E       F7F0            lea	bx,-$810[bp]
12600 366B           53                         push	bx
12601                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12602 366C           E8         CFEB            call	_get_SS
12603                                           ! Debug: list unsigned short = ax+0 (used reg = )
12604 366F           50                         push	ax
12605                                           ! Debug: list int = const 1 (used reg = )
12606 3670           B8                   0001  mov	ax,*1
12607 3673           50                         push	ax
12608                                           ! Debug: list long = const $800 (used reg = )
12609 3674           B8                   0800  mov	ax,#$800
12610 3677           31DB                       xor	bx,bx
12611 3679           53                         push	bx
12612 367A           50                         push	ax
12613                                           ! Debug: list int = const 0 (used reg = )
12614 367B           31C0                       xor	ax,ax
12615 367D           50                         push	ax
12616                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12617 367E           8D5E         F0            lea	bx,-$10[bp]
12618 3681           53                         push	bx
12619                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12620 3682           E8         CFD5            call	_get_SS
12621                                           ! Debug: list unsigned short = ax+0 (used reg = )
12622 3685           50                         push	ax
12623                                           ! Debug: list int = const $C (used reg = )
12624 3686           B8                   000C  mov	ax,*$C
12625 3689           50                         push	ax
12626                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12627 368A           8A86       F7E3            mov	al,-$81D[bp]
12628 368E           30E4                       xor	ah,ah
12629 3690           50                         push	ax
12630                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12631 3691           E8         F6B2            call	_ata_cmd_packet
12632 3694           83C4                   14  add	sp,*$14
12633                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12634 3697           8986       F7E4            mov	-$81C[bp],ax
12635                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12636 369B           85C0                       test	ax,ax
12637 369D           74           07            je  	.300
12638                       0000369F            .301:
12639                                           ! 2378     return 3;
12640 369F           B8                   0003  mov	ax,*3
12641 36A2           89EC                       mov	sp,bp
12642 36A4           5D                         pop	bp
12643 36A5           C3                         ret
12644                                           !BCC_EOS
12645                                           ! 2379   if(buffer[0]!=0) return 4;
12646                       000036A6            .300:
12647                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$812] (used reg = )
12648 36A6           8A86       F7F0            mov	al,-$810[bp]
12649 36AA           84C0                       test	al,al
12650 36AC           74           07            je  	.302
12651                       000036AE            .303:
12652 36AE           B8                   0004  mov	ax,*4
12653 36B1           89EC                       mov	sp,bp
12654 36B3           5D                         pop	bp
12655 36B4           C3                         ret
12656                                           !BCC_EOS
12657                                           ! 2380   for(i=0;i<5;i++){
12658                       000036B5            .302:
12659                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12660 36B5           31C0                       xor	ax,ax
12661 36B7           8986       F7E6            mov	-$81A[bp],ax
12662                                           !BCC_EOS
12663                                           !BCC_EOS
12664 36BB           EB           3B            jmp .306
12665                       000036BD            .307:
12666                                           ! 2381     if(buffer[1+i]!=_read_byte(&isotag[i], 0xf000)) return 5;
12667                                           ! Debug: list unsigned int = const $F000 (used reg = )
12668 36BD           B8                   F000  mov	ax,#$F000
12669 36C0           50                         push	ax
12670                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [6] char = isotag+0 (used reg = )
12671 36C1           8B9E       F7E6            mov	bx,-$81A[bp]
12672                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
12673                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
12674 36C5           81C3                 3596  add	bx,#_isotag
12675 36C9           53                         push	bx
12676                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12677 36CA           E8         CF12            call	__read_byte
12678 36CD           83C4                   04  add	sp,*4
12679 36D0           50                         push	ax
12680                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 1 (used reg = )
12681                                           ! Debug: expression subtree swapping
12682 36D1           8B86       F7E6            mov	ax,-$81A[bp]
12683                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12684 36D5           40                         inc	ax
12685 36D6           89EB                       mov	bx,bp
12686 36D8           01C3                       add	bx,ax
12687                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12688 36DA           8A87       F7F0            mov	al,-$810[bx]
12689 36DE           3A86       F7E0            cmp	al,-$820[bp]
12690 36E2           8DA6       F7E2            lea	sp,-$81E[bp]
12691 36E6           74           07            je  	.308
12692                       000036E8            .309:
12693 36E8           B8                   0005  mov	ax,*5
12694 36EB           89EC                       mov	sp,bp
12695 36ED           5D                         pop	bp
12696 36EE           C3                         ret
12697                                           !BCC_EOS
12698                                           ! 2382   }
12699                       000036EF            .308:
12700                                           ! 2383   for(i=0;i<23;i++)
12701                       000036EF            .305:
12702                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12703 36EF           8B86       F7E6            mov	ax,-$81A[bp]
12704 36F3           40                         inc	ax
12705 36F4           8986       F7E6            mov	-$81A[bp],ax
12706                       000036F8            .306:
12707                                           ! Debug: lt int = const 5 to unsigned short i = [S+$820-$81C] (used reg = )
12708 36F8           8B86       F7E6            mov	ax,-$81A[bp]
12709 36FC           3D                   0005  cmp	ax,*5
12710 36FF           72           BC            jb 	.307
12711                       00003701            .30A:
12712                       00003701            .304:
12713                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12714 3701           31C0                       xor	ax,ax
12715 3703           8986       F7E6            mov	-$81A[bp],ax
12716                                           !BCC_EOS
12717                                           !BCC_EOS
12718                                           ! 2384     if(buffer[7+i]!=_read_byte(&eltorito[i], 0xf000)) return 6;
12719 3707           EB           3D            jmp .30D
12720                       00003709            .30E:
12721                                           ! Debug: list unsigned int = const $F000 (used reg = )
12722 3709           B8                   F000  mov	ax,#$F000
12723 370C           50                         push	ax
12724                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [$18] char = eltorito+0 (used reg = )
12725 370D           8B9E       F7E6            mov	bx,-$81A[bp]
12726                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
12727                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
12728 3711           81C3                 359C  add	bx,#_eltorito
12729 3715           53                         push	bx
12730                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12731 3716           E8         CEC6            call	__read_byte
12732 3719           83C4                   04  add	sp,*4
12733 371C           50                         push	ax
12734                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 7 (used reg = )
12735                                           ! Debug: expression subtree swapping
12736 371D           8B86       F7E6            mov	ax,-$81A[bp]
12737                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12738 3721           05                   0007  add	ax,*7
12739 3724           89EB                       mov	bx,bp
12740 3726           01C3                       add	bx,ax
12741                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12742 3728           8A87       F7F0            mov	al,-$810[bx]
12743 372C           3A86       F7E0            cmp	al,-$820[bp]
12744 3730           8DA6       F7E2            lea	sp,-$81E[bp]
12745 3734           74           07            je  	.30F
12746                       00003736            .310:
12747 3736           B8                   0006  mov	ax,*6
12748 3739           89EC                       mov	sp,bp
12749 373B           5D                         pop	bp
12750 373C           C3                         ret
12751                                           !BCC_EOS
12752                                           ! 2385   lba=*((Bit32u *)&buffer[0x47]);
12753                       0000373D            .30F:
12754                       0000373D            .30C:
12755                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12756 373D           8B86       F7E6            mov	ax,-$81A[bp]
12757 3741           40                         inc	ax
12758 3742           8986       F7E6            mov	-$81A[bp],ax
12759                       00003746            .30D:
12760                                           ! Debug: lt int = const $17 to unsigned short i = [S+$820-$81C] (used reg = )
12761 3746           8B86       F7E6            mov	ax,-$81A[bp]
12762 374A           3D                   0017  cmp	ax,*$17
12763 374D           72           BA            jb 	.30E
12764                       0000374F            .311:
12765                       0000374F            .30B:
12766                                           ! Debug: eq unsigned long buffer = [S+$820-$7CB] to unsigned long lba = [S+$820-$816] (used reg = )
12767 374F           8B86       F837            mov	ax,-$7C9[bp]
12768 3753           8B9E       F839            mov	bx,-$7C7[bp]
12769 3757           8986       F7EC            mov	-$814[bp],ax
12770 375B           899E       F7EE            mov	-$812[bp],bx
12771                                           !BCC_EOS
12772                                           ! 2386   _memsetb(0,atacmd,get_SS(),12);
12773                                           ! Debug: list int = const $C (used reg = )
12774 375F           B8                   000C  mov	ax,*$C
12775 3762           50                         push	ax
12776                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12777 3763           E8         CEF4            call	_get_SS
12778                                           ! Debug: list unsigned short = ax+0 (used reg = )
12779 3766           50                         push	ax
12780                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12781 3767           8D5E         F0            lea	bx,-$10[bp]
12782 376A           53                         push	bx
12783                                           ! Debug: list int = const 0 (used reg = )
12784 376B           31C0                       xor	ax,ax
12785 376D           50                         push	ax
12786                                           ! Debug: func () void = _memsetb+0 (used reg = )
12787 376E           E8         C88F            call	__memsetb
12788 3771           83C4                   08  add	sp,*8
12789                                           !BCC_EOS
12790                                           ! 2387   atacmd[0]=0x28;
12791                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12792 3774           B0                     28  mov	al,*$28
12793 3776           8846         F0            mov	-$10[bp],al
12794                                           !BCC_EOS
12795                                           ! 2388   atacmd[7]=(0x01 & 0xff00) >> 8;
12796                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12797 3779           30C0                       xor	al,al
12798 377B           8846         F7            mov	-9[bp],al
12799                                           !BCC_EOS
12800                                           ! 2389   atacmd[8]=(0x01 & 0x00ff);
12801                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12802 377E           B0                     01  mov	al,*1
12803 3780           8846         F8            mov	-8[bp],al
12804                                           !BCC_EOS
12805                                           ! 2390   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
12806                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
12807 3783           8A86       F7EF            mov	al,-$811[bp]
12808 3787           8846         F2            mov	-$E[bp],al
12809                                           !BCC_EOS
12810                                           ! 2391   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
12811                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
12812 378A           8A86       F7EE            mov	al,-$812[bp]
12813 378E           8846         F3            mov	-$D[bp],al
12814                                           !BCC_EOS
12815                                           ! 2392   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
12816                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
12817 3791           8A86       F7ED            mov	al,-$813[bp]
12818 3795           8846         F4            mov	-$C[bp],al
12819                                           !BCC_EOS
12820                                           ! 2393   atacmd[5]=*((Bit8u *)&lba);
12821                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
12822 3798           8A86       F7EC            mov	al,-$814[bp]
12823 379C           8846         F5            mov	-$B[bp],al
12824                                           !BCC_EOS
12825                                           ! 2394   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12826                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12827 379F           8D9E       F7F0            lea	bx,-$810[bp]
12828 37A3           53                         push	bx
12829                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12830 37A4           E8         CEB3            call	_get_SS
12831                                           ! Debug: list unsigned short = ax+0 (used reg = )
12832 37A7           50                         push	ax
12833                                           ! Debug: list int = const 1 (used reg = )
12834 37A8           B8                   0001  mov	ax,*1
12835 37AB           50                         push	ax
12836                                           ! Debug: list long = const $800 (used reg = )
12837 37AC           B8                   0800  mov	ax,#$800
12838 37AF           31DB                       xor	bx,bx
12839 37B1           53                         push	bx
12840 37B2           50                         push	ax
12841                                           ! Debug: list int = const 0 (used reg = )
12842 37B3           31C0                       xor	ax,ax
12843 37B5           50                         push	ax
12844                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12845 37B6           8D5E         F0            lea	bx,-$10[bp]
12846 37B9           53                         push	bx
12847                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12848 37BA           E8         CE9D            call	_get_SS
12849                                           ! Debug: list unsigned short = ax+0 (used reg = )
12850 37BD           50                         push	ax
12851                                           ! Debug: list int = const $C (used reg = )
12852 37BE           B8                   000C  mov	ax,*$C
12853 37C1           50                         push	ax
12854                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12855 37C2           8A86       F7E3            mov	al,-$81D[bp]
12856 37C6           30E4                       xor	ah,ah
12857 37C8           50                         push	ax
12858                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12859 37C9           E8         F57A            call	_ata_cmd_packet
12860 37CC           83C4                   14  add	sp,*$14
12861                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12862 37CF           8986       F7E4            mov	-$81C[bp],ax
12863                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12864 37D3           85C0                       test	ax,ax
12865 37D5           74           07            je  	.312
12866                       000037D7            .313:
12867                                           ! 2395     return 7;
12868 37D7           B8                   0007  mov	ax,*7
12869 37DA           89EC                       mov	sp,bp
12870 37DC           5D                         pop	bp
12871 37DD           C3                         ret
12872                                           !BCC_EOS
12873                                           ! 2396   if(buffer[0x00]!=0x01)return 8;
12874                       000037DE            .312:
12875                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$820-$812] (used reg = )
12876 37DE           8A86       F7F0            mov	al,-$810[bp]
12877 37E2           3C                     01  cmp	al,*1
12878 37E4           74           07            je  	.314
12879                       000037E6            .315:
12880 37E6           B8                   0008  mov	ax,*8
12881 37E9           89EC                       mov	sp,bp
12882 37EB           5D                         pop	bp
12883 37EC           C3                         ret
12884                                           !BCC_EOS
12885                                           ! 2397   if(buffer[0x01]!=0x00)return 9;
12886                       000037ED            .314:
12887                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$811] (used reg = )
12888 37ED           8A86       F7F1            mov	al,-$80F[bp]
12889 37F1           84C0                       test	al,al
12890 37F3           74           07            je  	.316
12891                       000037F5            .317:
12892 37F5           B8                   0009  mov	ax,*9
12893 37F8           89EC                       mov	sp,bp
12894 37FA           5D                         pop	bp
12895 37FB           C3                         ret
12896                                           !BCC_EOS
12897                                           ! 2398   if(buffer[0x1E]!=0x55)return 10;
12898                       000037FC            .316:
12899                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$820-$7F4] (used reg = )
12900 37FC           8A86       F80E            mov	al,-$7F2[bp]
12901 3800           3C                     55  cmp	al,*$55
12902 3802           74           07            je  	.318
12903                       00003804            .319:
12904 3804           B8                   000A  mov	ax,*$A
12905 3807           89EC                       mov	sp,bp
12906 3809           5D                         pop	bp
12907 380A           C3                         ret
12908                                           !BCC_EOS
12909                                           ! 2399   if(buffer[0x1F]!=0xAA)return 10;
12910                       0000380B            .318:
12911                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$820-$7F3] (used reg = )
12912 380B           8A86       F80F            mov	al,-$7F1[bp]
12913 380F           3C                     AA  cmp	al,#$AA
12914 3811           74           07            je  	.31A
12915                       00003813            .31B:
12916 3813           B8                   000A  mov	ax,*$A
12917 3816           89EC                       mov	sp,bp
12918 3818           5D                         pop	bp
12919 3819           C3                         ret
12920                                           !BCC_EOS
12921                                           ! 2400   if(buffer[0x20]!=0x88)return 11;
12922                       0000381A            .31A:
12923                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$820-$7F2] (used reg = )
12924 381A           8A86       F810            mov	al,-$7F0[bp]
12925 381E           3C                     88  cmp	al,#$88
12926 3820           74           07            je  	.31C
12927                       00003822            .31D:
12928 3822           B8                   000B  mov	ax,*$B
12929 3825           89EC                       mov	sp,bp
12930 3827           5D                         pop	bp
12931 3828           C3                         ret
12932                                           !BCC_EOS
12933                                           ! 2401   old_ds = set_DS(ebda_seg);
12934                       00003829            .31C:
12935                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
12936 3829           FF76         FE            push	-2[bp]
12937                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
12938 382C           E8         CE2E            call	_set_DS
12939 382F           44                         inc	sp
12940 3830           44                         inc	sp
12941                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$820-6] (used reg = )
12942 3831           8946         FC            mov	-4[bp],ax
12943                                           !BCC_EOS
12944                                           ! 2402   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media)) = (buffer[0x21]);
12945                                           ! Debug: eq unsigned char buffer = [S+$820-$7F1] to unsigned char = [+$25B] (used reg = )
12946 3834           8A86       F811            mov	al,-$7EF[bp]
12947 3838           A2         025B            mov	[$25B],al
12948                                           !BCC_EOS
12949                                           ! 2403   if(buffer[0x21]==0){
12950                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$820-$7F1] (used reg = )
12951 383B           8A86       F811            mov	al,-$7EF[bp]
12952 383F           84C0                       test	al,al
12953 3841           75           07            jne 	.31E
12954                       00003843            .31F:
12955                                           ! 2404     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0xE0);
12956                                           ! Debug: eq int = const $E0 to unsigned char = [+$25C] (used reg = )
12957 3843           B0                     E0  mov	al,#$E0
12958 3845           A2         025C            mov	[$25C],al
12959                                           !BCC_EOS
12960                                           ! 2405   }
12961                                           ! 2406   else if(buffer[0x21]<4)
12962 3848           EB           14            jmp .320
12963                       0000384A            .31E:
12964                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$820-$7F1] (used reg = )
12965 384A           8A86       F811            mov	al,-$7EF[bp]
12966 384E           3C                     04  cmp	al,*4
12967 3850           73           07            jae 	.321
12968                       00003852            .322:
12969                                           ! 2407     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x00);
12970                                           ! Debug: eq int = const 0 to unsigned char = [+$25C] (used reg = )
12971 3852           30C0                       xor	al,al
12972 3854           A2         025C            mov	[$25C],al
12973                                           !BCC_EOS
12974                                           ! 2408   else
12975                                           ! 2409     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x80);
12976 3857           EB           05            jmp .323
12977                       00003859            .321:
12978                                           ! Debug: eq int = const $80 to unsigned char = [+$25C] (used reg = )
12979 3859           B0                     80  mov	al,#$80
12980 385B           A2         025C            mov	[$25C],al
12981                                           !BCC_EOS
12982                                           ! 2410   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) = (device/2);
12983                       0000385E            .323:
12984                       0000385E            .320:
12985                                           ! Debug: div int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
12986 385E           8A86       F7E3            mov	al,-$81D[bp]
12987 3862           30E4                       xor	ah,ah
12988 3864           D1E8                       shr	ax,*1
12989                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$25D] (used reg = )
12990 3866           A2         025D            mov	[$25D],al
12991                                           !BCC_EOS
12992                                           ! 2411   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec)) = (de
12993                                           ! 2411 vice%2);
12994                                           ! Debug: mod int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
12995 3869           8A86       F7E3            mov	al,-$81D[bp]
12996 386D           30E4                       xor	ah,ah
12997 386F           24                     01  and	al,*1
12998                                           ! Debug: eq unsigned char = al+0 to unsigned char = [+$25E] (used reg = )
12999 3871           A2         025E            mov	[$25E],al
13000                                           !BCC_EOS
13001                                           ! 2412   boot_segment=*((Bit16u *)&buffer[0x22]);
13002                                           ! Debug: eq unsigned short buffer = [S+$820-$7F0] to unsigned short boot_segment = [S+$820-$818] (used reg = )
13003 3874           8B86       F812            mov	ax,-$7EE[bp]
13004 3878           8986       F7EA            mov	-$816[bp],ax
13005                                           !BCC_EOS
13006                                           ! 2413   if(boot_segment==0x0000)boot_segment=0x07C0;
13007                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13008 387C           8B86       F7EA            mov	ax,-$816[bp]
13009 3880           85C0                       test	ax,ax
13010 3882           75           07            jne 	.324
13011                       00003884            .325:
13012                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13013 3884           B8                   07C0  mov	ax,#$7C0
13014 3887           8986       F7EA            mov	-$816[bp],ax
13015                                           !BCC_EOS
13016                                           ! 2414   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.load_segment)) = (boot_segment);
13017                       0000388B            .324:
13018                                           ! Debug: eq unsigned short boot_segment = [S+$820-$818] to unsigned short = [+$266] (used reg = )
13019 388B           8B86       F7EA            mov	ax,-$816[bp]
13020 388F           A3         0266            mov	[$266],ax
13021                                           !BCC_EOS
13022                                           ! 2415   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.buffer_segment)) = (0x0000);
13023                                           ! Debug: eq int = const 0 to unsigned short = [+$264] (used reg = )
13024 3892           31C0                       xor	ax,ax
13025 3894           A3         0264            mov	[$264],ax
13026                                           !BCC_EOS
13027                                           ! 2416   nbsectors=*((Bit16u *)&buffer[0x26]);
13028                                           ! Debug: eq unsigned short buffer = [S+$820-$7EC] to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13029 3897           8B86       F816            mov	ax,-$7EA[bp]
13030 389B           8986       F7E8            mov	-$818[bp],ax
13031                                           !BCC_EOS
13032                                           ! 2417   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.sector_count)) = (nbsectors);
13033                                           ! Debug: eq unsigned short nbsectors = [S+$820-$81A] to unsigned short = [+$268] (used reg = )
13034 389F           8B86       F7E8            mov	ax,-$818[bp]
13035 38A3           A3         0268            mov	[$268],ax
13036                                           !BCC_EOS
13037                                           ! 2418   lba=*((Bit32u *)&buffer[0x28]);
13038                                           ! Debug: eq unsigned long buffer = [S+$820-$7EA] to unsigned long lba = [S+$820-$816] (used reg = )
13039 38A6           8B86       F818            mov	ax,-$7E8[bp]
13040 38AA           8B9E       F81A            mov	bx,-$7E6[bp]
13041 38AE           8986       F7EC            mov	-$814[bp],ax
13042 38B2           899E       F7EE            mov	-$812[bp],bx
13043                                           !BCC_EOS
13044                                           ! 2419   *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba)) = (lba);
13045                                           ! Debug: eq unsigned long lba = [S+$820-$816] to unsigned long = [+$260] (used reg = )
13046 38B6           8B86       F7EC            mov	ax,-$814[bp]
13047 38BA           8B9E       F7EE            mov	bx,-$812[bp]
13048 38BE           A3         0260            mov	[$260],ax
13049 38C1           891E       0262            mov	[$262],bx
13050                                           !BCC_EOS
13051                                           ! 2420   _memsetb(0,atacmd,get_SS(),12);
13052                                           ! Debug: list int = const $C (used reg = )
13053 38C5           B8                   000C  mov	ax,*$C
13054 38C8           50                         push	ax
13055                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13056 38C9           E8         CD8E            call	_get_SS
13057                                           ! Debug: list unsigned short = ax+0 (used reg = )
13058 38CC           50                         push	ax
13059                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
13060 38CD           8D5E         F0            lea	bx,-$10[bp]
13061 38D0           53                         push	bx
13062                                           ! Debug: list int = const 0 (used reg = )
13063 38D1           31C0                       xor	ax,ax
13064 38D3           50                         push	ax
13065                                           ! Debug: func () void = _memsetb+0 (used reg = )
13066 38D4           E8         C729            call	__memsetb
13067 38D7           83C4                   08  add	sp,*8
13068                                           !BCC_EOS
13069                                           ! 2421   atacmd[0]=0x28;
13070                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
13071 38DA           B0                     28  mov	al,*$28
13072 38DC           8846         F0            mov	-$10[bp],al
13073                                           !BCC_EOS
13074                                           ! 2422   i = 1+(nbsectors-1)/4;
13075                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13076 38DF           8B86       F7E8            mov	ax,-$818[bp]
13077                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13078 38E3           48                         dec	ax
13079 38E4           D1E8                       shr	ax,*1
13080 38E6           D1E8                       shr	ax,*1
13081                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13082                                           ! Debug: expression subtree swapping
13083                                           ! Debug: eq unsigned int = ax+1 to unsigned short i = [S+$820-$81C] (used reg = )
13084 38E8           40                         inc	ax
13085 38E9           8986       F7E6            mov	-$81A[bp],ax
13086                                           !BCC_EOS
13087                                           ! 2423   atacmd[7]=*(((Bit8u *)&i)+1);
13088                                           ! Debug: eq unsigned char i = [S+$820-$81B] to unsigned char atacmd = [S+$820-$B] (used reg = )
13089 38ED           8A86       F7E7            mov	al,-$819[bp]
13090 38F1           8846         F7            mov	-9[bp],al
13091                                           !BCC_EOS
13092                                           ! 2424   atacmd[8]=*((Bit8u *)&i);
13093                                           ! Debug: eq unsigned char i = [S+$820-$81C] to unsigned char atacmd = [S+$820-$A] (used reg = )
13094 38F4           8A86       F7E6            mov	al,-$81A[bp]
13095 38F8           8846         F8            mov	-8[bp],al
13096                                           !BCC_EOS
13097                                           ! 2425   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
13098                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
13099 38FB           8A86       F7EF            mov	al,-$811[bp]
13100 38FF           8846         F2            mov	-$E[bp],al
13101                                           !BCC_EOS
13102                                           ! 2426   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
13103                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
13104 3902           8A86       F7EE            mov	al,-$812[bp]
13105 3906           8846         F3            mov	-$D[bp],al
13106                                           !BCC_EOS
13107                                           ! 2427   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
13108                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
13109 3909           8A86       F7ED            mov	al,-$813[bp]
13110 390D           8846         F4            mov	-$C[bp],al
13111                                           !BCC_EOS
13112                                           ! 2428   atacmd[5]=*((Bit8u *)&lba);
13113                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
13114 3910           8A86       F7EC            mov	al,-$814[bp]
13115 3914           8846         F5            mov	-$B[bp],al
13116                                           !BCC_EOS
13117                                           ! 2429   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
13118                                           ! Debug: list int = const 0 (used reg = )
13119 3917           31C0                       xor	ax,ax
13120 3919           50                         push	ax
13121                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13122 391A           FFB6       F7EA            push	-$816[bp]
13123                                           ! Debug: list int = const 1 (used reg = )
13124 391E           B8                   0001  mov	ax,*1
13125 3921           50                         push	ax
13126                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$826-$81A] (used reg = )
13127 3922           8B86       F7E8            mov	ax,-$818[bp]
13128 3926           31DB                       xor	bx,bx
13129                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
13130 3928           53                         push	bx
13131 3929           50                         push	ax
13132 392A           B8                   0200  mov	ax,#$200
13133 392D           31DB                       xor	bx,bx
13134 392F           53                         push	bx
13135 3930           50                         push	ax
13136 3931           8B86       F7D8            mov	ax,-$828[bp]
13137 3935           8B9E       F7DA            mov	bx,-$826[bp]
13138 3939           8DBE       F7D4            lea	di,-$82C[bp]
13139 393D           E8         C77A            call	lmulul
13140 3940           83C4                   08  add	sp,*8
13141                                           ! Debug: list unsigned long = bx+0 (used reg = )
13142 3943           53                         push	bx
13143 3944           50                         push	ax
13144                                           ! Debug: list int = const 0 (used reg = )
13145 3945           31C0                       xor	ax,ax
13146 3947           50                         push	ax
13147                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
13148 3948           8D5E         F0            lea	bx,-$10[bp]
13149 394B           53                         push	bx
13150                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13151 394C           E8         CD0B            call	_get_SS
13152                                           ! Debug: list unsigned short = ax+0 (used reg = )
13153 394F           50                         push	ax
13154                                           ! Debug: list int = const $C (used reg = )
13155 3950           B8                   000C  mov	ax,*$C
13156 3953           50                         push	ax
13157                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
13158 3954           8A86       F7E3            mov	al,-$81D[bp]
13159 3958           30E4                       xor	ah,ah
13160 395A           50                         push	ax
13161                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13162 395B           E8         F3E8            call	_ata_cmd_packet
13163 395E           83C4                   14  add	sp,*$14
13164                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
13165 3961           8986       F7E4            mov	-$81C[bp],ax
13166                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13167 3965           85C0                       test	ax,ax
13168 3967           74           0F            je  	.326
13169                       00003969            .327:
13170                                           ! 2430   {
13171                                           ! 2431     set_DS(old_ds);
13172                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13173 3969           FF76         FC            push	-4[bp]
13174                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13175 396C           E8         CCEE            call	_set_DS
13176 396F           44                         inc	sp
13177 3970           44                         inc	sp
13178                                           !BCC_EOS
13179                                           ! 2432     return 12;
13180 3971           B8                   000C  mov	ax,*$C
13181 3974           89EC                       mov	sp,bp
13182 3976           5D                         pop	bp
13183 3977           C3                         ret
13184                                           !BCC_EOS
13185                                           ! 2433   }
13186                                           ! 2434   switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
13187                       00003978            .326:
13188 3978           A0         025B            mov	al,[$25B]
13189 397B           E9         009B            br 	.32A
13190                                           ! 2435     case 0x01:
13191                                           ! 2436       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (15);
13192                       0000397E            .32B:
13193                                           ! Debug: eq int = const $F to unsigned short = [+$26E] (used reg = )
13194 397E           B8                   000F  mov	ax,*$F
13195 3981           A3         026E            mov	[$26E],ax
13196                                           !BCC_EOS
13197                                           ! 2437       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13198                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13199 3984           B8                   0050  mov	ax,*$50
13200 3987           A3         026C            mov	[$26C],ax
13201                                           !BCC_EOS
13202                                           ! 2438       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13203                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13204 398A           B8                   0002  mov	ax,*2
13205 398D           A3         026A            mov	[$26A],ax
13206                                           !BCC_EOS
13207                                           ! 2439       break;
13208 3990           E9         009C            br 	.328
13209                                           !BCC_EOS
13210                                           ! 2440     case 0x02:
13211                                           ! 2441       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (18);
13212                       00003993            .32C:
13213                                           ! Debug: eq int = const $12 to unsigned short = [+$26E] (used reg = )
13214 3993           B8                   0012  mov	ax,*$12
13215 3996           A3         026E            mov	[$26E],ax
13216                                           !BCC_EOS
13217                                           ! 2442       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13218                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13219 3999           B8                   0050  mov	ax,*$50
13220 399C           A3         026C            mov	[$26C],ax
13221                                           !BCC_EOS
13222                                           ! 2443       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13223                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13224 399F           B8                   0002  mov	ax,*2
13225 39A2           A3         026A            mov	[$26A],ax
13226                                           !BCC_EOS
13227                                           ! 2444       break;
13228 39A5           E9         0087            br 	.328
13229                                           !BCC_EOS
13230                                           ! 2445     case 0x03:
13231                                           ! 2446       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (36);
13232                       000039A8            .32D:
13233                                           ! Debug: eq int = const $24 to unsigned short = [+$26E] (used reg = )
13234 39A8           B8                   0024  mov	ax,*$24
13235 39AB           A3         026E            mov	[$26E],ax
13236                                           !BCC_EOS
13237                                           ! 2447       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13238                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13239 39AE           B8                   0050  mov	ax,*$50
13240 39B1           A3         026C            mov	[$26C],ax
13241                                           !BCC_EOS
13242                                           ! 2448       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13243                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13244 39B4           B8                   0002  mov	ax,*2
13245 39B7           A3         026A            mov	[$26A],ax
13246                                           !BCC_EOS
13247                                           ! 2449       break;
13248 39BA           EB           73            jmp .328
13249                                           !BCC_EOS
13250                                           ! 2450     case 0x04:
13251                                           ! 2451       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (_read_byte(446+6, boot_segment)&0x3f);
13252                       000039BC            .32E:
13253                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13254 39BC           FFB6       F7EA            push	-$816[bp]
13255                                           ! Debug: list int = const $1C4 (used reg = )
13256 39C0           B8                   01C4  mov	ax,#$1C4
13257 39C3           50                         push	ax
13258                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13259 39C4           E8         CC18            call	__read_byte
13260 39C7           83C4                   04  add	sp,*4
13261                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
13262 39CA           24                     3F  and	al,*$3F
13263                                           ! Debug: eq unsigned char = al+0 to unsigned short = [+$26E] (used reg = )
13264 39CC           30E4                       xor	ah,ah
13265 39CE           A3         026E            mov	[$26E],ax
13266                                           !BCC_EOS
13267                                           ! 2452       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = ((_read_byte(446+6, boot_segment)<<2) + _read_byte(446+7, boot_segment) + 1);
13268                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13269 39D1           FFB6       F7EA            push	-$816[bp]
13270                                           ! Debug: list int = const $1C5 (used reg = )
13271 39D5           B8                   01C5  mov	ax,#$1C5
13272 39D8           50                         push	ax
13273                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13274 39D9           E8         CC03            call	__read_byte
13275 39DC           83C4                   04  add	sp,*4
13276 39DF           50                         push	ax
13277                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13278 39E0           FFB6       F7EA            push	-$816[bp]
13279                                           ! Debug: list int = const $1C4 (used reg = )
13280 39E4           B8                   01C4  mov	ax,#$1C4
13281 39E7           50                         push	ax
13282                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13283 39E8           E8         CBF4            call	__read_byte
13284 39EB           83C4                   04  add	sp,*4
13285                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
13286 39EE           30E4                       xor	ah,ah
13287 39F0           D1E0                       shl	ax,*1
13288 39F2           D1E0                       shl	ax,*1
13289                                           ! Debug: add unsigned char (temp) = [S+$822-$822] to unsigned int = ax+0 (used reg = )
13290 39F4           0286       F7E0            add	al,0+..FFF9[bp]
13291 39F8           80D4                   00  adc	ah,*0
13292 39FB           44                         inc	sp
13293 39FC           44                         inc	sp
13294                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
13295                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26C] (used reg = )
13296 39FD           40                         inc	ax
13297 39FE           A3         026C            mov	[$26C],ax
13298                                           !BCC_EOS
13299                                           ! 2453       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (_read_byte(44
13300                                           ! 2453 6+5, boot_segment) + 1);
13301                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13302 3A01           FFB6       F7EA            push	-$816[bp]
13303                                           ! Debug: list int = const $1C3 (used reg = )
13304 3A05           B8                   01C3  mov	ax,#$1C3
13305 3A08           50                         push	ax
13306                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13307 3A09           E8         CBD3            call	__read_byte
13308 3A0C           83C4                   04  add	sp,*4
13309                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13310 3A0F           30E4                       xor	ah,ah
13311                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26A] (used reg = )
13312 3A11           40                         inc	ax
13313 3A12           A3         026A            mov	[$26A],ax
13314                                           !BCC_EOS
13315                                           ! 2454       break;
13316 3A15           EB           18            jmp .328
13317                                           !BCC_EOS
13318                                           ! 2455    }
13319                                           ! 2456   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0) {
13320 3A17           EB           16            jmp .328
13321                       00003A19            .32A:
13322 3A19           2C                     01  sub	al,*1
13323 3A1B         0F84         FF5F            beq 	.32B
13324 3A1F           2C                     01  sub	al,*1
13325 3A21         0F84         FF6E            beq 	.32C
13326 3A25           2C                     01  sub	al,*1
13327 3A27         0F84         FF7D            beq 	.32D
13328 3A2B           2C                     01  sub	al,*1
13329 3A2D           74           8D            je 	.32E
13330                       00003A2F            .328:
13331                       FFFFF7E0            ..FFF9	=	-$820
13332                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13333 3A2F           A0         025B            mov	al,[$25B]
13334 3A32           84C0                       test	al,al
13335 3A34           74           33            je  	.32F
13336                       00003A36            .330:
13337                                           ! 2457     if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))==0x00)
13338                                           ! Debug: logeq int = const 0 to unsigned char = [+$25C] (used reg = )
13339 3A36           A0         025C            mov	al,[$25C]
13340 3A39           84C0                       test	al,al
13341 3A3B           75           23            jne 	.331
13342                       00003A3D            .332:
13343                                           ! 2458       _write_byte(_read_byte(0x10, 0x40)|0x41, 0x10, 0x40);
13344                                           ! Debug: list int = const $40 (used reg = )
13345 3A3D           B8                   0040  mov	ax,*$40
13346 3A40           50                         push	ax
13347                                           ! Debug: list int = const $10 (used reg = )
13348 3A41           B8                   0010  mov	ax,*$10
13349 3A44           50                         push	ax
13350                                           ! Debug: list int = const $40 (used reg = )
13351 3A45           B8                   0040  mov	ax,*$40
13352 3A48           50                         push	ax
13353                                           ! Debug: list int = const $10 (used reg = )
13354 3A49           B8                   0010  mov	ax,*$10
13355 3A4C           50                         push	ax
13356                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13357 3A4D           E8         CB8F            call	__read_byte
13358 3A50           83C4                   04  add	sp,*4
13359                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
13360 3A53           0C                     41  or	al,*$41
13361                                           ! Debug: list unsigned char = al+0 (used reg = )
13362 3A55           30E4                       xor	ah,ah
13363 3A57           50                         push	ax
13364                                           ! Debug: func () void = _write_byte+0 (used reg = )
13365 3A58           E8         CBA0            call	__write_byte
13366 3A5B           83C4                   06  add	sp,*6
13367                                           !BCC_EOS
13368                                           ! 2459     else
13369                                           ! 2460       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) + 1);
13370 3A5E           EB           09            jmp .333
13371                       00003A60            .331:
13372                                           ! Debug: add int = const 1 to unsigned char = [+$232] (used reg = )
13373 3A60           A0         0232            mov	al,[$232]
13374 3A63           30E4                       xor	ah,ah
13375                                           ! Debug: eq unsigned int = ax+1 to unsigned char = [+$232] (used reg = )
13376 3A65           40                         inc	ax
13377 3A66           A2         0232            mov	[$232],al
13378                                           !BCC_EOS
13379                                           ! 2461   }
13380                       00003A69            .333:
13381                                           ! 2462   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0)
13382                       00003A69            .32F:
13383                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13384 3A69           A0         025B            mov	al,[$25B]
13385 3A6C           84C0                       test	al,al
13386 3A6E           74           05            je  	.334
13387                       00003A70            .335:
13388                                           ! 2463     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) = (0x01);
13389                                           ! Debug: eq int = const 1 to unsigned char = [+$25A] (used reg = )
13390 3A70           B0                     01  mov	al,*1
13391 3A72           A2         025A            mov	[$25A],al
13392                                           !BCC_EOS
13393                                           ! 2464   i = (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))*0x100)+0;
13394                       00003A75            .334:
13395                                           ! Debug: mul int = const $100 to unsigned char = [+$25C] (used reg = )
13396 3A75           A0         025C            mov	al,[$25C]
13397 3A78           30E4                       xor	ah,ah
13398 3A7A           B9                   0100  mov	cx,#$100
13399 3A7D           F7E9                       imul	cx
13400                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
13401                                           ! Debug: eq unsigned int = ax+0 to unsigned short i = [S+$820-$81C] (used reg = )
13402 3A7F           8986       F7E6            mov	-$81A[bp],ax
13403                                           !BCC_EOS
13404                                           ! 2465   set_DS(old_ds);
13405                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13406 3A83           FF76         FC            push	-4[bp]
13407                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13408 3A86           E8         CBD4            call	_set_DS
13409 3A89           44                         inc	sp
13410 3A8A           44                         inc	sp
13411                                           !BCC_EOS
13412                                           ! 2466   return i;
13413 3A8B           8B86       F7E6            mov	ax,-$81A[bp]
13414 3A8F           89EC                       mov	sp,bp
13415 3A91           5D                         pop	bp
13416 3A92           C3                         ret
13417                                           !BCC_EOS
13418                                           ! 2467 }
13419                                           ! 2468 void int14_function(regs, ds, iret_addr)
13420                                           ! Register BX used in function cdrom_boot
13421                                           ! 2469   pusha_regs_t regs;
13422                                           export	_int14_function
13423                       00003A93            _int14_function:
13424                                           !BCC_EOS
13425                                           ! 2470   Bit16u ds;
13426                                           !BCC_EOS
13427                                           ! 2471   iret_addr_t iret_addr;
13428                                           !BCC_EOS
13429                                           ! 2472 {
13430                                           ! 2473   Bit16u addr,timer,val16;
13431                                           !BCC_EOS
13432                                           ! 2474   Bit8u counter;
13433                                           !BCC_EOS
13434                                           ! 2475 #asm
13435 3A93           55                         push	bp
13436 3A94           89E5                       mov	bp,sp
13437 3A96           83C4                   F8  add	sp,*-8
13438                                           !BCC_EOS
13439                                           !BCC_ASM
13440                       0000001C            _int14_function.ds	set	$1C
13441                       00000014            .int14_function.ds	set	$14
13442                       00000001            _int14_function.counter	set	1
13443                       FFFFFFF9            .int14_function.counter	set	-7
13444                       00000004            _int14_function.timer	set	4
13445                       FFFFFFFC            .int14_function.timer	set	-4
13446                       0000001E            _int14_function.iret_addr	set	$1E
13447                       00000016            .int14_function.iret_addr	set	$16
13448                       00000006            _int14_function.addr	set	6
13449                       FFFFFFFE            .int14_function.addr	set	-2
13450                       00000002            _int14_function.val16	set	2
13451                       FFFFFFFA            .int14_function.val16	set	-6
13452                       0000000C            _int14_function.regs	set	$C
13453                       00000004            .int14_function.regs	set	4
13454 3A99           FB                           sti
13455                                           ! 2477 endasm
13456                                           !BCC_ENDASM
13457                                           !BCC_EOS
13458                                           ! 2478   addr = *((Bit16u *)(0x400 + (regs.u.r16.dx << 1)));
13459                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
13460 3A9A           8B46         0E            mov	ax,$E[bp]
13461 3A9D           D1E0                       shl	ax,*1
13462                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
13463                                           ! Debug: expression subtree swapping
13464                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$400 (used reg = )
13465 3A9F           89C3                       mov	bx,ax
13466                                           ! Debug: eq unsigned short = [bx+$400] to unsigned short addr = [S+$A-4] (used reg = )
13467 3AA1           8B9F       0400            mov	bx,$400[bx]
13468 3AA5           895E         FE            mov	-2[bp],bx
13469                                           !BCC_EOS
13470                                           ! 2479   counter = *((Bit8u *)(0x047C + regs.u.r16.dx));
13471                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $47C (used reg = )
13472                                           ! Debug: expression subtree swapping
13473 3AA8           8B46         0E            mov	ax,$E[bp]
13474                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$47C (used reg = )
13475 3AAB           89C3                       mov	bx,ax
13476                                           ! Debug: eq unsigned char = [bx+$47C] to unsigned char counter = [S+$A-9] (used reg = )
13477 3AAD           8A87       047C            mov	al,$47C[bx]
13478 3AB1           8846         F9            mov	-7[bp],al
13479                                           !BCC_EOS
13480                                           ! 2480   if ((regs.u.r16.dx < 4) && (addr > 0)) {
13481                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
13482 3AB4           8B46         0E            mov	ax,$E[bp]
13483 3AB7           3D                   0004  cmp	ax,*4
13484 3ABA         0F83         01F6            bhis	.336
13485                       00003ABE            .338:
13486                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
13487 3ABE           8B46         FE            mov	ax,-2[bp]
13488 3AC1           85C0                       test	ax,ax
13489 3AC3         0F84         01ED            beq 	.336
13490                       00003AC7            .337:
13491                                           ! 2481     switch (regs.u.r8.ah) {
13492 3AC7           8A46         13            mov	al,$13[bp]
13493 3ACA           E9         01CD            br 	.33B
13494                                           ! 2482       case 0:
13495                                           ! 2483         outb(addr+3, inb(addr+3) | 0x80);
13496                       00003ACD            .33C:
13497                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
13498 3ACD           8B46         FE            mov	ax,-2[bp]
13499                                           ! Debug: list unsigned int = ax+3 (used reg = )
13500 3AD0           05                   0003  add	ax,*3
13501 3AD3           50                         push	ax
13502                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13503 3AD4           E8         CA52            call	_inb
13504 3AD7           44                         inc	sp
13505 3AD8           44                         inc	sp
13506                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
13507 3AD9           0C                     80  or	al,#$80
13508                                           ! Debug: list unsigned char = al+0 (used reg = )
13509 3ADB           30E4                       xor	ah,ah
13510 3ADD           50                         push	ax
13511                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13512 3ADE           8B46         FE            mov	ax,-2[bp]
13513                                           ! Debug: list unsigned int = ax+3 (used reg = )
13514 3AE1           05                   0003  add	ax,*3
13515 3AE4           50                         push	ax
13516                                           ! Debug: func () void = outb+0 (used reg = )
13517 3AE5           E8         CA57            call	_outb
13518 3AE8           83C4                   04  add	sp,*4
13519                                           !BCC_EOS
13520                                           ! 2484         if (regs.u.r8.al & 0xE0 == 0) {
13521                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
13522 3AEB           8A46         12            mov	al,$12[bp]
13523 3AEE           30C0                       xor	al,al
13524 3AF0           84C0                       test	al,al
13525 3AF2           74           1E            je  	.33D
13526                       00003AF4            .33E:
13527                                           ! 2485           outb(addr, 0x17);
13528                                           ! Debug: list int = const $17 (used reg = )
13529 3AF4           B8                   0017  mov	ax,*$17
13530 3AF7           50                         push	ax
13531                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13532 3AF8           FF76         FE            push	-2[bp]
13533                                           ! Debug: func () void = outb+0 (used reg = )
13534 3AFB           E8         CA41            call	_outb
13535 3AFE           83C4                   04  add	sp,*4
13536                                           !BCC_EOS
13537                                           ! 2486           outb(addr+1, 0x04);
13538                                           ! Debug: list int = const 4 (used reg = )
13539 3B01           B8                   0004  mov	ax,*4
13540 3B04           50                         push	ax
13541                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13542 3B05           8B46         FE            mov	ax,-2[bp]
13543                                           ! Debug: list unsigned int = ax+1 (used reg = )
13544 3B08           40                         inc	ax
13545 3B09           50                         push	ax
13546                                           ! Debug: func () void = outb+0 (used reg = )
13547 3B0A           E8         CA32            call	_outb
13548 3B0D           83C4                   04  add	sp,*4
13549                                           !BCC_EOS
13550                                           ! 2487         } else {
13551 3B10           EB           37            jmp .33F
13552                       00003B12            .33D:
13553                                           ! 2488           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
13554                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
13555 3B12           8A46         12            mov	al,$12[bp]
13556 3B15           24                     E0  and	al,#$E0
13557                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
13558 3B17           30E4                       xor	ah,ah
13559 3B19           B1                     05  mov	cl,*5
13560 3B1B           D3E8                       shr	ax,cl
13561                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
13562 3B1D           89C3                       mov	bx,ax
13563 3B1F           B8                   0600  mov	ax,#$600
13564 3B22           89D9                       mov	cx,bx
13565 3B24           D3F8                       sar	ax,cl
13566                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
13567 3B26           8946         FA            mov	-6[bp],ax
13568                                           !BCC_EOS
13569                                           ! 2489           outb(addr, val16 & 0xFF);
13570                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
13571 3B29           8A46         FA            mov	al,-6[bp]
13572                                           ! Debug: list unsigned char = al+0 (used reg = )
13573 3B2C           30E4                       xor	ah,ah
13574 3B2E           50                         push	ax
13575                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13576 3B2F           FF76         FE            push	-2[bp]
13577                                           ! Debug: func () void = outb+0 (used reg = )
13578 3B32           E8         CA0A            call	_outb
13579 3B35           83C4                   04  add	sp,*4
13580                                           !BCC_EOS
13581                                           ! 2490           outb(addr+1, *(((Bit8u *)&val16)+1));
13582                                           ! Debug: list unsigned char val16 = [S+$A-7] (used reg = )
13583 3B38           8A46         FB            mov	al,-5[bp]
13584 3B3B           30E4                       xor	ah,ah
13585 3B3D           50                         push	ax
13586                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13587 3B3E           8B46         FE            mov	ax,-2[bp]
13588                                           ! Debug: list unsigned int = ax+1 (used reg = )
13589 3B41           40                         inc	ax
13590 3B42           50                         push	ax
13591                                           ! Debug: func () void = outb+0 (used reg = )
13592 3B43           E8         C9F9            call	_outb
13593 3B46           83C4                   04  add	sp,*4
13594                                           !BCC_EOS
13595                                           ! 2491         }
13596                                           ! 2492         outb(addr+3, regs.u.r8.al & 0x1F);
13597                       00003B49            .33F:
13598                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
13599 3B49           8A46         12            mov	al,$12[bp]
13600 3B4C           24                     1F  and	al,*$1F
13601                                           ! Debug: list unsigned char = al+0 (used reg = )
13602 3B4E           30E4                       xor	ah,ah
13603 3B50           50                         push	ax
13604                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13605 3B51           8B46         FE            mov	ax,-2[bp]
13606                                           ! Debug: list unsigned int = ax+3 (used reg = )
13607 3B54           05                   0003  add	ax,*3
13608 3B57           50                         push	ax
13609                                           ! Debug: func () void = outb+0 (used reg = )
13610 3B58           E8         C9E4            call	_outb
13611 3B5B           83C4                   04  add	sp,*4
13612                                           !BCC_EOS
13613                                           ! 2493         regs.u.r8.ah = inb(addr+5);
13614                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13615 3B5E           8B46         FE            mov	ax,-2[bp]
13616                                           ! Debug: list unsigned int = ax+5 (used reg = )
13617 3B61           05                   0005  add	ax,*5
13618 3B64           50                         push	ax
13619                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13620 3B65           E8         C9C1            call	_inb
13621 3B68           44                         inc	sp
13622 3B69           44                         inc	sp
13623                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13624 3B6A           8846         13            mov	$13[bp],al
13625                                           !BCC_EOS
13626                                           ! 2494         regs.u.r8.al = inb(addr+6);
13627                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13628 3B6D           8B46         FE            mov	ax,-2[bp]
13629                                           ! Debug: list unsigned int = ax+6 (used reg = )
13630 3B70           05                   0006  add	ax,*6
13631 3B73           50                         push	ax
13632                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13633 3B74           E8         C9B2            call	_inb
13634 3B77           44                         inc	sp
13635 3B78           44                         inc	sp
13636                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13637 3B79           8846         12            mov	$12[bp],al
13638                                           !BCC_EOS
13639                                           ! 2495         iret_addr.flags.u.r8.flagsl &= 0xfe;
13640                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13641 3B7C           8A46         1A            mov	al,$1A[bp]
13642 3B7F           24                     FE  and	al,#$FE
13643 3B81           8846         1A            mov	$1A[bp],al
13644                                           !BCC_EOS
13645                                           ! 2496         break;
13646 3B84           E9         012B            br 	.339
13647                                           !BCC_EOS
13648                                           ! 2497       case 1:
13649                                           ! 2498         timer = *((Bit16u *)(0x046C));
13650                       00003B87            .340:
13651                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13652 3B87           A1         046C            mov	ax,[$46C]
13653 3B8A           8946         FC            mov	-4[bp],ax
13654                                           !BCC_EOS
13655                                           ! 2499         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
13656 3B8D           EB           1B            jmp .342
13657                       00003B8F            .343:
13658                                           ! 2500           val16 = *((Bit16u *)(0x046C));
13659                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13660 3B8F           A1         046C            mov	ax,[$46C]
13661 3B92           8946         FA            mov	-6[bp],ax
13662                                           !BCC_EOS
13663                                           ! 2501           if (val16 != timer) {
13664                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13665 3B95           8B46         FA            mov	ax,-6[bp]
13666 3B98           3B46         FC            cmp	ax,-4[bp]
13667 3B9B           74           0D            je  	.344
13668                       00003B9D            .345:
13669                                           ! 2502             timer = val16;
13670                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13671 3B9D           8B46         FA            mov	ax,-6[bp]
13672 3BA0           8946         FC            mov	-4[bp],ax
13673                                           !BCC_EOS
13674                                           ! 2503             counter--;
13675                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13676 3BA3           8A46         F9            mov	al,-7[bp]
13677 3BA6           48                         dec	ax
13678 3BA7           8846         F9            mov	-7[bp],al
13679                                           !BCC_EOS
13680                                           ! 2504           }
13681                                           ! 2505         }
13682                       00003BAA            .344:
13683                                           ! 2506         if (counter > 0) {
13684                       00003BAA            .342:
13685                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13686 3BAA           8B46         FE            mov	ax,-2[bp]
13687                                           ! Debug: list unsigned int = ax+5 (used reg = )
13688 3BAD           05                   0005  add	ax,*5
13689 3BB0           50                         push	ax
13690                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13691 3BB1           E8         C975            call	_inb
13692 3BB4           44                         inc	sp
13693 3BB5           44                         inc	sp
13694                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
13695 3BB6           24                     60  and	al,*$60
13696                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
13697 3BB8           3C                     60  cmp	al,*$60
13698 3BBA           74           07            je  	.346
13699                       00003BBC            .347:
13700 3BBC           8A46         F9            mov	al,-7[bp]
13701 3BBF           84C0                       test	al,al
13702 3BC1           75           CC            jne	.343
13703                       00003BC3            .346:
13704                       00003BC3            .341:
13705                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13706 3BC3           8A46         F9            mov	al,-7[bp]
13707 3BC6           84C0                       test	al,al
13708 3BC8           74           20            je  	.348
13709                       00003BCA            .349:
13710                                           ! 2507           outb(addr, regs.u.r8.al);
13711                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
13712 3BCA           8A46         12            mov	al,$12[bp]
13713 3BCD           30E4                       xor	ah,ah
13714 3BCF           50                         push	ax
13715                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13716 3BD0           FF76         FE            push	-2[bp]
13717                                           ! Debug: func () void = outb+0 (used reg = )
13718 3BD3           E8         C969            call	_outb
13719 3BD6           83C4                   04  add	sp,*4
13720                                           !BCC_EOS
13721                                           ! 2508           regs.u.r8.ah = inb(addr+5);
13722                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13723 3BD9           8B46         FE            mov	ax,-2[bp]
13724                                           ! Debug: list unsigned int = ax+5 (used reg = )
13725 3BDC           05                   0005  add	ax,*5
13726 3BDF           50                         push	ax
13727                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13728 3BE0           E8         C946            call	_inb
13729 3BE3           44                         inc	sp
13730 3BE4           44                         inc	sp
13731                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13732 3BE5           8846         13            mov	$13[bp],al
13733                                           !BCC_EOS
13734                                           ! 2509         } else {
13735 3BE8           EB           05            jmp .34A
13736                       00003BEA            .348:
13737                                           ! 2510           regs.u.r8.ah = 0x80;
13738                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13739 3BEA           B0                     80  mov	al,#$80
13740 3BEC           8846         13            mov	$13[bp],al
13741                                           !BCC_EOS
13742                                           ! 2511         }
13743                                           ! 2512         iret_addr.flags.u.r8.flagsl &= 0xfe;
13744                       00003BEF            .34A:
13745                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13746 3BEF           8A46         1A            mov	al,$1A[bp]
13747 3BF2           24                     FE  and	al,#$FE
13748 3BF4           8846         1A            mov	$1A[bp],al
13749                                           !BCC_EOS
13750                                           ! 2513         break;
13751 3BF7           E9         00B8            br 	.339
13752                                           !BCC_EOS
13753                                           ! 2514       case 2:
13754                                           ! 2515         timer = *((Bit16u *)(0x046C));
13755                       00003BFA            .34B:
13756                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13757 3BFA           A1         046C            mov	ax,[$46C]
13758 3BFD           8946         FC            mov	-4[bp],ax
13759                                           !BCC_EOS
13760                                           ! 2516         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
13761 3C00           EB           1B            jmp .34D
13762                       00003C02            .34E:
13763                                           ! 2517           val16 = *((Bit16u *)(0x046C
13764                                           ! 2517 ));
13765                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13766 3C02           A1         046C            mov	ax,[$46C]
13767 3C05           8946         FA            mov	-6[bp],ax
13768                                           !BCC_EOS
13769                                           ! 2518           if (val16 != timer) {
13770                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13771 3C08           8B46         FA            mov	ax,-6[bp]
13772 3C0B           3B46         FC            cmp	ax,-4[bp]
13773 3C0E           74           0D            je  	.34F
13774                       00003C10            .350:
13775                                           ! 2519             timer = val16;
13776                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13777 3C10           8B46         FA            mov	ax,-6[bp]
13778 3C13           8946         FC            mov	-4[bp],ax
13779                                           !BCC_EOS
13780                                           ! 2520             counter--;
13781                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13782 3C16           8A46         F9            mov	al,-7[bp]
13783 3C19           48                         dec	ax
13784 3C1A           8846         F9            mov	-7[bp],al
13785                                           !BCC_EOS
13786                                           ! 2521           }
13787                                           ! 2522         }
13788                       00003C1D            .34F:
13789                                           ! 2523         if (counter > 0) {
13790                       00003C1D            .34D:
13791                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13792 3C1D           8B46         FE            mov	ax,-2[bp]
13793                                           ! Debug: list unsigned int = ax+5 (used reg = )
13794 3C20           05                   0005  add	ax,*5
13795 3C23           50                         push	ax
13796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13797 3C24           E8         C902            call	_inb
13798 3C27           44                         inc	sp
13799 3C28           44                         inc	sp
13800                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
13801 3C29           24                     01  and	al,*1
13802                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
13803 3C2B           84C0                       test	al,al
13804 3C2D           75           07            jne 	.351
13805                       00003C2F            .352:
13806 3C2F           8A46         F9            mov	al,-7[bp]
13807 3C32           84C0                       test	al,al
13808 3C34           75           CC            jne	.34E
13809                       00003C36            .351:
13810                       00003C36            .34C:
13811                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13812 3C36           8A46         F9            mov	al,-7[bp]
13813 3C39           84C0                       test	al,al
13814 3C3B           74           1C            je  	.353
13815                       00003C3D            .354:
13816                                           ! 2524           regs.u.r8.ah = inb(addr+5);
13817                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13818 3C3D           8B46         FE            mov	ax,-2[bp]
13819                                           ! Debug: list unsigned int = ax+5 (used reg = )
13820 3C40           05                   0005  add	ax,*5
13821 3C43           50                         push	ax
13822                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13823 3C44           E8         C8E2            call	_inb
13824 3C47           44                         inc	sp
13825 3C48           44                         inc	sp
13826                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13827 3C49           8846         13            mov	$13[bp],al
13828                                           !BCC_EOS
13829                                           ! 2525           regs.u.r8.al = inb(addr);
13830                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
13831 3C4C           FF76         FE            push	-2[bp]
13832                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13833 3C4F           E8         C8D7            call	_inb
13834 3C52           44                         inc	sp
13835 3C53           44                         inc	sp
13836                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13837 3C54           8846         12            mov	$12[bp],al
13838                                           !BCC_EOS
13839                                           ! 2526         } else {
13840 3C57           EB           05            jmp .355
13841                       00003C59            .353:
13842                                           ! 2527           regs.u.r8.ah = 0x80;
13843                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13844 3C59           B0                     80  mov	al,#$80
13845 3C5B           8846         13            mov	$13[bp],al
13846                                           !BCC_EOS
13847                                           ! 2528         }
13848                                           ! 2529         iret_addr.flags.u.r8.flagsl &= 0xfe;
13849                       00003C5E            .355:
13850                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13851 3C5E           8A46         1A            mov	al,$1A[bp]
13852 3C61           24                     FE  and	al,#$FE
13853 3C63           8846         1A            mov	$1A[bp],al
13854                                           !BCC_EOS
13855                                           ! 2530         break;
13856 3C66           EB           4A            jmp .339
13857                                           !BCC_EOS
13858                                           ! 2531       case 3:
13859                                           ! 2532         regs.u.r8.ah = inb(addr+5);
13860                       00003C68            .356:
13861                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13862 3C68           8B46         FE            mov	ax,-2[bp]
13863                                           ! Debug: list unsigned int = ax+5 (used reg = )
13864 3C6B           05                   0005  add	ax,*5
13865 3C6E           50                         push	ax
13866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13867 3C6F           E8         C8B7            call	_inb
13868 3C72           44                         inc	sp
13869 3C73           44                         inc	sp
13870                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13871 3C74           8846         13            mov	$13[bp],al
13872                                           !BCC_EOS
13873                                           ! 2533         regs.u.r8.al = inb(addr+6);
13874                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13875 3C77           8B46         FE            mov	ax,-2[bp]
13876                                           ! Debug: list unsigned int = ax+6 (used reg = )
13877 3C7A           05                   0006  add	ax,*6
13878 3C7D           50                         push	ax
13879                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13880 3C7E           E8         C8A8            call	_inb
13881 3C81           44                         inc	sp
13882 3C82           44                         inc	sp
13883                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13884 3C83           8846         12            mov	$12[bp],al
13885                                           !BCC_EOS
13886                                           ! 2534         iret_addr.flags.u.r8.flagsl &= 0xfe;
13887                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13888 3C86           8A46         1A            mov	al,$1A[bp]
13889 3C89           24                     FE  and	al,#$FE
13890 3C8B           8846         1A            mov	$1A[bp],al
13891                                           !BCC_EOS
13892                                           ! 2535         break;
13893 3C8E           EB           22            jmp .339
13894                                           !BCC_EOS
13895                                           ! 2536       default:
13896                                           ! 2537         iret_addr.flags.u.r8.flagsl |= 0x01;
13897                       00003C90            .357:
13898                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13899 3C90           8A46         1A            mov	al,$1A[bp]
13900 3C93           0C                     01  or	al,*1
13901 3C95           8846         1A            mov	$1A[bp],al
13902                                           !BCC_EOS
13903                                           ! 2538       }
13904                                           ! 2539   } else {
13905 3C98           EB           18            jmp .339
13906                       00003C9A            .33B:
13907 3C9A           2C                     00  sub	al,*0
13908 3C9C         0F84         FE2D            beq 	.33C
13909 3CA0           2C                     01  sub	al,*1
13910 3CA2         0F84         FEE1            beq 	.340
13911 3CA6           2C                     01  sub	al,*1
13912 3CA8         0F84         FF4E            beq 	.34B
13913 3CAC           2C                     01  sub	al,*1
13914 3CAE           74           B8            je 	.356
13915 3CB0           EB           DE            jmp	.357
13916                       00003CB2            .339:
13917                       FFFFFFF6            ..FFF8	=	-$A
13918 3CB2           EB           08            jmp .358
13919                       00003CB4            .336:
13920                                           ! 2540     iret_addr.flags.u.r8.flagsl |= 0x01;
13921                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13922 3CB4           8A46         1A            mov	al,$1A[bp]
13923 3CB7           0C                     01  or	al,*1
13924 3CB9           8846         1A            mov	$1A[bp],al
13925                                           !BCC_EOS
13926                                           ! 2541   }
13927                                           ! 2542 }
13928                       00003CBC            .358:
13929 3CBC           89EC                       mov	sp,bp
13930 3CBE           5D                         pop	bp
13931 3CBF           C3                         ret
13932                                           ! 2543   void
13933                                           ! Register BX used in function int14_function
13934                                           ! 2544 int15_function(regs, ES, DS, FLAGS)
13935                                           ! 2545   pusha_regs_t regs;
13936                                           export	_int15_function
13937                       00003CC0            _int15_function:
13938                                           !BCC_EOS
13939                                           ! 2546   Bit16u ES, DS, FLAGS;
13940                                           !BCC_EOS
13941                                           ! 2547 {
13942                                           ! 2548   Bit16u ebda_seg=get_ebda_seg();
13943 3CC0           55                         push	bp
13944 3CC1           89E5                       mov	bp,sp
13945 3CC3           4C                         dec	sp
13946 3CC4           4C                         dec	sp
13947                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
13948 3CC5           E8         C99F            call	_get_ebda_seg
13949                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13950 3CC8           8946         FE            mov	-2[bp],ax
13951                                           !BCC_EOS
13952                                           ! 2549   bx_bool prev_a20_enable;
13953                                           !BCC_EOS
13954                                           ! 2550   Bit16u base15_00;
13955                                           !BCC_EOS
13956                                           ! 2551   Bit8u base23_16;
13957                                           !BCC_EOS
13958                                           ! 2552   Bit16u ss;
13959                                           !BCC_EOS
13960                                           ! 2553   Bit16u BX,CX,DX;
13961                                           !BCC_EOS
13962                                           ! 2554   Bit16u bRegister;
13963                                           !BCC_EOS
13964                                           ! 2555   Bit8u irqDisable;
13965                                           !BCC_EOS
13966                                           ! 2556 ;
13967 3CCB           83C4                   EE  add	sp,*-$12
13968                                           !BCC_EOS
13969                                           ! 2557   switch (regs.u.r8.ah) {
13970 3CCE           8A46         13            mov	al,$13[bp]
13971 3CD1           E9         0482            br 	.35B
13972                                           ! 2558     case 0x24:
13973                                           ! 2559       switch (regs.u.r8.al) {
13974                       00003CD4            .35C:
13975 3CD4           8A46         12            mov	al,$12[bp]
13976 3CD7           EB           73            jmp .35F
13977                                           ! 2560         case 0x00:
13978                                           ! 2561         case 0x01:
13979                       00003CD9            .360:
13980                                           ! 2562           set_enable_a20(regs.u.r8.al);
13981                       00003CD9            .361:
13982                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
13983 3CD9           8A46         12            mov	al,$12[bp]
13984 3CDC           30E4                       xor	ah,ah
13985 3CDE           50                         push	ax
13986                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
13987 3CDF           E8         DA4F            call	_set_enable_a20
13988 3CE2           44                         inc	sp
13989 3CE3           44                         inc	sp
13990                                           !BCC_EOS
13991                                           ! 2563           FLAGS &= 0xfffe;
13992                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
13993 3CE4           8B46         18            mov	ax,$18[bp]
13994 3CE7           24                     FE  and	al,#$FE
13995 3CE9           8946         18            mov	$18[bp],ax
13996                                           !BCC_EOS
13997                                           ! 2564           regs.u.r8.ah = 0;
13998                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
13999 3CEC           30C0                       xor	al,al
14000 3CEE           8846         13            mov	$13[bp],al
14001                                           !BCC_EOS
14002                                           ! 2565           break;
14003 3CF1           EB           6B            jmp .35D
14004                                           !BCC_EOS
14005                                           ! 2566         case 0x02:
14006                                           ! 2567           regs.u.r8.al = (inb(0x0092) >> 1) & 0x01;
14007                       00003CF3            .362:
14008                                           ! Debug: list int = const $92 (used reg = )
14009 3CF3           B8                   0092  mov	ax,#$92
14010 3CF6           50                         push	ax
14011                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14012 3CF7           E8         C82F            call	_inb
14013 3CFA           44                         inc	sp
14014 3CFB           44                         inc	sp
14015                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
14016 3CFC           30E4                       xor	ah,ah
14017 3CFE           D1E8                       shr	ax,*1
14018                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
14019 3D00           24                     01  and	al,*1
14020                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14021 3D02           8846         12            mov	$12[bp],al
14022                                           !BCC_EOS
14023                                           ! 2568           FLAGS &= 0xfffe;
14024                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14025 3D05           8B46         18            mov	ax,$18[bp]
14026 3D08           24                     FE  and	al,#$FE
14027 3D0A           8946         18            mov	$18[bp],ax
14028                                           !BCC_EOS
14029                                           ! 2569           regs.u.r8.ah = 0;
14030                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14031 3D0D           30C0                       xor	al,al
14032 3D0F           8846         13            mov	$13[bp],al
14033                                           !BCC_EOS
14034                                           ! 2570           break;
14035 3D12           EB           4A            jmp .35D
14036                                           !BCC_EOS
14037                                           ! 2571         case 0x03:
14038                                           ! 2572           FLAGS &= 0xfffe;
14039                       00003D14            .363:
14040                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14041 3D14           8B46         18            mov	ax,$18[bp]
14042 3D17           24                     FE  and	al,#$FE
14043 3D19           8946         18            mov	$18[bp],ax
14044                                           !BCC_EOS
14045                                           ! 2573           regs.u.r8.ah = 0;
14046                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14047 3D1C           30C0                       xor	al,al
14048 3D1E           8846         13            mov	$13[bp],al
14049                                           !BCC_EOS
14050                                           ! 2574           regs.u.r16.bx = 3;
14051                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
14052 3D21           B8                   0003  mov	ax,*3
14053 3D24           8946         0C            mov	$C[bp],ax
14054                                           !BCC_EOS
14055                                           ! 2575           break;
14056 3D27           EB           35            jmp .35D
14057                                           !BCC_EOS
14058                                           ! 2576         default:
14059                                           ! 2577           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
14060                       00003D29            .364:
14061                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14062 3D29           8A46         12            mov	al,$12[bp]
14063 3D2C           30E4                       xor	ah,ah
14064 3D2E           50                         push	ax
14065                                           ! Debug: list * char = .365+0 (used reg = )
14066 3D2F           BB                   D576  mov	bx,#.365
14067 3D32           53                         push	bx
14068                                           ! Debug: list int = const 4 (used reg = )
14069 3D33           B8                   0004  mov	ax,*4
14070 3D36           50                         push	ax
14071                                           ! Debug: func () void = bios_printf+0 (used reg = )
14072 3D37           E8         CBFF            call	_bios_printf
14073 3D3A           83C4                   06  add	sp,*6
14074                                           !BCC_EOS
14075                                           ! 2578           FLAGS |= 0x0001;
14076                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14077 3D3D           8B46         18            mov	ax,$18[bp]
14078 3D40           0C                     01  or	al,*1
14079 3D42           8946         18            mov	$18[bp],ax
14080                                           !BCC_EOS
14081                                           ! 2579           regs.u.r8.ah = 0x86;
14082                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14083 3D45           B0                     86  mov	al,#$86
14084 3D47           8846         13            mov	$13[bp],al
14085                                           !BCC_EOS
14086                                           ! 2580       }
14087                                           ! 2581       break;
14088 3D4A           EB           12            jmp .35D
14089                       00003D4C            .35F:
14090 3D4C           2C                     00  sub	al,*0
14091 3D4E           74           89            je 	.360
14092 3D50           2C                     01  sub	al,*1
14093 3D52           74           85            je 	.361
14094 3D54           2C                     01  sub	al,*1
14095 3D56           74           9B            je 	.362
14096 3D58           2C                     01  sub	al,*1
14097 3D5A           74           B8            je 	.363
14098 3D5C           EB           CB            jmp	.364
14099                       00003D5E            .35D:
14100 3D5E           E9         043F            br 	.359
14101                                           !BCC_EOS
14102                                           ! 2582     case 0x41:
14103                                           ! 2583       FLAGS |= 0x0001;
14104                       00003D61            .366:
14105                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14106 3D61           8B46         18            mov	ax,$18[bp]
14107 3D64           0C                     01  or	al,*1
14108 3D66           8946         18            mov	$18[bp],ax
14109                                           !BCC_EOS
14110                                           ! 2584       regs.u.r8.ah = 0x86;
14111                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14112 3D69           B0                     86  mov	al,#$86
14113 3D6B           8846         13            mov	$13[bp],al
14114                                           !BCC_EOS
14115                                           ! 2585       break;
14116 3D6E           E9         042F            br 	.359
14117                                           !BCC_EOS
14118                                           ! 2586     case 0x4f:
14119                                           ! 2587       FLAGS |= 0x0001;
14120                       00003D71            .367:
14121                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14122 3D71           8B46         18            mov	ax,$18[bp]
14123 3D74           0C                     01  or	al,*1
14124 3D76           8946         18            mov	$18[bp],ax
14125                                           !BCC_EOS
14126                                           ! 2588       break;
14127 3D79           E9         0424            br 	.359
14128                                           !BCC_EOS
14129                                           ! 2589     case 0x52:
14130                                           ! 2590       FLAGS &= 0xfffe;
14131                       00003D7C            .368:
14132                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14133 3D7C           8B46         18            mov	ax,$18[bp]
14134 3D7F           24                     FE  and	al,#$FE
14135 3D81           8946         18            mov	$18[bp],ax
14136                                           !BCC_EOS
14137                                           ! 2591       regs.u.r8.ah = 0;
14138                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14139 3D84           30C0                       xor	al,al
14140 3D86           8846         13            mov	$13[bp],al
14141                                           !BCC_EOS
14142                                           ! 2592       break;
14143 3D89           E9         0414            br 	.359
14144                                           !BCC_EOS
14145                                           ! 2593     case 0x83: {
14146                       00003D8C            .369:
14147                                           ! 2594       set_DS(0x40);
14148                                           ! Debug: list int = const $40 (used reg = )
14149 3D8C           B8                   0040  mov	ax,*$40
14150 3D8F           50                         push	ax
14151                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14152 3D90           E8         C8CA            call	_set_DS
14153 3D93           44                         inc	sp
14154 3D94           44                         inc	sp
14155                                           !BCC_EOS
14156                                           ! 2595       if( regs.u.r8.al == 0 ) {
14157                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
14158 3D95           8A46         12            mov	al,$12[bp]
14159 3D98           84C0                       test	al,al
14160 3D9A           75           7B            jne 	.36A
14161                       00003D9C            .36B:
14162                                           ! 2596         if( ( *((Bit8u *)(0xA0)) & 1 ) == 0 ) {
14163                                           ! Debug: and int = const 1 to unsigned char = [+$A0] (used reg = )
14164 3D9C           A0         00A0            mov	al,[$A0]
14165 3D9F           24                     01  and	al,*1
14166                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14167 3DA1           84C0                       test	al,al
14168 3DA3           75           63            jne 	.36C
14169                       00003DA5            .36D:
14170                                           ! 2597           *((Bit8u *)(0xA0)) = (1);
14171                                           ! Debug: eq int = const 1 to unsigned char = [+$A0] (used reg = )
14172 3DA5           B0                     01  mov	al,*1
14173 3DA7           A2         00A0            mov	[$A0],al
14174                                           !BCC_EOS
14175                                           ! 2598           *((Bit16u *)(0x98)) = (ES);
14176                                           ! Debug: eq unsigned short ES = [S+$16+$12] to unsigned short = [+$98] (used reg = )
14177 3DAA           8B46         14            mov	ax,$14[bp]
14178 3DAD           A3         0098            mov	[$98],ax
14179                                           !BCC_EOS
14180                                           ! 2599           *((Bit16u *)(0x9A)) = (regs.u.r16.bx);
14181                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short = [+$9A] (used reg = )
14182 3DB0           8B46         0C            mov	ax,$C[bp]
14183 3DB3           A3         009A            mov	[$9A],ax
14184                                           !BCC_EOS
14185                                           ! 2600           *((Bit16u *)(0x9C)) = (regs.u.r1
14186                                           ! 2600 6.dx);
14187                                           ! Debug: eq unsigned short regs = [S+$16+$C] to unsigned short = [+$9C] (used reg = )
14188 3DB6           8B46         0E            mov	ax,$E[bp]
14189 3DB9           A3         009C            mov	[$9C],ax
14190                                           !BCC_EOS
14191                                           ! 2601           *((Bit16u *)(0x9E)) = (regs.u.r16.cx);
14192                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short = [+$9E] (used reg = )
14193 3DBC           8B46         10            mov	ax,$10[bp]
14194 3DBF           A3         009E            mov	[$9E],ax
14195                                           !BCC_EOS
14196                                           ! 2602           FLAGS &= 0xfffe;
14197                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14198 3DC2           8B46         18            mov	ax,$18[bp]
14199 3DC5           24                     FE  and	al,#$FE
14200 3DC7           8946         18            mov	$18[bp],ax
14201                                           !BCC_EOS
14202                                           ! 2603           irqDisable = inb( 0x00a1 );
14203                                           ! Debug: list int = const $A1 (used reg = )
14204 3DCA           B8                   00A1  mov	ax,#$A1
14205 3DCD           50                         push	ax
14206                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14207 3DCE           E8         C758            call	_inb
14208 3DD1           44                         inc	sp
14209 3DD2           44                         inc	sp
14210                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
14211 3DD3           8846         ED            mov	-$13[bp],al
14212                                           !BCC_EOS
14213                                           ! 2604           outb( 0x00a1, irqDisable & 0xFE );
14214                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
14215 3DD6           8A46         ED            mov	al,-$13[bp]
14216 3DD9           24                     FE  and	al,#$FE
14217                                           ! Debug: list unsigned char = al+0 (used reg = )
14218 3DDB           30E4                       xor	ah,ah
14219 3DDD           50                         push	ax
14220                                           ! Debug: list int = const $A1 (used reg = )
14221 3DDE           B8                   00A1  mov	ax,#$A1
14222 3DE1           50                         push	ax
14223                                           ! Debug: func () void = outb+0 (used reg = )
14224 3DE2           E8         C75A            call	_outb
14225 3DE5           83C4                   04  add	sp,*4
14226                                           !BCC_EOS
14227                                           ! 2605           bRegister = inb_cmos( 0xB );
14228                                           ! Debug: list int = const $B (used reg = )
14229 3DE8           B8                   000B  mov	ax,*$B
14230 3DEB           50                         push	ax
14231                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14232 3DEC           E8         C77F            call	_inb_cmos
14233 3DEF           44                         inc	sp
14234 3DF0           44                         inc	sp
14235                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14236 3DF1           30E4                       xor	ah,ah
14237 3DF3           8946         EE            mov	-$12[bp],ax
14238                                           !BCC_EOS
14239                                           ! 2606           outb_cmos( 0xB, bRegister | 0x40 );
14240                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
14241 3DF6           8B46         EE            mov	ax,-$12[bp]
14242 3DF9           0C                     40  or	al,*$40
14243                                           ! Debug: list unsigned int = ax+0 (used reg = )
14244 3DFB           50                         push	ax
14245                                           ! Debug: list int = const $B (used reg = )
14246 3DFC           B8                   000B  mov	ax,*$B
14247 3DFF           50                         push	ax
14248                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14249 3E00           E8         C75C            call	_outb_cmos
14250 3E03           83C4                   04  add	sp,*4
14251                                           !BCC_EOS
14252                                           ! 2607         } else {
14253 3E06           EB           0D            jmp .36E
14254                       00003E08            .36C:
14255                                           ! 2608           ;
14256                                           !BCC_EOS
14257                                           ! 2609           FLAGS |= 0x0001;
14258                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14259 3E08           8B46         18            mov	ax,$18[bp]
14260 3E0B           0C                     01  or	al,*1
14261 3E0D           8946         18            mov	$18[bp],ax
14262                                           !BCC_EOS
14263                                           ! 2610           regs.u.r8.ah = 0x86;
14264                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14265 3E10           B0                     86  mov	al,#$86
14266 3E12           8846         13            mov	$13[bp],al
14267                                           !BCC_EOS
14268                                           ! 2611         }
14269                                           ! 2612       } else if( regs.u.r8.al == 1 ) {
14270                       00003E15            .36E:
14271 3E15           EB           48            jmp .36F
14272                       00003E17            .36A:
14273                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
14274 3E17           8A46         12            mov	al,$12[bp]
14275 3E1A           3C                     01  cmp	al,*1
14276 3E1C           75           2D            jne 	.370
14277                       00003E1E            .371:
14278                                           ! 2613         *((Bit8u *)(0xA0)) = (0);
14279                                           ! Debug: eq int = const 0 to unsigned char = [+$A0] (used reg = )
14280 3E1E           30C0                       xor	al,al
14281 3E20           A2         00A0            mov	[$A0],al
14282                                           !BCC_EOS
14283                                           ! 2614         FLAGS &= 0xfffe;
14284                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14285 3E23           8B46         18            mov	ax,$18[bp]
14286 3E26           24                     FE  and	al,#$FE
14287 3E28           8946         18            mov	$18[bp],ax
14288                                           !BCC_EOS
14289                                           ! 2615         bRegister = inb_cmos( 0xB );
14290                                           ! Debug: list int = const $B (used reg = )
14291 3E2B           B8                   000B  mov	ax,*$B
14292 3E2E           50                         push	ax
14293                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14294 3E2F           E8         C73C            call	_inb_cmos
14295 3E32           44                         inc	sp
14296 3E33           44                         inc	sp
14297                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14298 3E34           30E4                       xor	ah,ah
14299 3E36           8946         EE            mov	-$12[bp],ax
14300                                           !BCC_EOS
14301                                           ! 2616         outb_cmos( 0xB, bRegister & ~0x40 );
14302                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
14303 3E39           8B46         EE            mov	ax,-$12[bp]
14304 3E3C           24                     BF  and	al,#$BF
14305                                           ! Debug: list unsigned int = ax+0 (used reg = )
14306 3E3E           50                         push	ax
14307                                           ! Debug: list int = const $B (used reg = )
14308 3E3F           B8                   000B  mov	ax,*$B
14309 3E42           50                         push	ax
14310                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14311 3E43           E8         C719            call	_outb_cmos
14312 3E46           83C4                   04  add	sp,*4
14313                                           !BCC_EOS
14314                                           ! 2617       } else {
14315 3E49           EB           14            jmp .372
14316                       00003E4B            .370:
14317                                           ! 2618         ;
14318                                           !BCC_EOS
14319                                           ! 2619         FLAGS |= 0x0001;
14320                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14321 3E4B           8B46         18            mov	ax,$18[bp]
14322 3E4E           0C                     01  or	al,*1
14323 3E50           8946         18            mov	$18[bp],ax
14324                                           !BCC_EOS
14325                                           ! 2620         regs.u.r8.ah = 0x86;
14326                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14327 3E53           B0                     86  mov	al,#$86
14328 3E55           8846         13            mov	$13[bp],al
14329                                           !BCC_EOS
14330                                           ! 2621         regs.u.r8.al--;
14331                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
14332 3E58           8A46         12            mov	al,$12[bp]
14333 3E5B           48                         dec	ax
14334 3E5C           8846         12            mov	$12[bp],al
14335                                           !BCC_EOS
14336                                           ! 2622       }
14337                                           ! 2623       break;
14338                       00003E5F            .372:
14339                       00003E5F            .36F:
14340 3E5F           E9         033E            br 	.359
14341                                           !BCC_EOS
14342                                           ! 2624     }
14343                                           ! 2625     case 0x87:
14344                                           ! 2626 #asm
14345                       00003E62            .373:
14346                                           !BCC_EOS
14347                                           !BCC_ASM
14348                       00000006            _int15_function.CX	set	6
14349                       FFFFFFF2            .int15_function.CX	set	-$E
14350                       0000002C            _int15_function.FLAGS	set	$2C
14351                       00000018            .int15_function.FLAGS	set	$18
14352                       00000001            _int15_function.irqDisable	set	1
14353                       FFFFFFED            .int15_function.irqDisable	set	-$13
14354                       0000002A            _int15_function.DS	set	$2A
14355                       00000016            .int15_function.DS	set	$16
14356                       00000004            _int15_function.DX	set	4
14357                       FFFFFFF0            .int15_function.DX	set	-$10
14358                       0000000D            _int15_function.base23_16	set	$D
14359                       FFFFFFF9            .int15_function.base23_16	set	-7
14360                       00000002            _int15_function.bRegister	set	2
14361                       FFFFFFEE            .int15_function.bRegister	set	-$12
14362                       00000028            _int15_function.ES	set	$28
14363                       00000014            .int15_function.ES	set	$14
14364                       00000012            _int15_function.ebda_seg	set	$12
14365                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14366                       0000000E            _int15_function.base15_00	set	$E
14367                       FFFFFFFA            .int15_function.base15_00	set	-6
14368                       0000000A            _int15_function.ss	set	$A
14369                       FFFFFFF6            .int15_function.ss	set	-$A
14370                       00000008            _int15_function.BX	set	8
14371                       FFFFFFF4            .int15_function.BX	set	-$C
14372                       00000018            _int15_function.regs	set	$18
14373                       00000004            .int15_function.regs	set	4
14374                       00000010            _int15_function.prev_a20_enable	set	$10
14375                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14376 3E62           FA                           cli
14377                                           ! 2628 endasm
14378                                           !BCC_ENDASM
14379                                           !BCC_EOS
14380                                           ! 2629       prev_a20_enable = set_enable_a20(1);
14381                                           ! Debug: list int = const 1 (used reg = )
14382 3E63           B8                   0001  mov	ax,*1
14383 3E66           50                         push	ax
14384                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14385 3E67           E8         D8C7            call	_set_enable_a20
14386 3E6A           44                         inc	sp
14387 3E6B           44                         inc	sp
14388                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14389 3E6C           8946         FC            mov	-4[bp],ax
14390                                           !BCC_EOS
14391                                           ! 2630       base15_00 = (ES << 4) + regs.u.r16.si;
14392                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14393 3E6F           8B46         14            mov	ax,$14[bp]
14394 3E72           B1                     04  mov	cl,*4
14395 3E74           D3E0                       shl	ax,cl
14396                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
14397 3E76           0346         06            add	ax,6[bp]
14398                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14399 3E79           8946         FA            mov	-6[bp],ax
14400                                           !BCC_EOS
14401                                           ! 2631       base23_16 = ES >> 12;
14402                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
14403 3E7C           8B46         14            mov	ax,$14[bp]
14404 3E7F           88E0                       mov	al,ah
14405 3E81           30E4                       xor	ah,ah
14406 3E83           B1                     04  mov	cl,*4
14407 3E85           D3E8                       shr	ax,cl
14408                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14409 3E87           8846         F9            mov	-7[bp],al
14410                                           !BCC_EOS
14411                                           ! 2632       if (base15_00 < (ES<<4))
14412                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14413 3E8A           8B46         14            mov	ax,$14[bp]
14414 3E8D           B1                     04  mov	cl,*4
14415 3E8F           D3E0                       shl	ax,cl
14416                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14417 3E91           3B46         FA            cmp	ax,-6[bp]
14418 3E94           76           07            jbe 	.374
14419                       00003E96            .375:
14420                                           ! 2633         base23_16++;
14421                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
14422 3E96           8A46         F9            mov	al,-7[bp]
14423 3E99           40                         inc	ax
14424 3E9A           8846         F9            mov	-7[bp],al
14425                                           !BCC_EOS
14426                                           ! 2634       set_DS(ES);
14427                       00003E9D            .374:
14428                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14429 3E9D           FF76         14            push	$14[bp]
14430                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14431 3EA0           E8         C7BA            call	_set_DS
14432 3EA3           44                         inc	sp
14433 3EA4           44                         inc	sp
14434                                           !BCC_EOS
14435                                           ! 2635       *((Bit16u *)(regs.u.r16.si+0x08+0)) = (47);
14436                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14437 3EA5           8B46         06            mov	ax,6[bp]
14438                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
14439                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
14440 3EA8           89C3                       mov	bx,ax
14441                                           ! Debug: eq int = const $2F to unsigned short = [bx+8] (used reg = )
14442 3EAA           B8                   002F  mov	ax,*$2F
14443 3EAD           8947         08            mov	8[bx],ax
14444                                           !BCC_EOS
14445                                           ! 2636       *((Bit16u *)(regs.u.r16.si+0x08+2)) = (base15_00);
14446                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14447 3EB0           8B46         06            mov	ax,6[bp]
14448                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
14449                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
14450 3EB3           89C3                       mov	bx,ax
14451                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$A] (used reg = )
14452 3EB5           8B46         FA            mov	ax,-6[bp]
14453 3EB8           8947         0A            mov	$A[bx],ax
14454                                           !BCC_EOS
14455                                           ! 2637       *((Bit8u *)(regs.u.r16.si+0x08+4)) = (base23_16);
14456                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14457 3EBB           8B46         06            mov	ax,6[bp]
14458                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
14459                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$C (used reg = )
14460 3EBE           89C3                       mov	bx,ax
14461                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$C] (used reg = )
14462 3EC0           8A46         F9            mov	al,-7[bp]
14463 3EC3           8847         0C            mov	$C[bx],al
14464                                           !BCC_EOS
14465                                           ! 2638       *((Bit8u *)(regs.u.r16.si+0x08+5)) = (0x93);
14466                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14467 3EC6           8B46         06            mov	ax,6[bp]
14468                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
14469                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$D (used reg = )
14470 3EC9           89C3                       mov	bx,ax
14471                                           ! Debug: eq int = const $93 to unsigned char = [bx+$D] (used reg = )
14472 3ECB           B0                     93  mov	al,#$93
14473 3ECD           8847         0D            mov	$D[bx],al
14474                                           !BCC_EOS
14475                                           ! 2639       *((Bit16u *)(regs.u.r16.si+0x08+6)) = (0x0000);
14476                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14477 3ED0           8B46         06            mov	ax,6[bp]
14478                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
14479                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
14480 3ED3           89C3                       mov	bx,ax
14481                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
14482 3ED5           31C0                       xor	ax,ax
14483 3ED7           8947         0E            mov	$E[bx],ax
14484                                           !BCC_EOS
14485                                           ! 2640       *((Bit16u *)(regs.u.r16.si+0x20+0)) = (0xffff);
14486                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14487 3EDA           8B46         06            mov	ax,6[bp]
14488                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
14489                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$20 (used reg = )
14490 3EDD           89C3                       mov	bx,ax
14491                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$20] (used reg = )
14492 3EDF           B8                   FFFF  mov	ax,#$FFFF
14493 3EE2           8947         20            mov	$20[bx],ax
14494                                           !BCC_EOS
14495                                           ! 2641       *((Bit16u *)(regs.u.r16.si+0x20+2)) = (0x0000);
14496                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14497 3EE5           8B46         06            mov	ax,6[bp]
14498                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
14499                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
14500 3EE8           89C3                       mov	bx,ax
14501                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
14502 3EEA           31C0                       xor	ax,ax
14503 3EEC           8947         22            mov	$22[bx],ax
14504                                           !BCC_EOS
14505                                           ! 2642       *((Bit8u *)(regs.u.r16.si+0x20+4)) = (0x000f);
14506                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14507 3EEF           8B46         06            mov	ax,6[bp]
14508                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
14509                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
14510 3EF2           89C3                       mov	bx,ax
14511                                           ! Debug: eq int = const $F to unsigned char = [bx+$24] (used reg = )
14512 3EF4           B0                     0F  mov	al,*$F
14513 3EF6           8847         24            mov	$24[bx],al
14514                                           !BCC_EOS
14515                                           ! 2643       *((Bit8u *)(regs.u.r16.si+0x20+5)) = (0x9b);
14516                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14517 3EF9           8B46         06            mov	ax,6[bp]
14518                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
14519                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
14520 3EFC           89C3                       mov	bx,ax
14521                                           ! Debug: eq int = const $9B to unsigned char = [bx+$25] (used reg = )
14522 3EFE           B0                     9B  mov	al,#$9B
14523 3F00           8847         25            mov	$25[bx],al
14524                                           !BCC_EOS
14525                                           ! 2644       *((Bit16u *)(regs.u.r16.si+0x20+6)) = (0x0000);
14526                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14527 3F03           8B46         06            mov	ax,6[bp]
14528                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
14529                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$26 (used reg = )
14530 3F06           89C3                       mov	bx,ax
14531                                           ! Debug: eq int = const 0 to unsigned short = [bx+$26] (used reg = )
14532 3F08           31C0                       xor	ax,ax
14533 3F0A           8947         26            mov	$26[bx],ax
14534                                           !BCC_EOS
14535                                           ! 2645       ss = get_SS();
14536                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14537 3F0D           E8         C74A            call	_get_SS
14538                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
14539 3F10           8946         F6            mov	-$A[bp],ax
14540                                           !BCC_EOS
14541                                           ! 2646       base15_00 = ss << 4;
14542                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
14543 3F13           8B46         F6            mov	ax,-$A[bp]
14544 3F16           B1                     04  mov	cl,*4
14545 3F18           D3E0                       shl	ax,cl
14546                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14547 3F1A           8946         FA            mov	-6[bp],ax
14548                                           !BCC_EOS
14549                                           ! 2647       base23_16 = ss >> 12;
14550                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
14551 3F1D           8B46         F6            mov	ax,-$A[bp]
14552 3F20           88E0                       mov	al,ah
14553 3F22           30E4                       xor	ah,ah
14554 3F24           B1                     04  mov	cl,*4
14555 3F26           D3E8                       shr	ax,cl
14556                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14557 3F28           8846         F9            mov	-7[bp],al
14558                                           !BCC_EOS
14559                                           ! 2648       *((Bit16u *)(regs.u.r16.si+0x28+0)) = (0xffff);
14560                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14561 3F2B           8B46         06            mov	ax,6[bp]
14562                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
14563                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$28 (used reg = )
14564 3F2E           89C3                       mov	bx,ax
14565                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$28] (used reg = )
14566 3F30           B8                   FFFF  mov	ax,#$FFFF
14567 3F33           8947         28            mov	$28[bx],ax
14568                                           !BCC_EOS
14569                                           ! 2649       *((Bit16u *)(regs.u.r16.si+0x28+2)) = (base15_00);
14570                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14571 3F36           8B46         06            mov	ax,6[bp]
14572                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
14573                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2A (used reg = )
14574 3F39           89C3                       mov	bx,ax
14575                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$2A] (used reg = )
14576 3F3B           8B46         FA            mov	ax,-6[bp]
14577 3F3E           8947         2A            mov	$2A[bx],ax
14578                                           !BCC_EOS
14579                                           ! 2650       *((Bit8u *)(regs.u.r16.si+0x28+4)) = (base23_16);
14580                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14581 3F41           8B46         06            mov	ax,6[bp]
14582                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
14583                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
14584 3F44           89C3                       mov	bx,ax
14585                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$2C] (used reg = )
14586 3F46           8A46         F9            mov	al,-7[bp]
14587 3F49           8847         2C            mov	$2C[bx],al
14588                                           !BCC_EOS
14589                                           ! 2651       *((Bit8u *)(regs.u.r16.si+0x28+5)) = (0x93);
14590                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14591 3F4C           8B46         06            mov	ax,6[bp]
14592                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
14593                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
14594 3F4F           89C3                       mov	bx,ax
14595                                           ! Debug: eq int = const $93 to unsigned char = [bx+$2D] (used reg = )
14596 3F51           B0                     93  mov	al,#$93
14597 3F53           8847         2D            mov	$2D[bx],al
14598                                           !BCC_EOS
14599                                           ! 2652       *((Bit16u *)(regs.u.r16.si+0x28+6)) = (0x0000);
14600                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14601 3F56           8B46         06            mov	ax,6[bp]
14602                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
14603                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2E (used reg = )
14604 3F59           89C3                       mov	bx,ax
14605                                           ! Debug: eq int = const 0 to unsigned short = [bx+$2E] (used reg = )
14606 3F5B           31C0                       xor	ax,ax
14607 3F5D           8947         2E            mov	$2E[bx],ax
14608                                           !BCC_EOS
14609                                           ! 2653       CX = regs.u.r16.cx;
14610                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
14611 3F60           8B46         10            mov	ax,$10[bp]
14612 3F63           8946         F2            mov	-$E[bp],ax
14613                                           !BCC_EOS
14614                                           ! 2654 #asm
14615                                           !BCC_EOS
14616                                           !BCC_ASM
14617                       00000006            _int15_function.CX	set	6
14618                       FFFFFFF2            .int15_function.CX	set	-$E
14619                       0000002C            _int15_function.FLAGS	set	$2C
14620                       00000018            .int15_function.FLAGS	set	$18
14621                       00000001            _int15_function.irqDisable	set	1
14622                       FFFFFFED            .int15_function.irqDisable	set	-$13
14623                       0000002A            _int15_function.DS	set	$2A
14624                       00000016            .int15_function.DS	set	$16
14625                       00000004            _int15_function.DX	set	4
14626                       FFFFFFF0            .int15_function.DX	set	-$10
14627                       0000000D            _int15_function.base23_16	set	$D
14628                       FFFFFFF9            .int15_function.base23_16	set	-7
14629                       00000002            _int15_function.bRegister	set	2
14630                       FFFFFFEE            .int15_function.bRegister	set	-$12
14631                       00000028            _int15_function.ES	set	$28
14632                       00000014            .int15_function.ES	set	$14
14633                       00000012            _int15_function.ebda_seg	set	$12
14634                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14635                       0000000E            _int15_function.base15_00	set	$E
14636                       FFFFFFFA            .int15_function.base15_00	set	-6
14637                       0000000A            _int15_function.ss	set	$A
14638                       FFFFFFF6            .int15_function.ss	set	-$A
14639                       00000008            _int15_function.BX	set	8
14640                       FFFFFFF4            .int15_function.BX	set	-$C
14641                       00000018            _int15_function.regs	set	$18
14642                       00000004            .int15_function.regs	set	4
14643                       00000010            _int15_function.prev_a20_enable	set	$10
14644                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14645 3F66           89E3                             mov bx, sp
14646 3F68           36                               SEG SS
14647 3F69           8B4F         06                    mov cx, _int15_function.CX [bx]
14648 3F6C     66    50                               push eax
14649 3F6E     66    31C0                             xor eax, eax
14650 3F71           8ED8                             mov ds, ax
14651 3F73           8C16       0469                  mov 0x0469, ss
14652 3F77           8926       0467                  mov 0x0467, sp
14653 3F7B           26                               SEG ES
14654 3F7C         0F0154         08                    lgdt [si + 0x08]
14655 3F80           2E                               SEG CS
14656 3F81         0F011E       F8AB                    lidt [pmode_IDT_info]
14657                                                 ;; perhaps do something with IDT here
14658                                                 ;; set PE bit in CR0
14659 3F86         0F20C0                             mov eax, cr0
14660 3F89           0C                     01        or al, #0x01
14661 3F8B         0F22C0                             mov cr0, eax
14662                                                 ;; far jump to flush CPU queue after transition to protected mode
14663                                                 JMP_AP(0x0020, protected_mode)
 +a   3F8E                        EA              db 0xea
 +a   3F8F                      3F93              dw  protected_mode
 +a   3F91                      0020              dw 0x0020
14664                       00003F93            protected_mode:
14665                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14666 3F93           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
14667 3F96           8ED0                             mov ss, ax
14668 3F98           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
14669 3F9B           8ED8                             mov ds, ax
14670 3F9D           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
14671 3FA0           8EC0                             mov es, ax
14672 3FA2           31F6                             xor si, si
14673 3FA4           31FF                             xor di, di
14674 3FA6           FC                               cld
14675 3FA7           F3                               rep
14676 3FA8           A5                                 movsw ;; move CX words from DS:SI to ES:DI
14677                                                 ;; make sure DS and ES limits are 64KB
14678 3FA9           B8                   0028        mov ax, #0x28
14679 3FAC           8ED8                             mov ds, ax
14680 3FAE           8EC0                             mov es, ax
14681                                                 ;; reset PG bit in CR0 ???
14682 3FB0         0F20C0                             mov eax, cr0
14683 3FB3           24                     FE        and al, #0xFE
14684 3FB5         0F22C0                             mov cr0, eax
14685                                                 ;; far jump to flush CPU queue after transition to real mode
14686                                                 JMP_AP(0xf000, real_mode)
 +a   3FB8                        EA              db 0xea
 +a   3FB9                      3FBD              dw  real_mode
 +a   3FBB                      F000              dw 0xf000
14687                       00003FBD            real_mode:
14688                                                 ;; restore IDT to normal real-mode defaults
14689 3FBD           2E                               SEG CS
14690 3FBE         0F011E       F8B1                    lidt [rmode_IDT_info]
14691 3FC3           31C0                             xor ax, ax
14692 3FC5           8ED8                             mov ds, ax
14693 3FC7           8E16       0469                  mov ss, 0x0469
14694 3FCB           8B26       0467                  mov sp, 0x0467
14695 3FCF     66    58                               pop eax
14696                                           ! 2706 endasm
14697                                           !BCC_ENDASM
14698                                           !BCC_EOS
14699                                           ! 2707       set_enable_a20(prev_a20_enable);
14700                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14701 3FD1           FF76         FC            push	-4[bp]
14702                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14703 3FD4           E8         D75A            call	_set_enable_a20
14704 3FD7           44                         inc	sp
14705 3FD8           44                         inc	sp
14706                                           !BCC_EOS
14707                                           ! 2708 #asm
14708                                           !BCC_EOS
14709                                           !BCC_ASM
14710                       00000006            _int15_function.CX	set	6
14711                       FFFFFFF2            .int15_function.CX	set	-$E
14712                       0000002C            _int15_function.FLAGS	set	$2C
14713                       00000018            .int15_function.FLAGS	set	$18
14714                       00000001            _int15_function.irqDisable	set	1
14715                       FFFFFFED            .int15_function.irqDisable	set	-$13
14716                       0000002A            _int15_function.DS	set	$2A
14717                       00000016            .int15_function.DS	set	$16
14718                       00000004            _int15_function.DX	set	4
14719                       FFFFFFF0            .int15_function.DX	set	-$10
14720                       0000000D            _int15_function.base23_16	set	$D
14721                       FFFFFFF9            .int15_function.base23_16	set	-7
14722                       00000002            _int15_function.bRegister	set	2
14723                       FFFFFFEE            .int15_function.bRegister	set	-$12
14724                       00000028            _int15_function.ES	set	$28
14725                       00000014            .int15_function.ES	set	$14
14726                       00000012            _int15_function.ebda_seg	set	$12
14727                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14728                       0000000E            _int15_function.base15_00	set	$E
14729                       FFFFFFFA            .int15_function.base15_00	set	-6
14730                       0000000A            _int15_function.ss	set	$A
14731                       FFFFFFF6            .int15_function.ss	set	-$A
14732                       00000008            _int15_function.BX	set	8
14733                       FFFFFFF4            .int15_function.BX	set	-$C
14734                       00000018            _int15_function.regs	set	$18
14735                       00000004            .int15_function.regs	set	4
14736                       00000010            _int15_function.prev_a20_enable	set	$10
14737                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14738 3FD9           FB                           sti
14739                                           ! 2710 endasm
14740                                           !BCC_ENDASM
14741                                           !BCC_EOS
14742                                           ! 2711       regs.u.r8.ah = 0;
14743                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14744 3FDA           30C0                       xor	al,al
14745 3FDC           8846         13            mov	$13[bp],al
14746                                           !BCC_EOS
14747                                           ! 2712       FLAGS &= 0xfffe;
14748                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14749 3FDF           8B46         18            mov	ax,$18[bp]
14750 3FE2           24                     FE  and	al,#$FE
14751 3FE4           8946         18            mov	$18[bp],ax
14752                                           !BCC_EOS
14753                                           ! 2713       break;
14754 3FE7           E9         01B6            br 	.359
14755                                           !BCC_EOS
14756                                           ! 2714     case 0x88:
14757                                           ! 2715       regs.u.r8.al = inb_cmos(0x30);
14758                       00003FEA            .376:
14759                                           ! Debug: list int = const $30 (used reg = )
14760 3FEA           B8                   0030  mov	ax,*$30
14761 3FED           50                         push	ax
14762                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14763 3FEE           E8         C57D            call	_inb_cmos
14764 3FF1           44                         inc	sp
14765 3FF2           44                         inc	sp
14766                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14767 3FF3           8846         12            mov	$12[bp],al
14768                                           !BCC_EOS
14769                                           ! 2716       regs.u.r8.ah = inb_cmos(0x31);
14770                                           ! Debug: list int = const $31 (used reg = )
14771 3FF6           B8                   0031  mov	ax,*$31
14772 3FF9           50                         push	ax
14773                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14774 3FFA           E8         C571            call	_inb_cmos
14775 3FFD           44                         inc	sp
14776 3FFE           44                         inc	sp
14777                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
14778 3FFF           8846         13            mov	$13[bp],al
14779                                           !BCC_EOS
14780                                           ! 2717       if(regs.u.r16.ax > 0xffc0)
14781                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14782 4002           8B46         12            mov	ax,$12[bp]
14783 4005           3D                   FFC0  cmp	ax,#$FFC0
14784 4008           76           06            jbe 	.377
14785                       0000400A            .378:
14786                                           ! 2718         regs.u.r16.ax = 0xffc0;
14787                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14788 400A           B8                   FFC0  mov	ax,#$FFC0
14789 400D           8946         12            mov	$12[bp],ax
14790                                           !BCC_EOS
14791                                           ! 2719       FLAGS &= 0xfffe;
14792                       00004010            .377:
14793                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14794 4010           8B46         18            mov	ax,$18[bp]
14795 4013           24                     FE  and	al,#$FE
14796 4015           8946         18            mov	$18[bp],ax
14797                                           !BCC_EOS
14798                                           ! 2720       break;
14799 4018           E9         0185            br 	.359
14800                                           !BCC_EOS
14801                                           ! 2721   case 0x89:
14802                                           ! 2722 #asm
14803                       0000401B            .379:
14804                                           !BCC_EOS
14805                                           !BCC_ASM
14806                       00000006            _int15_function.CX	set	6
14807                       FFFFFFF2            .int15_function.CX	set	-$E
14808                       0000002C            _int15_function.FLAGS	set	$2C
14809                       00000018            .int15_function.FLAGS	set	$18
14810                       00000001            _int15_function.irqDisable	set	1
14811                       FFFFFFED            .int15_function.irqDisable	set	-$13
14812                       0000002A            _int15_function.DS	set	$2A
14813                       00000016            .int15_function.DS	set	$16
14814                       00000004            _int15_function.DX	set	4
14815                       FFFFFFF0            .int15_function.DX	set	-$10
14816                       0000000D            _int15_function.base23_16	set	$D
14817                       FFFFFFF9            .int15_function.base23_16	set	-7
14818                       00000002            _int15_function.bRegister	set	2
14819                       FFFFFFEE            .int15_function.bRegister	set	-$12
14820                       00000028            _int15_function.ES	set	$28
14821                       00000014            .int15_function.ES	set	$14
14822                       00000012            _int15_function.ebda_seg	set	$12
14823                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14824                       0000000E            _int15_function.base15_00	set	$E
14825                       FFFFFFFA            .int15_function.base15_00	set	-6
14826                       0000000A            _int15_function.ss	set	$A
14827                       FFFFFFF6            .int15_function.ss	set	-$A
14828                       00000008            _int15_function.BX	set	8
14829                       FFFFFFF4            .int15_function.BX	set	-$C
14830                       00000018            _int15_function.regs	set	$18
14831                       00000004            .int15_function.regs	set	4
14832                       00000010            _int15_function.prev_a20_enable	set	$10
14833                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14834 401B           FA                           cli
14835                                           ! 2724 endasm
14836                                           !BCC_ENDASM
14837                                           !BCC_EOS
14838                                           ! 2725       set_enable_a20(1);
14839                                           ! Debug: list int = const 1 (used reg = )
14840 401C           B8                   0001  mov	ax,*1
14841 401F           50                         push	ax
14842                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14843 4020           E8         D70E            call	_set_enable_a20
14844 4023           44                         inc	sp
14845 4024           44                         inc	sp
14846                                           !BCC_EOS
14847                                           ! 2726       set_DS(ES);
14848                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14849 4025           FF76         14            push	$14[bp]
14850                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14851 4028           E8         C632            call	_set_DS
14852 402B           44                         inc	sp
14853 402C           44                         inc	sp
14854                                           !BCC_EOS
14855                                           ! 2727       *((Bit16u *)(regs.u.r16.si+0x38+0)) = (0xffff);
14856                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14857 402D           8B46         06            mov	ax,6[bp]
14858                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
14859                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$38 (used reg = )
14860 4030           89C3                       mov	bx,ax
14861                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$38] (used reg = )
14862 4032           B8                   FFFF  mov	ax,#$FFFF
14863 4035           8947         38            mov	$38[bx],ax
14864                                           !BCC_EOS
14865                                           ! 2728       *((Bit16u *)(regs.u.r16.si+0x38+2)) = (0x0000);
14866                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14867 4038           8B46         06            mov	ax,6[bp]
14868                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
14869                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
14870 403B           89C3                       mov	bx,ax
14871                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
14872 403D           31C0                       xor	ax,ax
14873 403F           8947         3A            mov	$3A[bx],ax
14874                                           !BCC_EOS
14875                                           ! 2729       *((Bit8u *)(regs.u.r16.si+0x38+4)) = (0x000f);
14876                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14877 4042           8B46         06            mov	ax,6[bp]
14878                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
14879                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3C (used reg = )
14880 4045           89C3                       mov	bx,ax
14881                                           ! Debug: eq int = const $F to unsigned char = [bx+$3C] (used reg = )
14882 4047           B0                     0F  mov	al,*$F
14883 4049           8847         3C            mov	$3C[bx],al
14884                                           !BCC_EOS
14885                                           ! 2730       *((Bit8u *)(regs.u.r16.si+0x38+5)) = (0x9b);
14886                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14887 404C           8B46         06            mov	ax,6[bp]
14888                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
14889                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3D (used reg = )
14890 404F           89C3                       mov	bx,ax
14891                                           ! Debug: eq int = const $9B to unsigned char = [bx+$3D] (used reg = )
14892 4051           B0                     9B  mov	al,#$9B
14893 4053           8847         3D            mov	$3D[bx],al
14894                                           !BCC_EOS
14895                                           ! 2731       *((Bit16u *)(regs.u.r16.si+0x38+6)) = (0x0000);
14896                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14897 4056           8B46         06            mov	ax,6[bp]
14898                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
14899                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3E (used reg = )
14900 4059           89C3                       mov	bx,ax
14901                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3E] (used reg = )
14902 405B           31C0                       xor	ax,ax
14903 405D           8947         3E            mov	$3E[bx],ax
14904                                           !BCC_EOS
14905                                           ! 2732       BX = regs.u.r16.bx;
14906                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
14907 4060           8B46         0C            mov	ax,$C[bp]
14908 4063           8946         F4            mov	-$C[bp],ax
14909                                           !BCC_EOS
14910                                           ! 2733 #asm
14911                                           !BCC_EOS
14912                                           !BCC_ASM
14913                       00000006            _int15_function.CX	set	6
14914                       FFFFFFF2            .int15_function.CX	set	-$E
14915                       0000002C            _int15_function.FLAGS	set	$2C
14916                       00000018            .int15_function.FLAGS	set	$18
14917                       00000001            _int15_function.irqDisable	set	1
14918                       FFFFFFED            .int15_function.irqDisable	set	-$13
14919                       0000002A            _int15_function.DS	set	$2A
14920                       00000016            .int15_function.DS	set	$16
14921                       00000004            _int15_function.DX	set	4
14922                       FFFFFFF0            .int15_function.DX	set	-$10
14923                       0000000D            _int15_function.base23_16	set	$D
14924                       FFFFFFF9            .int15_function.base23_16	set	-7
14925                       00000002            _int15_function.bRegister	set	2
14926                       FFFFFFEE            .int15_function.bRegister	set	-$12
14927                       00000028            _int15_function.ES	set	$28
14928                       00000014            .int15_function.ES	set	$14
14929                       00000012            _int15_function.ebda_seg	set	$12
14930                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14931                       0000000E            _int15_function.base15_00	set	$E
14932                       FFFFFFFA            .int15_function.base15_00	set	-6
14933                       0000000A            _int15_function.ss	set	$A
14934                       FFFFFFF6            .int15_function.ss	set	-$A
14935                       00000008            _int15_function.BX	set	8
14936                       FFFFFFF4            .int15_function.BX	set	-$C
14937                       00000018            _int15_function.regs	set	$18
14938                       00000004            .int15_function.regs	set	4
14939                       00000010            _int15_function.prev_a20_enable	set	$10
14940                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14941 4066           89E3                             mov bx, sp
14942 4068           36                               SEG SS
14943 4069           8B5F         08                    mov bx, _int15_function.BX [bx]
14944 406C           B0                     11        mov al, #0x11 ; send initialisation commands
14945 406E           E6                     20        out 0x0020, al
14946 4070           E6                     A0        out 0x00a0, al
14947 4072           88F8                             mov al, bh
14948 4074           E6                     21        out 0x0021, al
14949 4076           88D8                             mov al, bl
14950 4078           E6                     A1        out 0x00a1, al
14951 407A           B0                     04        mov al, #0x04
14952 407C           E6                     21        out 0x0021, al
14953 407E           B0                     02        mov al, #0x02
14954 4080           E6                     A1        out 0x00a1, al
14955 4082           B0                     01        mov al, #0x01
14956 4084           E6                     21        out 0x0021, al
14957 4086           E6                     A1        out 0x00a1, al
14958 4088           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
14959 408A           E6                     21        out 0x0021, al
14960 408C           E6                     A1        out 0x00a1, al
14961 408E           26                               SEG ES
14962 408F         0F0154         08                    lgdt [si + 0x08]
14963 4093           26                               SEG ES
14964 4094         0F015C         10                    lidt [si + 0x10]
14965 4098         0F20C0                             mov eax, cr0
14966 409B           0C                     01        or al, #0x01
14967 409D         0F22C0                             mov cr0, eax
14968                                                 JMP_AP(0x0038, protmode_switch)
 +a   40A0                        EA              db 0xea
 +a   40A1                      40A5              dw  protmode_switch
 +a   40A3                      0038              dw 0x0038
14969                       000040A5            protmode_switch:
14970                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14971 40A5           B8                   0028        mov ax, #0x28
14972 40A8           8ED0                             mov ss, ax
14973 40AA           B8                   0018        mov ax, #0x18
14974 40AD           8ED8                             mov ds, ax
14975 40AF           B8                   0020        mov ax, #0x20
14976 40B2           8EC0                             mov es, ax
14977 40B4           89EC                             mov sp,bp
14978 40B6           83C4                   04        add sp,#4 ; skip return address
14979 40B9           61                               popa ; restore regs
14980 40BA           58                               pop ax ; skip saved es
14981 40BB           58                               pop ax ; skip saved ds
14982 40BC           58                               pop ax ; skip saved flags
14983 40BD           59                               pop cx ; get return offset
14984 40BE           58                               pop ax ; skip return segment
14985 40BF           58                               pop ax ; skip flags
14986 40C0           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
14987 40C3           50                               push ax
14988 40C4           51                               push cx ; re-create modified ret address on stack
14989 40C5           CB                               retf
14990                                           ! 2783 endasm
14991                                           !BCC_ENDASM
14992                                           !BCC_EOS
14993                                           ! 2784       break;
14994 40C6           E9         00D7            br 	.359
14995                                           !BCC_EOS
14996                                           ! 2785     case 0xbf:
14997                                           ! 2786       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
14998                       000040C9            .37A:
14999                                           ! Debug: list * char = .37B+0 (used reg = )
15000 40C9           BB                   D547  mov	bx,#.37B
15001 40CC           53                         push	bx
15002                                           ! Debug: list int = const 4 (used reg = )
15003 40CD           B8                   0004  mov	ax,*4
15004 40D0           50                         push	ax
15005                                           ! Debug: func () void = bios_printf+0 (used reg = )
15006 40D1           E8         C865            call	_bios_printf
15007 40D4           83C4                   04  add	sp,*4
15008                                           !BCC_EOS
15009                                           ! 2787       FLAGS |= 0x0001;
15010                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15011 40D7           8B46         18            mov	ax,$18[bp]
15012 40DA           0C                     01  or	al,*1
15013 40DC           8946         18            mov	$18[bp],ax
15014                                           !BCC_EOS
15015                                           ! 2788       regs.u.r8.ah = 0x86;
15016                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15017 40DF           B0                     86  mov	al,#$86
15018 40E1           8846         13            mov	$13[bp],al
15019                                           !BCC_EOS
15020                                           ! 2789       break;
15021 40E4           E9         00B9            br 	.359
15022                                           !BCC_EOS
15023                                           ! 2790     case 0xC0:
15024                                           ! 2791       FLAGS &= 0xfffe;
15025                       000040E7            .37C:
15026                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15027 40E7           8B46         18            mov	ax,$18[bp]
15028 40EA           24                     FE  and	al,#$FE
15029 40EC           8946         18            mov	$18[bp],ax
15030                                           !BCC_EOS
15031                                           ! 2792       regs.u.r8.ah = 0;
15032                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15033 40EF           30C0                       xor	al,al
15034 40F1           8846         13            mov	$13[bp],al
15035                                           !BCC_EOS
15036                                           ! 2793       regs.u.r16.bx = 0xe6f5;
15037                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
15038 40F4           B8                   E6F5  mov	ax,#$E6F5
15039 40F7           8946         0C            mov	$C[bp],ax
15040                                           !BCC_EOS
15041                                           ! 2794       ES = 0xF000;
15042                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
15043 40FA           B8                   F000  mov	ax,#$F000
15044 40FD           8946         14            mov	$14[bp],ax
15045                                           !BCC_EOS
15046                                           ! 2795       break;
15047 4100           E9         009D            br 	.359
15048                                           !BCC_EOS
15049                                           ! 2796     case 0xc1:
15050                                           ! 2797       ES = ebda_seg;
15051                       00004103            .37D:
15052                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
15053 4103           8B46         FE            mov	ax,-2[bp]
15054 4106           8946         14            mov	$14[bp],ax
15055                                           !BCC_EOS
15056                                           ! 2798       FLAGS &= 0xfffe;
15057                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15058 4109           8B46         18            mov	ax,$18[bp]
15059 410C           24                     FE  and	al,#$FE
15060 410E           8946         18            mov	$18[bp],ax
15061                                           !BCC_EOS
15062                                           ! 2799       break;
15063 4111           E9         008C            br 	.359
15064                                           !BCC_EOS
15065                                           ! 2800     case 0xd8:
15066                                           ! 2801       bios_printf(8, "EISA BIOS not present\n");
15067                       00004114            .37E:
15068                                           ! Debug: list * char = .37F+0 (used reg = )
15069 4114           BB                   D530  mov	bx,#.37F
15070 4117           53                         push	bx
15071                                           ! Debug: list int = const 8 (used reg = )
15072 4118           B8                   0008  mov	ax,*8
15073 411B           50                         push	ax
15074                                           ! Debug: func () void = bios_printf+0 (used reg = )
15075 411C           E8         C81A            call	_bios_printf
15076 411F           83C4                   04  add	sp,*4
15077                                           !BCC_EOS
15078                                           ! 2802       FLAGS |= 0x0001;
15079                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15080 4122           8B46         18            mov	ax,$18[bp]
15081 4125           0C                     01  or	al,*1
15082 4127           8946         18            mov	$18[bp],ax
15083                                           !BCC_EOS
15084                                           ! 2803       regs.u.r8.ah = 0x86;
15085                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15086 412A           B0                     86  mov	al,#$86
15087 412C           8846         13            mov	$13[bp],al
15088                                           !BCC_EOS
15089                                           ! 2804       break;
15090 412F           EB           6F            jmp .359
15091                                           !BCC_EOS
15092                                           ! 2805     default:
15093                                           ! 2806       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
15094                       00004131            .380:
15095                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
15096 4131           FF76         0C            push	$C[bp]
15097                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
15098 4134           FF76         12            push	$12[bp]
15099                                           ! Debug: list * char = .381+0 (used reg = )
15100 4137           BB                   D4F6  mov	bx,#.381
15101 413A           53                         push	bx
15102                                           ! Debug: list int = const 4 (used reg = )
15103 413B           B8                   0004  mov	ax,*4
15104 413E           50                         push	ax
15105                                           ! Debug: func () void = bios_printf+0 (used reg = )
15106 413F           E8         C7F7            call	_bios_printf
15107 4142           83C4                   08  add	sp,*8
15108                                           !BCC_EOS
15109                                           ! 2807       FLAGS |= 0x0001;
15110                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15111 4145           8B46         18            mov	ax,$18[bp]
15112 4148           0C                     01  or	al,*1
15113 414A           8946         18            mov	$18[bp],ax
15114                                           !BCC_EOS
15115                                           ! 2808       regs.u.r8.ah = 0x86;
15116                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15117 414D           B0                     86  mov	al,#$86
15118 414F           8846         13            mov	$13[bp],al
15119                                           !BCC_EOS
15120                                           ! 2809       break;
15121 4152           EB           4C            jmp .359
15122                                           !BCC_EOS
15123                                           ! 2810     }
15124                                           ! 2811 }
15125 4154           EB           4A            jmp .359
15126                       00004156            .35B:
15127 4156           2C                     24  sub	al,*$24
15128 4158         0F84         FB78            beq 	.35C
15129 415C           2C                     1D  sub	al,*$1D
15130 415E         0F84         FBFF            beq 	.366
15131 4162           2C                     0E  sub	al,*$E
15132 4164         0F84         FC09            beq 	.367
15133 4168           2C                     03  sub	al,*3
15134 416A         0F84         FC0E            beq 	.368
15135 416E           2C                     31  sub	al,*$31
15136 4170         0F84         FC18            beq 	.369
15137 4174           2C                     04  sub	al,*4
15138 4176         0F84         FCE8            beq 	.373
15139 417A           2C                     01  sub	al,*1
15140 417C         0F84         FE6A            beq 	.376
15141 4180           2C                     01  sub	al,*1
15142 4182         0F84         FE95            beq 	.379
15143 4186           2C                     36  sub	al,*$36
15144 4188         0F84         FF3D            beq 	.37A
15145 418C           2C                     01  sub	al,*1
15146 418E         0F84         FF55            beq 	.37C
15147 4192           2C                     01  sub	al,*1
15148 4194         0F84         FF6B            beq 	.37D
15149 4198           2C                     17  sub	al,*$17
15150 419A         0F84         FF76            beq 	.37E
15151 419E           EB           91            jmp	.380
15152                       000041A0            .359:
15153                       FFFFFFEA            ..FFF7	=	-$16
15154 41A0           89EC                       mov	sp,bp
15155 41A2           5D                         pop	bp
15156 41A3           C3                         ret
15157                                           ! 2812   void
15158                                           ! Register BX used in function int15_function
15159                                           ! 2813 int15_function_mouse(regs, ES, DS, FLAGS)
15160                                           ! 2814   pusha_regs_t regs;
15161                                           export	_int15_function_mouse
15162                       000041A4            _int15_function_mouse:
15163                                           !BCC_EOS
15164                                           ! 2815   Bit16u ES, DS, FLAGS;
15165                                           !BCC_EOS
15166                                           ! 2816 {
15167                                           ! 2817   Bit16u ebda_seg=get_ebda_seg();
15168 41A4           55                         push	bp
15169 41A5           89E5                       mov	bp,sp
15170 41A7           4C                         dec	sp
15171 41A8           4C                         dec	sp
15172                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
15173 41A9           E8         C4BB            call	_get_ebda_seg
15174                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15175 41AC           8946         FE            mov	-2[bp],ax
15176                                           !BCC_EOS
15177                                           ! 2818   Bit8u mouse_flags_1, mouse_flags_2;
15178                                           !BCC_EOS
15179                                           ! 2819   Bit16u mouse_driver_seg;
15180                                           !BCC_EOS
15181                                           ! 2820   Bit16u mouse_driver_offset;
15182                                           !BCC_EOS
15183                                           ! 2821   Bit8u comm_byte, prev_command_byte;
15184                                           !BCC_EOS
15185                                           ! 2822   Bit8u ret, mouse
15186                                           ! 2822 _data1, mouse_data2, mouse_data3;
15187                                           !BCC_EOS
15188                                           ! 2823 ;
15189 41AF           83C4                   F4  add	sp,*-$C
15190                                           !BCC_EOS
15191                                           ! 2824   switch (regs.u.r8.ah) {
15192 41B2           8A46         13            mov	al,$13[bp]
15193 41B5           E9         066A            br 	.384
15194                                           ! 2825     case 0xC2:
15195                                           ! 2826       switch (regs.u.r8.al) {
15196                       000041B8            .385:
15197 41B8           8A46         12            mov	al,$12[bp]
15198 41BB           E9         0618            br 	.388
15199                                           ! 2827         case 0:
15200                                           ! 2828 ;
15201                       000041BE            .389:
15202                                           !BCC_EOS
15203                                           ! 2829           switch (regs.u.r8.bh) {
15204 41BE           8A46         0D            mov	al,$D[bp]
15205 41C1           E9         00E9            br 	.38C
15206                                           ! 2830             case 0:
15207                                           ! 2831 ;
15208                       000041C4            .38D:
15209                                           !BCC_EOS
15210                                           ! 2832               inhibit_mouse_int_and_events();
15211                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15212 41C4           E8         1019            call	_inhibit_mouse_int_and_events
15213                                           !BCC_EOS
15214                                           ! 2833               ret = send_to_mouse_ctrl(0xF5);
15215                                           ! Debug: list int = const $F5 (used reg = )
15216 41C7           B8                   00F5  mov	ax,#$F5
15217 41CA           50                         push	ax
15218                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15219 41CB           E8         1163            call	_send_to_mouse_ctrl
15220 41CE           44                         inc	sp
15221 41CF           44                         inc	sp
15222                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15223 41D0           8846         F5            mov	-$B[bp],al
15224                                           !BCC_EOS
15225                                           ! 2834               if (ret == 0) {
15226                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15227 41D3           8A46         F5            mov	al,-$B[bp]
15228 41D6           84C0                       test	al,al
15229 41D8           75           2B            jne 	.38E
15230                       000041DA            .38F:
15231                                           ! 2835                 ret = get_mouse_data(&mouse_data1);
15232                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15233 41DA           8D5E         F4            lea	bx,-$C[bp]
15234 41DD           53                         push	bx
15235                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15236 41DE           E8         119A            call	_get_mouse_data
15237 41E1           44                         inc	sp
15238 41E2           44                         inc	sp
15239                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15240 41E3           8846         F5            mov	-$B[bp],al
15241                                           !BCC_EOS
15242                                           ! 2836                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
15243                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15244 41E6           8A46         F5            mov	al,-$B[bp]
15245 41E9           84C0                       test	al,al
15246 41EB           74           07            je  	.391
15247                       000041ED            .392:
15248                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15249 41ED           8A46         F4            mov	al,-$C[bp]
15250 41F0           3C                     FA  cmp	al,#$FA
15251 41F2           75           11            jne 	.390
15252                       000041F4            .391:
15253                                           ! 2837                   FLAGS &= 0xfffe;
15254                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15255 41F4           8B46         18            mov	ax,$18[bp]
15256 41F7           24                     FE  and	al,#$FE
15257 41F9           8946         18            mov	$18[bp],ax
15258                                           !BCC_EOS
15259                                           ! 2838                   regs.u.r8.ah = 0;
15260                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15261 41FC           30C0                       xor	al,al
15262 41FE           8846         13            mov	$13[bp],al
15263                                           !BCC_EOS
15264                                           ! 2839                   return;
15265 4201           89EC                       mov	sp,bp
15266 4203           5D                         pop	bp
15267 4204           C3                         ret
15268                                           !BCC_EOS
15269                                           ! 2840                 }
15270                                           ! 2841               }
15271                       00004205            .390:
15272                                           ! 2842               FLAGS |= 0x0001;
15273                       00004205            .38E:
15274                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15275 4205           8B46         18            mov	ax,$18[bp]
15276 4208           0C                     01  or	al,*1
15277 420A           8946         18            mov	$18[bp],ax
15278                                           !BCC_EOS
15279                                           ! 2843               regs.u.r8.ah = ret;
15280                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15281 420D           8A46         F5            mov	al,-$B[bp]
15282 4210           8846         13            mov	$13[bp],al
15283                                           !BCC_EOS
15284                                           ! 2844               return;
15285 4213           89EC                       mov	sp,bp
15286 4215           5D                         pop	bp
15287 4216           C3                         ret
15288                                           !BCC_EOS
15289                                           ! 2845               break;
15290 4217           E9         00A1            br 	.38A
15291                                           !BCC_EOS
15292                                           ! 2846             case 1:
15293                                           ! 2847 ;
15294                       0000421A            .393:
15295                                           !BCC_EOS
15296                                           ! 2848               mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15297                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15298 421A           FF76         FE            push	-2[bp]
15299                                           ! Debug: list * unsigned char = const $27 (used reg = )
15300 421D           B8                   0027  mov	ax,*$27
15301 4220           50                         push	ax
15302                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15303 4221           E8         C3BB            call	__read_byte
15304 4224           83C4                   04  add	sp,*4
15305                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15306 4227           8846         FC            mov	-4[bp],al
15307                                           !BCC_EOS
15308                                           ! 2849               if ( (mouse_flags_2 & 0x80) == 0 ) {
15309                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15310 422A           8A46         FC            mov	al,-4[bp]
15311 422D           24                     80  and	al,#$80
15312                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15313 422F           84C0                       test	al,al
15314 4231           75           11            jne 	.394
15315                       00004233            .395:
15316                                           ! 2850                 ;
15317                                           !BCC_EOS
15318                                           ! 2851                 FLAGS |= 0x0001;
15319                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15320 4233           8B46         18            mov	ax,$18[bp]
15321 4236           0C                     01  or	al,*1
15322 4238           8946         18            mov	$18[bp],ax
15323                                           !BCC_EOS
15324                                           ! 2852                 regs.u.r8.ah = 5;
15325                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
15326 423B           B0                     05  mov	al,*5
15327 423D           8846         13            mov	$13[bp],al
15328                                           !BCC_EOS
15329                                           ! 2853                 return;
15330 4240           89EC                       mov	sp,bp
15331 4242           5D                         pop	bp
15332 4243           C3                         ret
15333                                           !BCC_EOS
15334                                           ! 2854               }
15335                                           ! 2855               inhibit_mouse_int_and_events();
15336                       00004244            .394:
15337                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15338 4244           E8         0F99            call	_inhibit_mouse_int_and_events
15339                                           !BCC_EOS
15340                                           ! 2856               ret = send_to_mouse_ctrl(0xF4);
15341                                           ! Debug: list int = const $F4 (used reg = )
15342 4247           B8                   00F4  mov	ax,#$F4
15343 424A           50                         push	ax
15344                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15345 424B           E8         10E3            call	_send_to_mouse_ctrl
15346 424E           44                         inc	sp
15347 424F           44                         inc	sp
15348                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15349 4250           8846         F5            mov	-$B[bp],al
15350                                           !BCC_EOS
15351                                           ! 2857               if (ret == 0) {
15352                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15353 4253           8A46         F5            mov	al,-$B[bp]
15354 4256           84C0                       test	al,al
15355 4258           75           2E            jne 	.396
15356                       0000425A            .397:
15357                                           ! 2858                 ret = get_mouse_data(&mouse_data1);
15358                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15359 425A           8D5E         F4            lea	bx,-$C[bp]
15360 425D           53                         push	bx
15361                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15362 425E           E8         111A            call	_get_mouse_data
15363 4261           44                         inc	sp
15364 4262           44                         inc	sp
15365                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15366 4263           8846         F5            mov	-$B[bp],al
15367                                           !BCC_EOS
15368                                           ! 2859                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
15369                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15370 4266           8A46         F5            mov	al,-$B[bp]
15371 4269           84C0                       test	al,al
15372 426B           75           1B            jne 	.398
15373                       0000426D            .39A:
15374                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15375 426D           8A46         F4            mov	al,-$C[bp]
15376 4270           3C                     FA  cmp	al,#$FA
15377 4272           75           14            jne 	.398
15378                       00004274            .399:
15379                                           ! 2860                   enable_mouse_int_and_events();
15380                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15381 4274           E8         1016            call	_enable_mouse_int_and_events
15382                                           !BCC_EOS
15383                                           ! 2861                   FLAGS &= 0xfffe;
15384                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15385 4277           8B46         18            mov	ax,$18[bp]
15386 427A           24                     FE  and	al,#$FE
15387 427C           8946         18            mov	$18[bp],ax
15388                                           !BCC_EOS
15389                                           ! 2862                   regs.u.r8.ah = 0;
15390                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15391 427F           30C0                       xor	al,al
15392 4281           8846         13            mov	$13[bp],al
15393                                           !BCC_EOS
15394                                           ! 2863                   return;
15395 4284           89EC                       mov	sp,bp
15396 4286           5D                         pop	bp
15397 4287           C3                         ret
15398                                           !BCC_EOS
15399                                           ! 2864                 }
15400                                           ! 2865               }
15401                       00004288            .398:
15402                                           ! 2866               FLAGS |= 0x0001;
15403                       00004288            .396:
15404                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15405 4288           8B46         18            mov	ax,$18[bp]
15406 428B           0C                     01  or	al,*1
15407 428D           8946         18            mov	$18[bp],ax
15408                                           !BCC_EOS
15409                                           ! 2867               regs.u.r8.ah = ret;
15410                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15411 4290           8A46         F5            mov	al,-$B[bp]
15412 4293           8846         13            mov	$13[bp],al
15413                                           !BCC_EOS
15414                                           ! 2868               return;
15415 4296           89EC                       mov	sp,bp
15416 4298           5D                         pop	bp
15417 4299           C3                         ret
15418                                           !BCC_EOS
15419                                           ! 2869             default:
15420                                           ! 2870               ;
15421                       0000429A            .39B:
15422                                           !BCC_EOS
15423                                           ! 2871               FLAGS |= 0x0001;
15424                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15425 429A           8B46         18            mov	ax,$18[bp]
15426 429D           0C                     01  or	al,*1
15427 429F           8946         18            mov	$18[bp],ax
15428                                           !BCC_EOS
15429                                           ! 2872               regs.u.r8.ah = 1;
15430                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
15431 42A2           B0                     01  mov	al,*1
15432 42A4           8846         13            mov	$13[bp],al
15433                                           !BCC_EOS
15434                                           ! 2873               return;
15435 42A7           89EC                       mov	sp,bp
15436 42A9           5D                         pop	bp
15437 42AA           C3                         ret
15438                                           !BCC_EOS
15439                                           ! 2874           }
15440                                           ! 2875           break;
15441 42AB           EB           0E            jmp .38A
15442                       000042AD            .38C:
15443 42AD           2C                     00  sub	al,*0
15444 42AF         0F84         FF11            beq 	.38D
15445 42B3           2C                     01  sub	al,*1
15446 42B5         0F84         FF61            beq 	.393
15447 42B9           EB           DF            jmp	.39B
15448                       000042BB            .38A:
15449 42BB           E9         053D            br 	.386
15450                                           !BCC_EOS
15451                                           ! 2876         case 1:
15452                                           ! 2877         case 5:
15453                       000042BE            .39C:
15454                                           ! 2878 ;
15455                       000042BE            .39D:
15456                                           !BCC_EOS
15457                                           ! 2879           if (regs.u.r8.al == 5) {
15458                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
15459 42BE           8A46         12            mov	al,$12[bp]
15460 42C1           3C                     05  cmp	al,*5
15461 42C3           75           70            jne 	.39E
15462                       000042C5            .39F:
15463                                           ! 2880             if ((regs.u.r8.bh != 3) && (regs.u.r8.bh != 4)) {
15464                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
15465 42C5           8A46         0D            mov	al,$D[bp]
15466 42C8           3C                     03  cmp	al,*3
15467 42CA           74           18            je  	.3A0
15468                       000042CC            .3A2:
15469                                           ! Debug: ne int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15470 42CC           8A46         0D            mov	al,$D[bp]
15471 42CF           3C                     04  cmp	al,*4
15472 42D1           74           11            je  	.3A0
15473                       000042D3            .3A1:
15474                                           ! 2881               FLAGS |= 0x0001;
15475                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15476 42D3           8B46         18            mov	ax,$18[bp]
15477 42D6           0C                     01  or	al,*1
15478 42D8           8946         18            mov	$18[bp],ax
15479                                           !BCC_EOS
15480                                           ! 2882               regs.u.r8.ah = 0x02;
15481                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
15482 42DB           B0                     02  mov	al,*2
15483 42DD           8846         13            mov	$13[bp],al
15484                                           !BCC_EOS
15485                                           ! 2883               return;
15486 42E0           89EC                       mov	sp,bp
15487 42E2           5D                         pop	bp
15488 42E3           C3                         ret
15489                                           !BCC_EOS
15490                                           ! 2884             }
15491                                           ! 2885             mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15492                       000042E4            .3A0:
15493                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15494 42E4           FF76         FE            push	-2[bp]
15495                                           ! Debug: list * unsigned char = const $27 (used reg = )
15496 42E7           B8                   0027  mov	ax,*$27
15497 42EA           50                         push	ax
15498                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15499 42EB           E8         C2F1            call	__read_byte
15500 42EE           83C4                   04  add	sp,*4
15501                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15502 42F1           8846         FC            mov	-4[bp],al
15503                                           !BCC_EOS
15504                                           ! 2886             mouse_flags_2 = (mouse_flags_2 & 0xF8) | regs.u.r8.bh - 1;
15505                                           ! Debug: sub int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
15506 42F4           8A46         0D            mov	al,$D[bp]
15507 42F7           30E4                       xor	ah,ah
15508 42F9           48                         dec	ax
15509 42FA           50                         push	ax
15510                                           ! Debug: and int = const $F8 to unsigned char mouse_flags_2 = [S+$12-6] (used reg = )
15511 42FB           8A46         FC            mov	al,-4[bp]
15512 42FE           24                     F8  and	al,#$F8
15513                                           ! Debug: or unsigned int (temp) = [S+$12-$12] to unsigned char = al+0 (used reg = )
15514 4300           30E4                       xor	ah,ah
15515 4302           0B46         F0            or	ax,0+..FFF6[bp]
15516 4305           44                         inc	sp
15517 4306           44                         inc	sp
15518                                           ! Debug: eq unsigned int = ax+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15519 4307           8846         FC            mov	-4[bp],al
15520                                           !BCC_EOS
15521                                           ! 2887             mouse_flags_1 = 0x00;
15522                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
15523 430A           30C0                       xor	al,al
15524 430C           8846         FD            mov	-3[bp],al
15525                                           !BCC_EOS
15526                                           ! 2888             _write_byte(mouse_fl
15527                                           ! 2888 ags_1, &((ebda_data_t *) 0)->mouse_flag1, ebda_seg);
15528                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15529 430F           FF76         FE            push	-2[bp]
15530                                           ! Debug: list * unsigned char = const $26 (used reg = )
15531 4312           B8                   0026  mov	ax,*$26
15532 4315           50                         push	ax
15533                                           ! Debug: list unsigned char mouse_flags_1 = [S+$14-5] (used reg = )
15534 4316           8A46         FD            mov	al,-3[bp]
15535 4319           30E4                       xor	ah,ah
15536 431B           50                         push	ax
15537                                           ! Debug: func () void = _write_byte+0 (used reg = )
15538 431C           E8         C2DC            call	__write_byte
15539 431F           83C4                   06  add	sp,*6
15540                                           !BCC_EOS
15541                                           ! 2889             _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15542                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15543 4322           FF76         FE            push	-2[bp]
15544                                           ! Debug: list * unsigned char = const $27 (used reg = )
15545 4325           B8                   0027  mov	ax,*$27
15546 4328           50                         push	ax
15547                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
15548 4329           8A46         FC            mov	al,-4[bp]
15549 432C           30E4                       xor	ah,ah
15550 432E           50                         push	ax
15551                                           ! Debug: func () void = _write_byte+0 (used reg = )
15552 432F           E8         C2C9            call	__write_byte
15553 4332           83C4                   06  add	sp,*6
15554                                           !BCC_EOS
15555                                           ! 2890           }
15556                                           ! 2891           inhibit_mouse_int_and_events();
15557                       00004335            .39E:
15558                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15559 4335           E8         0EA8            call	_inhibit_mouse_int_and_events
15560                                           !BCC_EOS
15561                                           ! 2892           ret = send_to_mouse_ctrl(0xFF);
15562                                           ! Debug: list int = const $FF (used reg = )
15563 4338           B8                   00FF  mov	ax,#$FF
15564 433B           50                         push	ax
15565                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15566 433C           E8         0FF2            call	_send_to_mouse_ctrl
15567 433F           44                         inc	sp
15568 4340           44                         inc	sp
15569                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15570 4341           8846         F5            mov	-$B[bp],al
15571                                           !BCC_EOS
15572                                           ! 2893           if (ret == 0) {
15573                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15574 4344           8A46         F5            mov	al,-$B[bp]
15575 4347           84C0                       test	al,al
15576 4349         0F85         0087            bne 	.3A3
15577                       0000434D            .3A4:
15578                                           ! 2894             ret = get_mouse_data(&mouse_data3);
15579                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
15580 434D           8D5E         F2            lea	bx,-$E[bp]
15581 4350           53                         push	bx
15582                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15583 4351           E8         1027            call	_get_mouse_data
15584 4354           44                         inc	sp
15585 4355           44                         inc	sp
15586                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15587 4356           8846         F5            mov	-$B[bp],al
15588                                           !BCC_EOS
15589                                           ! 2895             if (mouse_data3 == 0xfe) {
15590                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15591 4359           8A46         F2            mov	al,-$E[bp]
15592 435C           3C                     FE  cmp	al,#$FE
15593 435E           75           0C            jne 	.3A5
15594                       00004360            .3A6:
15595                                           ! 2896               FLAGS |= 0x0001;
15596                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15597 4360           8B46         18            mov	ax,$18[bp]
15598 4363           0C                     01  or	al,*1
15599 4365           8946         18            mov	$18[bp],ax
15600                                           !BCC_EOS
15601                                           ! 2897               return;
15602 4368           89EC                       mov	sp,bp
15603 436A           5D                         pop	bp
15604 436B           C3                         ret
15605                                           !BCC_EOS
15606                                           ! 2898             }
15607                                           ! 2899             if (mouse_data3 != 0xfa)
15608                       0000436C            .3A5:
15609                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15610 436C           8A46         F2            mov	al,-$E[bp]
15611 436F           3C                     FA  cmp	al,#$FA
15612 4371           74           14            je  	.3A7
15613                       00004373            .3A8:
15614                                           ! 2900               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
15615                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15616 4373           8A46         F2            mov	al,-$E[bp]
15617 4376           30E4                       xor	ah,ah
15618 4378           50                         push	ax
15619                                           ! Debug: list * char = .3A9+0 (used reg = )
15620 4379           BB                   D4CB  mov	bx,#.3A9
15621 437C           53                         push	bx
15622                                           ! Debug: list int = const 7 (used reg = )
15623 437D           B8                   0007  mov	ax,*7
15624 4380           50                         push	ax
15625                                           ! Debug: func () void = bios_printf+0 (used reg = )
15626 4381           E8         C5B5            call	_bios_printf
15627 4384           83C4                   06  add	sp,*6
15628                                           !BCC_EOS
15629                                           ! 2901             if ( ret == 0 ) {
15630                       00004387            .3A7:
15631                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15632 4387           8A46         F5            mov	al,-$B[bp]
15633 438A           84C0                       test	al,al
15634 438C           75           46            jne 	.3AA
15635                       0000438E            .3AB:
15636                                           ! 2902               ret = get_mouse_data(&mouse_data1);
15637                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15638 438E           8D5E         F4            lea	bx,-$C[bp]
15639 4391           53                         push	bx
15640                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15641 4392           E8         0FE6            call	_get_mouse_data
15642 4395           44                         inc	sp
15643 4396           44                         inc	sp
15644                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15645 4397           8846         F5            mov	-$B[bp],al
15646                                           !BCC_EOS
15647                                           ! 2903               if ( ret == 0 ) {
15648                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15649 439A           8A46         F5            mov	al,-$B[bp]
15650 439D           84C0                       test	al,al
15651 439F           75           33            jne 	.3AC
15652                       000043A1            .3AD:
15653                                           ! 2904                 ret = get_mouse_data(&mouse_data2);
15654                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15655 43A1           8D5E         F3            lea	bx,-$D[bp]
15656 43A4           53                         push	bx
15657                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15658 43A5           E8         0FD3            call	_get_mouse_data
15659 43A8           44                         inc	sp
15660 43A9           44                         inc	sp
15661                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15662 43AA           8846         F5            mov	-$B[bp],al
15663                                           !BCC_EOS
15664                                           ! 2905                 if ( ret == 0 ) {
15665                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15666 43AD           8A46         F5            mov	al,-$B[bp]
15667 43B0           84C0                       test	al,al
15668 43B2           75           20            jne 	.3AE
15669                       000043B4            .3AF:
15670                                           ! 2906                   enable_mouse_int_and_events();
15671                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15672 43B4           E8         0ED6            call	_enable_mouse_int_and_events
15673                                           !BCC_EOS
15674                                           ! 2907                   FLAGS &= 0xfffe;
15675                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15676 43B7           8B46         18            mov	ax,$18[bp]
15677 43BA           24                     FE  and	al,#$FE
15678 43BC           8946         18            mov	$18[bp],ax
15679                                           !BCC_EOS
15680                                           ! 2908                   regs.u.r8.ah = 0;
15681                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15682 43BF           30C0                       xor	al,al
15683 43C1           8846         13            mov	$13[bp],al
15684                                           !BCC_EOS
15685                                           ! 2909                   regs.u.r8.bl = mouse_data1;
15686                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
15687 43C4           8A46         F4            mov	al,-$C[bp]
15688 43C7           8846         0C            mov	$C[bp],al
15689                                           !BCC_EOS
15690                                           ! 2910                   regs.u.r8.bh = mouse_data2;
15691                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
15692 43CA           8A46         F3            mov	al,-$D[bp]
15693 43CD           8846         0D            mov	$D[bp],al
15694                                           !BCC_EOS
15695                                           ! 2911                   return;
15696 43D0           89EC                       mov	sp,bp
15697 43D2           5D                         pop	bp
15698 43D3           C3                         ret
15699                                           !BCC_EOS
15700                                           ! 2912                 }
15701                                           ! 2913               }
15702                       000043D4            .3AE:
15703                                           ! 2914             }
15704                       000043D4            .3AC:
15705                                           ! 2915           }
15706                       000043D4            .3AA:
15707                                           ! 2916           FLAGS |= 0x0001;
15708                       000043D4            .3A3:
15709                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15710 43D4           8B46         18            mov	ax,$18[bp]
15711 43D7           0C                     01  or	al,*1
15712 43D9           8946         18            mov	$18[bp],ax
15713                                           !BCC_EOS
15714                                           ! 2917           regs.u.r8.ah = ret;
15715                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15716 43DC           8A46         F5            mov	al,-$B[bp]
15717 43DF           8846         13            mov	$13[bp],al
15718                                           !BCC_EOS
15719                                           ! 2918           return;
15720 43E2           89EC                       mov	sp,bp
15721 43E4           5D                         pop	bp
15722 43E5           C3                         ret
15723                                           !BCC_EOS
15724                                           ! 2919         case 2:
15725                                           ! 2920 ;
15726                       000043E6            .3B0:
15727                                           !BCC_EOS
15728                                           ! 2921           switch (regs.u.r8.bh) {
15729 43E6           8A46         0D            mov	al,$D[bp]
15730 43E9           EB           38            jmp .3B3
15731                                           ! 2922             case 0: mouse_data1 = 10; break;
15732                       000043EB            .3B4:
15733                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15734 43EB           B0                     0A  mov	al,*$A
15735 43ED           8846         F4            mov	-$C[bp],al
15736                                           !BCC_EOS
15737 43F0           EB           54            jmp .3B1
15738                                           !BCC_EOS
15739                                           ! 2923             case 1: mouse_data1 = 20; break;
15740                       000043F2            .3B5:
15741                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15742 43F2           B0                     14  mov	al,*$14
15743 43F4           8846         F4            mov	-$C[bp],al
15744                                           !BCC_EOS
15745 43F7           EB           4D            jmp .3B1
15746                                           !BCC_EOS
15747                                           ! 2924             case 2: mouse_data1 = 40; break;
15748                       000043F9            .3B6:
15749                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15750 43F9           B0                     28  mov	al,*$28
15751 43FB           8846         F4            mov	-$C[bp],al
15752                                           !BCC_EOS
15753 43FE           EB           46            jmp .3B1
15754                                           !BCC_EOS
15755                                           ! 2925             case 3: mouse_data1 = 60; break;
15756                       00004400            .3B7:
15757                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15758 4400           B0                     3C  mov	al,*$3C
15759 4402           8846         F4            mov	-$C[bp],al
15760                                           !BCC_EOS
15761 4405           EB           3F            jmp .3B1
15762                                           !BCC_EOS
15763                                           ! 2926             case 4: mouse_data1 = 80; break;
15764                       00004407            .3B8:
15765                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15766 4407           B0                     50  mov	al,*$50
15767 4409           8846         F4            mov	-$C[bp],al
15768                                           !BCC_EOS
15769 440C           EB           38            jmp .3B1
15770                                           !BCC_EOS
15771                                           ! 2927             case 5: mouse_data1 = 100; break;
15772                       0000440E            .3B9:
15773                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15774 440E           B0                     64  mov	al,*$64
15775 4410           8846         F4            mov	-$C[bp],al
15776                                           !BCC_EOS
15777 4413           EB           31            jmp .3B1
15778                                           !BCC_EOS
15779                                           ! 2928             case 6: mouse_data1 = 200; break;
15780                       00004415            .3BA:
15781                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15782 4415           B0                     C8  mov	al,#$C8
15783 4417           8846         F4            mov	-$C[bp],al
15784                                           !BCC_EOS
15785 441A           EB           2A            jmp .3B1
15786                                           !BCC_EOS
15787                                           ! 2929             default: mouse_data1 = 0;
15788                       0000441C            .3BB:
15789                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15790 441C           30C0                       xor	al,al
15791 441E           8846         F4            mov	-$C[bp],al
15792                                           !BCC_EOS
15793                                           ! 2930           }
15794                                           ! 2931           if (mouse_data1 > 0) {
15795 4421           EB           23            jmp .3B1
15796                       00004423            .3B3:
15797 4423           2C                     00  sub	al,*0
15798 4425           72           F5            jb 	.3BB
15799 4427           3C                     06  cmp	al,*6
15800 4429           77           19            ja  	.3BC
15801 442B           30E4                       xor	ah,ah
15802 442D           D1E0                       shl	ax,*1
15803 442F           89C3                       mov	bx,ax
15804 4431           2E                         seg	cs
15805 4432           FFA7       4436            br	.3BD[bx]
15806                       00004436            .3BD:
15807 4436                      43EB            .word	.3B4
15808 4438                      43F2            .word	.3B5
15809 443A                      43F9            .word	.3B6
15810 443C                      4400            .word	.3B7
15811 443E                      4407            .word	.3B8
15812 4440                      440E            .word	.3B9
15813 4442                      4415            .word	.3BA
15814                       00004444            .3BC:
15815 4444           EB           D6            jmp	.3BB
15816                       00004446            .3B1:
15817                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15818 4446           8A46         F4            mov	al,-$C[bp]
15819 4449           84C0                       test	al,al
15820 444B         0F84         0057            beq 	.3BE
15821                       0000444F            .3BF:
15822                                           ! 2932             ret = send_to_mouse_ctrl(0xF3);
15823                                           ! Debug: list int = const $F3 (used reg = )
15824 444F           B8                   00F3  mov	ax,#$F3
15825 4452           50                         push	ax
15826                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15827 4453           E8         0EDB            call	_send_to_mouse_ctrl
15828 4456           44                         inc	sp
15829 4457           44                         inc	sp
15830                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15831 4458           8846         F5            mov	-$B[bp],al
15832                                           !BCC_EOS
15833                                           ! 2933             if (ret == 0) {
15834                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15835 445B           8A46         F5            mov	al,-$B[bp]
15836 445E           84C0                       test	al,al
15837 4460           75           35            jne 	.3C0
15838                       00004462            .3C1:
15839                                           ! 2934               ret = get_mouse_data(&mouse_data2);
15840                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15841 4462           8D5E         F3            lea	bx,-$D[bp]
15842 4465           53                         push	bx
15843                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15844 4466           E8         0F12            call	_get_mouse_data
15845 4469           44                         inc	sp
15846 446A           44                         inc	sp
15847                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15848 446B           8846         F5            mov	-$B[bp],al
15849                                           !BCC_EOS
15850                                           ! 2935               ret = send_to_mouse_ctrl(mouse_data1);
15851                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15852 446E           8A46         F4            mov	al,-$C[bp]
15853 4471           30E4                       xor	ah,ah
15854 4473           50                         push	ax
15855                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15856 4474           E8         0EBA            call	_send_to_mouse_ctrl
15857 4477           44                         inc	sp
15858 4478           44                         inc	sp
15859                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15860 4479           8846         F5            mov	-$B[bp],al
15861                                           !BCC_EOS
15862                                           ! 2936               ret = get_mouse_data(&mouse_data2);
15863                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15864 447C           8D5E         F3            lea	bx,-$D[bp]
15865 447F           53                         push	bx
15866                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15867 4480           E8         0EF8            call	_get_mouse_data
15868 4483           44                         inc	sp
15869 4484           44                         inc	sp
15870                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15871 4485           8846         F5            mov	-$B[bp],al
15872                                           !BCC_EOS
15873                                           ! 2937               FLAGS &= 0xfffe;
15874                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15875 4488           8B46         18            mov	ax,$18[bp]
15876 448B           24                     FE  and	al,#$FE
15877 448D           8946         18            mov	$18[bp],ax
15878                                           !BCC_EOS
15879                                           ! 2938               regs.u.r8.ah = 0;
15880                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15881 4490           30C0                       xor	al,al
15882 4492           8846         13            mov	$13[bp],al
15883                                           !BCC_EOS
15884                                           ! 2939             } else {
15885 4495           EB           0D            jmp .3C2
15886                       00004497            .3C0:
15887                                           ! 2940               FLAGS |= 0x0001;
15888                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15889 4497           8B46         18            mov	ax,$18[bp]
15890 449A           0C                     01  or	al,*1
15891 449C           8946         18            mov	$18[bp],ax
15892                                           !BCC_EOS
15893                                           ! 2941               regs.u.r8.ah = 0x86;
15894                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15895 449F           B0                     86  mov	al,#$86
15896 44A1           8846         13            mov	$13[bp],al
15897                                           !BCC_EOS
15898                                           ! 2942             }
15899                                           ! 2943           } else {
15900                       000044A4            .3C2:
15901 44A4           EB           0D            jmp .3C3
15902                       000044A6            .3BE:
15903                                           ! 2944             FLAGS |= 0x0001;
15904                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15905 44A6           8B46         18            mov	ax,$18[bp]
15906 44A9           0C                     01  or	al,*1
15907 44AB           8946         18            mov	$18[bp],ax
15908                                           !BCC_EOS
15909                                           ! 2945             regs.u.r8.ah = 
15910                                           ! 2945 0x86;
15911                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15912 44AE           B0                     86  mov	al,#$86
15913 44B0           8846         13            mov	$13[bp],al
15914                                           !BCC_EOS
15915                                           ! 2946           }
15916                                           ! 2947           break;
15917                       000044B3            .3C3:
15918 44B3           E9         0345            br 	.386
15919                                           !BCC_EOS
15920                                           ! 2948         case 3:
15921                                           ! 2949 ;
15922                       000044B6            .3C4:
15923                                           !BCC_EOS
15924                                           ! 2950           comm_byte = inhibit_mouse_int_and_events();
15925                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15926 44B6           E8         0D27            call	_inhibit_mouse_int_and_events
15927                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
15928 44B9           8846         F7            mov	-9[bp],al
15929                                           !BCC_EOS
15930                                           ! 2951           if (regs.u.r8.bh < 4) {
15931                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15932 44BC           8A46         0D            mov	al,$D[bp]
15933 44BF           3C                     04  cmp	al,*4
15934 44C1         0F83         008F            bhis	.3C5
15935                       000044C5            .3C6:
15936                                           ! 2952             ret = send_to_mouse_ctrl(0xE8);
15937                                           ! Debug: list int = const $E8 (used reg = )
15938 44C5           B8                   00E8  mov	ax,#$E8
15939 44C8           50                         push	ax
15940                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15941 44C9           E8         0E65            call	_send_to_mouse_ctrl
15942 44CC           44                         inc	sp
15943 44CD           44                         inc	sp
15944                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15945 44CE           8846         F5            mov	-$B[bp],al
15946                                           !BCC_EOS
15947                                           ! 2953             if (ret == 0) {
15948                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15949 44D1           8A46         F5            mov	al,-$B[bp]
15950 44D4           84C0                       test	al,al
15951 44D6         0F85         006B            bne 	.3C7
15952                       000044DA            .3C8:
15953                                           ! 2954               ret = get_mouse_data(&mouse_data1);
15954                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15955 44DA           8D5E         F4            lea	bx,-$C[bp]
15956 44DD           53                         push	bx
15957                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15958 44DE           E8         0E9A            call	_get_mouse_data
15959 44E1           44                         inc	sp
15960 44E2           44                         inc	sp
15961                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15962 44E3           8846         F5            mov	-$B[bp],al
15963                                           !BCC_EOS
15964                                           ! 2955               if (mouse_data1 != 0xfa)
15965                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15966 44E6           8A46         F4            mov	al,-$C[bp]
15967 44E9           3C                     FA  cmp	al,#$FA
15968 44EB           74           14            je  	.3C9
15969                       000044ED            .3CA:
15970                                           ! 2956                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
15971                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15972 44ED           8A46         F4            mov	al,-$C[bp]
15973 44F0           30E4                       xor	ah,ah
15974 44F2           50                         push	ax
15975                                           ! Debug: list * char = .3CB+0 (used reg = )
15976 44F3           BB                   D49F  mov	bx,#.3CB
15977 44F6           53                         push	bx
15978                                           ! Debug: list int = const 7 (used reg = )
15979 44F7           B8                   0007  mov	ax,*7
15980 44FA           50                         push	ax
15981                                           ! Debug: func () void = bios_printf+0 (used reg = )
15982 44FB           E8         C43B            call	_bios_printf
15983 44FE           83C4                   06  add	sp,*6
15984                                           !BCC_EOS
15985                                           ! 2957               ret = send_to_mouse_ctrl(regs.u.r8.bh);
15986                       00004501            .3C9:
15987                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
15988 4501           8A46         0D            mov	al,$D[bp]
15989 4504           30E4                       xor	ah,ah
15990 4506           50                         push	ax
15991                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15992 4507           E8         0E27            call	_send_to_mouse_ctrl
15993 450A           44                         inc	sp
15994 450B           44                         inc	sp
15995                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15996 450C           8846         F5            mov	-$B[bp],al
15997                                           !BCC_EOS
15998                                           ! 2958               ret = get_mouse_data(&mouse_data1);
15999                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16000 450F           8D5E         F4            lea	bx,-$C[bp]
16001 4512           53                         push	bx
16002                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16003 4513           E8         0E65            call	_get_mouse_data
16004 4516           44                         inc	sp
16005 4517           44                         inc	sp
16006                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16007 4518           8846         F5            mov	-$B[bp],al
16008                                           !BCC_EOS
16009                                           ! 2959               if (mouse_data1 != 0xfa)
16010                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16011 451B           8A46         F4            mov	al,-$C[bp]
16012 451E           3C                     FA  cmp	al,#$FA
16013 4520           74           14            je  	.3CC
16014                       00004522            .3CD:
16015                                           ! 2960                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16016                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16017 4522           8A46         F4            mov	al,-$C[bp]
16018 4525           30E4                       xor	ah,ah
16019 4527           50                         push	ax
16020                                           ! Debug: list * char = .3CE+0 (used reg = )
16021 4528           BB                   D473  mov	bx,#.3CE
16022 452B           53                         push	bx
16023                                           ! Debug: list int = const 7 (used reg = )
16024 452C           B8                   0007  mov	ax,*7
16025 452F           50                         push	ax
16026                                           ! Debug: func () void = bios_printf+0 (used reg = )
16027 4530           E8         C406            call	_bios_printf
16028 4533           83C4                   06  add	sp,*6
16029                                           !BCC_EOS
16030                                           ! 2961               FLAGS &= 0xfffe;
16031                       00004536            .3CC:
16032                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16033 4536           8B46         18            mov	ax,$18[bp]
16034 4539           24                     FE  and	al,#$FE
16035 453B           8946         18            mov	$18[bp],ax
16036                                           !BCC_EOS
16037                                           ! 2962               regs.u.r8.ah = 0;
16038                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16039 453E           30C0                       xor	al,al
16040 4540           8846         13            mov	$13[bp],al
16041                                           !BCC_EOS
16042                                           ! 2963             } else {
16043 4543           EB           0D            jmp .3CF
16044                       00004545            .3C7:
16045                                           ! 2964               FLAGS |= 0x0001;
16046                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16047 4545           8B46         18            mov	ax,$18[bp]
16048 4548           0C                     01  or	al,*1
16049 454A           8946         18            mov	$18[bp],ax
16050                                           !BCC_EOS
16051                                           ! 2965               regs.u.r8.ah = 0x86;
16052                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16053 454D           B0                     86  mov	al,#$86
16054 454F           8846         13            mov	$13[bp],al
16055                                           !BCC_EOS
16056                                           ! 2966             }
16057                                           ! 2967           } else {
16058                       00004552            .3CF:
16059 4552           EB           0D            jmp .3D0
16060                       00004554            .3C5:
16061                                           ! 2968             FLAGS |= 0x0001;
16062                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16063 4554           8B46         18            mov	ax,$18[bp]
16064 4557           0C                     01  or	al,*1
16065 4559           8946         18            mov	$18[bp],ax
16066                                           !BCC_EOS
16067                                           ! 2969             regs.u.r8.ah = 0x86;
16068                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16069 455C           B0                     86  mov	al,#$86
16070 455E           8846         13            mov	$13[bp],al
16071                                           !BCC_EOS
16072                                           ! 2970           }
16073                                           ! 2971           set_kbd_command_byte(comm_byte);
16074                       00004561            .3D0:
16075                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16076 4561           8A46         F7            mov	al,-9[bp]
16077 4564           30E4                       xor	ah,ah
16078 4566           50                         push	ax
16079                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16080 4567           E8         0E48            call	_set_kbd_command_byte
16081 456A           44                         inc	sp
16082 456B           44                         inc	sp
16083                                           !BCC_EOS
16084                                           ! 2972           break;
16085 456C           E9         028C            br 	.386
16086                                           !BCC_EOS
16087                                           ! 2973         case 4:
16088                                           ! 2974 ;
16089                       0000456F            .3D1:
16090                                           !BCC_EOS
16091                                           ! 2975           inhibit_mouse_int_and_events();
16092                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16093 456F           E8         0C6E            call	_inhibit_mouse_int_and_events
16094                                           !BCC_EOS
16095                                           ! 2976           ret = send_to_mouse_ctrl(0xF2);
16096                                           ! Debug: list int = const $F2 (used reg = )
16097 4572           B8                   00F2  mov	ax,#$F2
16098 4575           50                         push	ax
16099                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16100 4576           E8         0DB8            call	_send_to_mouse_ctrl
16101 4579           44                         inc	sp
16102 457A           44                         inc	sp
16103                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16104 457B           8846         F5            mov	-$B[bp],al
16105                                           !BCC_EOS
16106                                           ! 2977           if (ret == 0) {
16107                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16108 457E           8A46         F5            mov	al,-$B[bp]
16109 4581           84C0                       test	al,al
16110 4583           75           2D            jne 	.3D2
16111                       00004585            .3D3:
16112                                           ! 2978             ret = get_mouse_data(&mouse_data1);
16113                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16114 4585           8D5E         F4            lea	bx,-$C[bp]
16115 4588           53                         push	bx
16116                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16117 4589           E8         0DEF            call	_get_mouse_data
16118 458C           44                         inc	sp
16119 458D           44                         inc	sp
16120                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16121 458E           8846         F5            mov	-$B[bp],al
16122                                           !BCC_EOS
16123                                           ! 2979             ret = get_mouse_data(&mouse_data2);
16124                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16125 4591           8D5E         F3            lea	bx,-$D[bp]
16126 4594           53                         push	bx
16127                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16128 4595           E8         0DE3            call	_get_mouse_data
16129 4598           44                         inc	sp
16130 4599           44                         inc	sp
16131                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16132 459A           8846         F5            mov	-$B[bp],al
16133                                           !BCC_EOS
16134                                           ! 2980             FLAGS &= 0xfffe;
16135                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16136 459D           8B46         18            mov	ax,$18[bp]
16137 45A0           24                     FE  and	al,#$FE
16138 45A2           8946         18            mov	$18[bp],ax
16139                                           !BCC_EOS
16140                                           ! 2981             regs.u.r8.ah = 0;
16141                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16142 45A5           30C0                       xor	al,al
16143 45A7           8846         13            mov	$13[bp],al
16144                                           !BCC_EOS
16145                                           ! 2982             regs.u.r8.bh = mouse_data2;
16146                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16147 45AA           8A46         F3            mov	al,-$D[bp]
16148 45AD           8846         0D            mov	$D[bp],al
16149                                           !BCC_EOS
16150                                           ! 2983           } else {
16151 45B0           EB           0D            jmp .3D4
16152                       000045B2            .3D2:
16153                                           ! 2984             FLAGS |= 0x0001;
16154                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16155 45B2           8B46         18            mov	ax,$18[bp]
16156 45B5           0C                     01  or	al,*1
16157 45B7           8946         18            mov	$18[bp],ax
16158                                           !BCC_EOS
16159                                           ! 2985             regs.u.r8.ah = 0x86;
16160                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16161 45BA           B0                     86  mov	al,#$86
16162 45BC           8846         13            mov	$13[bp],al
16163                                           !BCC_EOS
16164                                           ! 2986           }
16165                                           ! 2987           break;
16166                       000045BF            .3D4:
16167 45BF           E9         0239            br 	.386
16168                                           !BCC_EOS
16169                                           ! 2988         case 6:
16170                                           ! 2989 ;
16171                       000045C2            .3D5:
16172                                           !BCC_EOS
16173                                           ! 2990           switch (regs.u.r8.bh) {
16174 45C2           8A46         0D            mov	al,$D[bp]
16175 45C5           E9         015E            br 	.3D8
16176                                           ! 2991             case 0:
16177                                           ! 2992               comm_byte = inhibit_mouse_int_and_events();
16178                       000045C8            .3D9:
16179                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16180 45C8           E8         0C15            call	_inhibit_mouse_int_and_events
16181                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16182 45CB           8846         F7            mov	-9[bp],al
16183                                           !BCC_EOS
16184                                           ! 2993               ret = send_to_mouse_ctrl(0xE9);
16185                                           ! Debug: list int = const $E9 (used reg = )
16186 45CE           B8                   00E9  mov	ax,#$E9
16187 45D1           50                         push	ax
16188                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16189 45D2           E8         0D5C            call	_send_to_mouse_ctrl
16190 45D5           44                         inc	sp
16191 45D6           44                         inc	sp
16192                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16193 45D7           8846         F5            mov	-$B[bp],al
16194                                           !BCC_EOS
16195                                           ! 2994               if (ret == 0) {
16196                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16197 45DA           8A46         F5            mov	al,-$B[bp]
16198 45DD           84C0                       test	al,al
16199 45DF         0F85         0099            bne 	.3DA
16200                       000045E3            .3DB:
16201                                           ! 2995                 ret = get_mouse_data(&mouse_data1);
16202                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16203 45E3           8D5E         F4            lea	bx,-$C[bp]
16204 45E6           53                         push	bx
16205                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16206 45E7           E8         0D91            call	_get_mouse_data
16207 45EA           44                         inc	sp
16208 45EB           44                         inc	sp
16209                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16210 45EC           8846         F5            mov	-$B[bp],al
16211                                           !BCC_EOS
16212                                           ! 2996                 if (mouse_data1 != 0xfa)
16213                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16214 45EF           8A46         F4            mov	al,-$C[bp]
16215 45F2           3C                     FA  cmp	al,#$FA
16216 45F4           74           14            je  	.3DC
16217                       000045F6            .3DD:
16218                                           ! 2997                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16219                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16220 45F6           8A46         F4            mov	al,-$C[bp]
16221 45F9           30E4                       xor	ah,ah
16222 45FB           50                         push	ax
16223                                           ! Debug: list * char = .3DE+0 (used reg = )
16224 45FC           BB                   D447  mov	bx,#.3DE
16225 45FF           53                         push	bx
16226                                           ! Debug: list int = const 7 (used reg = )
16227 4600           B8                   0007  mov	ax,*7
16228 4603           50                         push	ax
16229                                           ! Debug: func () void = bios_printf+0 (used reg = )
16230 4604           E8         C332            call	_bios_printf
16231 4607           83C4                   06  add	sp,*6
16232                                           !BCC_EOS
16233                                           ! 2998                 if (ret == 0) {
16234                       0000460A            .3DC:
16235                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16236 460A           8A46         F5            mov	al,-$B[bp]
16237 460D           84C0                       test	al,al
16238 460F         0F85         0069            bne 	.3DF
16239                       00004613            .3E0:
16240                                           ! 2999                   ret = get_mouse_data(&mouse_data1);
16241                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16242 4613           8D5E         F4            lea	bx,-$C[bp]
16243 4616           53                         push	bx
16244                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16245 4617           E8         0D61            call	_get_mouse_data
16246 461A           44                         inc	sp
16247 461B           44                         inc	sp
16248                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16249 461C           8846         F5            mov	-$B[bp],al
16250                                           !BCC_EOS
16251                                           ! 3000                   if (ret == 0) {
16252                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16253 461F           8A46         F5            mov	al,-$B[bp]
16254 4622           84C0                       test	al,al
16255 4624         0F85         0054            bne 	.3E1
16256                       00004628            .3E2:
16257                                           ! 3001                     ret = get_mouse_data(&mouse_data2);
16258                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16259 4628           8D5E         F3            lea	bx,-$D[bp]
16260 462B           53                         push	bx
16261                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16262 462C           E8         0D4C            call	_get_mouse_data
16263 462F           44                         inc	sp
16264 4630           44                         inc	sp
16265                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16266 4631           8846         F5            mov	-$B[bp],al
16267                                           !BCC_EOS
16268                                           ! 3002                     if (ret == 0) {
16269                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16270 4634           8A46         F5            mov	al,-$B[bp]
16271 4637           84C0                       test	al,al
16272 4639           75           41            jne 	.3E3
16273                       0000463B            .3E4:
16274                                           ! 3003  
16275                                           ! 3003                      ret = get_mouse_data(&mouse_data3);
16276                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16277 463B           8D5E         F2            lea	bx,-$E[bp]
16278 463E           53                         push	bx
16279                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16280 463F           E8         0D39            call	_get_mouse_data
16281 4642           44                         inc	sp
16282 4643           44                         inc	sp
16283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16284 4644           8846         F5            mov	-$B[bp],al
16285                                           !BCC_EOS
16286                                           ! 3004                       if (ret == 0) {
16287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16288 4647           8A46         F5            mov	al,-$B[bp]
16289 464A           84C0                       test	al,al
16290 464C           75           2E            jne 	.3E5
16291                       0000464E            .3E6:
16292                                           ! 3005                         FLAGS &= 0xfffe;
16293                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16294 464E           8B46         18            mov	ax,$18[bp]
16295 4651           24                     FE  and	al,#$FE
16296 4653           8946         18            mov	$18[bp],ax
16297                                           !BCC_EOS
16298                                           ! 3006                         regs.u.r8.ah = 0;
16299                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16300 4656           30C0                       xor	al,al
16301 4658           8846         13            mov	$13[bp],al
16302                                           !BCC_EOS
16303                                           ! 3007                         regs.u.r8.bl = mouse_data1;
16304                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16305 465B           8A46         F4            mov	al,-$C[bp]
16306 465E           8846         0C            mov	$C[bp],al
16307                                           !BCC_EOS
16308                                           ! 3008                         regs.u.r8.cl = mouse_data2;
16309                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
16310 4661           8A46         F3            mov	al,-$D[bp]
16311 4664           8846         10            mov	$10[bp],al
16312                                           !BCC_EOS
16313                                           ! 3009                         regs.u.r8.dl = mouse_data3;
16314                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
16315 4667           8A46         F2            mov	al,-$E[bp]
16316 466A           8846         0E            mov	$E[bp],al
16317                                           !BCC_EOS
16318                                           ! 3010                         set_kbd_command_byte(comm_byte);
16319                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16320 466D           8A46         F7            mov	al,-9[bp]
16321 4670           30E4                       xor	ah,ah
16322 4672           50                         push	ax
16323                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16324 4673           E8         0D3C            call	_set_kbd_command_byte
16325 4676           44                         inc	sp
16326 4677           44                         inc	sp
16327                                           !BCC_EOS
16328                                           ! 3011                         return;
16329 4678           89EC                       mov	sp,bp
16330 467A           5D                         pop	bp
16331 467B           C3                         ret
16332                                           !BCC_EOS
16333                                           ! 3012                       }
16334                                           ! 3013                     }
16335                       0000467C            .3E5:
16336                                           ! 3014                   }
16337                       0000467C            .3E3:
16338                                           ! 3015                 }
16339                       0000467C            .3E1:
16340                                           ! 3016               }
16341                       0000467C            .3DF:
16342                                           ! 3017               FLAGS |= 0x0001;
16343                       0000467C            .3DA:
16344                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16345 467C           8B46         18            mov	ax,$18[bp]
16346 467F           0C                     01  or	al,*1
16347 4681           8946         18            mov	$18[bp],ax
16348                                           !BCC_EOS
16349                                           ! 3018               regs.u.r8.ah = ret;
16350                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16351 4684           8A46         F5            mov	al,-$B[bp]
16352 4687           8846         13            mov	$13[bp],al
16353                                           !BCC_EOS
16354                                           ! 3019               set_kbd_command_byte(comm_byte);
16355                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16356 468A           8A46         F7            mov	al,-9[bp]
16357 468D           30E4                       xor	ah,ah
16358 468F           50                         push	ax
16359                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16360 4690           E8         0D1F            call	_set_kbd_command_byte
16361 4693           44                         inc	sp
16362 4694           44                         inc	sp
16363                                           !BCC_EOS
16364                                           ! 3020               return;
16365 4695           89EC                       mov	sp,bp
16366 4697           5D                         pop	bp
16367 4698           C3                         ret
16368                                           !BCC_EOS
16369                                           ! 3021             case 1:
16370                                           ! 3022             case 2:
16371                       00004699            .3E7:
16372                                           ! 3023               comm_byte = inhibit_mouse_int_and_events();
16373                       00004699            .3E8:
16374                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16375 4699           E8         0B44            call	_inhibit_mouse_int_and_events
16376                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16377 469C           8846         F7            mov	-9[bp],al
16378                                           !BCC_EOS
16379                                           ! 3024               if (regs.u.r8.bh == 1) {
16380                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
16381 469F           8A46         0D            mov	al,$D[bp]
16382 46A2           3C                     01  cmp	al,*1
16383 46A4           75           0E            jne 	.3E9
16384                       000046A6            .3EA:
16385                                           ! 3025                 ret = send_to_mouse_ctrl(0xE6);
16386                                           ! Debug: list int = const $E6 (used reg = )
16387 46A6           B8                   00E6  mov	ax,#$E6
16388 46A9           50                         push	ax
16389                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16390 46AA           E8         0C84            call	_send_to_mouse_ctrl
16391 46AD           44                         inc	sp
16392 46AE           44                         inc	sp
16393                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16394 46AF           8846         F5            mov	-$B[bp],al
16395                                           !BCC_EOS
16396                                           ! 3026               } else {
16397 46B2           EB           0C            jmp .3EB
16398                       000046B4            .3E9:
16399                                           ! 3027                 ret = send_to_mouse_ctrl(0xE7);
16400                                           ! Debug: list int = const $E7 (used reg = )
16401 46B4           B8                   00E7  mov	ax,#$E7
16402 46B7           50                         push	ax
16403                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16404 46B8           E8         0C76            call	_send_to_mouse_ctrl
16405 46BB           44                         inc	sp
16406 46BC           44                         inc	sp
16407                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16408 46BD           8846         F5            mov	-$B[bp],al
16409                                           !BCC_EOS
16410                                           ! 3028               }
16411                                           ! 3029               if (ret == 0) {
16412                       000046C0            .3EB:
16413                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16414 46C0           8A46         F5            mov	al,-$B[bp]
16415 46C3           84C0                       test	al,al
16416 46C5           75           19            jne 	.3EC
16417                       000046C7            .3ED:
16418                                           ! 3030                 get_mouse_data(&mouse_data1);
16419                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16420 46C7           8D5E         F4            lea	bx,-$C[bp]
16421 46CA           53                         push	bx
16422                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16423 46CB           E8         0CAD            call	_get_mouse_data
16424 46CE           44                         inc	sp
16425 46CF           44                         inc	sp
16426                                           !BCC_EOS
16427                                           ! 3031                 ret = (mouse_data1 != 0xFA);
16428                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16429 46D0           8A46         F4            mov	al,-$C[bp]
16430 46D3           3C                     FA  cmp	al,#$FA
16431 46D5           74           04            je 	.3EE
16432 46D7           B0                     01  mov	al,*1
16433 46D9           EB           02            jmp	.3EF
16434                       000046DB            .3EE:
16435 46DB           30C0                       xor	al,al
16436                       000046DD            .3EF:
16437                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16438 46DD           8846         F5            mov	-$B[bp],al
16439                                           !BCC_EOS
16440                                           ! 3032               }
16441                                           ! 3033               if (ret == 0) {
16442                       000046E0            .3EC:
16443                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16444 46E0           8A46         F5            mov	al,-$B[bp]
16445 46E3           84C0                       test	al,al
16446 46E5           75           0F            jne 	.3F0
16447                       000046E7            .3F1:
16448                                           ! 3034                 FLAGS &= 0xfffe;
16449                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16450 46E7           8B46         18            mov	ax,$18[bp]
16451 46EA           24                     FE  and	al,#$FE
16452 46EC           8946         18            mov	$18[bp],ax
16453                                           !BCC_EOS
16454                                           ! 3035                 regs.u.r8.ah = 0;
16455                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16456 46EF           30C0                       xor	al,al
16457 46F1           8846         13            mov	$13[bp],al
16458                                           !BCC_EOS
16459                                           ! 3036               } else {
16460 46F4           EB           0D            jmp .3F2
16461                       000046F6            .3F0:
16462                                           ! 3037                 FLAGS |= 0x0001;
16463                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16464 46F6           8B46         18            mov	ax,$18[bp]
16465 46F9           0C                     01  or	al,*1
16466 46FB           8946         18            mov	$18[bp],ax
16467                                           !BCC_EOS
16468                                           ! 3038                 regs.u.r8.ah = 0x86;
16469                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16470 46FE           B0                     86  mov	al,#$86
16471 4700           8846         13            mov	$13[bp],al
16472                                           !BCC_EOS
16473                                           ! 3039               }
16474                                           ! 3040               set_kbd_command_byte(comm_byte);
16475                       00004703            .3F2:
16476                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16477 4703           8A46         F7            mov	al,-9[bp]
16478 4706           30E4                       xor	ah,ah
16479 4708           50                         push	ax
16480                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16481 4709           E8         0CA6            call	_set_kbd_command_byte
16482 470C           44                         inc	sp
16483 470D           44                         inc	sp
16484                                           !BCC_EOS
16485                                           ! 3041               break;
16486 470E           EB           2A            jmp .3D6
16487                                           !BCC_EOS
16488                                           ! 3042             default:
16489                                           ! 3043               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
16490                       00004710            .3F3:
16491                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16492 4710           8A46         0D            mov	al,$D[bp]
16493 4713           30E4                       xor	ah,ah
16494 4715           50                         push	ax
16495                                           ! Debug: list * char = .3F4+0 (used reg = )
16496 4716           BB                   D42D  mov	bx,#.3F4
16497 4719           53                         push	bx
16498                                           ! Debug: list int = const 7 (used reg = )
16499 471A           B8                   0007  mov	ax,*7
16500 471D           50                         push	ax
16501                                           ! Debug: func () void = bios_printf+0 (used reg = )
16502 471E           E8         C218            call	_bios_printf
16503 4721           83C4                   06  add	sp,*6
16504                                           !BCC_EOS
16505                                           ! 3044           }
16506                                           ! 3045           break;
16507 4724           EB           14            jmp .3D6
16508                       00004726            .3D8:
16509 4726           2C                     00  sub	al,*0
16510 4728         0F84         FE9C            beq 	.3D9
16511 472C           2C                     01  sub	al,*1
16512 472E         0F84         FF67            beq 	.3E7
16513 4732           2C                     01  sub	al,*1
16514 4734         0F84         FF61            beq 	.3E8
16515 4738           EB           D6            jmp	.3F3
16516                       0000473A            .3D6:
16517 473A           E9         00BE            br 	.386
16518                                           !BCC_EOS
16519                                           ! 3046         case 7:
16520                                           ! 3047 ;
16521                       0000473D            .3F5:
16522                                           !BCC_EOS
16523                                           ! 3048           mouse_driver_seg = ES;
16524                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16525 473D           8B46         14            mov	ax,$14[bp]
16526 4740           8946         FA            mov	-6[bp],ax
16527                                           !BCC_EOS
16528                                           ! 3049           mouse_driver_offset = regs.u.r16.bx;
16529                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16530 4743           8B46         0C            mov	ax,$C[bp]
16531 4746           8946         F8            mov	-8[bp],ax
16532                                           !BCC_EOS
16533                                           ! 3050           _write_word(mouse_driver_offset, &((ebda_data_t *) 0)->mouse_driver_offset, ebda_seg);
16534                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16535 4749           FF76         FE            push	-2[bp]
16536                                           ! Debug: list * unsigned short = const $22 (used reg = )
16537 474C           B8                   0022  mov	ax,*$22
16538 474F           50                         push	ax
16539                                           ! Debug: list unsigned short mouse_driver_offset = [S+$14-$A] (used reg = )
16540 4750           FF76         F8            push	-8[bp]
16541                                           ! Debug: func () void = _write_word+0 (used reg = )
16542 4753           E8         BEB8            call	__write_word
16543 4756           83C4                   06  add	sp,*6
16544                                           !BCC_EOS
16545                                           ! 3051           _write_word(mouse_driver_seg, &((ebda_data_t *) 0)->mouse_driver_seg, ebda_seg);
16546                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16547 4759           FF76         FE            push	-2[bp]
16548                                           ! Debug: list * unsigned short = const $24 (used reg = )
16549 475C           B8                   0024  mov	ax,*$24
16550 475F           50                         push	ax
16551                                           ! Debug: list unsigned short mouse_driver_seg = [S+$14-8] (used reg = )
16552 4760           FF76         FA            push	-6[bp]
16553                                           ! Debug: func () void = _write_word+0 (used reg = )
16554 4763           E8         BEA8            call	__write_word
16555 4766           83C4                   06  add	sp,*6
16556                                           !BCC_EOS
16557                                           ! 3052           mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16558                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16559 4769           FF76         FE            push	-2[bp]
16560                                           ! Debug: list * unsigned char = const $27 (used reg = )
16561 476C           B8                   0027  mov	ax,*$27
16562 476F           50                         push	ax
16563                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
16564 4770           E8         BE6C            call	__read_byte
16565 4773           83C4                   04  add	sp,*4
16566                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16567 4776           8846         FC            mov	-4[bp],al
16568                                           !BCC_EOS
16569                                           ! 3053           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
16570                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16571 4779           8B46         F8            mov	ax,-8[bp]
16572 477C           85C0                       test	ax,ax
16573 477E           75           1D            jne 	.3F6
16574                       00004780            .3F8:
16575                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16576 4780           8B46         FA            mov	ax,-6[bp]
16577 4783           85C0                       test	ax,ax
16578 4785           75           16            jne 	.3F6
16579                       00004787            .3F7:
16580                                           ! 3054             if ( (mouse_flags_2 & 0x80) != 0 ) {
16581                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16582 4787           8A46         FC            mov	al,-4[bp]
16583 478A           24                     80  and	al,#$80
16584                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
16585 478C           84C0                       test	al,al
16586 478E           74           0B            je  	.3F9
16587                       00004790            .3FA:
16588                                           ! 3055               mouse_flags_2 &= ~0x80;
16589                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16590 4790           8A46         FC            mov	al,-4[bp]
16591 4793           24                     7F  and	al,*$7F
16592 4795           8846         FC            mov	-4[bp],al
16593                                           !BCC_EOS
16594                                           ! 3056               inhibit_mouse_int_and_even
16595                                           ! 3056 ts();
16596                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16597 4798           E8         0A45            call	_inhibit_mouse_int_and_events
16598                                           !BCC_EOS
16599                                           ! 3057             }
16600                                           ! 3058           }
16601                       0000479B            .3F9:
16602                                           ! 3059           else {
16603 479B           EB           08            jmp .3FB
16604                       0000479D            .3F6:
16605                                           ! 3060             mouse_flags_2 |= 0x80;
16606                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16607 479D           8A46         FC            mov	al,-4[bp]
16608 47A0           0C                     80  or	al,#$80
16609 47A2           8846         FC            mov	-4[bp],al
16610                                           !BCC_EOS
16611                                           ! 3061           }
16612                                           ! 3062           _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16613                       000047A5            .3FB:
16614                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16615 47A5           FF76         FE            push	-2[bp]
16616                                           ! Debug: list * unsigned char = const $27 (used reg = )
16617 47A8           B8                   0027  mov	ax,*$27
16618 47AB           50                         push	ax
16619                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
16620 47AC           8A46         FC            mov	al,-4[bp]
16621 47AF           30E4                       xor	ah,ah
16622 47B1           50                         push	ax
16623                                           ! Debug: func () void = _write_byte+0 (used reg = )
16624 47B2           E8         BE46            call	__write_byte
16625 47B5           83C4                   06  add	sp,*6
16626                                           !BCC_EOS
16627                                           ! 3063           FLAGS &= 0xfffe;
16628                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16629 47B8           8B46         18            mov	ax,$18[bp]
16630 47BB           24                     FE  and	al,#$FE
16631 47BD           8946         18            mov	$18[bp],ax
16632                                           !BCC_EOS
16633                                           ! 3064           regs.u.r8.ah = 0;
16634                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16635 47C0           30C0                       xor	al,al
16636 47C2           8846         13            mov	$13[bp],al
16637                                           !BCC_EOS
16638                                           ! 3065           break;
16639 47C5           EB           34            jmp .386
16640                                           !BCC_EOS
16641                                           ! 3066         default:
16642                                           ! 3067 ;
16643                       000047C7            .3FC:
16644                                           !BCC_EOS
16645                                           ! 3068           regs.u.r8.ah = 1;
16646                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
16647 47C7           B0                     01  mov	al,*1
16648 47C9           8846         13            mov	$13[bp],al
16649                                           !BCC_EOS
16650                                           ! 3069           FLAGS |= 0x0001;
16651                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16652 47CC           8B46         18            mov	ax,$18[bp]
16653 47CF           0C                     01  or	al,*1
16654 47D1           8946         18            mov	$18[bp],ax
16655                                           !BCC_EOS
16656                                           ! 3070       }
16657                                           ! 3071       break;
16658 47D4           EB           25            jmp .386
16659                       000047D6            .388:
16660 47D6           2C                     00  sub	al,*0
16661 47D8           72           ED            jb 	.3FC
16662 47DA           3C                     07  cmp	al,*7
16663 47DC           77           1B            ja  	.3FD
16664 47DE           30E4                       xor	ah,ah
16665 47E0           D1E0                       shl	ax,*1
16666 47E2           89C3                       mov	bx,ax
16667 47E4           2E                         seg	cs
16668 47E5           FFA7       47E9            br	.3FE[bx]
16669                       000047E9            .3FE:
16670 47E9                      41BE            .word	.389
16671 47EB                      42BE            .word	.39C
16672 47ED                      43E6            .word	.3B0
16673 47EF                      44B6            .word	.3C4
16674 47F1                      456F            .word	.3D1
16675 47F3                      42BE            .word	.39D
16676 47F5                      45C2            .word	.3D5
16677 47F7                      473D            .word	.3F5
16678                       000047F9            .3FD:
16679 47F9           EB           CC            jmp	.3FC
16680                       000047FB            .386:
16681 47FB           EB           2D            jmp .382
16682                                           !BCC_EOS
16683                                           ! 3072     default:
16684                                           ! 3073       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
16685                       000047FD            .3FF:
16686                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
16687 47FD           FF76         0C            push	$C[bp]
16688                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
16689 4800           FF76         12            push	$12[bp]
16690                                           ! Debug: list * char = .400+0 (used reg = )
16691 4803           BB                   D3F3  mov	bx,#.400
16692 4806           53                         push	bx
16693                                           ! Debug: list int = const 4 (used reg = )
16694 4807           B8                   0004  mov	ax,*4
16695 480A           50                         push	ax
16696                                           ! Debug: func () void = bios_printf+0 (used reg = )
16697 480B           E8         C12B            call	_bios_printf
16698 480E           83C4                   08  add	sp,*8
16699                                           !BCC_EOS
16700                                           ! 3074       FLAGS |= 0x0001;
16701                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16702 4811           8B46         18            mov	ax,$18[bp]
16703 4814           0C                     01  or	al,*1
16704 4816           8946         18            mov	$18[bp],ax
16705                                           !BCC_EOS
16706                                           ! 3075       regs.u.r8.ah = 0x86;
16707                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16708 4819           B0                     86  mov	al,#$86
16709 481B           8846         13            mov	$13[bp],al
16710                                           !BCC_EOS
16711                                           ! 3076       break;
16712 481E           EB           0A            jmp .382
16713                                           !BCC_EOS
16714                                           ! 3077   }
16715                                           ! 3078 }
16716 4820           EB           08            jmp .382
16717                       00004822            .384:
16718 4822           2C                     C2  sub	al,#$C2
16719 4824         0F84         F990            beq 	.385
16720 4828           EB           D3            jmp	.3FF
16721                       0000482A            .382:
16722                       FFFFFFF0            ..FFF6	=	-$10
16723 482A           89EC                       mov	sp,bp
16724 482C           5D                         pop	bp
16725 482D           C3                         ret
16726                                           ! 3079 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
16727                                           ! Register BX used in function int15_function_mouse
16728                                           ! 3080      Bit16u ES;
16729                                           export	_set_e820_range
16730                       0000482E            _set_e820_range:
16731                                           !BCC_EOS
16732                                           ! 3081      Bit16u DI;
16733                                           !BCC_EOS
16734                                           ! 3082      Bit32u start;
16735                                           !BCC_EOS
16736                                           ! 3083      Bit32u end;
16737                                           !BCC_EOS
16738                                           ! 3084      Bit8u extra_start;
16739                                           !BCC_EOS
16740                                           ! 3085      Bit8u extra_end;
16741                                           !BCC_EOS
16742                                           ! 3086      Bit16u type;
16743                                           !BCC_EOS
16744                                           ! 3087 {
16745                                           ! 3088     Bit16u old_ds = set_DS(ES);
16746 482E           55                         push	bp
16747 482F           89E5                       mov	bp,sp
16748 4831           4C                         dec	sp
16749 4832           4C                         dec	sp
16750                                           ! Debug: list unsigned short ES = [S+4+2] (used reg = )
16751 4833           FF76         04            push	4[bp]
16752                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16753 4836           E8         BE24            call	_set_DS
16754 4839           44                         inc	sp
16755 483A           44                         inc	sp
16756                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+4-4] (used reg = )
16757 483B           8946         FE            mov	-2[bp],ax
16758                                           !BCC_EOS
16759                                           ! 3089     *((Bit32u *)(DI)) = (start);
16760 483E           8B5E         06            mov	bx,6[bp]
16761                                           ! Debug: eq unsigned long start = [S+4+6] to unsigned long = [bx+0] (used reg = )
16762 4841           8B46         08            mov	ax,8[bp]
16763 4844           8B76         0A            mov	si,$A[bp]
16764 4847           8907                       mov	[bx],ax
16765 4849           8977         02            mov	2[bx],si
16766                                           !BCC_EOS
16767                                           ! 3090     *((Bit16u *)(DI+4)) = (extra_start);
16768                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
16769 484C           8B46         06            mov	ax,6[bp]
16770                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+4 (used reg = )
16771 484F           89C3                       mov	bx,ax
16772                                           ! Debug: eq unsigned char extra_start = [S+4+$E] to unsigned short = [bx+4] (used reg = )
16773 4851           8A46         10            mov	al,$10[bp]
16774 4854           30E4                       xor	ah,ah
16775 4856           8947         04            mov	4[bx],ax
16776                                           !BCC_EOS
16777                                           ! 3091     *((Bit16u *)(DI+6)) = (0x00);
16778                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
16779 4859           8B46         06            mov	ax,6[bp]
16780                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+6 (used reg = )
16781 485C           89C3                       mov	bx,ax
16782                                           ! Debug: eq int = const 0 to unsigned short = [bx+6] (used reg = )
16783 485E           31C0                       xor	ax,ax
16784 4860           8947         06            mov	6[bx],ax
16785                                           !BCC_EOS
16786                                           ! 3092     end -= start;
16787                                           ! Debug: subab unsigned long start = [S+4+6] to unsigned long end = [S+4+$A] (used reg = )
16788 4863           8B46         0C            mov	ax,$C[bp]
16789 4866           8B5E         0E            mov	bx,$E[bp]
16790 4869           8D7E         08            lea	di,8[bp]
16791 486C           E8         B843            call	lsubul
16792 486F           8946         0C            mov	$C[bp],ax
16793 4872           895E         0E            mov	$E[bp],bx
16794                                           !BCC_EOS
16795                                           ! 3093     extra_end -= extra_start;
16796                                           ! Debug: subab unsigned char extra_start = [S+4+$E] to unsigned char extra_end = [S+4+$10] (used reg = )
16797 4875           8A46         12            mov	al,$12[bp]
16798 4878           30E4                       xor	ah,ah
16799 487A           2A46         10            sub	al,$10[bp]
16800 487D           80DC                   00  sbb	ah,*0
16801 4880           8846         12            mov	$12[bp],al
16802                                           !BCC_EOS
16803                                           ! 3094     *((Bit32u *)(DI+8)) = (end);
16804                                           ! Debug: add int = const 8 to unsigned short DI = [S+4+4] (used reg = )
16805 4883           8B46         06            mov	ax,6[bp]
16806                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+8 (used reg = )
16807 4886           89C3                       mov	bx,ax
16808                                           ! Debug: eq unsigned long end = [S+4+$A] to unsigned long = [bx+8] (used reg = )
16809 4888           8B46         0C            mov	ax,$C[bp]
16810 488B           8B76         0E            mov	si,$E[bp]
16811 488E           8947         08            mov	8[bx],ax
16812 4891           8977         0A            mov	$A[bx],si
16813                                           !BCC_EOS
16814                                           ! 3095     *((Bit16u *)(DI+12)) = (extra_end);
16815                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
16816 4894           8B46         06            mov	ax,6[bp]
16817                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
16818 4897           89C3                       mov	bx,ax
16819                                           ! Debug: eq unsigned char extra_end = [S+4+$10] to unsigned short = [bx+$C] (used reg = )
16820 4899           8A46         12            mov	al,$12[bp]
16821 489C           30E4                       xor	ah,ah
16822 489E           8947         0C            mov	$C[bx],ax
16823                                           !BCC_EOS
16824                                           ! 3096     *((Bit16u *)(DI+14)) = (0x0000);
16825                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
16826 48A1           8B46         06            mov	ax,6[bp]
16827                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
16828 48A4           89C3                       mov	bx,ax
16829                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
16830 48A6           31C0                       xor	ax,ax
16831 48A8           8947         0E            mov	$E[bx],ax
16832                                           !BCC_EOS
16833                                           ! 3097     *((Bit16u *)(DI+16)) = (type);
16834                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
16835 48AB           8B46         06            mov	ax,6[bp]
16836                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$10 (used reg = )
16837 48AE           89C3                       mov	bx,ax
16838                                           ! Debug: eq unsigned short type = [S+4+$12] to unsigned short = [bx+$10] (used reg = )
16839 48B0           8B46         14            mov	ax,$14[bp]
16840 48B3           8947         10            mov	$10[bx],ax
16841                                           !BCC_EOS
16842                                           ! 3098     *((Bit16u *)(DI+18)) = (0x0);
16843                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
16844 48B6           8B46         06            mov	ax,6[bp]
16845                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$12 (used reg = )
16846 48B9           89C3                       mov	bx,ax
16847                                           ! Debug: eq int = const 0 to unsigned short = [bx+$12] (used reg = )
16848 48BB           31C0                       xor	ax,ax
16849 48BD           8947         12            mov	$12[bx],ax
16850                                           !BCC_EOS
16851                                           ! 3099     set_DS(old_ds);
16852                                           ! Debug: list unsigned short old_ds = [S+4-4] (used reg = )
16853 48C0           FF76         FE            push	-2[bp]
16854                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16855 48C3           E8         BD97            call	_set_DS
16856 48C6           44                         inc	sp
16857 48C7           44                         inc	sp
16858                                           !BCC_EOS
16859                                           ! 3100 }
16860 48C8           89EC                       mov	sp,bp
16861 48CA           5D                         pop	bp
16862 48CB           C3                         ret
16863                                           ! 3101   void
16864                                           ! Register BX used in function set_e820_range
16865                                           ! 3102 int15_function32(regs, ES, DS, FLAGS)
16866                                           ! 3103   pushad_regs_t regs;
16867                                           export	_int15_function32
16868                       000048CC            _int15_function32:
16869                                           !BCC_EOS
16870                                           ! 3104   Bit16u ES, DS, FLAGS;
16871                                           !BCC_EOS
16872                                           ! 3105 {
16873                                           ! 3106   Bit32u extended_memory_size=0;
16874 48CC           55                         push	bp
16875 48CD           89E5                       mov	bp,sp
16876 48CF           83C4                   FC  add	sp,*-4
16877                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
16878 48D2           31C0                       xor	ax,ax
16879 48D4           31DB                       xor	bx,bx
16880 48D6           8946         FC            mov	-4[bp],ax
16881 48D9           895E         FE            mov	-2[bp],bx
16882                                           !BCC_EOS
16883                                           ! 3107   Bit32u extra_lowbits_memory_size=0;
16884 48DC           83C4                   FC  add	sp,*-4
16885                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
16886 48DF           31C0                       xor	ax,ax
16887 48E1           31DB                       xor	bx,bx
16888 48E3           8946         F8            mov	-8[bp],ax
16889 48E6           895E         FA            mov	-6[bp],bx
16890                                           !BCC_EOS
16891                                           ! 3108   Bit16u CX,DX;
16892                                           !BCC_EOS
16893                                           ! 3109   Bit8u extra_highbits_memory_size=0;
16894 48E9           83C4                   FB  add	sp,*-5
16895                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
16896 48EC           30C0                       xor	al,al
16897 48EE           8846         F3            mov	-$D[bp],al
16898                                           !BCC_EOS
16899                                           ! 3110 ;
16900 48F1           4C                         dec	sp
16901                                           !BCC_EOS
16902                                           ! 3111   switch (regs.u.r8.ah) {
16903 48F2           8A46         21            mov	al,$21[bp]
16904 48F5           E9         0477            br 	.403
16905                                           ! 3112     case 0x86:
16906                                           ! 3113       CX = regs.u.r16.cx;
16907                       000048F8            .404:
16908                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
16909 48F8           8B46         1C            mov	ax,$1C[bp]
16910 48FB           8946         F6            mov	-$A[bp],ax
16911                                           !BCC_EOS
16912                                           ! 3114       DX = regs.u.r16.dx;
16913                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
16914 48FE           8B46         18            mov	ax,$18[bp]
16915 4901           8946         F4            mov	-$C[bp],ax
16916                                           !BCC_EOS
16917                                           ! 3115 #asm
16918                                           !BCC_EOS
16919                                           !BCC_ASM
16920                       00000004            _int15_function32.CX	set	4
16921                       FFFFFFF6            .int15_function32.CX	set	-$A
16922                       00000001            _int15_function32.extra_highbits_memory_size	set	1
16923                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
16924                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
16925                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
16926                       0000000A            _int15_function32.extended_memory_size	set	$A
16927                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
16928                       00000036            _int15_function32.FLAGS	set	$36
16929                       00000028            .int15_function32.FLAGS	set	$28
16930                       00000034            _int15_function32.DS	set	$34
16931                       00000026            .int15_function32.DS	set	$26
16932                       00000002            _int15_function32.DX	set	2
16933                       FFFFFFF4            .int15_function32.DX	set	-$C
16934                       00000032            _int15_function32.ES	set	$32
16935                       00000024            .int15_function32.ES	set	$24
16936                       00000012            _int15_function32.regs	set	$12
16937                       00000004            .int15_function32.regs	set	4
16938 4904           FB                               sti
16939                                                 ;; Get the count in eax
16940 4905           89E3                             mov bx, sp
16941 4907           36                               SEG SS
16942 4908           8B47         04                    mov ax, _int15_function32.CX [bx]
16943 490B     66    C1E0                   10        shl eax, #16
16944 490F           36                               SEG SS
16945 4910           8B47         02                    mov ax, _int15_function32.DX [bx]
16946                                                 ;; convert to numbers of 15usec ticks
16947 4913     66    BB               0000000F        mov ebx, #15
16948 4919     66    31D2                             xor edx, edx
16949 491C     66    F7F3                             div eax, ebx
16950 491F     66    89C1                             mov ecx, eax
16951                                                 ;; wait for ecx number of refresh requests
16952 4922           E4                     61        in al, 0x0061
16953 4924           24                     10        and al,#0x10
16954 4926           88C4                             mov ah, al
16955 4928     66    09C9                             or ecx, ecx
16956 492B           74           0E                  je int1586_tick_end
16957                       0000492D            int1586_tick:
16958 492D           E4                     61        in al, 0x0061
16959 492F           24                     10        and al,#0x10
16960 4931           38E0                             cmp al, ah
16961 4933           74           F8                  je int1586_tick
16962 4935           88C4                             mov ah, al
16963 4937     66    49                               dec ecx
16964 4939           75           F2                  jnz int1586_tick
16965                       0000493B            int1586_tick_end:
16966                                           ! 3144 endasm
16967                                           !BCC_ENDASM
16968                                           !BCC_EOS
16969                                           ! 3145       break;
16970 493B           E9         043F            br 	.401
16971                                           !BCC_EOS
16972                                           ! 3146     case 0xe8:
16973                                           ! 3147         switch(regs.u.r8.al) {
16974                       0000493E            .405:
16975 493E           8A46         20            mov	al,$20[bp]
16976 4941           E9         03F8            br 	.408
16977                                           ! 3148          case 0x20:
16978                                           ! 3149             if (regs.u.r32.edx == 0x534D4150) {
16979                       00004944            .409:
16980                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
16981                                           ! Debug: expression subtree swapping
16982 4944           B8                   4150  mov	ax,#$4150
16983 4947           BB                   534D  mov	bx,#$534D
16984 494A           53                         push	bx
16985 494B           50                         push	ax
16986 494C           8B46         18            mov	ax,$18[bp]
16987 494F           8B5E         1A            mov	bx,$1A[bp]
16988 4952           8D7E         EE            lea	di,-2+..FFF5[bp]
16989 4955           E8         B744            call	lcmpul
16990 4958           8D66         F2            lea	sp,2+..FFF5[bp]
16991 495B         0F85         037B            bne 	.40A
16992                       0000495F            .40B:
16993                                           ! 3150                 *((Bit8u *)&extended_memory_size) = inb_cmos(0x34);
16994                                           ! Debug: list int = const $34 (used reg = )
16995 495F           B8                   0034  mov	ax,*$34
16996 4962           50                         push	ax
16997                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16998 4963           E8         BC08            call	_inb_cmos
16999 4966           44                         inc	sp
17000 4967           44                         inc	sp
17001                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17002 4968           8846         FC            mov	-4[bp],al
17003                                           !BCC_EOS
17004                                           ! 3151                 *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x35);
17005                                           ! Debug: list int = const $35 (used reg = )
17006 496B           B8                   0035  mov	ax,*$35
17007 496E           50                         push	ax
17008                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17009 496F           E8         BBFC            call	_inb_cmos
17010 4972           44                         inc	sp
17011 4973           44                         inc	sp
17012                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17013 4974           8846         FD            mov	-3[bp],al
17014                                           !BCC_EOS
17015                                           ! 3152                 extended_memory_size *= 64;
17016                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17017 4977           B8                   0040  mov	ax,*$40
17018 497A           31DB                       xor	bx,bx
17019 497C           53                         push	bx
17020 497D           50                         push	ax
17021 497E           8B46         FC            mov	ax,-4[bp]
17022 4981           8B5E         FE            mov	bx,-2[bp]
17023 4984           8D7E         EE            lea	di,-2+..FFF5[bp]
17024 4987           E8         B730            call	lmulul
17025 498A           8946         FC            mov	-4[bp],ax
17026 498D           895E         FE            mov	-2[bp],bx
17027 4990           83C4                   04  add	sp,*4
17028                                           !BCC_EOS
17029                                           ! 3153                 if (extended_memory_size > 0x2fc000) {
17030                                           ! Debug: gt long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17031 4993           B8                   C000  mov	ax,#$C000
17032 4996           BB                   002F  mov	bx,*$2F
17033 4999           8D7E         FC            lea	di,-4[bp]
17034 499C           E8         B6FD            call	lcmpul
17035 499F         0F83         000C            bhis	.40C
17036                       000049A3            .40D:
17037                                           ! 3154                     extended_memory_size = 0x2fc000;
17038                                           ! Debug: eq long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17039 49A3           B8                   C000  mov	ax,#$C000
17040 49A6           BB                   002F  mov	bx,*$2F
17041 49A9           8946         FC            mov	-4[bp],ax
17042 49AC           895E         FE            mov	-2[bp],bx
17043                                           !BCC_EOS
17044                                           ! 3155                 }
17045                                           ! 3156                 extended_memory_size *= 1024;
17046                       000049AF            .40C:
17047                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17048 49AF           B8                   0400  mov	ax,#$400
17049 49B2           31DB                       xor	bx,bx
17050 49B4           53                         push	bx
17051 49B5           50                         push	ax
17052 49B6           8B46         FC            mov	ax,-4[bp]
17053 49B9           8B5E         FE            mov	bx,-2[bp]
17054 49BC           8D7E         EE            lea	di,-2+..FFF5[bp]
17055 49BF           E8         B6F8            call	lmulul
17056 49C2           8946         FC            mov	-4[bp],ax
17057 49C5           895E         FE            mov	-2[bp],bx
17058 49C8           83C4                   04  add	sp,*4
17059                                           !BCC_EOS
17060                                           ! 3157                 extended_memory_size += (16L * 1024 * 1024);
17061                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17062 49CB           31C0                       xor	ax,ax
17063 49CD           BB                   0100  mov	bx,#$100
17064 49D0           53                         push	bx
17065 49D1           50                         push	ax
17066 49D2           8B46         FC            mov	ax,-4[bp]
17067 49D5           8B5E         FE            mov	bx,-2[bp]
17068 49D8           8D7E         EE            lea	di,-2+..FFF5[bp]
17069 49DB           E8         B6B6            call	laddul
17070 49DE           8946         FC            mov	-4[bp],ax
17071 49E1           895E         FE            mov	-2[bp],bx
17072 49E4           83C4                   04  add	sp,*4
17073                                           !BCC_EOS
17074                                           ! 3158                 if (extended_memory_size <= (16L * 1024 * 1024)) {
17075                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17076 49E7           31C0                       xor	ax,ax
17077 49E9           BB                   0100  mov	bx,#$100
17078 49EC           8D7E         FC            lea	di,-4[bp]
17079 49EF           E8         B6AA            call	lcmpul
17080 49F2           72           50            jb  	.40E
17081                       000049F4            .40F:
17082                                           ! 3159                     *((Bit8u *)&extended_memory_size) = inb_cmos(0x30);
17083                                           ! Debug: list int = const $30 (used reg = )
17084 49F4           B8                   0030  mov	ax,*$30
17085 49F7           50                         push	ax
17086                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17087 49F8           E8         BB73            call	_inb_cmos
17088 49FB           44                         inc	sp
17089 49FC           44                         inc	sp
17090                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17091 49FD           8846         FC            mov	-4[bp],al
17092                                           !BCC_EOS
17093                                           ! 3160                     *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x31);
17094                                           ! Debug: list int = const $31 (used reg = )
17095 4A00           B8                   0031  mov	ax,*$31
17096 4A03           50                         push	ax
17097                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17098 4A04           E8         BB67            call	_inb_cmos
17099 4A07           44                         inc	sp
17100 4A08           44                         inc	sp
17101                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17102 4A09           8846         FD            mov	-3[bp],al
17103                                           !BCC_EOS
17104                                           ! 3161                     extended_memory_size *= 1024;
17105                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17106 4A0C           B8                   0400  mov	ax,#$400
17107 4A0F           31DB                       xor	bx,bx
17108 4A11           53                         push	bx
17109 4A12           50                         push	ax
17110 4A13           8B46         FC            mov	ax,-4[bp]
17111 4A16           8B5E         FE            mov	bx,-2[bp]
17112 4A19           8D7E         EE            lea	di,-2+..FFF5[bp]
17113 4A1C           E8         B69B            call	lmulul
17114 4A1F           8946         FC            mov	-4[bp],ax
17115 4A22           895E         FE            mov	-2[bp],bx
17116 4A25           83C4                   04  add	sp,*4
17117                                           !BCC_EOS
17118                                           ! 3162                     extended_memory_size += (1L * 1024 * 1024);
17119                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17120 4A28           31C0                       xor	ax,ax
17121 4A2A           BB                   0010  mov	bx,*$10
17122 4A2D           53                         push	bx
17123 4A2E           50                         push	ax
17124 4A2F           8B46         FC            mov	ax,-4[bp]
17125 4A32           8B5E         FE            mov	bx,-2[bp]
17126 4A35           8D7E         EE            lea	di,-2+..FFF5[bp]
17127 4A38           E8         B659            call	laddul
17128 4A3B           8946         FC            mov	-4[bp],ax
17129 4A3E           895E         FE            mov	-2[bp],bx
17130 4A41           83C4                   04  add	sp,*4
17131                                           !BCC_EOS
17132                                           ! 3163                 }
17133                                           ! 3164                 *((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1)) = inb_cmos(0x5b);
17134                       00004A44            .40E:
17135                                           ! Debug: list int = const $5B (used reg = )
17136 4A44           B8                   005B  mov	ax,*$5B
17137 4A47           50                         push	ax
17138                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17139 4A48           E8         BB23            call	_inb_cmos
17140 4A4B           44                         inc	sp
17141 4A4C           44                         inc	sp
17142                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-8] (used reg = )
17143 4A4D           8846         FA            mov	-6[bp],al
17144                                           !BCC_EOS
17145                                           ! 3165                 *(((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1))+1) = inb_cmos(0x5c);
17146                                           ! Debug: list int = const $5C (used reg = )
17147 4A50           B8                   005C  mov	ax,*$5C
17148 4A53           50                         push	ax
17149                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17150 4A54           E8         BB17            call	_inb_cmos
17151 4A57           44                         inc	sp
17152 4A58           44                         inc	sp
17153                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-7] (used reg = )
17154 4A59           8846         FB            mov	-5[bp],al
17155                                           !BCC_EOS
17156                                           ! 3166                 *((Bit16u *)&extra_lowbits_memory_size) = 0;
17157                                           ! Debug: eq int = const 0 to unsigned short extra_lowbits_memory_size = [S+$10-$A] (used reg = )
17158 4A5C           31C0                       xor	ax,ax
17159 4A5E           8946         F8            mov	-8[bp],ax
17160                                           !BCC_EOS
17161                                           ! 3167                 extra_highbits_memory_size = inb_cmos(0x5d);
17162                                           ! Debug: list int = const $5D (used reg = )
17163 4A61           B8                   005D  mov	ax,*$5D
17164 4A64           50                         push	ax
17165                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17166 4A65           E8         BB06            call	_inb_cmos
17167 4A68           44                         inc	sp
17168 4A69           44                         inc	sp
17169                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17170 4A6A           8846         F3            mov	-$D[bp],al
17171                                           !BCC_EOS
17172                                           ! 3168                 switch(regs.u.r16.bx)
17173 4A6D           8B46         14            mov	ax,$14[bp]
17174                                           ! 3169                 {
17175 4A70           E9         0221            br 	.412
17176                                           ! 3170                     case 0:
17177                                           ! 3171                         set_e820_range(ES, regs.u.r16.di,
17178                       00004A73            .413:
17179                                           ! 3172                                        0x0000000L, 0x0009f000L, 0, 0, 1);
17180                                           ! Debug: list int = const 1 (used reg = )
17181 4A73           B8                   0001  mov	ax,*1
17182 4A76           50                         push	ax
17183                                           ! Debug: list int = const 0 (used reg = )
17184 4A77           31C0                       xor	ax,ax
17185 4A79           50                         push	ax
17186                                           ! Debug: list int = const 0 (used reg = )
17187 4A7A           31C0                       xor	ax,ax
17188 4A7C           50                         push	ax
17189                                           ! Debug: list long = const $9F000 (used reg = )
17190 4A7D           B8                   F000  mov	ax,#$F000
17191 4A80           BB                   0009  mov	bx,*9
17192 4A83           53                         push	bx
17193 4A84           50                         push	ax
17194                                           ! Debug: list long = const 0 (used reg = )
17195 4A85           31C0                       xor	ax,ax
17196 4A87           31DB                       xor	bx,bx
17197 4A89           53                         push	bx
17198 4A8A           50                         push	ax
17199                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17200 4A8B           FF76         04            push	4[bp]
17201                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17202 4A8E           FF76         24            push	$24[bp]
17203                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17204 4A91           E8         FD9A            call	_set_e820_range
17205 4A94           83C4                   12  add	sp,*$12
17206                                           !BCC_EOS
17207                                           ! 3173                         regs.u.r32.ebx = 1;
17208                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
17209 4A97           B8                   0001  mov	ax,*1
17210 4A9A           31DB                       xor	bx,bx
17211 4A9C           8946         14            mov	$14[bp],ax
17212 4A9F           895E         16            mov	$16[bp],bx
17213                                           !BCC_EOS
17214                                           ! 3174                         break;
17215 4AA2           E9         0214            br 	.410
17216                                           !BCC_EOS
17217                                           ! 3175                     case 1:
17218                                           ! 3176                         set_e820_range(ES, regs.u.r16.di,
17219                       00004AA5            .414:
17220                                           ! 3177                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
17221                                           ! Debug: list int = const 2 (used reg = )
17222 4AA5           B8                   0002  mov	ax,*2
17223 4AA8           50                         push	ax
17224                                           ! Debug: list int = const 0 (used reg = )
17225 4AA9           31C0                       xor	ax,ax
17226 4AAB           50                         push	ax
17227                                           ! Debug: list int = const 0 (used reg = )
17228 4AAC           31C0                       xor	ax,ax
17229 4AAE           50                         push	ax
17230                                           ! Debug: list long = const $A0000 (used reg = )
17231 4AAF           31C0                       xor	ax,ax
17232 4AB1           BB                   000A  mov	bx,*$A
17233 4AB4           53                         push	bx
17234 4AB5           50                         push	ax
17235                                           ! Debug: list long = const $9F000 (used reg = )
17236 4AB6           B8                   F000  mov	ax,#$F000
17237 4AB9           BB                   0009  mov	bx,*9
17238 4ABC           53                         push	bx
17239 4ABD           50                         push	ax
17240                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17241 4ABE           FF76         04            push	4[bp]
17242                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17243 4AC1           FF76         24            push	$24[bp]
17244                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17245 4AC4           E8         FD67            call	_set_e820_range
17246 4AC7           83C4                   12  add	sp,*$12
17247                                           !BCC_EOS
17248                                           ! 3178                         regs.u.r32.ebx = 2;
17249                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
17250 4ACA           B8                   0002  mov	ax,*2
17251 4ACD           31DB                       xor	bx,bx
17252 4ACF           8946         14            mov	$14[bp],ax
17253 4AD2           895E         16            mov	$16[bp],bx
17254                                           !BCC_EOS
17255                                           ! 3179                         break;
17256 4AD5           E9         01E1            br 	.410
17257                                           !BCC_EOS
17258                                           ! 3180                     case 2:
17259                                           ! 3181                         set_e820_range(ES, regs.u.r16.di,
17260                       00004AD8            .415:
17261                                           ! 3182                                        0x000e8000L, 0x00100000L, 0, 0, 2);
17262                                           ! Debug: list int = const 2 (used reg = )
17263 4AD8           B8                   0002  mov	ax,*2
17264 4ADB           50                         push	ax
17265                                           ! Debug: list int = const 0 (used reg = )
17266 4ADC           31C0                       xor	ax,ax
17267 4ADE           50                         push	ax
17268                                           ! Debug: list int = const 0 (used reg = )
17269 4ADF           31C0                       xor	ax,ax
17270 4AE1           50                         push	ax
17271                                           ! Debug: list long = const $100000 (used reg = )
17272 4AE2           31C0                       xor	ax,ax
17273 4AE4           BB                   0010  mov	bx,*$10
17274 4AE7           53                         push	bx
17275 4AE8           50                         push	ax
17276                                           ! Debug: list long = const $E8000 (used reg = )
17277 4AE9           B8                   8000  mov	ax,#$8000
17278 4AEC           BB                   000E  mov	bx,*$E
17279 4AEF           53                         push	bx
17280 4AF0           50                         push	ax
17281                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17282 4AF1           FF76         04            push	4[bp]
17283                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17284 4AF4           FF76         24            push	$24[bp]
17285                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17286 4AF7           E8         FD34            call	_set_e820_range
17287 4AFA           83C4                   12  add	sp,*$12
17288                                           !BCC_EOS
17289                                           ! 3183                         if (extended_memory_size <= 0x100000)
17290                                           ! Debug: le long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17291 4AFD           31C0                       xor	ax,ax
17292 4AFF           BB                   0010  mov	bx,*$10
17293 4B02           8D7E         FC            lea	di,-4[bp]
17294 4B05           E8         B594            call	lcmpul
17295 4B08           72           0D            jb  	.416
17296                       00004B0A            .417:
17297                                           ! 3184                  
17298                                           ! 3184            regs.u.r32.ebx = 6;
17299                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17300 4B0A           B8                   0006  mov	ax,*6
17301 4B0D           31DB                       xor	bx,bx
17302 4B0F           8946         14            mov	$14[bp],ax
17303 4B12           895E         16            mov	$16[bp],bx
17304                                           !BCC_EOS
17305                                           ! 3185                         else
17306                                           ! 3186                             regs.u.r32.ebx = 3;
17307 4B15           EB           0B            jmp .418
17308                       00004B17            .416:
17309                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
17310 4B17           B8                   0003  mov	ax,*3
17311 4B1A           31DB                       xor	bx,bx
17312 4B1C           8946         14            mov	$14[bp],ax
17313 4B1F           895E         16            mov	$16[bp],bx
17314                                           !BCC_EOS
17315                                           ! 3187                         break;
17316                       00004B22            .418:
17317 4B22           E9         0194            br 	.410
17318                                           !BCC_EOS
17319                                           ! 3188                     case 3:
17320                                           ! 3189                         set_e820_range(ES, regs.u.r16.di,
17321                       00004B25            .419:
17322                                           ! 3190                                        0x00100000L,
17323                                           ! 3191                                        extended_memory_size, 0, 0, 1);
17324                                           ! Debug: list int = const 1 (used reg = )
17325 4B25           B8                   0001  mov	ax,*1
17326 4B28           50                         push	ax
17327                                           ! Debug: list int = const 0 (used reg = )
17328 4B29           31C0                       xor	ax,ax
17329 4B2B           50                         push	ax
17330                                           ! Debug: list int = const 0 (used reg = )
17331 4B2C           31C0                       xor	ax,ax
17332 4B2E           50                         push	ax
17333                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17334 4B2F           FF76         FE            push	-2[bp]
17335 4B32           FF76         FC            push	-4[bp]
17336                                           ! Debug: list long = const $100000 (used reg = )
17337 4B35           31C0                       xor	ax,ax
17338 4B37           BB                   0010  mov	bx,*$10
17339 4B3A           53                         push	bx
17340 4B3B           50                         push	ax
17341                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17342 4B3C           FF76         04            push	4[bp]
17343                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17344 4B3F           FF76         24            push	$24[bp]
17345                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17346 4B42           E8         FCE9            call	_set_e820_range
17347 4B45           83C4                   12  add	sp,*$12
17348                                           !BCC_EOS
17349                                           ! 3192                         regs.u.r32.ebx = 6;
17350                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17351 4B48           B8                   0006  mov	ax,*6
17352 4B4B           31DB                       xor	bx,bx
17353 4B4D           8946         14            mov	$14[bp],ax
17354 4B50           895E         16            mov	$16[bp],bx
17355                                           !BCC_EOS
17356                                           ! 3193                         break;
17357 4B53           E9         0163            br 	.410
17358                                           !BCC_EOS
17359                                           ! 3194                     case 4:
17360                                           ! 3195                         set_e820_range(ES, regs.u.r16.di,
17361                       00004B56            .41A:
17362                                           ! 3196                                        extended_memory_size - 0x00010000L - 0x00002000,
17363                                           ! 3197                                        extended_memory_size - 0x00010000L, 0, 0, 2);
17364                                           ! Debug: list int = const 2 (used reg = )
17365 4B56           B8                   0002  mov	ax,*2
17366 4B59           50                         push	ax
17367                                           ! Debug: list int = const 0 (used reg = )
17368 4B5A           31C0                       xor	ax,ax
17369 4B5C           50                         push	ax
17370                                           ! Debug: list int = const 0 (used reg = )
17371 4B5D           31C0                       xor	ax,ax
17372 4B5F           50                         push	ax
17373                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17374 4B60           31C0                       xor	ax,ax
17375 4B62           BB                   0001  mov	bx,*1
17376 4B65           53                         push	bx
17377 4B66           50                         push	ax
17378 4B67           8B46         FC            mov	ax,-4[bp]
17379 4B6A           8B5E         FE            mov	bx,-2[bp]
17380 4B6D           8D7E         E8            lea	di,-8+..FFF5[bp]
17381 4B70           E8         B53F            call	lsubul
17382 4B73           83C4                   04  add	sp,*4
17383                                           ! Debug: list unsigned long = bx+0 (used reg = )
17384 4B76           53                         push	bx
17385 4B77           50                         push	ax
17386                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17387 4B78           31C0                       xor	ax,ax
17388 4B7A           BB                   0001  mov	bx,*1
17389 4B7D           53                         push	bx
17390 4B7E           50                         push	ax
17391 4B7F           8B46         FC            mov	ax,-4[bp]
17392 4B82           8B5E         FE            mov	bx,-2[bp]
17393 4B85           8D7E         E4            lea	di,-$C+..FFF5[bp]
17394 4B88           E8         B527            call	lsubul
17395 4B8B           83C4                   04  add	sp,*4
17396                                           ! Debug: sub unsigned long = const $2000 to unsigned long = bx+0 (used reg = )
17397 4B8E           53                         push	bx
17398 4B8F           50                         push	ax
17399 4B90           B8                   2000  mov	ax,#$2000
17400 4B93           31DB                       xor	bx,bx
17401 4B95           53                         push	bx
17402 4B96           50                         push	ax
17403 4B97           8B46         E4            mov	ax,-$C+..FFF5[bp]
17404 4B9A           8B5E         E6            mov	bx,-$A+..FFF5[bp]
17405 4B9D           8D7E         E0            lea	di,-$10+..FFF5[bp]
17406 4BA0           E8         B50F            call	lsubul
17407 4BA3           83C4                   08  add	sp,*8
17408                                           ! Debug: list unsigned long = bx+0 (used reg = )
17409 4BA6           53                         push	bx
17410 4BA7           50                         push	ax
17411                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17412 4BA8           FF76         04            push	4[bp]
17413                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17414 4BAB           FF76         24            push	$24[bp]
17415                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17416 4BAE           E8         FC7D            call	_set_e820_range
17417 4BB1           83C4                   12  add	sp,*$12
17418                                           !BCC_EOS
17419                                           ! 3198                         regs.u.r32.ebx = 5;
17420                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17421 4BB4           B8                   0005  mov	ax,*5
17422 4BB7           31DB                       xor	bx,bx
17423 4BB9           8946         14            mov	$14[bp],ax
17424 4BBC           895E         16            mov	$16[bp],bx
17425                                           !BCC_EOS
17426                                           ! 3199                         break;
17427 4BBF           E9         00F7            br 	.410
17428                                           !BCC_EOS
17429                                           ! 3200                     case 5:
17430                                           ! 3201                         set_e820_range(ES, regs.u.r16.di,
17431                       00004BC2            .41B:
17432                                           ! 3202                                        extended_memory_size - 0x00010000L,
17433                                           ! 3203                                        extended_memory_size, 0, 0, 3);
17434                                           ! Debug: list int = const 3 (used reg = )
17435 4BC2           B8                   0003  mov	ax,*3
17436 4BC5           50                         push	ax
17437                                           ! Debug: list int = const 0 (used reg = )
17438 4BC6           31C0                       xor	ax,ax
17439 4BC8           50                         push	ax
17440                                           ! Debug: list int = const 0 (used reg = )
17441 4BC9           31C0                       xor	ax,ax
17442 4BCB           50                         push	ax
17443                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17444 4BCC           FF76         FE            push	-2[bp]
17445 4BCF           FF76         FC            push	-4[bp]
17446                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17447 4BD2           31C0                       xor	ax,ax
17448 4BD4           BB                   0001  mov	bx,*1
17449 4BD7           53                         push	bx
17450 4BD8           50                         push	ax
17451 4BD9           8B46         FC            mov	ax,-4[bp]
17452 4BDC           8B5E         FE            mov	bx,-2[bp]
17453 4BDF           8D7E         E4            lea	di,-$C+..FFF5[bp]
17454 4BE2           E8         B4CD            call	lsubul
17455 4BE5           83C4                   04  add	sp,*4
17456                                           ! Debug: list unsigned long = bx+0 (used reg = )
17457 4BE8           53                         push	bx
17458 4BE9           50                         push	ax
17459                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17460 4BEA           FF76         04            push	4[bp]
17461                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17462 4BED           FF76         24            push	$24[bp]
17463                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17464 4BF0           E8         FC3B            call	_set_e820_range
17465 4BF3           83C4                   12  add	sp,*$12
17466                                           !BCC_EOS
17467                                           ! 3204                         regs.u.r32.ebx = 6;
17468                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17469 4BF6           B8                   0006  mov	ax,*6
17470 4BF9           31DB                       xor	bx,bx
17471 4BFB           8946         14            mov	$14[bp],ax
17472 4BFE           895E         16            mov	$16[bp],bx
17473                                           !BCC_EOS
17474                                           ! 3205                         break;
17475 4C01           E9         00B5            br 	.410
17476                                           !BCC_EOS
17477                                           ! 3206                     case 6:
17478                                           ! 3207                         set_e820_range(ES, regs.u.r16.di,
17479                       00004C04            .41C:
17480                                           ! 3208                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
17481                                           ! Debug: list int = const 2 (used reg = )
17482 4C04           B8                   0002  mov	ax,*2
17483 4C07           50                         push	ax
17484                                           ! Debug: list int = const 0 (used reg = )
17485 4C08           31C0                       xor	ax,ax
17486 4C0A           50                         push	ax
17487                                           ! Debug: list int = const 0 (used reg = )
17488 4C0B           31C0                       xor	ax,ax
17489 4C0D           50                         push	ax
17490                                           ! Debug: list long = const 0 (used reg = )
17491 4C0E           31C0                       xor	ax,ax
17492 4C10           31DB                       xor	bx,bx
17493 4C12           53                         push	bx
17494 4C13           50                         push	ax
17495                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
17496 4C14           31C0                       xor	ax,ax
17497 4C16           BB                   FFFC  mov	bx,#$FFFC
17498 4C19           53                         push	bx
17499 4C1A           50                         push	ax
17500                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17501 4C1B           FF76         04            push	4[bp]
17502                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17503 4C1E           FF76         24            push	$24[bp]
17504                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17505 4C21           E8         FC0A            call	_set_e820_range
17506 4C24           83C4                   12  add	sp,*$12
17507                                           !BCC_EOS
17508                                           ! 3209                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
17509                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17510 4C27           8A46         F3            mov	al,-$D[bp]
17511 4C2A           30E4                       xor	ah,ah
17512 4C2C           31DB                       xor	bx,bx
17513 4C2E           E8         B4B4            call	ltstl
17514 4C31           75           0B            jne 	.41E
17515                       00004C33            .41F:
17516 4C33           8B46         F8            mov	ax,-8[bp]
17517 4C36           8B5E         FA            mov	bx,-6[bp]
17518 4C39           E8         B4A9            call	ltstl
17519 4C3C           74           0D            je  	.41D
17520                       00004C3E            .41E:
17521                                           ! 3210                             regs.u.r32.ebx = 7;
17522                                           ! Debug: eq int = const 7 to unsigned long regs = [S+$10+$12] (used reg = )
17523 4C3E           B8                   0007  mov	ax,*7
17524 4C41           31DB                       xor	bx,bx
17525 4C43           8946         14            mov	$14[bp],ax
17526 4C46           895E         16            mov	$16[bp],bx
17527                                           !BCC_EOS
17528                                           ! 3211                         else
17529                                           ! 3212                             regs.u.r32.ebx = 0;
17530 4C49           EB           0A            jmp .420
17531                       00004C4B            .41D:
17532                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17533 4C4B           31C0                       xor	ax,ax
17534 4C4D           31DB                       xor	bx,bx
17535 4C4F           8946         14            mov	$14[bp],ax
17536 4C52           895E         16            mov	$16[bp],bx
17537                                           !BCC_EOS
17538                                           ! 3213                         break;
17539                       00004C55            .420:
17540 4C55           EB           62            jmp .410
17541                                           !BCC_EOS
17542                                           ! 3214                     case 7:
17543                                           ! 3215                         set_e820_range(ES, regs.u.r16.di, 0x00000000L,
17544                       00004C57            .421:
17545                                           ! 3216                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
17546                                           ! 3217                                        + 1, 1);
17547                                           ! Debug: list int = const 1 (used reg = )
17548 4C57           B8                   0001  mov	ax,*1
17549 4C5A           50                         push	ax
17550                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
17551 4C5B           8A46         F3            mov	al,-$D[bp]
17552 4C5E           30E4                       xor	ah,ah
17553                                           ! Debug: list unsigned int = ax+1 (used reg = )
17554 4C60           40                         inc	ax
17555 4C61           50                         push	ax
17556                                           ! Debug: list int = const 1 (used reg = )
17557 4C62           B8                   0001  mov	ax,*1
17558 4C65           50                         push	ax
17559                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
17560 4C66           FF76         FA            push	-6[bp]
17561 4C69           FF76         F8            push	-8[bp]
17562                                           ! Debug: list long = const 0 (used reg = )
17563 4C6C           31C0                       xor	ax,ax
17564 4C6E           31DB                       xor	bx,bx
17565 4C70           53                         push	bx
17566 4C71           50                         push	ax
17567                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17568 4C72           FF76         04            push	4[bp]
17569                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17570 4C75           FF76         24            push	$24[bp]
17571                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17572 4C78           E8         FBB3            call	_set_e820_range
17573 4C7B           83C4                   12  add	sp,*$12
17574                                           !BCC_EOS
17575                                           ! 3218                         regs.u.r32.ebx = 0;
17576                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17577 4C7E           31C0                       xor	ax,ax
17578 4C80           31DB                       xor	bx,bx
17579 4C82           8946         14            mov	$14[bp],ax
17580 4C85           895E         16            mov	$16[bp],bx
17581                                           !BCC_EOS
17582                                           ! 3219                         break;
17583 4C88           EB           2F            jmp .410
17584                                           !BCC_EOS
17585                                           ! 3220                     default:
17586                                           ! 3221                         goto int15_unimplemented;
17587                       00004C8A            .422:
17588 4C8A           83C4                   00  add	sp,#..FFF4-..FFF5
17589 4C8D           E9         00BA            br 	.FFF4
17590                                           !BCC_EOS
17591                                           ! 3222                         break;
17592 4C90           EB           27            jmp .410
17593                                           !BCC_EOS
17594                                           ! 3223                 }
17595                                           ! 3224                 regs.u.r32.eax = 0x534D4150;
17596 4C92           EB           25            jmp .410
17597                       00004C94            .412:
17598 4C94           2D                   0000  sub	ax,*0
17599 4C97           7C           F1            jl 	.422
17600 4C99           3D                   0007  cmp	ax,*7
17601 4C9C           77           19            ja  	.423
17602 4C9E           D1E0                       shl	ax,*1
17603 4CA0           89C3                       mov	bx,ax
17604 4CA2           2E                         seg	cs
17605 4CA3           FFA7       4CA7            br	.424[bx]
17606                       00004CA7            .424:
17607 4CA7                      4A73            .word	.413
17608 4CA9                      4AA5            .word	.414
17609 4CAB                      4AD8            .word	.415
17610 4CAD                      4B25            .word	.419
17611 4CAF                      4B56            .word	.41A
17612 4CB1                      4BC2            .word	.41B
17613 4CB3                      4C04            .word	.41C
17614 4CB5                      4C57            .word	.421
17615                       00004CB7            .423:
17616 4CB7           EB           D1            jmp	.422
17617                       00004CB9            .410:
17618                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
17619 4CB9           B8                   4150  mov	ax,#$4150
17620 4CBC           BB                   534D  mov	bx,#$534D
17621 4CBF           8946         20            mov	$20[bp],ax
17622 4CC2           895E         22            mov	$22[bp],bx
17623                                           !BCC_EOS
17624                                           ! 3225                 regs.u.r32.ecx = 0x14;
17625                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
17626 4CC5           B8                   0014  mov	ax,*$14
17627 4CC8           31DB                       xor	bx,bx
17628 4CCA           8946         1C            mov	$1C[bp],ax
17629 4CCD           895E         1E            mov	$1E[bp],bx
17630                                           !BCC_EOS
17631                                           ! 3226                 FLAGS &= 0xfffe;
17632                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17633 4CD0           8B46         28            mov	ax,$28[bp]
17634 4CD3           24                     FE  and	al,#$FE
17635 4CD5           8946         28            mov	$28[bp],ax
17636                                           !BCC_EOS
17637                                           ! 3227             } else {
17638 4CD8           EB           05            jmp .425
17639                       00004CDA            .40A:
17640                                           ! 3228          
17641                                           ! 3228      goto int15_unimplemented;
17642 4CDA           83C4                   00  add	sp,#..FFF4-..FFF5
17643 4CDD           EB           6B            jmp .FFF4
17644                                           !BCC_EOS
17645                                           ! 3229             }
17646                                           ! 3230             break;
17647                       00004CDF            .425:
17648 4CDF           EB           67            jmp .406
17649                                           !BCC_EOS
17650                                           ! 3231         case 0x01:
17651                                           ! 3232           FLAGS &= 0xfffe;
17652                       00004CE1            .426:
17653                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17654 4CE1           8B46         28            mov	ax,$28[bp]
17655 4CE4           24                     FE  and	al,#$FE
17656 4CE6           8946         28            mov	$28[bp],ax
17657                                           !BCC_EOS
17658                                           ! 3233           regs.u.r8.cl = inb_cmos(0x30);
17659                                           ! Debug: list int = const $30 (used reg = )
17660 4CE9           B8                   0030  mov	ax,*$30
17661 4CEC           50                         push	ax
17662                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17663 4CED           E8         B87E            call	_inb_cmos
17664 4CF0           44                         inc	sp
17665 4CF1           44                         inc	sp
17666                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
17667 4CF2           8846         1C            mov	$1C[bp],al
17668                                           !BCC_EOS
17669                                           ! 3234           regs.u.r8.ch = inb_cmos(0x31);
17670                                           ! Debug: list int = const $31 (used reg = )
17671 4CF5           B8                   0031  mov	ax,*$31
17672 4CF8           50                         push	ax
17673                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17674 4CF9           E8         B872            call	_inb_cmos
17675 4CFC           44                         inc	sp
17676 4CFD           44                         inc	sp
17677                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
17678 4CFE           8846         1D            mov	$1D[bp],al
17679                                           !BCC_EOS
17680                                           ! 3235           if(regs.u.r16.cx > 0x3c00)
17681                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17682 4D01           8B46         1C            mov	ax,$1C[bp]
17683 4D04           3D                   3C00  cmp	ax,#$3C00
17684 4D07           76           06            jbe 	.427
17685                       00004D09            .428:
17686                                           ! 3236           {
17687                                           ! 3237             regs.u.r16.cx = 0x3c00;
17688                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17689 4D09           B8                   3C00  mov	ax,#$3C00
17690 4D0C           8946         1C            mov	$1C[bp],ax
17691                                           !BCC_EOS
17692                                           ! 3238           }
17693                                           ! 3239           regs.u.r8.dl = inb_cmos(0x34);
17694                       00004D0F            .427:
17695                                           ! Debug: list int = const $34 (used reg = )
17696 4D0F           B8                   0034  mov	ax,*$34
17697 4D12           50                         push	ax
17698                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17699 4D13           E8         B858            call	_inb_cmos
17700 4D16           44                         inc	sp
17701 4D17           44                         inc	sp
17702                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
17703 4D18           8846         18            mov	$18[bp],al
17704                                           !BCC_EOS
17705                                           ! 3240           regs.u.r8.dh = inb_cmos(0x35);
17706                                           ! Debug: list int = const $35 (used reg = )
17707 4D1B           B8                   0035  mov	ax,*$35
17708 4D1E           50                         push	ax
17709                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17710 4D1F           E8         B84C            call	_inb_cmos
17711 4D22           44                         inc	sp
17712 4D23           44                         inc	sp
17713                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
17714 4D24           8846         19            mov	$19[bp],al
17715                                           !BCC_EOS
17716                                           ! 3241           regs.u.r16.ax = regs.u.r16.cx;
17717                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
17718 4D27           8B46         1C            mov	ax,$1C[bp]
17719 4D2A           8946         20            mov	$20[bp],ax
17720                                           !BCC_EOS
17721                                           ! 3242           regs.u.r16.bx = regs.u.r16.dx;
17722                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
17723 4D2D           8B46         18            mov	ax,$18[bp]
17724 4D30           8946         14            mov	$14[bp],ax
17725                                           !BCC_EOS
17726                                           ! 3243           break;
17727 4D33           EB           13            jmp .406
17728                                           !BCC_EOS
17729                                           ! 3244         default:
17730                                           ! 3245           goto int15_unimplemented;
17731                       00004D35            .429:
17732 4D35           83C4                   00  add	sp,#..FFF4-..FFF5
17733 4D38           EB           10            jmp .FFF4
17734                                           !BCC_EOS
17735                                           ! 3246        }
17736                                           ! 3247        break;
17737 4D3A           EB           0C            jmp .406
17738                       00004D3C            .408:
17739 4D3C           2C                     01  sub	al,*1
17740 4D3E           74           A1            je 	.426
17741 4D40           2C                     1F  sub	al,*$1F
17742 4D42         0F84         FBFE            beq 	.409
17743 4D46           EB           ED            jmp	.429
17744                       00004D48            .406:
17745 4D48           EB           33            jmp .401
17746                                           !BCC_EOS
17747                                           ! 3248     int15_unimplemented:
17748                       00004D4A            .FFF4:
17749                                           ! 3249     default:
17750                                           ! 3250       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17751                       00004D4A            .42A:
17752                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
17753 4D4A           FF76         14            push	$14[bp]
17754                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
17755 4D4D           FF76         20            push	$20[bp]
17756                                           ! Debug: list * char = .42B+0 (used reg = )
17757 4D50           BB                   D3B9  mov	bx,#.42B
17758 4D53           53                         push	bx
17759                                           ! Debug: list int = const 4 (used reg = )
17760 4D54           B8                   0004  mov	ax,*4
17761 4D57           50                         push	ax
17762                                           ! Debug: func () void = bios_printf+0 (used reg = )
17763 4D58           E8         BBDE            call	_bios_printf
17764 4D5B           83C4                   08  add	sp,*8
17765                                           !BCC_EOS
17766                                           ! 3251       FLAGS |= 0x0001;
17767                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
17768 4D5E           8B46         28            mov	ax,$28[bp]
17769 4D61           0C                     01  or	al,*1
17770 4D63           8946         28            mov	$28[bp],ax
17771                                           !BCC_EOS
17772                                           ! 3252       regs.u.r8.ah = 0x86;
17773                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
17774 4D66           B0                     86  mov	al,#$86
17775 4D68           8846         21            mov	$21[bp],al
17776                                           !BCC_EOS
17777                                           ! 3253       break;
17778 4D6B           EB           10            jmp .401
17779                                           !BCC_EOS
17780                                           ! 3254     }
17781                                           ! 3255 }
17782 4D6D           EB           0E            jmp .401
17783                       00004D6F            .403:
17784 4D6F           2C                     86  sub	al,#$86
17785 4D71         0F84         FB83            beq 	.404
17786 4D75           2C                     62  sub	al,*$62
17787 4D77         0F84         FBC3            beq 	.405
17788 4D7B           EB           CD            jmp	.42A
17789                       00004D7D            .401:
17790                       FFFFFFF0            ..FFF5	=	-$10
17791                       FFFFFFF0            ..FFF4	=	-$10
17792 4D7D           89EC                       mov	sp,bp
17793 4D7F           5D                         pop	bp
17794 4D80           C3                         ret
17795                                           ! 3256   void
17796                                           ! Register BX used in function int15_function32
17797                                           ! 3257 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
17798                                           ! 3258   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
17799                                           export	_int16_function
17800                       00004D81            _int16_function:
17801                                           !BCC_EOS
17802                                           ! 3259 {
17803                                           ! 3260   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
17804                                           !BCC_EOS
17805                                           ! 3261   Bit16u kbd_code, max;
17806                                           !BCC_EOS
17807                                           ! 3262   ;
17808 4D81           55                         push	bp
17809 4D82           89E5                       mov	bp,sp
17810 4D84           83C4                   F6  add	sp,*-$A
17811                                           !BCC_EOS
17812                                           ! 3263   shift_flags = *((Bit8u *)(0x17));
17813                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
17814 4D87           A0         0017            mov	al,[$17]
17815 4D8A           8846         FD            mov	-3[bp],al
17816                                           !BCC_EOS
17817                                           ! 3264   led_flags = *((Bit8u *)(0x97));
17818                                           ! Debug: eq unsigned char = [+$97] to unsigned char led_flags = [S+$C-6] (used reg = )
17819 4D8D           A0         0097            mov	al,[$97]
17820 4D90           8846         FC            mov	-4[bp],al
17821                                           !BCC_EOS
17822                                           ! 3265   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
17823                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17824 4D93           8A46         FC            mov	al,-4[bp]
17825 4D96           24                     07  and	al,*7
17826 4D98           50                         push	ax
17827                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
17828 4D99           8A46         FD            mov	al,-3[bp]
17829 4D9C           30E4                       xor	ah,ah
17830 4D9E           B1                     04  mov	cl,*4
17831 4DA0           D3E8                       shr	ax,cl
17832                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17833 4DA2           24                     07  and	al,*7
17834                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
17835 4DA4           3246         F4            xor	al,-$C[bp]
17836 4DA7           44                         inc	sp
17837 4DA8           44                         inc	sp
17838                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
17839 4DA9           84C0                       test	al,al
17840 4DAB         0F84         0095            beq 	.42C
17841                       00004DAF            .42D:
17842                                           ! 3266 #asm
17843                                           !BCC_EOS
17844                                           !BCC_ASM
17845                       00000012            _int16_function.BP	set	$12
17846                       00000008            .int16_function.BP	set	8
17847                       00000005            _int16_function.count	set	5
17848                       FFFFFFFB            .int16_function.count	set	-5
17849                       0000001A            _int16_function.CX	set	$1A
17850                       00000010            .int16_function.CX	set	$10
17851                       00000008            _int16_function.ascii_code	set	8
17852                       FFFFFFFE            .int16_function.ascii_code	set	-2
17853                       0000000E            _int16_function.DI	set	$E
17854                       00000004            .int16_function.DI	set	4
17855                       0000001E            _int16_function.FLAGS	set	$1E
17856                       00000014            .int16_function.FLAGS	set	$14
17857                       00000002            _int16_function.kbd_code	set	2
17858                       FFFFFFF8            .int16_function.kbd_code	set	-8
17859                       00000009            _int16_function.scan_code	set	9
17860                       FFFFFFFF            .int16_function.scan_code	set	-1
17861                       00000018            _int16_function.DX	set	$18
17862                       0000000E            .int16_function.DX	set	$E
17863                       00000006            _int16_function.led_flags	set	6
17864                       FFFFFFFC            .int16_function.led_flags	set	-4
17865                       00000010            _int16_function.SI	set	$10
17866                       00000006            .int16_function.SI	set	6
17867                       0000001C            _int16_function.AX	set	$1C
17868                       00000012            .int16_function.AX	set	$12
17869                       00000014            _int16_function.SP	set	$14
17870                       0000000A            .int16_function.SP	set	$A
17871                       00000016            _int16_function.BX	set	$16
17872                       0000000C            .int16_function.BX	set	$C
17873                       00000007            _int16_function.shift_flags	set	7
17874                       FFFFFFFD            .int16_function.shift_flags	set	-3
17875                       00000000            _int16_function.max	set	0
17876                       FFFFFFF6            .int16_function.max	set	-$A
17877 4DAF           FA                             cli
17878                                           ! 3268 endasm
17879                                           !BCC_ENDASM
17880                                           !BCC_EOS
17881                                           ! 3269     outb(0x0060, 0xed);
17882                                           ! Debug: list int = const $ED (used reg = )
17883 4DB0           B8                   00ED  mov	ax,#$ED
17884 4DB3           50                         push	ax
17885                                           ! Debug: list int = const $60 (used reg = )
17886 4DB4           B8                   0060  mov	ax,*$60
17887 4DB7           50                         push	ax
17888                                           ! Debug: func () void = outb+0 (used reg = )
17889 4DB8           E8         B784            call	_outb
17890 4DBB           83C4                   04  add	sp,*4
17891                                           !BCC_EOS
17892                                           ! 3270     while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17893 4DBE           EB           0E            jmp .42F
17894                       00004DC0            .430:
17895                                           ! Debug: list int = const $21 (used reg = )
17896 4DC0           B8                   0021  mov	ax,*$21
17897 4DC3           50                         push	ax
17898                                           ! Debug: list int = const $80 (used reg = )
17899 4DC4           B8                   0080  mov	ax,#$80
17900 4DC7           50                         push	ax
17901                                           ! Debug: func () void = outb+0 (used reg = )
17902 4DC8           E8         B774            call	_outb
17903 4DCB           83C4                   04  add	sp,*4
17904                                           !BCC_EOS
17905                                           ! 3271     if ((inb(0x0060) == 0xfa)) {
17906                       00004DCE            .42F:
17907                                           ! Debug: list int = const $64 (used reg = )
17908 4DCE           B8                   0064  mov	ax,*$64
17909 4DD1           50                         push	ax
17910                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17911 4DD2           E8         B754            call	_inb
17912 4DD5           44                         inc	sp
17913 4DD6           44                         inc	sp
17914                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17915 4DD7           24                     01  and	al,*1
17916                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17917 4DD9           84C0                       test	al,al
17918 4DDB           74           E3            je 	.430
17919                       00004DDD            .431:
17920                       00004DDD            .42E:
17921                                           ! Debug: list int = const $60 (used reg = )
17922 4DDD           B8                   0060  mov	ax,*$60
17923 4DE0           50                         push	ax
17924                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17925 4DE1           E8         B745            call	_inb
17926 4DE4           44                         inc	sp
17927 4DE5           44                         inc	sp
17928                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
17929 4DE6           3C                     FA  cmp	al,#$FA
17930 4DE8           75           59            jne 	.432
17931                       00004DEA            .433:
17932                                           ! 3272       led_flags &= 0xf8;
17933                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
17934 4DEA           8A46         FC            mov	al,-4[bp]
17935 4DED           24                     F8  and	al,#$F8
17936 4DEF           8846         FC            mov	-4[bp],al
17937                                           !BCC_EOS
17938                                           ! 3273       led_flags |= ((shift_flags >> 4) & 0x07);
17939                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
17940 4DF2           8A46         FD            mov	al,-3[bp]
17941 4DF5           30E4                       xor	ah,ah
17942 4DF7           B1                     04  mov	cl,*4
17943 4DF9           D3E8                       shr	ax,cl
17944                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17945 4DFB           24                     07  and	al,*7
17946                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
17947 4DFD           0A46         FC            or	al,-4[bp]
17948 4E00           8846         FC            mov	-4[bp],al
17949                                           !BCC_EOS
17950                                           ! 3274       outb(0x0060, led_flags & 0x07);
17951                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17952 4E03           8A46         FC            mov	al,-4[bp]
17953 4E06           24                     07  and	al,*7
17954                                           ! Debug: list unsigned char = al+0 (used reg = )
17955 4E08           30E4                       xor	ah,ah
17956 4E0A           50                         push	ax
17957                                           ! Debug: list int = const $60 (used reg = )
17958 4E0B           B8                   0060  mov	ax,*$60
17959 4E0E           50                         push	ax
17960                                           ! Debug: func () void = outb+0 (used reg = )
17961 4E0F           E8         B72D            call	_outb
17962 4E12           83C4                   04  add	sp,*4
17963                                           !BCC_EOS
17964                                           ! 3275       while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17965 4E15           EB           0E            jmp .435
17966                       00004E17            .436:
17967                                           ! Debug: list int = const $21 (used reg = )
17968 4E17           B8                   0021  mov	ax,*$21
17969 4E1A           50                         push	ax
17970                                           ! Debug: list int = const $80 (used reg = )
17971 4E1B           B8                   0080  mov	ax,#$80
17972 4E1E           50                         push	ax
17973                                           ! Debug: func () void = outb+0 (used reg = )
17974 4E1F           E8         B71D            call	_outb
17975 4E22           83C4                   04  add	sp,*4
17976                                           !BCC_EOS
17977                                           ! 3276       inb(0x0060);
17978                       00004E25            .435:
17979                                           ! Debug: list int = const $64 (used reg = )
17980 4E25           B8                   0064  mov	ax,*$64
17981 4E28           50                         push	ax
17982                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17983 4E29           E8         B6FD            call	_inb
17984 4E2C           44                         inc	sp
17985 4E2D           44                         inc	sp
17986                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17987 4E2E           24                     01  and	al,*1
17988                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17989 4E30           84C0                       test	al,al
17990 4E32           74           E3            je 	.436
17991                       00004E34            .437:
17992                       00004E34            .434:
17993                                           ! Debug: list int = const $60 (used reg = )
17994 4E34           B8                   0060  mov	ax,*$60
17995 4E37           50                         push	ax
17996                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17997 4E38           E8         B6EE            call	_inb
17998 4E3B           44                         inc	sp
17999 4E3C           44                         inc	sp
18000                                           !BCC_EOS
18001                                           ! 3277       *((Bit8u *)(0x97)) = (led_flags);
18002                                           ! Debug: eq unsigned char led_flags = [S+$C-6] to unsigned char = [+$97] (used reg = )
18003 4E3D           8A46         FC            mov	al,-4[bp]
18004 4E40           A2         0097            mov	[$97],al
18005                                           !BCC_EOS
18006                                           ! 3278     }
18007                                           ! 3279 #asm
18008                       00004E43            .432:
18009                                           !BCC_EOS
18010                                           !BCC_ASM
18011                       00000012            _int16_function.BP	set	$12
18012                       00000008            .int16_function.BP	set	8
18013                       00000005            _int16_function.count	set	5
18014                       FFFFFFFB            .int16_function.count	set	-5
18015                       0000001A            _int16_function.CX	set	$1A
18016                       00000010            .int16_function.CX	set	$10
18017                       00000008            _int16_function.ascii_code	set	8
18018                       FFFFFFFE            .int16_function.ascii_code	set	-2
18019                       0000000E            _int16_function.DI	set	$E
18020                       00000004            .int16_function.DI	set	4
18021                       0000001E            _int16_function.FLAGS	set	$1E
18022                       00000014            .int16_function.FLAGS	set	$14
18023                       00000002            _int16_function.kbd_code	set	2
18024                       FFFFFFF8            .int16_function.kbd_code	set	-8
18025                       00000009            _int16_function.scan_code	set	9
18026                       FFFFFFFF            .int16_function.scan_code	set	-1
18027                       00000018            _int16_function.DX	set	$18
18028                       0000000E            .int16_function.DX	set	$E
18029                       00000006            _int16_function.led_flags	set	6
18030                       FFFFFFFC            .int16_function.led_flags	set	-4
18031                       00000010            _int16_function.SI	set	$10
18032                       00000006            .int16_function.SI	set	6
18033                       0000001C            _int16_function.AX	set	$1C
18034                       00000012            .int16_function.AX	set	$12
18035                       00000014            _int16_function.SP	set	$14
18036                       0000000A            .int16_function.SP	set	$A
18037                       00000016            _int16_function.BX	set	$16
18038                       0000000C            .int16_function.BX	set	$C
18039                       00000007            _int16_function.shift_flags	set	7
18040                       FFFFFFFD            .int16_function.shift_flags	set	-3
18041                       00000000            _int16_function.max	set	0
18042                       FFFFFFF6            .int16_function.max	set	-$A
18043 4E43           FB                             sti
18044                                           ! 3281 endasm
18045                                           !BCC_ENDASM
18046                                           !BCC_EOS
18047                                           ! 3282   }
18048                                           ! 3283   switch (*(((Bit8u *)&AX)+1)) {
18049                       00004E44            .42C:
18050 4E44           8A46         13            mov	al,$13[bp]
18051 4E47           E9         029E            br 	.43A
18052                                           ! 3284     case 0x00:
18053                                           ! 3285       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18054                       00004E4A            .43B:
18055                                           ! Debug: list int = const 1 (used reg = )
18056 4E4A           B8                   0001  mov	ax,*1
18057 4E4D           50                         push	ax
18058                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18059 4E4E           8D5E         FE            lea	bx,-2[bp]
18060 4E51           53                         push	bx
18061                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18062 4E52           8D5E         FF            lea	bx,-1[bp]
18063 4E55           53                         push	bx
18064                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18065 4E56           E8         02DA            call	_dequeue_key
18066 4E59           83C4                   06  add	sp,*6
18067 4E5C           85C0                       test	ax,ax
18068 4E5E           75           0E            jne 	.43C
18069                       00004E60            .43D:
18070                                           ! 3286         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18071                                           ! Debug: list * char = .43E+0 (used reg = )
18072 4E60           BB                   D395  mov	bx,#.43E
18073 4E63           53                         push	bx
18074                                           ! Debug: list int = const 7 (used reg = )
18075 4E64           B8                   0007  mov	ax,*7
18076 4E67           50                         push	ax
18077                                           ! Debug: func () void = bios_printf+0 (used reg = )
18078 4E68           E8         BACE            call	_bios_printf
18079 4E6B           83C4                   04  add	sp,*4
18080                                           !BCC_EOS
18081                                           ! 3287       }
18082                                           ! 3288       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18083                       00004E6E            .43C:
18084                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18085 4E6E           8A46         FF            mov	al,-1[bp]
18086 4E71           84C0                       test	al,al
18087 4E73           74           0E            je  	.43F
18088                       00004E75            .441:
18089                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18090 4E75           8A46         FE            mov	al,-2[bp]
18091 4E78           3C                     F0  cmp	al,#$F0
18092 4E7A           75           07            jne 	.43F
18093                       00004E7C            .440:
18094                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18095 4E7C           30C0                       xor	al,al
18096 4E7E           8846         FE            mov	-2[bp],al
18097                                           !BCC_EOS
18098                                           ! 3289       else if (ascii_code == 0xE0) ascii_code = 0;
18099 4E81           EB           0C            jmp .442
18100                       00004E83            .43F:
18101                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18102 4E83           8A46         FE            mov	al,-2[bp]
18103 4E86           3C                     E0  cmp	al,#$E0
18104 4E88           75           05            jne 	.443
18105                       00004E8A            .444:
18106                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18107 4E8A           30C0                       xor	al,al
18108 4E8C           8846         FE            mov	-2[bp],al
18109                                           !BCC_EOS
18110                                           ! 3290       AX = (scan_code << 8) | ascii_code;
18111                       00004E8F            .443:
18112                       00004E8F            .442:
18113                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18114 4E8F           8A46         FF            mov	al,-1[bp]
18115 4E92           30E4                       xor	ah,ah
18116 4E94           88C4                       mov	ah,al
18117 4E96           30C0                       xor	al,al
18118                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18119 4E98           0A46         FE            or	al,-2[bp]
18120                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18121 4E9B           8946         12            mov	$12[bp],ax
18122                                           !BCC_EOS
18123                                           ! 3291       break;
18124 4E9E           E9         028E            br 	.438
18125                                           !BCC_EOS
18126                                           ! 3292     case 0x01:
18127                                           ! 3293       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18128                       00004EA1            .445:
18129                                           ! Debug: list int = const 0 (used reg = )
18130 4EA1           31C0                       xor	ax,ax
18131 4EA3           50                         push	ax
18132                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18133 4EA4           8D5E         FE            lea	bx,-2[bp]
18134 4EA7           53                         push	bx
18135                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18136 4EA8           8D5E         FF            lea	bx,-1[bp]
18137 4EAB           53                         push	bx
18138                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18139 4EAC           E8         0284            call	_dequeue_key
18140 4EAF           83C4                   06  add	sp,*6
18141 4EB2           85C0                       test	ax,ax
18142 4EB4           75           0C            jne 	.446
18143                       00004EB6            .447:
18144                                           ! 3294         FLAGS |= 0x0040;
18145                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18146 4EB6           8B46         14            mov	ax,$14[bp]
18147 4EB9           0C                     40  or	al,*$40
18148 4EBB           8946         14            mov	$14[bp],ax
18149                                           !BCC_EOS
18150                                           ! 3295         return;
18151 4EBE           89EC                       mov	sp,bp
18152 4EC0           5D                         pop	bp
18153 4EC1           C3                         ret
18154                                           !BCC_EOS
18155                                           ! 3296       }
18156                                           ! 3297       if (scan_code !=0 && ascii_code == 0xF0) as
18157                       00004EC2            .446:
18158                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18159 4EC2           8A46         FF            mov	al,-1[bp]
18160 4EC5           84C0                       test	al,al
18161 4EC7           74           0E            je  	.448
18162                       00004EC9            .44A:
18163                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18164 4EC9           8A46         FE            mov	al,-2[bp]
18165 4ECC           3C                     F0  cmp	al,#$F0
18166 4ECE           75           07            jne 	.448
18167                       00004ED0            .449:
18168                                           ! 3297 cii_code = 0;
18169                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18170 4ED0           30C0                       xor	al,al
18171 4ED2           8846         FE            mov	-2[bp],al
18172                                           !BCC_EOS
18173                                           ! 3298       else if (ascii_code == 0xE0) ascii_code = 0;
18174 4ED5           EB           0C            jmp .44B
18175                       00004ED7            .448:
18176                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18177 4ED7           8A46         FE            mov	al,-2[bp]
18178 4EDA           3C                     E0  cmp	al,#$E0
18179 4EDC           75           05            jne 	.44C
18180                       00004EDE            .44D:
18181                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18182 4EDE           30C0                       xor	al,al
18183 4EE0           8846         FE            mov	-2[bp],al
18184                                           !BCC_EOS
18185                                           ! 3299       AX = (scan_code << 8) | ascii_code;
18186                       00004EE3            .44C:
18187                       00004EE3            .44B:
18188                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18189 4EE3           8A46         FF            mov	al,-1[bp]
18190 4EE6           30E4                       xor	ah,ah
18191 4EE8           88C4                       mov	ah,al
18192 4EEA           30C0                       xor	al,al
18193                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18194 4EEC           0A46         FE            or	al,-2[bp]
18195                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18196 4EEF           8946         12            mov	$12[bp],ax
18197                                           !BCC_EOS
18198                                           ! 3300       FLAGS &= 0xffbf;
18199                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18200 4EF2           8B46         14            mov	ax,$14[bp]
18201 4EF5           24                     BF  and	al,#$BF
18202 4EF7           8946         14            mov	$14[bp],ax
18203                                           !BCC_EOS
18204                                           ! 3301       break;
18205 4EFA           E9         0232            br 	.438
18206                                           !BCC_EOS
18207                                           ! 3302     case 0x02:
18208                                           ! 3303       shift_flags = *((Bit8u *)(0x17));
18209                       00004EFD            .44E:
18210                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18211 4EFD           A0         0017            mov	al,[$17]
18212 4F00           8846         FD            mov	-3[bp],al
18213                                           !BCC_EOS
18214                                           ! 3304       *((Bit8u *)&AX) = (shift_flags);
18215                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18216 4F03           8A46         FD            mov	al,-3[bp]
18217 4F06           8846         12            mov	$12[bp],al
18218                                           !BCC_EOS
18219                                           ! 3305       break;
18220 4F09           E9         0223            br 	.438
18221                                           !BCC_EOS
18222                                           ! 3306     case 0x05:
18223                                           ! 3307       if ( !enqueue_key(*(((Bit8u *)&CX)+1), ( CX & 0x00ff )) ) {
18224                       00004F0C            .44F:
18225                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
18226 4F0C           8A46         10            mov	al,$10[bp]
18227                                           ! Debug: list unsigned char = al+0 (used reg = )
18228 4F0F           30E4                       xor	ah,ah
18229 4F11           50                         push	ax
18230                                           ! Debug: list unsigned char CX = [S+$E+$F] (used reg = )
18231 4F12           8A46         11            mov	al,$11[bp]
18232 4F15           30E4                       xor	ah,ah
18233 4F17           50                         push	ax
18234                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
18235 4F18           E8         0A57            call	_enqueue_key
18236 4F1B           83C4                   04  add	sp,*4
18237 4F1E           85C0                       test	ax,ax
18238 4F20           75           07            jne 	.450
18239                       00004F22            .451:
18240                                           ! 3308         *((Bit8u *)&AX) = (1);
18241                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$C+$10] (used reg = )
18242 4F22           B0                     01  mov	al,*1
18243 4F24           8846         12            mov	$12[bp],al
18244                                           !BCC_EOS
18245                                           ! 3309       }
18246                                           ! 3310       else {
18247 4F27           EB           05            jmp .452
18248                       00004F29            .450:
18249                                           ! 3311         *((Bit8u *)&AX) = (0);
18250                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$C+$10] (used reg = )
18251 4F29           30C0                       xor	al,al
18252 4F2B           8846         12            mov	$12[bp],al
18253                                           !BCC_EOS
18254                                           ! 3312       }
18255                                           ! 3313       break;
18256                       00004F2E            .452:
18257 4F2E           E9         01FE            br 	.438
18258                                           !BCC_EOS
18259                                           ! 3314     case 0x09:
18260                                           ! 3315       *((Bit8u *)&AX) = (0x30);
18261                       00004F31            .453:
18262                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$C+$10] (used reg = )
18263 4F31           B0                     30  mov	al,*$30
18264 4F33           8846         12            mov	$12[bp],al
18265                                           !BCC_EOS
18266                                           ! 3316       break;
18267 4F36           E9         01F6            br 	.438
18268                                           !BCC_EOS
18269                                           ! 3317     case 0x0A:
18270                                           ! 3318       count = 2;
18271                       00004F39            .454:
18272                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
18273 4F39           B0                     02  mov	al,*2
18274 4F3B           8846         FB            mov	-5[bp],al
18275                                           !BCC_EOS
18276                                           ! 3319       kbd_code = 0x0;
18277                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18278 4F3E           31C0                       xor	ax,ax
18279 4F40           8946         F8            mov	-8[bp],ax
18280                                           !BCC_EOS
18281                                           ! 3320       outb(0x0060, 0xf2);
18282                                           ! Debug: list int = const $F2 (used reg = )
18283 4F43           B8                   00F2  mov	ax,#$F2
18284 4F46           50                         push	ax
18285                                           ! Debug: list int = const $60 (used reg = )
18286 4F47           B8                   0060  mov	ax,*$60
18287 4F4A           50                         push	ax
18288                                           ! Debug: func () void = outb+0 (used reg = )
18289 4F4B           E8         B5F1            call	_outb
18290 4F4E           83C4                   04  add	sp,*4
18291                                           !BCC_EOS
18292                                           ! 3321       max=0xffff;
18293                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18294 4F51           B8                   FFFF  mov	ax,#$FFFF
18295 4F54           8946         F6            mov	-$A[bp],ax
18296                                           !BCC_EOS
18297                                           ! 3322       while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18298 4F57           EB           0D            jmp .456
18299                       00004F59            .457:
18300                                           ! Debug: list int = const 0 (used reg = )
18301 4F59           31C0                       xor	ax,ax
18302 4F5B           50                         push	ax
18303                                           ! Debug: list int = const $80 (used reg = )
18304 4F5C           B8                   0080  mov	ax,#$80
18305 4F5F           50                         push	ax
18306                                           ! Debug: func () void = outb+0 (used reg = )
18307 4F60           E8         B5DC            call	_outb
18308 4F63           83C4                   04  add	sp,*4
18309                                           !BCC_EOS
18310                                           ! 3323       if (max>0x0) {
18311                       00004F66            .456:
18312                                           ! Debug: list int = const $64 (used reg = )
18313 4F66           B8                   0064  mov	ax,*$64
18314 4F69           50                         push	ax
18315                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18316 4F6A           E8         B5BC            call	_inb
18317 4F6D           44                         inc	sp
18318 4F6E           44                         inc	sp
18319                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18320 4F6F           24                     01  and	al,*1
18321                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18322 4F71           84C0                       test	al,al
18323 4F73           75           0B            jne 	.458
18324                       00004F75            .459:
18325                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18326 4F75           8B46         F6            mov	ax,-$A[bp]
18327 4F78           48                         dec	ax
18328 4F79           8946         F6            mov	-$A[bp],ax
18329                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18330 4F7C           85C0                       test	ax,ax
18331 4F7E           75           D9            jne	.457
18332                       00004F80            .458:
18333                       00004F80            .455:
18334                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18335 4F80           8B46         F6            mov	ax,-$A[bp]
18336 4F83           85C0                       test	ax,ax
18337 4F85         0F84         006D            beq 	.45A
18338                       00004F89            .45B:
18339                                           ! 3324         if ((inb(0x0060) == 0xfa)) {
18340                                           ! Debug: list int = const $60 (used reg = )
18341 4F89           B8                   0060  mov	ax,*$60
18342 4F8C           50                         push	ax
18343                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18344 4F8D           E8         B599            call	_inb
18345 4F90           44                         inc	sp
18346 4F91           44                         inc	sp
18347                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18348 4F92           3C                     FA  cmp	al,#$FA
18349 4F94           75           60            jne 	.45C
18350                       00004F96            .45D:
18351                                           ! 3325           do {
18352                       00004F96            .460:
18353                                           ! 3326             max=0xffff;
18354                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18355 4F96           B8                   FFFF  mov	ax,#$FFFF
18356 4F99           8946         F6            mov	-$A[bp],ax
18357                                           !BCC_EOS
18358                                           ! 3327             while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18359 4F9C           EB           0D            jmp .462
18360                       00004F9E            .463:
18361                                           ! Debug: list int = const 0 (used reg = )
18362 4F9E           31C0                       xor	ax,ax
18363 4FA0           50                         push	ax
18364                                           ! Debug: list int = const $80 (used reg = )
18365 4FA1           B8                   0080  mov	ax,#$80
18366 4FA4           50                         push	ax
18367                                           ! Debug: func () void = outb+0 (used reg = )
18368 4FA5           E8         B597            call	_outb
18369 4FA8           83C4                   04  add	sp,*4
18370                                           !BCC_EOS
18371                                           ! 3328             if (max>0x0) {
18372                       00004FAB            .462:
18373                                           ! Debug: list int = const $64 (used reg = )
18374 4FAB           B8                   0064  mov	ax,*$64
18375 4FAE           50                         push	ax
18376                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18377 4FAF           E8         B577            call	_inb
18378 4FB2           44                         inc	sp
18379 4FB3           44                         inc	sp
18380                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18381 4FB4           24                     01  and	al,*1
18382                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18383 4FB6           84C0                       test	al,al
18384 4FB8           75           0B            jne 	.464
18385                       00004FBA            .465:
18386                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18387 4FBA           8B46         F6            mov	ax,-$A[bp]
18388 4FBD           48                         dec	ax
18389 4FBE           8946         F6            mov	-$A[bp],ax
18390                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18391 4FC1           85C0                       test	ax,ax
18392 4FC3           75           D9            jne	.463
18393                       00004FC5            .464:
18394                       00004FC5            .461:
18395                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18396 4FC5           8B46         F6            mov	ax,-$A[bp]
18397 4FC8           85C0                       test	ax,ax
18398 4FCA           74           1F            je  	.466
18399                       00004FCC            .467:
18400                                           ! 3329               kbd_code >>= 8;
18401                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18402 4FCC           8B46         F8            mov	ax,-8[bp]
18403 4FCF           88E0                       mov	al,ah
18404 4FD1           30E4                       xor	ah,ah
18405 4FD3           8946         F8            mov	-8[bp],ax
18406                                           !BCC_EOS
18407                                           ! 3330               kbd_code |= (inb(0x0060) << 8);
18408                                           ! Debug: list int = const $60 (used reg = )
18409 4FD6           B8                   0060  mov	ax,*$60
18410 4FD9           50                         push	ax
18411                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18412 4FDA           E8         B54C            call	_inb
18413 4FDD           44                         inc	sp
18414 4FDE           44                         inc	sp
18415                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
18416 4FDF           30E4                       xor	ah,ah
18417 4FE1           88C4                       mov	ah,al
18418 4FE3           30C0                       xor	al,al
18419                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18420 4FE5           0B46         F8            or	ax,-8[bp]
18421 4FE8           8946         F8            mov	-8[bp],ax
18422                                           !BCC_EOS
18423                                           ! 3331             }
18424                                           ! 3332           } while (--count>0);
18425                       00004FEB            .466:
18426                       00004FEB            .45F:
18427                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
18428 4FEB           8A46         FB            mov	al,-5[bp]
18429 4FEE           48                         dec	ax
18430 4FEF           8846         FB            mov	-5[bp],al
18431                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
18432 4FF2           84C0                       test	al,al
18433 4FF4           75           A0            jne	.460
18434                       00004FF6            .468:
18435                                           !BCC_EOS
18436                                           ! 3333         }
18437                       00004FF6            .45E:
18438                                           ! 3334       }
18439                       00004FF6            .45C:
18440                                           ! 3335       BX=kbd_code;
18441                       00004FF6            .45A:
18442                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
18443 4FF6           8B46         F8            mov	ax,-8[bp]
18444 4FF9           8946         0C            mov	$C[bp],ax
18445                                           !BCC_EOS
18446                                           ! 3336       break;
18447 4FFC           E9         0130            br 	.438
18448                                           !BCC_EOS
18449                                           ! 3337     case 0x10:
18450                                           ! 3338       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18451                       00004FFF            .469:
18452                                           ! Debug: list int = const 1 (used reg = )
18453 4FFF           B8                   0001  mov	ax,*1
18454 5002           50                         push	ax
18455                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18456 5003           8D5E         FE            lea	bx,-2[bp]
18457 5006           53                         push	bx
18458                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18459 5007           8D5E         FF            lea	bx,-1[bp]
18460 500A           53                         push	bx
18461                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18462 500B           E8         0125            call	_dequeue_key
18463 500E           83C4                   06  add	sp,*6
18464 5011           85C0                       test	ax,ax
18465 5013           75           0E            jne 	.46A
18466                       00005015            .46B:
18467                                           ! 3339         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18468                                           ! Debug: list * char = .46C+0 (used reg = )
18469 5015           BB                   D371  mov	bx,#.46C
18470 5018           53                         push	bx
18471                                           ! Debug: list int = const 7 (used reg = )
18472 5019           B8                   0007  mov	ax,*7
18473 501C           50                         push	ax
18474                                           ! Debug: func () void = bios_printf+0 (used reg = )
18475 501D           E8         B919            call	_bios_printf
18476 5020           83C4                   04  add	sp,*4
18477                                           !BCC_EOS
18478                                           ! 3340       }
18479                                           ! 3341       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18480                       00005023            .46A:
18481                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18482 5023           8A46         FF            mov	al,-1[bp]
18483 5026           84C0                       test	al,al
18484 5028           74           0C            je  	.46D
18485                       0000502A            .46F:
18486                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18487 502A           8A46         FE            mov	al,-2[bp]
18488 502D           3C                     F0  cmp	al,#$F0
18489 502F           75           05            jne 	.46D
18490                       00005031            .46E:
18491                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18492 5031           30C0                       xor	al,al
18493 5033           8846         FE            mov	-2[bp],al
18494                                           !BCC_EOS
18495                                           ! 3342       AX = (scan_code << 8) | ascii_code;
18496                       00005036            .46D:
18497                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18498 5036           8A46         FF            mov	al,-1[bp]
18499 5039           30E4                       xor	ah,ah
18500 503B           88C4                       mov	ah,al
18501 503D           30C0                       xor	al,al
18502                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18503 503F           0A46         FE            or	al,-2[bp]
18504                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18505 5042           8946         12            mov	$12[bp],ax
18506                                           !BCC_EOS
18507                                           ! 3343       break;
18508 5045           E9         00E7            br 	.438
18509                                           !BCC_EOS
18510                                           ! 3344     case 0x11:
18511                                           ! 3345       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18512                       00005048            .470:
18513                                           ! Debug: list int = const 0 (used reg = )
18514 5048           31C0                       xor	ax,ax
18515 504A           50                         push	ax
18516                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18517 504B           8D5E         FE            lea	bx,-2[bp]
18518 504E           53                         push	bx
18519                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18520 504F           8D5E         FF            lea	bx,-1[bp]
18521 5052           53                         push	bx
18522                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18523 5053           E8         00DD            call	_dequeue_key
18524 5056           83C4                   06  add	sp,*6
18525 5059           85C0                       test	ax,ax
18526 505B           75           0C            jne 	.471
18527                       0000505D            .472:
18528                                           ! 3346         FLAGS |= 0x0040;
18529                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18530 505D           8B46         14            mov	ax,$14[bp]
18531 5060           0C                     40  or	al,*$40
18532 5062           8946         14            mov	$14[bp],ax
18533                                           !BCC_EOS
18534                                           ! 3347         return;
18535 5065           89EC                       mov	sp,bp
18536 5067           5D                         pop	bp
18537 5068           C3                         ret
18538                                           !BCC_EOS
18539                                           ! 3348       }
18540                                           ! 3349       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18541                       00005069            .471:
18542                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18543 5069           8A46         FF            mov	al,-1[bp]
18544 506C           84C0                       test	al,al
18545 506E           74           0C            je  	.473
18546                       00005070            .475:
18547                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18548 5070           8A46         FE            mov	al,-2[bp]
18549 5073           3C                     F0  cmp	al,#$F0
18550 5075           75           05            jne 	.473
18551                       00005077            .474:
18552                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18553 5077           30C0                       xor	al,al
18554 5079           8846         FE            mov	-2[bp],al
18555                                           !BCC_EOS
18556                                           ! 3350       AX = (scan_code << 8) | ascii_code;
18557                       0000507C            .473:
18558                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18559 507C           8A46         FF            mov	al,-1[bp]
18560 507F           30E4                       xor	ah,ah
18561 5081           88C4                       mov	ah,al
18562 5083           30C0                       xor	al,al
18563                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18564 5085           0A46         FE            or	al,-2[bp]
18565                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18566 5088           8946         12            mov	$12[bp],ax
18567                                           !BCC_EOS
18568                                           ! 3351       FLAGS &= 0xffbf;
18569                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18570 508B           8B46         14            mov	ax,$14[bp]
18571 508E           24                     BF  and	al,#$BF
18572 5090           8946         14            mov	$14[bp],ax
18573                                           !BCC_EOS
18574                                           ! 3352       break;
18575 5093           E9         0099            br 	.438
18576                                           !BCC_EOS
18577                                           ! 3353     case 0x12:
18578                                           ! 3354       shift_flags = *((Bit8u *)(0x17));
18579                       00005096            .476:
18580                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18581 5096           A0         0017            mov	al,[$17]
18582 5099           8846         FD            mov	-3[bp],al
18583                                           !BCC_EOS
18584                                           ! 3355       *((Bit8u *)&AX) = (shift_flags);
18585                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18586 509C           8A46         FD            mov	al,-3[bp]
18587 509F           8846         12            mov	$12[bp],al
18588                                           !BCC_EOS
18589                                           ! 3356       shift_flags = *((Bit8u *)(0x18)) & 0x73;
18590                                           ! Debug: and int = const $73 to unsigned char = [+$18] (used reg = )
18591 50A2           A0         0018            mov	al,[$18]
18592 50A5           24                     73  and	al,*$73
18593                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18594 50A7           8846         FD            mov	-3[bp],al
18595                                           !BCC_EOS
18596                                           ! 3357       shift_flags |= *((Bit8u *)(0x96)) & 0x0c;
18597                                           ! Debug: and int = const $C to unsigned char = [+$96] (used reg = )
18598 50AA           A0         0096            mov	al,[$96]
18599 50AD           24                     0C  and	al,*$C
18600                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18601 50AF           0A46         FD            or	al,-3[bp]
18602 50B2           8846         FD            mov	-3[bp],al
18603                                           !BCC_EOS
18604                                           ! 3358       *(((Bit8u *)&AX)+1) = (shift_flags);
18605                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$11] (used reg = )
18606 50B5           8A46         FD            mov	al,-3[bp]
18607 50B8           8846         13            mov	$13[bp],al
18608                                           !BCC_EOS
18609                                           ! 3359       ;
18610                                           !BCC_EOS
18611                                           ! 3360       break;
18612 50BB           EB           72            jmp .438
18613                                           !BCC_EOS
18614                                           ! 3361     case 0x92:
18615                                           ! 3362       *(((Bit8u *)&AX)+1) = (0x80);
18616                       000050BD            .477:
18617                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$C+$11] (used reg = )
18618 50BD           B0                     80  mov	al,#$80
18619 50BF           8846         13            mov	$13[bp],al
18620                                           !BCC_EOS
18621                                           ! 3363       break;
18622 50C2           EB           6B            jmp .438
18623                                           !BCC_EOS
18624                                           ! 3364     case 0xA2:
18625                                           ! 3365       break;
18626                       000050C4            .478:
18627 50C4           EB           69            jmp .438
18628                                           !BCC_EOS
18629                                           ! 3366     case 0x6F:
18630                                           ! 3367       if (( AX & 0x00ff ) == 0x08)
18631                       000050C6            .479:
18632                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
18633 50C6           8A46         12            mov	al,$12[bp]
18634                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
18635 50C9           3C                     08  cmp	al,*8
18636 50CB           75           05            jne 	.47A
18637                       000050CD            .47B:
18638                                           ! 3368         *(((Bit8u *)&AX)+1) = (0x02);
18639                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$C+$11] (used reg = )
18640 50CD           B0                     02  mov	al,*2
18641 50CF           8846         13            mov	$13[bp],al
18642                                           !BCC_EOS
18643                                           ! 3369     default:
18644                       000050D2            .47A:
18645                                           ! 3370       bios_printf(4, "
18646                       000050D2            .47C:
18647                                           ! 3370 KBD: unsupported int 16h function %02x\n", *(((Bit8u *)&AX)+1));
18648                                           ! Debug: list unsigned char AX = [S+$C+$11] (used reg = )
18649 50D2           8A46         13            mov	al,$13[bp]
18650 50D5           30E4                       xor	ah,ah
18651 50D7           50                         push	ax
18652                                           ! Debug: list * char = .47D+0 (used reg = )
18653 50D8           BB                   D349  mov	bx,#.47D
18654 50DB           53                         push	bx
18655                                           ! Debug: list int = const 4 (used reg = )
18656 50DC           B8                   0004  mov	ax,*4
18657 50DF           50                         push	ax
18658                                           ! Debug: func () void = bios_printf+0 (used reg = )
18659 50E0           E8         B856            call	_bios_printf
18660 50E3           83C4                   06  add	sp,*6
18661                                           !BCC_EOS
18662                                           ! 3371   }
18663                                           ! 3372 }
18664 50E6           EB           47            jmp .438
18665                       000050E8            .43A:
18666 50E8           2C                     00  sub	al,*0
18667 50EA           72           E6            jb 	.47C
18668 50EC           3C                     12  cmp	al,*$12
18669 50EE           77           31            ja  	.47E
18670 50F0           30E4                       xor	ah,ah
18671 50F2           D1E0                       shl	ax,*1
18672 50F4           89C3                       mov	bx,ax
18673 50F6           2E                         seg	cs
18674 50F7           FFA7       50FB            br	.47F[bx]
18675                       000050FB            .47F:
18676 50FB                      4E4A            .word	.43B
18677 50FD                      4EA1            .word	.445
18678 50FF                      4EFD            .word	.44E
18679 5101                      50D2            .word	.47C
18680 5103                      50D2            .word	.47C
18681 5105                      4F0C            .word	.44F
18682 5107                      50D2            .word	.47C
18683 5109                      50D2            .word	.47C
18684 510B                      50D2            .word	.47C
18685 510D                      4F31            .word	.453
18686 510F                      4F39            .word	.454
18687 5111                      50D2            .word	.47C
18688 5113                      50D2            .word	.47C
18689 5115                      50D2            .word	.47C
18690 5117                      50D2            .word	.47C
18691 5119                      50D2            .word	.47C
18692 511B                      4FFF            .word	.469
18693 511D                      5048            .word	.470
18694 511F                      5096            .word	.476
18695                       00005121            .47E:
18696 5121           2C                     6F  sub	al,*$6F
18697 5123           74           A1            je 	.479
18698 5125           2C                     23  sub	al,*$23
18699 5127           74           94            je 	.477
18700 5129           2C                     10  sub	al,*$10
18701 512B           74           97            je 	.478
18702 512D           EB           A3            jmp	.47C
18703                       0000512F            .438:
18704                       FFFFFFF4            ..FFF3	=	-$C
18705 512F           89EC                       mov	sp,bp
18706 5131           5D                         pop	bp
18707 5132           C3                         ret
18708                                           ! 3373   unsigned int
18709                                           ! Register BX used in function int16_function
18710                                           ! 3374 dequeue_key(scan_code, ascii_code, incr)
18711                                           ! 3375   Bit8u *scan_code;
18712                                           export	_dequeue_key
18713                       00005133            _dequeue_key:
18714                                           !BCC_EOS
18715                                           ! 3376   Bit8u *ascii_code;
18716                                           !BCC_EOS
18717                                           ! 3377   unsigned int incr;
18718                                           !BCC_EOS
18719                                           ! 3378 {
18720                                           ! 3379   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
18721                                           !BCC_EOS
18722                                           ! 3380   Bit8u acode, scode;
18723                                           !BCC_EOS
18724                                           ! 3381   buffer_start = *((Bit16u *)(0x0080));
18725 5133           55                         push	bp
18726 5134           89E5                       mov	bp,sp
18727 5136           83C4                   F6  add	sp,*-$A
18728                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$C-4] (used reg = )
18729 5139           A1         0080            mov	ax,[$80]
18730 513C           8946         FE            mov	-2[bp],ax
18731                                           !BCC_EOS
18732                                           ! 3382   buffer_end = *((Bit16u *)(0x0082));
18733                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$C-6] (used reg = )
18734 513F           A1         0082            mov	ax,[$82]
18735 5142           8946         FC            mov	-4[bp],ax
18736                                           !BCC_EOS
18737                                           ! 3383   buffer_head = *((Bit16u *)(0x001a));
18738                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18739 5145           A1         001A            mov	ax,[$1A]
18740 5148           8946         FA            mov	-6[bp],ax
18741                                           !BCC_EOS
18742                                           ! 3384   buffer_tail = *((Bit16u *)(0x001c));
18743                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
18744 514B           A1         001C            mov	ax,[$1C]
18745 514E           8946         F8            mov	-8[bp],ax
18746                                           !BCC_EOS
18747                                           ! 3385   if (buffer_head != buffer_tail) {
18748                                           ! Debug: ne unsigned short buffer_tail = [S+$C-$A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18749 5151           8B46         FA            mov	ax,-6[bp]
18750 5154           3B46         F8            cmp	ax,-8[bp]
18751 5157           74           5D            je  	.480
18752                       00005159            .481:
18753                                           ! 3386     acode = *((Bit8u *)(buffer_head));
18754 5159           8B5E         FA            mov	bx,-6[bp]
18755                                           ! Debug: eq unsigned char = [bx+0] to unsigned char acode = [S+$C-$B] (used reg = )
18756 515C           8A07                       mov	al,[bx]
18757 515E           8846         F7            mov	-9[bp],al
18758                                           !BCC_EOS
18759                                           ! 3387     scode = *((Bit8u *)(buffer_head+1));
18760                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$C-8] (used reg = )
18761 5161           8B46         FA            mov	ax,-6[bp]
18762                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
18763 5164           89C3                       mov	bx,ax
18764                                           ! Debug: eq unsigned char = [bx+1] to unsigned char scode = [S+$C-$C] (used reg = )
18765 5166           8A47         01            mov	al,1[bx]
18766 5169           8846         F6            mov	-$A[bp],al
18767                                           !BCC_EOS
18768                                           ! 3388     _write_byte_SS(acode, ascii_code);
18769                                           ! Debug: list * unsigned char ascii_code = [S+$C+4] (used reg = )
18770 516C           FF76         06            push	6[bp]
18771                                           ! Debug: list unsigned char acode = [S+$E-$B] (used reg = )
18772 516F           8A46         F7            mov	al,-9[bp]
18773 5172           30E4                       xor	ah,ah
18774 5174           50                         push	ax
18775                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18776 5175           E8         B4BF            call	__write_byte_SS
18777 5178           83C4                   04  add	sp,*4
18778                                           !BCC_EOS
18779                                           ! 3389     _write_byte_SS(scode, scan_code);
18780                                           ! Debug: list * unsigned char scan_code = [S+$C+2] (used reg = )
18781 517B           FF76         04            push	4[bp]
18782                                           ! Debug: list unsigned char scode = [S+$E-$C] (used reg = )
18783 517E           8A46         F6            mov	al,-$A[bp]
18784 5181           30E4                       xor	ah,ah
18785 5183           50                         push	ax
18786                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18787 5184           E8         B4B0            call	__write_byte_SS
18788 5187           83C4                   04  add	sp,*4
18789                                           !BCC_EOS
18790                                           ! 3390     if (incr) {
18791 518A           8B46         08            mov	ax,8[bp]
18792 518D           85C0                       test	ax,ax
18793 518F           74           1C            je  	.482
18794                       00005191            .483:
18795                                           ! 3391       buffer_head += 2;
18796                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$C-8] (used reg = )
18797 5191           8B46         FA            mov	ax,-6[bp]
18798 5194           40                         inc	ax
18799 5195           40                         inc	ax
18800 5196           8946         FA            mov	-6[bp],ax
18801                                           !BCC_EOS
18802                                           ! 3392       if (buffer_head >= buffer_end)
18803                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_head = [S+$C-8] (used reg = )
18804 5199           8B46         FA            mov	ax,-6[bp]
18805 519C           3B46         FC            cmp	ax,-4[bp]
18806 519F           72           06            jb  	.484
18807                       000051A1            .485:
18808                                           ! 3393         buffer_head = buffer_start;
18809                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_head = [S+$C-8] (used reg = )
18810 51A1           8B46         FE            mov	ax,-2[bp]
18811 51A4           8946         FA            mov	-6[bp],ax
18812                                           !BCC_EOS
18813                                           ! 3394       *((Bit16u *)(0x001a)) = (buffer_head);
18814                       000051A7            .484:
18815                                           ! Debug: eq unsigned short buffer_head = [S+$C-8] to unsigned short = [+$1A] (used reg = )
18816 51A7           8B46         FA            mov	ax,-6[bp]
18817 51AA           A3         001A            mov	[$1A],ax
18818                                           !BCC_EOS
18819                                           ! 3395     }
18820                                           ! 3396     return(1);
18821                       000051AD            .482:
18822 51AD           B8                   0001  mov	ax,*1
18823 51B0           89EC                       mov	sp,bp
18824 51B2           5D                         pop	bp
18825 51B3           C3                         ret
18826                                           !BCC_EOS
18827                                           ! 3397   }
18828                                           ! 3398   else {
18829 51B4           EB           06            jmp .486
18830                       000051B6            .480:
18831                                           ! 3399     return(0);
18832 51B6           31C0                       xor	ax,ax
18833 51B8           89EC                       mov	sp,bp
18834 51BA           5D                         pop	bp
18835 51BB           C3                         ret
18836                                           !BCC_EOS
18837                                           ! 3400   }
18838                                           ! 3401 }
18839                       000051BC            .486:
18840 51BC           89EC                       mov	sp,bp
18841 51BE           5D                         pop	bp
18842 51BF           C3                         ret
18843                                           ! 3402 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
18844                                           ! Register BX used in function dequeue_key
18845                                           
18846                       000051C0            _panic_msg_keyb_buffer_full:
18847                       000051C0            .487:
18848 51C0                        25            .ascii	"%s: keyboard input buffer full"
18849 51DE                        0A            .byte	$A
18850 51DF                        00            .byte	0
18851                                           !BCC_EOS
18852                                           ! 3403   Bit8u
18853                                           ! 3404 inhibit_mouse_int_and_events()
18854                                           ! 3405 {
18855                                           
18856                                           export	_inhibit_mouse_int_and_events
18857                       000051E0            _inhibit_mouse_int_and_events:
18858                                           ! 3406   Bit8u command_byte, prev_command_byte;
18859                                           !BCC_EOS
18860                                           ! 3407   if ( inb(0x0064) & 0x02 )
18861 51E0           55                         push	bp
18862 51E1           89E5                       mov	bp,sp
18863 51E3           4C                         dec	sp
18864 51E4           4C                         dec	sp
18865                                           ! Debug: list int = const $64 (used reg = )
18866 51E5           B8                   0064  mov	ax,*$64
18867 51E8           50                         push	ax
18868                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18869 51E9           E8         B33D            call	_inb
18870 51EC           44                         inc	sp
18871 51ED           44                         inc	sp
18872                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18873 51EE           24                     02  and	al,*2
18874 51F0           84C0                       test	al,al
18875 51F2           74           12            je  	.488
18876                       000051F4            .489:
18877                                           ! 3408     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18878                                           ! Debug: list * char = .48A+0 (used reg = )
18879 51F4           BB                   D33E  mov	bx,#.48A
18880 51F7           53                         push	bx
18881                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18882 51F8           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
18883 51FB           53                         push	bx
18884                                           ! Debug: list int = const 7 (used reg = )
18885 51FC           B8                   0007  mov	ax,*7
18886 51FF           50                         push	ax
18887                                           ! Debug: func () void = bios_printf+0 (used reg = )
18888 5200           E8         B736            call	_bios_printf
18889 5203           83C4                   06  add	sp,*6
18890                                           !BCC_EOS
18891                                           ! 3409   outb(0x0064, 0x20);
18892                       00005206            .488:
18893                                           ! Debug: list int = const $20 (used reg = )
18894 5206           B8                   0020  mov	ax,*$20
18895 5209           50                         push	ax
18896                                           ! Debug: list int = const $64 (used reg = )
18897 520A           B8                   0064  mov	ax,*$64
18898 520D           50                         push	ax
18899                                           ! Debug: func () void = outb+0 (used reg = )
18900 520E           E8         B32E            call	_outb
18901 5211           83C4                   04  add	sp,*4
18902                                           !BCC_EOS
18903                                           ! 3410   while ( (inb(0x0064) & 0x01) != 0x01 );
18904 5214           EB           00            jmp .48C
18905                       00005216            .48D:
18906                                           !BCC_EOS
18907                                           ! 3411   prev_command_byte = inb(0x0060);
18908                       00005216            .48C:
18909                                           ! Debug: list int = const $64 (used reg = )
18910 5216           B8                   0064  mov	ax,*$64
18911 5219           50                         push	ax
18912                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18913 521A           E8         B30C            call	_inb
18914 521D           44                         inc	sp
18915 521E           44                         inc	sp
18916                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18917 521F           24                     01  and	al,*1
18918                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18919 5221           3C                     01  cmp	al,*1
18920 5223           75           F1            jne	.48D
18921                       00005225            .48E:
18922                       00005225            .48B:
18923                                           ! Debug: list int = const $60 (used reg = )
18924 5225           B8                   0060  mov	ax,*$60
18925 5228           50                         push	ax
18926                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18927 5229           E8         B2FD            call	_inb
18928 522C           44                         inc	sp
18929 522D           44                         inc	sp
18930                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
18931 522E           8846         FE            mov	-2[bp],al
18932                                           !BCC_EOS
18933                                           ! 3412   command_byte = prev_command_byte;
18934                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
18935 5231           8A46         FE            mov	al,-2[bp]
18936 5234           8846         FF            mov	-1[bp],al
18937                                           !BCC_EOS
18938                                           ! 3413   if ( inb(0x0064) & 0x02 )
18939                                           ! Debug: list int = const $64 (used reg = )
18940 5237           B8                   0064  mov	ax,*$64
18941 523A           50                         push	ax
18942                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18943 523B           E8         B2EB            call	_inb
18944 523E           44                         inc	sp
18945 523F           44                         inc	sp
18946                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18947 5240           24                     02  and	al,*2
18948 5242           84C0                       test	al,al
18949 5244           74           12            je  	.48F
18950                       00005246            .490:
18951                                           ! 3414     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18952                                           ! Debug: list * char = .491+0 (used reg = )
18953 5246           BB                   D333  mov	bx,#.491
18954 5249           53                         push	bx
18955                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18956 524A           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
18957 524D           53                         push	bx
18958                                           ! Debug: list int = const 7 (used reg = )
18959 524E           B8                   0007  mov	ax,*7
18960 5251           50                         push	ax
18961                                           ! Debug: func () void = bios_printf+0 (used reg = )
18962 5252           E8         B6E4            call	_bios_printf
18963 5255           83C4                   06  add	sp,*6
18964                                           !BCC_EOS
18965                                           ! 3415   command_byte &= 0xfd;
18966                       00005258            .48F:
18967                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
18968 5258           8A46         FF            mov	al,-1[bp]
18969 525B           24                     FD  and	al,#$FD
18970 525D           8846         FF            mov	-1[bp],al
18971                                           !BCC_EOS
18972                                           ! 3416   command_byte |= 0x20;
18973                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
18974 5260           8A46         FF            mov	al,-1[bp]
18975 5263           0C                     20  or	al,*$20
18976 5265           8846         FF            mov	-1[bp],al
18977                                           !BCC_EOS
18978                                           ! 3417   outb(0x0064, 0x60);
18979                                           ! Debug: list int = const $60 (used reg = )
18980 5268           B8                   0060  mov	ax,*$60
18981 526B           50                         push	ax
18982                                           ! Debug: list int = const $64 (used reg = )
18983 526C           B8                   0064  mov	ax,*$64
18984 526F           50                         push	ax
18985                                           ! Debug: func () void = outb+0 (used reg = )
18986 5270           E8         B2CC            call	_outb
18987 5273           83C4                   04  add	sp,*4
18988                                           !BCC_EOS
18989                                           ! 3418   outb(0x0060, command_byte);
18990                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
18991 5276           8A46         FF            mov	al,-1[bp]
18992 5279           30E4                       xor	ah,ah
18993 527B           50                         push	ax
18994                                           ! Debug: list int = const $60 (used reg = )
18995 527C           B8                   0060  mov	ax,*$60
18996 527F           50                         push	ax
18997                                           ! Debug: func () void = outb+0 (used reg = )
18998 5280           E8         B2BC            call	_outb
18999 5283           83C4                   04  add	sp,*4
19000                                           !BCC_EOS
19001                                           ! 3419   return(prev_command_byte);
19002 5286           8A46         FE            mov	al,-2[bp]
19003 5289           89EC                       mov	sp,bp
19004 528B           5D                         pop	bp
19005 528C           C3                         ret
19006                                           !BCC_EOS
19007                                           ! 3420 }
19008                                           ! 3421   void
19009                                           ! Register BX used in function inhibit_mouse_int_and_events
19010                                           ! 3422 enable_mouse_int_and_events()
19011                                           ! 3423 {
19012                                           export	_enable_mouse_int_and_events
19013                       0000528D            _enable_mouse_int_and_events:
19014                                           ! 3424   Bit8u command_byte;
19015                                           !BCC_EOS
19016                                           ! 3425   if ( inb(0x0064) & 0x02 )
19017 528D           55                         push	bp
19018 528E           89E5                       mov	bp,sp
19019 5290           4C                         dec	sp
19020 5291           4C                         dec	sp
19021                                           ! Debug: list int = const $64 (used reg = )
19022 5292           B8                   0064  mov	ax,*$64
19023 5295           50                         push	ax
19024                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19025 5296           E8         B290            call	_inb
19026 5299           44                         inc	sp
19027 529A           44                         inc	sp
19028                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19029 529B           24                     02  and	al,*2
19030 529D           84C0                       test	al,al
19031 529F           74           12            je  	.492
19032                       000052A1            .493:
19033                                           ! 3426     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19034                                           ! Debug: list * char = .494+0 (used reg = )
19035 52A1           BB                   D329  mov	bx,#.494
19036 52A4           53                         push	bx
19037                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19038 52A5           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
19039 52A8           53                         push	bx
19040                                           ! Debug: list int = const 7 (used reg = )
19041 52A9           B8                   0007  mov	ax,*7
19042 52AC           50                         push	ax
19043                                           ! Debug: func () void = bios_printf+0 (used reg = )
19044 52AD           E8         B689            call	_bios_printf
19045 52B0           83C4                   06  add	sp,*6
19046                                           !BCC_EOS
19047                                           ! 3427   outb(0x0064, 0x20);
19048                       000052B3            .492:
19049                                           ! Debug: list int = const $20 (used reg = )
19050 52B3           B8                   0020  mov	ax,*$20
19051 52B6           50                         push	ax
19052                                           ! Debug: list int = const $64 (used reg = )
19053 52B7           B8                   0064  mov	ax,*$64
19054 52BA           50                         push	ax
19055                                           ! Debug: func () void = outb+0 (used reg = )
19056 52BB           E8         B281            call	_outb
19057 52BE           83C4                   04  add	sp,*4
19058                                           !BCC_EOS
19059                                           ! 3428   while ( (inb(0x0064) & 0x01) != 0x01 );
19060 52C1           EB           00            jmp .496
19061                       000052C3            .497:
19062                                           !BCC_EOS
19063                                           ! 3429   command_byte = inb(0x0060);
19064                       000052C3            .496:
19065                                           ! Debug: list int = const $64 (used reg = )
19066 52C3           B8                   0064  mov	ax,*$64
19067 52C6           50                         push	ax
19068                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19069 52C7           E8         B25F            call	_inb
19070 52CA           44                         inc	sp
19071 52CB           44                         inc	sp
19072                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19073 52CC           24                     01  and	al,*1
19074                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
19075 52CE           3C                     01  cmp	al,*1
19076 52D0           75           F1            jne	.497
19077                       000052D2            .498:
19078                       000052D2            .495:
19079                                           ! Debug: list int = const $60 (used reg = )
19080 52D2           B8                   0060  mov	ax,*$60
19081 52D5           50                         push	ax
19082                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19083 52D6           E8         B250            call	_inb
19084 52D9           44                         inc	sp
19085 52DA           44                         inc	sp
19086                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
19087 52DB           8846         FF            mov	-1[bp],al
19088                                           !BCC_EOS
19089                                           ! 3430   if ( inb(0x0064) & 0x02 )
19090                                           ! Debug: list int = const $64 (used reg = )
19091 52DE           B8                   0064  mov	ax,*$64
19092 52E1           50                         push	ax
19093                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19094 52E2           E8         B244            call	_inb
19095 52E5           44                         inc	sp
19096 52E6           44                         inc	sp
19097                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19098 52E7           24                     02  and	al,*2
19099 52E9           84C0                       test	al,al
19100 52EB           74           12            je  	.499
19101                       000052ED            .49A:
19102                                           ! 3431     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19103                                           ! Debug: list * char = .49B+0 (used reg = )
19104 52ED           BB                   D31F  mov	bx,#.49B
19105 52F0           53                         push	bx
19106                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19107 52F1           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
19108 52F4           53                         push	bx
19109                                           ! Debug: list int = const 7 (used reg = )
19110 52F5           B8                   0007  mov	ax,*7
19111 52F8           50                         push	ax
19112                                           ! Debug: func () void = bios_printf+0 (used reg = )
19113 52F9           E8         B63D            call	_bios_printf
19114 52FC           83C4                   06  add	sp,*6
19115                                           !BCC_EOS
19116                                           ! 3432   command_byte |= 0x02;
19117                       000052FF            .499:
19118                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
19119 52FF           8A46         FF            mov	al,-1[bp]
19120 5302           0C                     02  or	al,*2
19121 5304           8846         FF            mov	-1[bp],al
19122                                           !BCC_EOS
19123                                           ! 3433   command_byte &= 0xdf;
19124                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
19125 5307           8A46         FF            mov	al,-1[bp]
19126 530A           24                     DF  and	al,#$DF
19127 530C           8846         FF            mov	-1[bp],al
19128                                           !BCC_EOS
19129                                           ! 3434   outb(0x0064, 0x60);
19130                                           ! Debug: list int = const $60 (used reg = )
19131 530F           B8                   0060  mov	ax,*$60
19132 5312           50                         push	ax
19133                                           ! Debug: list int = const $64 (used reg = )
19134 5313           B8                   0064  mov	ax,*$64
19135 5316           50                         push	ax
19136                                           ! Debug: func () void = outb+0 (used reg = )
19137 5317           E8         B225            call	_outb
19138 531A           83C4                   04  add	sp,*4
19139                                           !BCC_EOS
19140                                           ! 3435   outb(0x0060, command_byte);
19141                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19142 531D           8A46         FF            mov	al,-1[bp]
19143 5320           30E4                       xor	ah,ah
19144 5322           50                         push	ax
19145                                           ! Debug: list int = const $60 (used reg = )
19146 5323           B8                   0060  mov	ax,*$60
19147 5326           50                         push	ax
19148                                           ! Debug: func () void = outb+0 (used reg = )
19149 5327           E8         B215            call	_outb
19150 532A           83C4                   04  add	sp,*4
19151                                           !BCC_EOS
19152                                           ! 3436 }
19153 532D           89EC                       mov	sp,bp
19154 532F           5D                         pop	bp
19155 5330           C3                         ret
19156                                           ! 3437   Bit8u
19157                                           ! Register BX used in function enable_mouse_int_and_events
19158                                           ! 3438 send_to_mouse_ctrl(sendbyte)
19159                                           ! 3439   Bit8u sendbyte;
19160                                           export	_send_to_mouse_ctrl
19161                       00005331            _send_to_mouse_ctrl:
19162                                           !BCC_EOS
19163                                           ! 3440 {
19164                                           ! 3441   Bit8u response;
19165                                           !BCC_EOS
19166                                           ! 3442   if ( inb(0x0064) & 0x02 )
19167 5331           55                         push	bp
19168 5332           89E5                       mov	bp,sp
19169 5334           4C                         dec	sp
19170 5335           4C                         dec	sp
19171                                           ! Debug: list int = const $64 (used reg = )
19172 5336           B8                   0064  mov	ax,*$64
19173 5339           50                         push	ax
19174                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19175 533A           E8         B1EC            call	_inb
19176 533D           44                         inc	sp
19177 533E           44                         inc	sp
19178                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19179 533F           24                     02  and	al,*2
19180 5341           84C0                       test	al,al
19181 5343           74           12            je  	.49C
19182                       00005345            .49D:
19183                                           ! 3443     bios_printf((2 | 4 | 1), pa
19184                                           ! 3443 nic_msg_keyb_buffer_full,"sendmouse");
19185                                           ! Debug: list * char = .49E+0 (used reg = )
19186 5345           BB                   D315  mov	bx,#.49E
19187 5348           53                         push	bx
19188                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19189 5349           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
19190 534C           53                         push	bx
19191                                           ! Debug: list int = const 7 (used reg = )
19192 534D           B8                   0007  mov	ax,*7
19193 5350           50                         push	ax
19194                                           ! Debug: func () void = bios_printf+0 (used reg = )
19195 5351           E8         B5E5            call	_bios_printf
19196 5354           83C4                   06  add	sp,*6
19197                                           !BCC_EOS
19198                                           ! 3444   outb(0x0064, 0xD4);
19199                       00005357            .49C:
19200                                           ! Debug: list int = const $D4 (used reg = )
19201 5357           B8                   00D4  mov	ax,#$D4
19202 535A           50                         push	ax
19203                                           ! Debug: list int = const $64 (used reg = )
19204 535B           B8                   0064  mov	ax,*$64
19205 535E           50                         push	ax
19206                                           ! Debug: func () void = outb+0 (used reg = )
19207 535F           E8         B1DD            call	_outb
19208 5362           83C4                   04  add	sp,*4
19209                                           !BCC_EOS
19210                                           ! 3445   outb(0x0060, sendbyte);
19211                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
19212 5365           8A46         04            mov	al,4[bp]
19213 5368           30E4                       xor	ah,ah
19214 536A           50                         push	ax
19215                                           ! Debug: list int = const $60 (used reg = )
19216 536B           B8                   0060  mov	ax,*$60
19217 536E           50                         push	ax
19218                                           ! Debug: func () void = outb+0 (used reg = )
19219 536F           E8         B1CD            call	_outb
19220 5372           83C4                   04  add	sp,*4
19221                                           !BCC_EOS
19222                                           ! 3446   return(0);
19223 5375           30C0                       xor	al,al
19224 5377           89EC                       mov	sp,bp
19225 5379           5D                         pop	bp
19226 537A           C3                         ret
19227                                           !BCC_EOS
19228                                           ! 3447 }
19229                                           ! 3448   Bit8u
19230                                           ! Register BX used in function send_to_mouse_ctrl
19231                                           ! 3449 get_mouse_data(data)
19232                                           ! 3450   Bit8u *data;
19233                                           export	_get_mouse_data
19234                       0000537B            _get_mouse_data:
19235                                           !BCC_EOS
19236                                           ! 3451 {
19237                                           ! 3452   Bit8u response;
19238                                           !BCC_EOS
19239                                           ! 3453   while ((inb(0x0064) & 0x21) != 0x21) { }
19240 537B           55                         push	bp
19241 537C           89E5                       mov	bp,sp
19242 537E           4C                         dec	sp
19243 537F           4C                         dec	sp
19244 5380           EB           00            jmp .4A0
19245                       00005382            .4A1:
19246                                           ! 3454   response = inb(0x0060);
19247                       00005382            .4A0:
19248                                           ! Debug: list int = const $64 (used reg = )
19249 5382           B8                   0064  mov	ax,*$64
19250 5385           50                         push	ax
19251                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19252 5386           E8         B1A0            call	_inb
19253 5389           44                         inc	sp
19254 538A           44                         inc	sp
19255                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
19256 538B           24                     21  and	al,*$21
19257                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
19258 538D           3C                     21  cmp	al,*$21
19259 538F           75           F1            jne	.4A1
19260                       00005391            .4A2:
19261                       00005391            .49F:
19262                                           ! Debug: list int = const $60 (used reg = )
19263 5391           B8                   0060  mov	ax,*$60
19264 5394           50                         push	ax
19265                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19266 5395           E8         B191            call	_inb
19267 5398           44                         inc	sp
19268 5399           44                         inc	sp
19269                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+4-3] (used reg = )
19270 539A           8846         FF            mov	-1[bp],al
19271                                           !BCC_EOS
19272                                           ! 3455   _write_byte_SS(response, data);
19273                                           ! Debug: list * unsigned char data = [S+4+2] (used reg = )
19274 539D           FF76         04            push	4[bp]
19275                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
19276 53A0           8A46         FF            mov	al,-1[bp]
19277 53A3           30E4                       xor	ah,ah
19278 53A5           50                         push	ax
19279                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
19280 53A6           E8         B28E            call	__write_byte_SS
19281 53A9           83C4                   04  add	sp,*4
19282                                           !BCC_EOS
19283                                           ! 3456   return(0);
19284 53AC           30C0                       xor	al,al
19285 53AE           89EC                       mov	sp,bp
19286 53B0           5D                         pop	bp
19287 53B1           C3                         ret
19288                                           !BCC_EOS
19289                                           ! 3457 }
19290                                           ! 3458   void
19291                                           ! 3459 set_kbd_command_byte(command_byte)
19292                                           ! 3460   Bit8u command_byte;
19293                                           export	_set_kbd_command_byte
19294                       000053B2            _set_kbd_command_byte:
19295                                           !BCC_EOS
19296                                           ! 3461 {
19297                                           ! 3462   if ( inb(0x0064) & 0x02 )
19298 53B2           55                         push	bp
19299 53B3           89E5                       mov	bp,sp
19300                                           ! Debug: list int = const $64 (used reg = )
19301 53B5           B8                   0064  mov	ax,*$64
19302 53B8           50                         push	ax
19303                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19304 53B9           E8         B16D            call	_inb
19305 53BC           89EC                       mov	sp,bp
19306                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19307 53BE           24                     02  and	al,*2
19308 53C0           84C0                       test	al,al
19309 53C2           74           11            je  	.4A3
19310                       000053C4            .4A4:
19311                                           ! 3463     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
19312                                           ! Debug: list * char = .4A5+0 (used reg = )
19313 53C4           BB                   D30A  mov	bx,#.4A5
19314 53C7           53                         push	bx
19315                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19316 53C8           BB                   51C0  mov	bx,#_panic_msg_keyb_buffer_full
19317 53CB           53                         push	bx
19318                                           ! Debug: list int = const 7 (used reg = )
19319 53CC           B8                   0007  mov	ax,*7
19320 53CF           50                         push	ax
19321                                           ! Debug: func () void = bios_printf+0 (used reg = )
19322 53D0           E8         B566            call	_bios_printf
19323 53D3           89EC                       mov	sp,bp
19324                                           !BCC_EOS
19325                                           ! 3464   outb(0x0064, 0xD4);
19326                       000053D5            .4A3:
19327                                           ! Debug: list int = const $D4 (used reg = )
19328 53D5           B8                   00D4  mov	ax,#$D4
19329 53D8           50                         push	ax
19330                                           ! Debug: list int = const $64 (used reg = )
19331 53D9           B8                   0064  mov	ax,*$64
19332 53DC           50                         push	ax
19333                                           ! Debug: func () void = outb+0 (used reg = )
19334 53DD           E8         B15F            call	_outb
19335 53E0           89EC                       mov	sp,bp
19336                                           !BCC_EOS
19337                                           ! 3465   outb(0x0064, 0x60);
19338                                           ! Debug: list int = const $60 (used reg = )
19339 53E2           B8                   0060  mov	ax,*$60
19340 53E5           50                         push	ax
19341                                           ! Debug: list int = const $64 (used reg = )
19342 53E6           B8                   0064  mov	ax,*$64
19343 53E9           50                         push	ax
19344                                           ! Debug: func () void = outb+0 (used reg = )
19345 53EA           E8         B152            call	_outb
19346 53ED           89EC                       mov	sp,bp
19347                                           !BCC_EOS
19348                                           ! 3466   outb(0x0060, command_byte);
19349                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
19350 53EF           8A46         04            mov	al,4[bp]
19351 53F2           30E4                       xor	ah,ah
19352 53F4           50                         push	ax
19353                                           ! Debug: list int = const $60 (used reg = )
19354 53F5           B8                   0060  mov	ax,*$60
19355 53F8           50                         push	ax
19356                                           ! Debug: func () void = outb+0 (used reg = )
19357 53F9           E8         B143            call	_outb
19358 53FC           89EC                       mov	sp,bp
19359                                           !BCC_EOS
19360                                           ! 3467 }
19361 53FE           5D                         pop	bp
19362 53FF           C3                         ret
19363                                           ! 3468   void
19364                                           ! Register BX used in function set_kbd_command_byte
19365                                           ! 3469 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
19366                                           ! 3470   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
19367                                           export	_int09_function
19368                       00005400            _int09_function:
19369                                           !BCC_EOS
19370                                           ! 3471 {
19371                                           ! 3472   Bit8u scancode, asciicode, shift_flags;
19372                                           !BCC_EOS
19373                                           ! 3473   Bit8u mf2_flags, mf2_state;
19374                                           !BCC_EOS
19375                                           ! 3474   scancode = ( AX & 0x00ff );
19376 5400           55                         push	bp
19377 5401           89E5                       mov	bp,sp
19378 5403           83C4                   FA  add	sp,*-6
19379                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
19380 5406           8A46         12            mov	al,$12[bp]
19381                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
19382 5409           8846         FF            mov	-1[bp],al
19383                                           !BCC_EOS
19384                                           ! 3475   if (scancode == 0) {
19385                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
19386 540C           8A46         FF            mov	al,-1[bp]
19387 540F           84C0                       test	al,al
19388 5411           75           12            jne 	.4A6
19389                       00005413            .4A7:
19390                                           ! 3476     bios_printf(4, "KBD: int09 handler: AL=0\n");
19391                                           ! Debug: list * char = .4A8+0 (used reg = )
19392 5413           BB                   D2F0  mov	bx,#.4A8
19393 5416           53                         push	bx
19394                                           ! Debug: list int = const 4 (used reg = )
19395 5417           B8                   0004  mov	ax,*4
19396 541A           50                         push	ax
19397                                           ! Debug: func () void = bios_printf+0 (used reg = )
19398 541B           E8         B51B            call	_bios_printf
19399 541E           83C4                   04  add	sp,*4
19400                                           !BCC_EOS
19401                                           ! 3477     return;
19402 5421           89EC                       mov	sp,bp
19403 5423           5D                         pop	bp
19404 5424           C3                         ret
19405                                           !BCC_EOS
19406                                           ! 3478   }
19407                                           ! 3479   shift_flags = *((Bit8u *)(0x17));
19408                       00005425            .4A6:
19409                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+8-5] (used reg = )
19410 5425           A0         0017            mov	al,[$17]
19411 5428           8846         FD            mov	-3[bp],al
19412                                           !BCC_EOS
19413                                           ! 3480   mf2_flags = *((Bit8u *)(0x18));
19414                                           ! Debug: eq unsigned char = [+$18] to unsigned char mf2_flags = [S+8-6] (used reg = )
19415 542B           A0         0018            mov	al,[$18]
19416 542E           8846         FC            mov	-4[bp],al
19417                                           !BCC_EOS
19418                                           ! 3481   mf2_state = *((Bit8u *)(0x96));
19419                                           ! Debug: eq unsigned char = [+$96] to unsigned char mf2_state = [S+8-7] (used reg = )
19420 5431           A0         0096            mov	al,[$96]
19421 5434           8846         FB            mov	-5[bp],al
19422                                           !BCC_EOS
19423                                           ! 3482   asciicode = 0;
19424                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
19425 5437           30C0                       xor	al,al
19426 5439           8846         FE            mov	-2[bp],al
19427                                           !BCC_EOS
19428                                           ! 3483   switch (scancode) {
19429 543C           8A46         FF            mov	al,-1[bp]
19430 543F           E9         04B6            br 	.4AB
19431                                           ! 3484     case 0x3a:
19432                                           ! 3485       shift_flags ^= 0x40;
19433                       00005442            .4AC:
19434                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
19435 5442           8A46         FD            mov	al,-3[bp]
19436 5445           34                     40  xor	al,*$40
19437 5447           8846         FD            mov	-3[bp],al
19438                                           !BCC_EOS
19439                                           ! 3486       *((Bit8u *)(0x17)) = (shift_flags);
19440                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19441 544A           8A46         FD            mov	al,-3[bp]
19442 544D           A2         0017            mov	[$17],al
19443                                           !BCC_EOS
19444                                           ! 3487       mf2_flags |= 0x40;
19445                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
19446 5450           8A46         FC            mov	al,-4[bp]
19447 5453           0C                     40  or	al,*$40
19448 5455           8846         FC            mov	-4[bp],al
19449                                           !BCC_EOS
19450                                           ! 3488       *((Bit8u *)(0x18)) = (mf2_flags);
19451                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19452 5458           8A46         FC            mov	al,-4[bp]
19453 545B           A2         0018            mov	[$18],al
19454                                           !BCC_EOS
19455                                           ! 3489       break;
19456 545E           E9         04EE            br 	.4A9
19457                                           !BCC_EOS
19458                                           ! 3490     case 0xba:
19459                                           ! 3491       mf2_flags &= ~0x40;
19460                       00005461            .4AD:
19461                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
19462 5461           8A46         FC            mov	al,-4[bp]
19463 5464           24                     BF  and	al,#$BF
19464 5466           8846         FC            mov	-4[bp],al
19465                                           !BCC_EOS
19466                                           ! 3492       *((Bit8u *)(0x18)) = (mf2_flags);
19467                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19468 5469           8A46         FC            mov	al,-4[bp]
19469 546C           A2         0018            mov	[$18],al
19470                                           !BCC_EOS
19471                                           ! 3493       break;
19472 546F           E9         04DD            br 	.4A9
19473                                           !BCC_EOS
19474                                           ! 3494     case 0x2a:
19475                                           ! 3495       shift_flags |= 0x02;
19476                       00005472            .4AE:
19477                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
19478 5472           8A46         FD            mov	al,-3[bp]
19479 5475           0C                     02  or	al,*2
19480 5477           8846         FD            mov	-3[bp],al
19481                                           !BCC_EOS
19482                                           ! 3496       *((Bit8u *)(0x17)) = (shift_flags);
19483                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19484 547A           8A46         FD            mov	al,-3[bp]
19485 547D           A2         0017            mov	[$17],al
19486                                           !BCC_EOS
19487                                           ! 3497       break;
19488 5480           E9         04CC            br 	.4A9
19489                                           !BCC_EOS
19490                                           ! 3498     case 0xaa:
19491                                           ! 3499       shift_flags &= ~0x02;
19492                       00005483            .4AF:
19493                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
19494 5483           8A46         FD            mov	al,-3[bp]
19495 5486           24                     FD  and	al,#$FD
19496 5488           8846         FD            mov	-3[bp],al
19497                                           !BCC_EOS
19498                                           ! 3500       *((Bit8u *)(0x17)) = (shift_flags);
19499                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19500 548B           8A46         FD            mov	al,-3[bp]
19501 548E           A2         0017            mov	[$17],al
19502                                           !BCC_EOS
19503                                           ! 3501       break;
19504 5491           E9         04BB            br 	.4A9
19505                                           !BCC_EOS
19506                                           ! 3502     case 0x36:
19507                                           ! 3503       shift_flags |= 0x01;
19508                       00005494            .4B0:
19509                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
19510 5494           8A46         FD            mov	al,-3[bp]
19511 5497           0C                     01  or	al,*1
19512 5499           8846         FD            mov	-3[bp],al
19513                                           !BCC_EOS
19514                                           ! 3504       *((Bit8u *)(0x17)) = (shift_flags);
19515                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19516 549C           8A46         FD            mov	al,-3[bp]
19517 549F           A2         0017            mov	[$17],al
19518                                           !BCC_EOS
19519                                           ! 3505       break;
19520 54A2           E9         04AA            br 	.4A9
19521                                           !BCC_EOS
19522                                           ! 3506     case 0xb6:
19523                                           ! 3507       shift_flags &= ~0x01;
19524                       000054A5            .4B1:
19525                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
19526 54A5           8A46         FD            mov	al,-3[bp]
19527 54A8           24                     FE  and	al,#$FE
19528 54AA           8846         FD            mov	-3[bp],al
19529                                           !BCC_EOS
19530                                           ! 3508       *((Bit8u *)(0x17)) = (shift_flags);
19531                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19532 54AD           8A46         FD            mov	al,-3[bp]
19533 54B0           A2         0017            mov	[$17],al
19534                                           !BCC_EOS
19535                                           ! 3509       break;
19536 54B3           E9         0499            br 	.4A9
19537                                           !BCC_EOS
19538                                           ! 3510     case 0x1d:
19539                                           ! 3511       if ((mf2_state & 0x01) == 0) {
19540                       000054B6            .4B2:
19541                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19542 54B6           8A46         FB            mov	al,-5[bp]
19543 54B9           24                     01  and	al,*1
19544                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19545 54BB           84C0                       test	al,al
19546 54BD           75           35            jne 	.4B3
19547                       000054BF            .4B4:
19548                                           ! 3512         shift_flags |= 0x04;
19549                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19550 54BF           8A46         FD            mov	al,-3[bp]
19551 54C2           0C                     04  or	al,*4
19552 54C4           8846         FD            mov	-3[bp],al
19553                                           !BCC_EOS
19554                                           ! 3513         *((Bit8u *)(0x17)) = (shift_flags);
19555                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19556 54C7           8A46         FD            mov	al,-3[bp]
19557 54CA           A2         0017            mov	[$17],al
19558                                           !BCC_EOS
19559                                           ! 3514         if (mf2_state & 0x02) {
19560                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19561 54CD           8A46         FB            mov	al,-5[bp]
19562 54D0           24                     02  and	al,*2
19563 54D2           84C0                       test	al,al
19564 54D4           74           10            je  	.4B5
19565                       000054D6            .4B6:
19566                                           ! 3515           mf2_state |= 0x04;
19567                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
19568 54D6           8A46         FB            mov	al,-5[bp]
19569 54D9           0C                     04  or	al,*4
19570 54DB           8846         FB            mov	-5[bp],al
19571                                           !BCC_EOS
19572                                           ! 3516           *((Bit8u *)(0x96)) = (mf2_state);
19573                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19574 54DE           8A46         FB            mov	al,-5[bp]
19575 54E1           A2         0096            mov	[$96],al
19576                                           !BCC_EOS
19577                                           ! 3517         } else {
19578 54E4           EB           0E            jmp .4B7
19579                       000054E6            .4B5:
19580                                           ! 3518           mf2_flags |= 0x01;
19581                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
19582 54E6           8A46         FC            mov	al,-4[bp]
19583 54E9           0C                     01  or	al,*1
19584 54EB           8846         FC            mov	-4[bp],al
19585                                           !BCC_EOS
19586                                           ! 3519           *((Bit8u *)(0x18)) = (mf2_flags);
19587                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19588 54EE           8A46         FC            mov	al,-4[bp]
19589 54F1           A2         0018            mov	[$18],al
19590                                           !BCC_EOS
19591                                           ! 3520         }
19592                                           ! 3521       }
19593                       000054F4            .4B7:
19594                                           ! 3522       break;
19595                       000054F4            .4B3:
19596 54F4           E9         0458            br 	.4A9
19597                                           !BCC_EOS
19598                                           ! 3523     case 0x9d:
19599                                           ! 3524       if ((mf2_state & 0x01) == 0) {
19600                       000054F7            .4B8:
19601                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19602 54F7           8A46         FB            mov	al,-5[bp]
19603 54FA           24                     01  and	al,*1
19604                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19605 54FC           84C0                       test	al,al
19606 54FE           75           35            jne 	.4B9
19607                       00005500            .4BA:
19608                                           ! 3525         shift_flags &= ~0x04;
19609                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
19610 5500           8A46         FD            mov	al,-3[bp]
19611 5503           24                     FB  and	al,#$FB
19612 5505           8846         FD            mov	-3[bp],al
19613                                           !BCC_EOS
19614                                           ! 3526         *((Bi
19615                                           ! 3526 t8u *)(0x17)) = (shift_flags);
19616                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19617 5508           8A46         FD            mov	al,-3[bp]
19618 550B           A2         0017            mov	[$17],al
19619                                           !BCC_EOS
19620                                           ! 3527         if (mf2_state & 0x02) {
19621                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19622 550E           8A46         FB            mov	al,-5[bp]
19623 5511           24                     02  and	al,*2
19624 5513           84C0                       test	al,al
19625 5515           74           10            je  	.4BB
19626                       00005517            .4BC:
19627                                           ! 3528           mf2_state &= ~0x04;
19628                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
19629 5517           8A46         FB            mov	al,-5[bp]
19630 551A           24                     FB  and	al,#$FB
19631 551C           8846         FB            mov	-5[bp],al
19632                                           !BCC_EOS
19633                                           ! 3529           *((Bit8u *)(0x96)) = (mf2_state);
19634                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19635 551F           8A46         FB            mov	al,-5[bp]
19636 5522           A2         0096            mov	[$96],al
19637                                           !BCC_EOS
19638                                           ! 3530         } else {
19639 5525           EB           0E            jmp .4BD
19640                       00005527            .4BB:
19641                                           ! 3531           mf2_flags &= ~0x01;
19642                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19643 5527           8A46         FC            mov	al,-4[bp]
19644 552A           24                     FE  and	al,#$FE
19645 552C           8846         FC            mov	-4[bp],al
19646                                           !BCC_EOS
19647                                           ! 3532           *((Bit8u *)(0x18)) = (mf2_flags);
19648                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19649 552F           8A46         FC            mov	al,-4[bp]
19650 5532           A2         0018            mov	[$18],al
19651                                           !BCC_EOS
19652                                           ! 3533         }
19653                                           ! 3534       }
19654                       00005535            .4BD:
19655                                           ! 3535       break;
19656                       00005535            .4B9:
19657 5535           E9         0417            br 	.4A9
19658                                           !BCC_EOS
19659                                           ! 3536     case 0x38:
19660                                           ! 3537       shift_flags |= 0x08;
19661                       00005538            .4BE:
19662                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
19663 5538           8A46         FD            mov	al,-3[bp]
19664 553B           0C                     08  or	al,*8
19665 553D           8846         FD            mov	-3[bp],al
19666                                           !BCC_EOS
19667                                           ! 3538       *((Bit8u *)(0x17)) = (shift_flags);
19668                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19669 5540           8A46         FD            mov	al,-3[bp]
19670 5543           A2         0017            mov	[$17],al
19671                                           !BCC_EOS
19672                                           ! 3539       if (mf2_state & 0x02) {
19673                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19674 5546           8A46         FB            mov	al,-5[bp]
19675 5549           24                     02  and	al,*2
19676 554B           84C0                       test	al,al
19677 554D           74           10            je  	.4BF
19678                       0000554F            .4C0:
19679                                           ! 3540         mf2_state |= 0x08;
19680                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
19681 554F           8A46         FB            mov	al,-5[bp]
19682 5552           0C                     08  or	al,*8
19683 5554           8846         FB            mov	-5[bp],al
19684                                           !BCC_EOS
19685                                           ! 3541         *((Bit8u *)(0x96)) = (mf2_state);
19686                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19687 5557           8A46         FB            mov	al,-5[bp]
19688 555A           A2         0096            mov	[$96],al
19689                                           !BCC_EOS
19690                                           ! 3542       } else {
19691 555D           EB           0E            jmp .4C1
19692                       0000555F            .4BF:
19693                                           ! 3543         mf2_flags |= 0x02;
19694                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19695 555F           8A46         FC            mov	al,-4[bp]
19696 5562           0C                     02  or	al,*2
19697 5564           8846         FC            mov	-4[bp],al
19698                                           !BCC_EOS
19699                                           ! 3544         *((Bit8u *)(0x18)) = (mf2_flags);
19700                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19701 5567           8A46         FC            mov	al,-4[bp]
19702 556A           A2         0018            mov	[$18],al
19703                                           !BCC_EOS
19704                                           ! 3545       }
19705                                           ! 3546       break;
19706                       0000556D            .4C1:
19707 556D           E9         03DF            br 	.4A9
19708                                           !BCC_EOS
19709                                           ! 3547     case 0xb8:
19710                                           ! 3548       shift_flags &= ~0x08;
19711                       00005570            .4C2:
19712                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
19713 5570           8A46         FD            mov	al,-3[bp]
19714 5573           24                     F7  and	al,#$F7
19715 5575           8846         FD            mov	-3[bp],al
19716                                           !BCC_EOS
19717                                           ! 3549       *((Bit8u *)(0x17)) = (shift_flags);
19718                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19719 5578           8A46         FD            mov	al,-3[bp]
19720 557B           A2         0017            mov	[$17],al
19721                                           !BCC_EOS
19722                                           ! 3550       if (mf2_state & 0x02) {
19723                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19724 557E           8A46         FB            mov	al,-5[bp]
19725 5581           24                     02  and	al,*2
19726 5583           84C0                       test	al,al
19727 5585           74           10            je  	.4C3
19728                       00005587            .4C4:
19729                                           ! 3551         mf2_state &= ~0x08;
19730                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
19731 5587           8A46         FB            mov	al,-5[bp]
19732 558A           24                     F7  and	al,#$F7
19733 558C           8846         FB            mov	-5[bp],al
19734                                           !BCC_EOS
19735                                           ! 3552         *((Bit8u *)(0x96)) = (mf2_state);
19736                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19737 558F           8A46         FB            mov	al,-5[bp]
19738 5592           A2         0096            mov	[$96],al
19739                                           !BCC_EOS
19740                                           ! 3553       } else {
19741 5595           EB           0E            jmp .4C5
19742                       00005597            .4C3:
19743                                           ! 3554         mf2_flags &= ~0x02;
19744                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
19745 5597           8A46         FC            mov	al,-4[bp]
19746 559A           24                     FD  and	al,#$FD
19747 559C           8846         FC            mov	-4[bp],al
19748                                           !BCC_EOS
19749                                           ! 3555         *((Bit8u *)(0x18)) = (mf2_flags);
19750                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19751 559F           8A46         FC            mov	al,-4[bp]
19752 55A2           A2         0018            mov	[$18],al
19753                                           !BCC_EOS
19754                                           ! 3556       }
19755                                           ! 3557       break;
19756                       000055A5            .4C5:
19757 55A5           E9         03A7            br 	.4A9
19758                                           !BCC_EOS
19759                                           ! 3558     case 0x45:
19760                                           ! 3559       if ((mf2_state & 0x03) == 0) {
19761                       000055A8            .4C6:
19762                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19763 55A8           8A46         FB            mov	al,-5[bp]
19764 55AB           24                     03  and	al,*3
19765                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19766 55AD           84C0                       test	al,al
19767 55AF           75           1C            jne 	.4C7
19768                       000055B1            .4C8:
19769                                           ! 3560         mf2_flags |= 0x20;
19770                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
19771 55B1           8A46         FC            mov	al,-4[bp]
19772 55B4           0C                     20  or	al,*$20
19773 55B6           8846         FC            mov	-4[bp],al
19774                                           !BCC_EOS
19775                                           ! 3561         *((Bit8u *)(0x18)) = (mf2_flags);
19776                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19777 55B9           8A46         FC            mov	al,-4[bp]
19778 55BC           A2         0018            mov	[$18],al
19779                                           !BCC_EOS
19780                                           ! 3562         shift_flags ^= 0x20;
19781                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
19782 55BF           8A46         FD            mov	al,-3[bp]
19783 55C2           34                     20  xor	al,*$20
19784 55C4           8846         FD            mov	-3[bp],al
19785                                           !BCC_EOS
19786                                           ! 3563         *((Bit8u *)(0x17)) = (shift_flags);
19787                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19788 55C7           8A46         FD            mov	al,-3[bp]
19789 55CA           A2         0017            mov	[$17],al
19790                                           !BCC_EOS
19791                                           ! 3564       }
19792                                           ! 3565       break;
19793                       000055CD            .4C7:
19794 55CD           E9         037F            br 	.4A9
19795                                           !BCC_EOS
19796                                           ! 3566     case 0xc5:
19797                                           ! 3567       if ((mf2_state & 0x03) == 0) {
19798                       000055D0            .4C9:
19799                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19800 55D0           8A46         FB            mov	al,-5[bp]
19801 55D3           24                     03  and	al,*3
19802                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19803 55D5           84C0                       test	al,al
19804 55D7           75           0E            jne 	.4CA
19805                       000055D9            .4CB:
19806                                           ! 3568         mf2_flags &= ~0x20;
19807                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
19808 55D9           8A46         FC            mov	al,-4[bp]
19809 55DC           24                     DF  and	al,#$DF
19810 55DE           8846         FC            mov	-4[bp],al
19811                                           !BCC_EOS
19812                                           ! 3569         *((Bit8u *)(0x18)) = (mf2_flags);
19813                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19814 55E1           8A46         FC            mov	al,-4[bp]
19815 55E4           A2         0018            mov	[$18],al
19816                                           !BCC_EOS
19817                                           ! 3570       }
19818                                           ! 3571       break;
19819                       000055E7            .4CA:
19820 55E7           E9         0365            br 	.4A9
19821                                           !BCC_EOS
19822                                           ! 3572     case 0x46:
19823                                           ! 3573       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19824                       000055EA            .4CC:
19825                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19826 55EA           8A46         FB            mov	al,-5[bp]
19827 55ED           24                     02  and	al,*2
19828 55EF           84C0                       test	al,al
19829 55F1           75           12            jne 	.4CE
19830                       000055F3            .4CF:
19831                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19832 55F3           8A46         FB            mov	al,-5[bp]
19833 55F6           24                     10  and	al,*$10
19834 55F8           84C0                       test	al,al
19835 55FA           75           32            jne 	.4CD
19836                       000055FC            .4D0:
19837                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19838 55FC           8A46         FD            mov	al,-3[bp]
19839 55FF           24                     04  and	al,*4
19840 5601           84C0                       test	al,al
19841 5603           74           29            je  	.4CD
19842                       00005605            .4CE:
19843                                           ! 3574         mf2_state &= ~0x02;
19844                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
19845 5605           8A46         FB            mov	al,-5[bp]
19846 5608           24                     FD  and	al,#$FD
19847 560A           8846         FB            mov	-5[bp],al
19848                                           !BCC_EOS
19849                                           ! 3575         *((Bit8u *)(0x96)) = (mf2_state);
19850                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19851 560D           8A46         FB            mov	al,-5[bp]
19852 5610           A2         0096            mov	[$96],al
19853                                           !BCC_EOS
19854                                           ! 3576         *((Bit8u *)(0x71)) = (0x80);
19855                                           ! Debug: eq int = const $80 to unsigned char = [+$71] (used reg = )
19856 5613           B0                     80  mov	al,#$80
19857 5615           A2         0071            mov	[$71],al
19858                                           !BCC_EOS
19859                                           ! 3577         *((Bit16u *)(0x001C)) = (*((Bit16u *)(0x001A)));
19860                                           ! Debug: eq unsigned short = [+$1A] to unsigned short = [+$1C] (used reg = )
19861 5618           A1         001A            mov	ax,[$1A]
19862 561B           A3         001C            mov	[$1C],ax
19863                                           !BCC_EOS
19864                                           ! 3578 #asm
19865                                           !BCC_EOS
19866                                           !BCC_ASM
19867                       0000000E            _int09_function.BP	set	$E
19868                       00000008            .int09_function.BP	set	8
19869                       00000016            _int09_function.CX	set	$16
19870                       00000010            .int09_function.CX	set	$10
19871                       0000000A            _int09_function.DI	set	$A
19872                       00000004            .int09_function.DI	set	4
19873                       00000014            _int09_function.DX	set	$14
19874                       0000000E            .int09_function.DX	set	$E
19875                       00000002            _int09_function.mf2_flags	set	2
19876                       FFFFFFFC            .int09_function.mf2_flags	set	-4
19877                       0000000C            _int09_function.SI	set	$C
19878                       00000006            .int09_function.SI	set	6
19879                       00000001            _int09_function.mf2_state	set	1
19880                       FFFFFFFB            .int09_function.mf2_state	set	-5
19881                       00000018            _int09_function.AX	set	$18
19882                       00000012            .int09_function.AX	set	$12
19883                       00000004            _int09_function.asciicode	set	4
19884                       FFFFFFFE            .int09_function.asciicode	set	-2
19885                       00000005            _int09_function.scancode	set	5
19886                       FFFFFFFF            .int09_function.scancode	set	-1
19887                       00000010            _int09_function.SP	set	$10
19888                       0000000A            .int09_function.SP	set	$A
19889                       00000012            _int09_function.BX	set	$12
19890                       0000000C            .int09_function.BX	set	$C
19891                       00000003            _int09_function.shift_flags	set	3
19892                       FFFFFFFD            .int09_function.shift_flags	set	-3
19893 561E           CD                     1B          int #0x1B
19894                                           ! 3580 endasm
19895                                           !BCC_ENDASM
19896                                           !BCC_EOS
19897                                           ! 3581         enqueue_key(0, 0);
19898                                           ! Debug: list int = const 0 (used reg = )
19899 5620           31C0                       xor	ax,ax
19900 5622           50                         push	ax
19901                                           ! Debug: list int = const 0 (used reg = )
19902 5623           31C0                       xor	ax,ax
19903 5625           50                         push	ax
19904                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
19905 5626           E8         0349            call	_enqueue_key
19906 5629           83C4                   04  add	sp,*4
19907                                           !BCC_EOS
19908                                           ! 3582       } else {
19909 562C           EB           1C            jmp .4D1
19910                       0000562E            .4CD:
19911                                           ! 3583         mf2_flags |= 0x10;
19912                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
19913 562E           8A46         FC            mov	al,-4[bp]
19914 5631           0C                     10  or	al,*$10
19915 5633           8846         FC            mov	-4[bp],al
19916                                           !BCC_EOS
19917                                           ! 3584         *((Bit8u *)(0x18)) = (mf2_flags);
19918                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19919 5636           8A46         FC            mov	al,-4[bp]
19920 5639           A2         0018            mov	[$18],al
19921                                           !BCC_EOS
19922                                           ! 3585         shift_flags ^= 0x10;
19923                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
19924 563C           8A46         FD            mov	al,-3[bp]
19925 563F           34                     10  xor	al,*$10
19926 5641           8846         FD            mov	-3[bp],al
19927                                           !BCC_EOS
19928                                           ! 3586         *((Bit8u *)(0x17)) = (shift_flags);
19929                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19930 5644           8A46         FD            mov	al,-3[bp]
19931 5647           A2         0017            mov	[$17],al
19932                                           !BCC_EOS
19933                                           ! 3587       }
19934                                           ! 3588       break;
19935                       0000564A            .4D1:
19936 564A           E9         0302            br 	.4A9
19937                                           !BCC_EOS
19938                                           ! 3589     case 0xc6:
19939                                           ! 3590       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19940                       0000564D            .4D2:
19941                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19942 564D           8A46         FB            mov	al,-5[bp]
19943 5650           24                     02  and	al,*2
19944 5652           84C0                       test	al,al
19945 5654           75           12            jne 	.4D4
19946                       00005656            .4D5:
19947                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19948 5656           8A46         FB            mov	al,-5[bp]
19949 5659           24                     10  and	al,*$10
19950 565B           84C0                       test	al,al
19951 565D           75           0B            jne 	.4D3
19952                       0000565F            .4D6:
19953                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19954 565F           8A46         FD            mov	al,-3[bp]
19955 5662           24                     04  and	al,*4
19956 5664           84C0                       test	al,al
19957 5666           74           02            je  	.4D3
19958                       00005668            .4D4:
19959                                           ! 3591       } else {
19960 5668           EB           0E            jmp .4D7
19961                       0000566A            .4D3:
19962                                           ! 3592         mf2_flags &= ~0x10;
19963                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
19964 566A           8A46         FC            mov	al,-4[bp]
19965 566D           24                     EF  and	al,#$EF
19966 566F           8846         FC            mov	-4[bp],al
19967                                           !BCC_EOS
19968                                           ! 3593         *((Bit8u *)(0x18)) = (mf2_flags);
19969                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19970 5672           8A46         FC            mov	al,-4[bp]
19971 5675           A2         0018            mov	[$18],al
19972                                           !BCC_EOS
19973                                           ! 3594       }
19974                                           ! 3595       break;
19975                       00005678            .4D7:
19976 5678           E9         02D4            br 	.4A9
19977                                           !BCC_EOS
19978                                           ! 3596     default:
19979                                           ! 3597       if (scancode & 0x80) {
19980                       0000567B            .4D8:
19981                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
19982 567B           8A46         FF            mov	al,-1[bp]
19983 567E           24                     80  and	al,#$80
19984 5680           84C0                       test	al,al
19985 5682           74           03            je  	.4D9
19986                       00005684            .4DA:
19987                                           ! 3598         break;
19988 5684           E9         02C8            br 	.4A9
19989                                           !BCC_EOS
19990                                           ! 3599       }
19991                                           ! 3600       if (scancode > 0x58) {
19992                       00005687            .4D9:
19993                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
19994 5687           8A46         FF            mov	al,-1[bp]
19995 568A           3C                     58  cmp	al,*$58
19996 568C           76           18            jbe 	.4DB
19997                       0000568E            .4DC:
19998                                           ! 3601         bios_printf(4, "KBD: int09h_handler(): unknown scanc
19999                                           ! 3601 ode read: 0x%02x!\n", scancode);
20000                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
20001 568E           8A46         FF            mov	al,-1[bp]
20002 5691           30E4                       xor	ah,ah
20003 5693           50                         push	ax
20004                                           ! Debug: list * char = .4DD+0 (used reg = )
20005 5694           BB                   D2B9  mov	bx,#.4DD
20006 5697           53                         push	bx
20007                                           ! Debug: list int = const 4 (used reg = )
20008 5698           B8                   0004  mov	ax,*4
20009 569B           50                         push	ax
20010                                           ! Debug: func () void = bios_printf+0 (used reg = )
20011 569C           E8         B29A            call	_bios_printf
20012 569F           83C4                   06  add	sp,*6
20013                                           !BCC_EOS
20014                                           ! 3602         return;
20015 56A2           89EC                       mov	sp,bp
20016 56A4           5D                         pop	bp
20017 56A5           C3                         ret
20018                                           !BCC_EOS
20019                                           ! 3603       }
20020                                           ! 3604       if (scancode == 0x53) {
20021                       000056A6            .4DB:
20022                                           ! Debug: logeq int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20023 56A6           8A46         FF            mov	al,-1[bp]
20024 56A9           3C                     53  cmp	al,*$53
20025 56AB           75           14            jne 	.4DE
20026                       000056AD            .4DF:
20027                                           ! 3605         if ((shift_flags & 0x0f) == 0x0c) {
20028                                           ! Debug: and int = const $F to unsigned char shift_flags = [S+8-5] (used reg = )
20029 56AD           8A46         FD            mov	al,-3[bp]
20030 56B0           24                     0F  and	al,*$F
20031                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
20032 56B2           3C                     0C  cmp	al,*$C
20033 56B4           75           0B            jne 	.4E0
20034                       000056B6            .4E1:
20035                                           ! 3606           *((Bit16u *)(0x0072)) = (0x1234);
20036                                           ! Debug: eq int = const $1234 to unsigned short = [+$72] (used reg = )
20037 56B6           B8                   1234  mov	ax,#$1234
20038 56B9           A3         0072            mov	[$72],ax
20039                                           !BCC_EOS
20040                                           ! 3607 #asm
20041                                           !BCC_EOS
20042                                           !BCC_ASM
20043                       0000000E            _int09_function.BP	set	$E
20044                       00000008            .int09_function.BP	set	8
20045                       00000016            _int09_function.CX	set	$16
20046                       00000010            .int09_function.CX	set	$10
20047                       0000000A            _int09_function.DI	set	$A
20048                       00000004            .int09_function.DI	set	4
20049                       00000014            _int09_function.DX	set	$14
20050                       0000000E            .int09_function.DX	set	$E
20051                       00000002            _int09_function.mf2_flags	set	2
20052                       FFFFFFFC            .int09_function.mf2_flags	set	-4
20053                       0000000C            _int09_function.SI	set	$C
20054                       00000006            .int09_function.SI	set	6
20055                       00000001            _int09_function.mf2_state	set	1
20056                       FFFFFFFB            .int09_function.mf2_state	set	-5
20057                       00000018            _int09_function.AX	set	$18
20058                       00000012            .int09_function.AX	set	$12
20059                       00000004            _int09_function.asciicode	set	4
20060                       FFFFFFFE            .int09_function.asciicode	set	-2
20061                       00000005            _int09_function.scancode	set	5
20062                       FFFFFFFF            .int09_function.scancode	set	-1
20063                       00000010            _int09_function.SP	set	$10
20064                       0000000A            .int09_function.SP	set	$A
20065                       00000012            _int09_function.BX	set	$12
20066                       0000000C            .int09_function.BX	set	$C
20067                       00000003            _int09_function.shift_flags	set	3
20068                       FFFFFFFD            .int09_function.shift_flags	set	-3
20069 56BC           EA         E05B      F000            jmp 0xf000:post;
20070                                           ! 3609 endasm
20071                                           !BCC_ENDASM
20072                                           !BCC_EOS
20073                                           ! 3610         }
20074                                           ! 3611       }
20075                       000056C1            .4E0:
20076                                           ! 3612       set_DS(get_CS());
20077                       000056C1            .4DE:
20078                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
20079 56C1           E8         AF93            call	_get_CS
20080                                           ! Debug: list unsigned short = ax+0 (used reg = )
20081 56C4           50                         push	ax
20082                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20083 56C5           E8         AF95            call	_set_DS
20084 56C8           44                         inc	sp
20085 56C9           44                         inc	sp
20086                                           !BCC_EOS
20087                                           ! 3613       if (shift_flags & 0x08) {
20088                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
20089 56CA           8A46         FD            mov	al,-3[bp]
20090 56CD           24                     08  and	al,*8
20091 56CF           84C0                       test	al,al
20092 56D1           74           3D            je  	.4E2
20093                       000056D3            .4E3:
20094                                           ! 3614         asciicode = scan_to_scanascii[scancode].alt;
20095                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20096 56D3           8A46         FF            mov	al,-1[bp]
20097 56D6           30E4                       xor	ah,ah
20098 56D8           89C2                       mov	dx,ax
20099 56DA           D1E0                       shl	ax,*1
20100 56DC           D1E0                       shl	ax,*1
20101 56DE           01D0                       add	ax,dx
20102 56E0           D1E0                       shl	ax,*1
20103 56E2           89C3                       mov	bx,ax
20104 56E4           81C3                 01AF  add	bx,#_scan_to_scanascii
20105                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
20106 56E8           8A47         06            mov	al,6[bx]
20107 56EB           8846         FE            mov	-2[bp],al
20108                                           !BCC_EOS
20109                                           ! 3615         scancode = scan_to_scanascii[scancode].alt >> 8;
20110                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20111 56EE           8A46         FF            mov	al,-1[bp]
20112 56F1           30E4                       xor	ah,ah
20113 56F3           89C2                       mov	dx,ax
20114 56F5           D1E0                       shl	ax,*1
20115 56F7           D1E0                       shl	ax,*1
20116 56F9           01D0                       add	ax,dx
20117 56FB           D1E0                       shl	ax,*1
20118 56FD           89C3                       mov	bx,ax
20119 56FF           81C3                 01AF  add	bx,#_scan_to_scanascii
20120                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
20121 5703           8B47         06            mov	ax,6[bx]
20122 5706           88E0                       mov	al,ah
20123 5708           30E4                       xor	ah,ah
20124                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20125 570A           8846         FF            mov	-1[bp],al
20126                                           !BCC_EOS
20127                                           ! 3616       } else if (shift_flags & 0x04) {
20128 570D           E9         01AD            br 	.4E4
20129                       00005710            .4E2:
20130                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20131 5710           8A46         FD            mov	al,-3[bp]
20132 5713           24                     04  and	al,*4
20133 5715           84C0                       test	al,al
20134 5717           74           3D            je  	.4E5
20135                       00005719            .4E6:
20136                                           ! 3617         asciicode = scan_to_scanascii[scancode].control;
20137                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20138 5719           8A46         FF            mov	al,-1[bp]
20139 571C           30E4                       xor	ah,ah
20140 571E           89C2                       mov	dx,ax
20141 5720           D1E0                       shl	ax,*1
20142 5722           D1E0                       shl	ax,*1
20143 5724           01D0                       add	ax,dx
20144 5726           D1E0                       shl	ax,*1
20145 5728           89C3                       mov	bx,ax
20146 572A           81C3                 01AF  add	bx,#_scan_to_scanascii
20147                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
20148 572E           8A47         04            mov	al,4[bx]
20149 5731           8846         FE            mov	-2[bp],al
20150                                           !BCC_EOS
20151                                           ! 3618         scancode = scan_to_scanascii[scancode].control >> 8;
20152                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20153 5734           8A46         FF            mov	al,-1[bp]
20154 5737           30E4                       xor	ah,ah
20155 5739           89C2                       mov	dx,ax
20156 573B           D1E0                       shl	ax,*1
20157 573D           D1E0                       shl	ax,*1
20158 573F           01D0                       add	ax,dx
20159 5741           D1E0                       shl	ax,*1
20160 5743           89C3                       mov	bx,ax
20161 5745           81C3                 01AF  add	bx,#_scan_to_scanascii
20162                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
20163 5749           8B47         04            mov	ax,4[bx]
20164 574C           88E0                       mov	al,ah
20165 574E           30E4                       xor	ah,ah
20166                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20167 5750           8846         FF            mov	-1[bp],al
20168                                           !BCC_EOS
20169                                           ! 3619       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
20170 5753           E9         0167            br 	.4E7
20171                       00005756            .4E5:
20172                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20173 5756           8A46         FB            mov	al,-5[bp]
20174 5759           24                     02  and	al,*2
20175                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20176 575B           84C0                       test	al,al
20177 575D           74           32            je  	.4E8
20178                       0000575F            .4EA:
20179                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
20180 575F           8A46         FF            mov	al,-1[bp]
20181 5762           3C                     47  cmp	al,*$47
20182 5764           72           2B            jb  	.4E8
20183                       00005766            .4EB:
20184                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20185 5766           8A46         FF            mov	al,-1[bp]
20186 5769           3C                     53  cmp	al,*$53
20187 576B           77           24            ja  	.4E8
20188                       0000576D            .4E9:
20189                                           ! 3620         asciicode = 0xe0;
20190                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
20191 576D           B0                     E0  mov	al,#$E0
20192 576F           8846         FE            mov	-2[bp],al
20193                                           !BCC_EOS
20194                                           ! 3621         scancode = scan_to_scanascii[scancode].normal >> 8;
20195                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20196 5772           8A46         FF            mov	al,-1[bp]
20197 5775           30E4                       xor	ah,ah
20198 5777           89C2                       mov	dx,ax
20199 5779           D1E0                       shl	ax,*1
20200 577B           D1E0                       shl	ax,*1
20201 577D           01D0                       add	ax,dx
20202 577F           D1E0                       shl	ax,*1
20203 5781           89C3                       mov	bx,ax
20204                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20205 5783           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20206 5787           88E0                       mov	al,ah
20207 5789           30E4                       xor	ah,ah
20208                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20209 578B           8846         FF            mov	-1[bp],al
20210                                           !BCC_EOS
20211                                           ! 3622       } else if (shift_flags & 0x03) {
20212 578E           E9         012C            br 	.4EC
20213                       00005791            .4E8:
20214                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
20215 5791           8A46         FD            mov	al,-3[bp]
20216 5794           24                     03  and	al,*3
20217 5796           84C0                       test	al,al
20218 5798         0F84         0092            beq 	.4ED
20219                       0000579C            .4EE:
20220                                           ! 3623         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20221                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20222 579C           8A46         FF            mov	al,-1[bp]
20223 579F           30E4                       xor	ah,ah
20224 57A1           89C2                       mov	dx,ax
20225 57A3           D1E0                       shl	ax,*1
20226 57A5           D1E0                       shl	ax,*1
20227 57A7           01D0                       add	ax,dx
20228 57A9           D1E0                       shl	ax,*1
20229 57AB           89C3                       mov	bx,ax
20230 57AD           81C3                 01AF  add	bx,#_scan_to_scanascii
20231                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20232 57B1           8A46         FD            mov	al,-3[bp]
20233 57B4           2247         08            and	al,8[bx]
20234 57B7           84C0                       test	al,al
20235 57B9           74           36            je  	.4EF
20236                       000057BB            .4F0:
20237                                           ! 3624           asciicode = scan_to_scanascii[scancode].normal;
20238                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20239 57BB           8A46         FF            mov	al,-1[bp]
20240 57BE           30E4                       xor	ah,ah
20241 57C0           89C2                       mov	dx,ax
20242 57C2           D1E0                       shl	ax,*1
20243 57C4           D1E0                       shl	ax,*1
20244 57C6           01D0                       add	ax,dx
20245 57C8           D1E0                       shl	ax,*1
20246 57CA           89C3                       mov	bx,ax
20247                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20248 57CC           8A87       01AF            mov	al,_scan_to_scanascii[bx]
20249 57D0           8846         FE            mov	-2[bp],al
20250                                           !BCC_EOS
20251                                           ! 3625           scancode = scan_to_scanascii[scancode].normal >> 8;
20252                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20253 57D3           8A46         FF            mov	al,-1[bp]
20254 57D6           30E4                       xor	ah,ah
20255 57D8           89C2                       mov	dx,ax
20256 57DA           D1E0                       shl	ax,*1
20257 57DC           D1E0                       shl	ax,*1
20258 57DE           01D0                       add	ax,dx
20259 57E0           D1E0                       shl	ax,*1
20260 57E2           89C3                       mov	bx,ax
20261                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20262 57E4           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20263 57E8           88E0                       mov	al,ah
20264 57EA           30E4                       xor	ah,ah
20265                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20266 57EC           8846         FF            mov	-1[bp],al
20267                                           !BCC_EOS
20268                                           ! 3626         } else {
20269 57EF           EB           3A            jmp .4F1
20270                       000057F1            .4EF:
20271                                           ! 3627           asciicode = scan_to_scanascii[scancode].shift;
20272                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20273 57F1           8A46         FF            mov	al,-1[bp]
20274 57F4           30E4                       xor	ah,ah
20275 57F6           89C2                       mov	dx,ax
20276 57F8           D1E0                       shl	ax,*1
20277 57FA           D1E0                       shl	ax,*1
20278 57FC           01D0                       add	ax,dx
20279 57FE           D1E0                       shl	ax,*1
20280 5800           89C3                       mov	bx,ax
20281 5802           81C3                 01AF  add	bx,#_scan_to_scanascii
20282                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20283 5806           8A47         02            mov	al,2[bx]
20284 5809           8846         FE            mov	-2[bp],al
20285                                           !BCC_EOS
20286                                           ! 3628           scancode = scan_to_scanascii[scancode].shift >> 8;
20287                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20288 580C           8A46         FF            mov	al,-1[bp]
20289 580F           30E4                       xor	ah,ah
20290 5811           89C2                       mov	dx,ax
20291 5813           D1E0                       shl	ax,*1
20292 5815           D1E0                       shl	ax,*1
20293 5817           01D0                       add	ax,dx
20294 5819           D1E0                       shl	ax,*1
20295 581B           89C3                       mov	bx,ax
20296 581D           81C3                 01AF  add	bx,#_scan_to_scanascii
20297                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20298 5821           8B47         02            mov	ax,2[bx]
20299 5824           88E0                       mov	al,ah
20300 5826           30E4                       xor	ah,ah
20301                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20302 5828           8846         FF            mov	-1[bp],al
20303                                           !BCC_EOS
20304                                           ! 3629         }
20305                                           ! 3630       } else {
20306                       0000582B            .4F1:
20307 582B           E9         008F            br 	.4F2
20308                       0000582E            .4ED:
20309                                           ! 3631         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20310                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20311 582E           8A46         FF            mov	al,-1[bp]
20312 5831           30E4                       xor	ah,ah
20313 5833           89C2                       mov	dx,ax
20314 5835           D1E0                       shl	ax,*1
20315 5837           D1E0                       shl	ax,*1
20316 5839           01D0                       add	ax,dx
20317 583B           D1E0                       shl	ax,*1
20318 583D           89C3                       mov	bx,ax
20319 583F           81C3                 01AF  add	bx,#_scan_to_scanascii
20320                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20321 5843           8A46         FD            mov	al,-3[bp]
20322 5846           2247         08            and	al,8[bx]
20323 5849           84C0                       test	al,al
20324 584B           74           3C            je  	.4F3
20325                       0000584D            .4F4:
20326                                           ! 3632           asciicode = scan_to_scanascii[scancode].shift;
20327                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20328 584D           8A46         FF            mov	al,-1[bp]
20329 5850           30E4                       xor	ah,ah
20330 5852           89C2                       mov	dx,ax
20331 5854           D1E0                       shl	ax,*1
20332 5856           D1E0                       shl	ax,*1
20333 5858           01D0                       add	ax,dx
20334 585A           D1E0                       shl	ax,*1
20335 585C           89C3                       mov	bx,ax
20336 585E           81C3                 01AF  add	bx,#_scan_to_scanascii
20337                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20338 5862           8A47         02            mov	al,2[bx]
20339 5865           8846         FE            mov	-2[bp],al
20340                                           !BCC_EOS
20341                                           ! 3633           scancode = scan_to_scanascii[scancode].shift >> 8;
20342                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20343 5868           8A46         FF            mov	al,-1[bp]
20344 586B           30E4                       xor	ah,ah
20345 586D           89C2                       mov	dx,ax
20346 586F           D1E0                       shl	ax,*1
20347 5871           D1E0                       shl	ax,*1
20348 5873           01D0                       add	ax,dx
20349 5875           D1E0                       shl	ax,*1
20350 5877           89C3                       mov	bx,ax
20351 5879           81C3                 01AF  add	bx,#_scan_to_scanascii
20352                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20353 587D           8B47         02            mov	ax,2[bx]
20354 5880           88E0                       mov	al,ah
20355 5882           30E4                       xor	ah,ah
20356                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20357 5884           8846         FF            mov	-1[bp],al
20358                                           !BCC_EOS
20359                                           ! 3634         } else {
20360 5887           EB           34            jmp .4F5
20361                       00005889            .4F3:
20362                                           ! 3635           asciicode = scan_to_scanascii[scancode].normal;
20363                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20364 5889           8A46         FF            mov	al,-1[bp]
20365 588C           30E4                       xor	ah,ah
20366 588E           89C2                       mov	dx,ax
20367 5890           D1E0                       shl	ax,*1
20368 5892           D1E0                       shl	ax,*1
20369 5894           01D0                       add	ax,dx
20370 5896           D1E0                       shl	ax,*1
20371 5898           89C3                       mov	bx,ax
20372                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20373 589A           8A87       01AF            mov	al,_scan_to_scanascii[bx]
20374 589E           8846         FE            mov	-2[bp],al
20375                                           !BCC_EOS
20376                                           ! 3636           scancode = scan_to_scanascii[scancode].normal >> 8;
20377                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20378 58A1           8A46         FF            mov	al,-1[bp]
20379 58A4           30E4                       xor	ah,ah
20380 58A6           89C2                       mov	dx,ax
20381 58A8           D1E0                       shl	ax,*1
20382 58AA           D1E0                       shl	ax,*1
20383 58AC           01D0                       add	ax,dx
20384 58AE           D1E0                       shl	ax,*1
20385 58B0           89C3                       mov	bx,ax
20386                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20387 58B2           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20388 58B6           88E0                       mov	al,ah
20389 58B8           30E4                       xor	ah,ah
20390                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20391 58BA           8846         FF            mov	-1[bp],al
20392                                           !BCC_EOS
20393                                           ! 3637         }
20394                                           ! 3638       }
20395                       000058BD            .4F5:
20396                                           ! 3639       set_DS(0x40);
20397                       000058BD            .4F2:
20398                       000058BD            .4EC:
20399                       000058BD            .4E7:
20400                       000058BD            .4E4:
20401                                           ! Debug: list int = const $40 (used reg = )
20402 58BD           B8                   0040  mov	ax,*$40
20403 58C0           50                         push	ax
20404                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20405 58C1           E8         AD99            call	_set_DS
20406 58C4           44                         inc	sp
20407 58C5           44                         inc	sp
20408                                           !BCC_EOS
20409                                           ! 3640       if (scancode==0 && asciicode==0) {
20410                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
20411 58C6           8A46         FF            mov	al,-1[bp]
20412 58C9           84C0                       test	al,al
20413 58CB           75           15            jne 	.4F6
20414                       000058CD            .4F8:
20415                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
20416 58CD           8A46         FE            mov	al,-2[bp]
20417 58D0           84C0                       test	al,al
20418 58D2           75           0E            jne 	.4F6
20419                       000058D4            .4F7:
20420                                           ! 3641         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
20421                                           ! Debug: list * char = .4F9+0 (used reg = )
20422 58D4           BB                   D282  mov	bx,#.4F9
20423 58D7           53                         push	bx
20424                                           ! Debug: list int = const 4 (used reg = )
20425 58D8           B8                   0004  mov	ax,*4
20426 58DB           50                         push	ax
20427                                           ! Debug: func () void = bios_printf+0 (used reg = )
20428 58DC           E8         B05A            call	_bios_printf
20429 58DF           83C4                   04  add	sp,*4
20430                                           !BCC_EOS
20431                                           ! 3642       }
20432                                           ! 3643       enqueue_key(scancode, asciicode);
20433                       000058E2            .4F6:
20434                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
20435 58E2           8A46         FE            mov	al,-2[bp]
20436 58E5           30E4                       xor	ah,ah
20437 58E7           50                         push	ax
20438                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
20439 58E8           8A46         FF            mov	al,-1[bp]
20440 58EB           30E4                       xor	ah,ah
20441 58ED           50                         push	ax
20442                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20443 58EE           E8         0081            call	_enqueue_key
20444 58F1           83C4                   04  add	sp,*4
20445                                           !BCC_EOS
20446                                           ! 3644       break;
20447 58F4           EB           59            jmp .4A9
20448                                           !BCC_EOS
20449                                           ! 3645   }
20450                                           ! 3646   if ((scancode & 0x7f) != 0x1d) {
20451 58F6           EB           57            jmp .4A9
20452                       000058F8            .4AB:
20453 58F8           2C                     1D  sub	al,*$1D
20454 58FA         0F84         FBB8            beq 	.4B2
20455 58FE           2C                     0D  sub	al,*$D
20456 5900         0F84         FB6E            beq 	.4AE
20457 5904           2C                     0C  sub	al,*$C
20458 5906         0F84         FB8A            beq 	.4B0
20459 590A           2C                     02  sub	al,*2
20460 590C         0F84         FC28            beq 	.4BE
20461 5910           2C                     02  sub	al,*2
20462 5912         0F84         FB2C            beq 	.4AC
20463 5916           2C                     0B  sub	al,*$B
20464 5918         0F84         FC8C            beq 	.4C6
20465 591C           2C                     01  sub	al,*1
20466 591E         0F84         FCC8            beq 	.4CC
20467 5922           2C                     57  sub	al,*$57
20468 5924         0F84         FBCF            beq 	.4B8
20469 5928           2C                     0D  sub	al,*$D
20470 592A         0F84         FB55            beq 	.4AF
20471 592E           2C                     0C  sub	al,*$C
20472 5930         0F84         FB71            beq 	.4B1
20473 5934           2C                     02  sub	al,*2
20474 5936         0F84         FC36            beq 	.4C2
20475 593A           2C                     02  sub	al,*2
20476 593C         0F84         FB21            beq 	.4AD
20477 5940           2C                     0B  sub	al,*$B
20478 5942         0F84         FC8A            beq 	.4C9
20479 5946           2C                     01  sub	al,*1
20480 5948         0F84         FD01            beq 	.4D2
20481 594C           E9         FD2C            br 	.4D8
20482                       0000594F            .4A9:
20483                       FFFFFFF8            ..FFF2	=	-8
20484                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
20485 594F           8A46         FF            mov	al,-1[bp]
20486 5952           24                     7F  and	al,*$7F
20487                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
20488 5954           3C                     1D  cmp	al,*$1D
20489 5956           74           08            je  	.4FA
20490                       00005958            .4FB:
20491                                           ! 3647     mf2_state &= ~0x01;
20492                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
20493 5958           8A46         FB            mov	al,-5[bp]
20494 595B           24                     FE  and	al,#$FE
20495 595D           8846         FB            mov	-5[bp],al
20496                                           !BCC_EOS
20497                                           ! 3648   }
20498                                           ! 3649   mf2_state &= ~0x02;
20499                       00005960            .4FA:
20500                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
20501 5960           8A46         FB            mov	al,-5[bp]
20502 5963           24                     FD  and	al,#$FD
20503 5965           8846         FB            mov	-5[bp],al
20504                                           !BCC_EOS
20505                                           ! 3650   *((Bit8u *)(0x96)) = (mf2_state);
20506                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
20507 5968           8A46         FB            mov	al,-5[bp]
20508 596B           A2         0096            mov	[$96],al
20509                                           !BCC_EOS
20510                                           ! 3651 }
20511 596E           89EC                       mov	sp,bp
20512 5970           5D                         pop	bp
20513 5971           C3                         ret
20514                                           ! 3652   unsigned int
20515                                           ! Register BX used in function int09_function
20516                                           ! 3653 enqueue_key(scan_code, ascii_code)
20517                                           ! 3654   Bit8u scan_code, ascii_code;
20518                                           export	_enqueue_key
20519                       00005972            _enqueue_key:
20520                                           !BCC_EOS
20521                                           ! 3655 {
20522                                           ! 3656   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail, old_ds;
20523                                           !BCC_EOS
20524                                           ! 3657   old_ds = set_DS(0x40);
20525 5972           55                         push	bp
20526 5973           89E5                       mov	bp,sp
20527 5975           83C4                   F4  add	sp,*-$C
20528                                           ! Debug: list int = const $40 (used reg = )
20529 5978           B8                   0040  mov	ax,*$40
20530 597B           50                         push	ax
20531                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20532 597C           E8         ACDE            call	_set_DS
20533 597F           44                         inc	sp
20534 5980           44                         inc	sp
20535                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$E-$E] (used reg = )
20536 5981           8946         F4            mov	-$C[bp],ax
20537                                           !BCC_EOS
20538                                           ! 3658   buffer_start = *((Bit16u *)(0x0080));
20539                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$E-4] (used reg = )
20540 5984           A1         0080            mov	ax,[$80]
20541 5987           8946         FE            mov	-2[bp],ax
20542                                           !BCC_EOS
20543                                           ! 3659   buffer_end = *((Bit16u *)
20544                                           ! 3659 (0x0082));
20545                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$E-6] (used reg = )
20546 598A           A1         0082            mov	ax,[$82]
20547 598D           8946         FC            mov	-4[bp],ax
20548                                           !BCC_EOS
20549                                           ! 3660   buffer_head = *((Bit16u *)(0x001A));
20550                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20551 5990           A1         001A            mov	ax,[$1A]
20552 5993           8946         FA            mov	-6[bp],ax
20553                                           !BCC_EOS
20554                                           ! 3661   buffer_tail = *((Bit16u *)(0x001C));
20555                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20556 5996           A1         001C            mov	ax,[$1C]
20557 5999           8946         F8            mov	-8[bp],ax
20558                                           !BCC_EOS
20559                                           ! 3662   temp_tail = buffer_tail;
20560                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short temp_tail = [S+$E-$C] (used reg = )
20561 599C           8B46         F8            mov	ax,-8[bp]
20562 599F           8946         F6            mov	-$A[bp],ax
20563                                           !BCC_EOS
20564                                           ! 3663   buffer_tail += 2;
20565                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20566 59A2           8B46         F8            mov	ax,-8[bp]
20567 59A5           40                         inc	ax
20568 59A6           40                         inc	ax
20569 59A7           8946         F8            mov	-8[bp],ax
20570                                           !BCC_EOS
20571                                           ! 3664   if (buffer_tail >= buffer_end)
20572                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20573 59AA           8B46         F8            mov	ax,-8[bp]
20574 59AD           3B46         FC            cmp	ax,-4[bp]
20575 59B0           72           06            jb  	.4FC
20576                       000059B2            .4FD:
20577                                           ! 3665     buffer_tail = buffer_start;
20578                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20579 59B2           8B46         FE            mov	ax,-2[bp]
20580 59B5           8946         F8            mov	-8[bp],ax
20581                                           !BCC_EOS
20582                                           ! 3666   if (buffer_tail == buffer_head) {
20583                       000059B8            .4FC:
20584                                           ! Debug: logeq unsigned short buffer_head = [S+$E-8] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20585 59B8           8B46         F8            mov	ax,-8[bp]
20586 59BB           3B46         FA            cmp	ax,-6[bp]
20587 59BE           75           0E            jne 	.4FE
20588                       000059C0            .4FF:
20589                                           ! 3667     set_DS(old_ds);
20590                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20591 59C0           FF76         F4            push	-$C[bp]
20592                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20593 59C3           E8         AC97            call	_set_DS
20594 59C6           44                         inc	sp
20595 59C7           44                         inc	sp
20596                                           !BCC_EOS
20597                                           ! 3668     return(0);
20598 59C8           31C0                       xor	ax,ax
20599 59CA           89EC                       mov	sp,bp
20600 59CC           5D                         pop	bp
20601 59CD           C3                         ret
20602                                           !BCC_EOS
20603                                           ! 3669   }
20604                                           ! 3670   *((Bit8u *)(temp_tail)) = (ascii_code);
20605                       000059CE            .4FE:
20606 59CE           8B5E         F6            mov	bx,-$A[bp]
20607                                           ! Debug: eq unsigned char ascii_code = [S+$E+4] to unsigned char = [bx+0] (used reg = )
20608 59D1           8A46         06            mov	al,6[bp]
20609 59D4           8807                       mov	[bx],al
20610                                           !BCC_EOS
20611                                           ! 3671   *((Bit8u *)(temp_tail+1)) = (scan_code);
20612                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
20613 59D6           8B46         F6            mov	ax,-$A[bp]
20614                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
20615 59D9           89C3                       mov	bx,ax
20616                                           ! Debug: eq unsigned char scan_code = [S+$E+2] to unsigned char = [bx+1] (used reg = )
20617 59DB           8A46         04            mov	al,4[bp]
20618 59DE           8847         01            mov	1[bx],al
20619                                           !BCC_EOS
20620                                           ! 3672   *((Bit16u *)(0x001C)) = (buffer_tail);
20621                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short = [+$1C] (used reg = )
20622 59E1           8B46         F8            mov	ax,-8[bp]
20623 59E4           A3         001C            mov	[$1C],ax
20624                                           !BCC_EOS
20625                                           ! 3673   set_DS(old_ds);
20626                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20627 59E7           FF76         F4            push	-$C[bp]
20628                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20629 59EA           E8         AC70            call	_set_DS
20630 59ED           44                         inc	sp
20631 59EE           44                         inc	sp
20632                                           !BCC_EOS
20633                                           ! 3674   return(1);
20634 59EF           B8                   0001  mov	ax,*1
20635 59F2           89EC                       mov	sp,bp
20636 59F4           5D                         pop	bp
20637 59F5           C3                         ret
20638                                           !BCC_EOS
20639                                           ! 3675 }
20640                                           ! 3676   void
20641                                           ! Register BX used in function enqueue_key
20642                                           ! 3677 int74_function(make_farcall, Z, Y, X, status)
20643                                           ! 3678   Bit16u make_farcall, Z, Y, X, status;
20644                                           export	_int74_function
20645                       000059F6            _int74_function:
20646                                           !BCC_EOS
20647                                           ! 3679 {
20648                                           ! 3680   Bit8u in_byte, index, package_count;
20649                                           !BCC_EOS
20650                                           ! 3681   Bit8u mouse_flags_1, mouse_flags_2;
20651                                           !BCC_EOS
20652                                           ! 3682 ;
20653 59F6           55                         push	bp
20654 59F7           89E5                       mov	bp,sp
20655 59F9           83C4                   FA  add	sp,*-6
20656                                           !BCC_EOS
20657                                           ! 3683   make_farcall = 0;
20658                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+8+2] (used reg = )
20659 59FC           31C0                       xor	ax,ax
20660 59FE           8946         04            mov	4[bp],ax
20661                                           !BCC_EOS
20662                                           ! 3684   in_byte = inb(0x0064);
20663                                           ! Debug: list int = const $64 (used reg = )
20664 5A01           B8                   0064  mov	ax,*$64
20665 5A04           50                         push	ax
20666                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20667 5A05           E8         AB21            call	_inb
20668 5A08           44                         inc	sp
20669 5A09           44                         inc	sp
20670                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20671 5A0A           8846         FF            mov	-1[bp],al
20672                                           !BCC_EOS
20673                                           ! 3685   if ((in_byte & 0x21) != 0x21) {
20674                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+8-3] (used reg = )
20675 5A0D           8A46         FF            mov	al,-1[bp]
20676 5A10           24                     21  and	al,*$21
20677                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20678 5A12           3C                     21  cmp	al,*$21
20679 5A14           74           04            je  	.500
20680                       00005A16            .501:
20681                                           ! 3686     return;
20682 5A16           89EC                       mov	sp,bp
20683 5A18           5D                         pop	bp
20684 5A19           C3                         ret
20685                                           !BCC_EOS
20686                                           ! 3687   }
20687                                           ! 3688   in_byte = inb(0x0060);
20688                       00005A1A            .500:
20689                                           ! Debug: list int = const $60 (used reg = )
20690 5A1A           B8                   0060  mov	ax,*$60
20691 5A1D           50                         push	ax
20692                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20693 5A1E           E8         AB08            call	_inb
20694 5A21           44                         inc	sp
20695 5A22           44                         inc	sp
20696                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20697 5A23           8846         FF            mov	-1[bp],al
20698                                           !BCC_EOS
20699                                           ! 3689 ;
20700                                           !BCC_EOS
20701                                           ! 3690   mouse_flags_1 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1));
20702                                           ! Debug: eq unsigned char = [+$26] to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20703 5A26           A0         0026            mov	al,[$26]
20704 5A29           8846         FC            mov	-4[bp],al
20705                                           !BCC_EOS
20706                                           ! 3691   mouse_flags_2 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag2));
20707                                           ! Debug: eq unsigned char = [+$27] to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20708 5A2C           A0         0027            mov	al,[$27]
20709 5A2F           8846         FB            mov	-5[bp],al
20710                                           !BCC_EOS
20711                                           ! 3692   if ((mouse_flags_2 & 0x80) != 0x80) {
20712                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20713 5A32           8A46         FB            mov	al,-5[bp]
20714 5A35           24                     80  and	al,#$80
20715                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
20716 5A37           3C                     80  cmp	al,#$80
20717 5A39           74           04            je  	.502
20718                       00005A3B            .503:
20719                                           ! 3693       return;
20720 5A3B           89EC                       mov	sp,bp
20721 5A3D           5D                         pop	bp
20722 5A3E           C3                         ret
20723                                           !BCC_EOS
20724                                           ! 3694   }
20725                                           ! 3695   package_count = mouse_flags_2 & 0x07;
20726                       00005A3F            .502:
20727                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20728 5A3F           8A46         FB            mov	al,-5[bp]
20729 5A42           24                     07  and	al,*7
20730                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+8-5] (used reg = )
20731 5A44           8846         FD            mov	-3[bp],al
20732                                           !BCC_EOS
20733                                           ! 3696   index = mouse_flags_1 & 0x07;
20734                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20735 5A47           8A46         FC            mov	al,-4[bp]
20736 5A4A           24                     07  and	al,*7
20737                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+8-4] (used reg = )
20738 5A4C           8846         FE            mov	-2[bp],al
20739                                           !BCC_EOS
20740                                           ! 3697   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[index])) = (in_byte);
20741                                           ! Debug: ptradd unsigned char index = [S+8-4] to [8] unsigned char = const $28 (used reg = )
20742 5A4F           8A46         FE            mov	al,-2[bp]
20743 5A52           30E4                       xor	ah,ah
20744 5A54           89C3                       mov	bx,ax
20745                                           ! Debug: address unsigned char = [bx+$28] (used reg = )
20746                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$28 (used reg = )
20747                                           ! Debug: eq unsigned char in_byte = [S+8-3] to unsigned char = [bx+$28] (used reg = )
20748 5A56           8A46         FF            mov	al,-1[bp]
20749 5A59           8847         28            mov	$28[bx],al
20750                                           !BCC_EOS
20751                                           ! 3698   if (index >= package_count) {
20752                                           ! Debug: ge unsigned char package_count = [S+8-5] to unsigned char index = [S+8-4] (used reg = )
20753 5A5C           8A46         FE            mov	al,-2[bp]
20754 5A5F           3A46         FD            cmp	al,-3[bp]
20755 5A62           72           5A            jb  	.504
20756                       00005A64            .505:
20757                                           ! 3699 ;
20758                                           !BCC_EOS
20759                                           ! 3700     if (package_count == 3) {
20760                                           ! Debug: logeq int = const 3 to unsigned char package_count = [S+8-5] (used reg = )
20761 5A64           8A46         FD            mov	al,-3[bp]
20762 5A67           3C                     03  cmp	al,*3
20763 5A69           75           20            jne 	.506
20764                       00005A6B            .507:
20765                                           ! 3701       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20766                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20767 5A6B           A0         0028            mov	al,[$28]
20768 5A6E           30E4                       xor	ah,ah
20769 5A70           8946         0C            mov	$C[bp],ax
20770                                           !BCC_EOS
20771                                           ! 3702       *(((Bit8u *)&status)+1) = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20772                                           ! Debug: eq unsigned char = [+$29] to unsigned char status = [S+8+$B] (used reg = )
20773 5A73           A0         0029            mov	al,[$29]
20774 5A76           8846         0D            mov	$D[bp],al
20775                                           !BCC_EOS
20776                                           ! 3703       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20777                                           ! Debug: eq unsigned char = [+$2A] to unsigned short X = [S+8+8] (used reg = )
20778 5A79           A0         002A            mov	al,[$2A]
20779 5A7C           30E4                       xor	ah,ah
20780 5A7E           8946         0A            mov	$A[bp],ax
20781                                           !BCC_EOS
20782                                           ! 3704       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[3]));
20783                                           ! Debug: eq unsigned char = [+$2B] to unsigned short Y = [S+8+6] (used reg = )
20784 5A81           A0         002B            mov	al,[$2B]
20785 5A84           30E4                       xor	ah,ah
20786 5A86           8946         08            mov	8[bp],ax
20787                                           !BCC_EOS
20788                                           ! 3705     } else {
20789 5A89           EB           18            jmp .508
20790                       00005A8B            .506:
20791                                           ! 3706       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20792                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20793 5A8B           A0         0028            mov	al,[$28]
20794 5A8E           30E4                       xor	ah,ah
20795 5A90           8946         0C            mov	$C[bp],ax
20796                                           !BCC_EOS
20797                                           ! 3707       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20798                                           ! Debug: eq unsigned char = [+$29] to unsigned short X = [S+8+8] (used reg = )
20799 5A93           A0         0029            mov	al,[$29]
20800 5A96           30E4                       xor	ah,ah
20801 5A98           8946         0A            mov	$A[bp],ax
20802                                           !BCC_EOS
20803                                           ! 3708       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20804                                           ! Debug: eq unsigned char = [+$2A] to unsigned short Y = [S+8+6] (used reg = )
20805 5A9B           A0         002A            mov	al,[$2A]
20806 5A9E           30E4                       xor	ah,ah
20807 5AA0           8946         08            mov	8[bp],ax
20808                                           !BCC_EOS
20809                                           ! 3709     }
20810                                           ! 3710     Z = 0;
20811                       00005AA3            .508:
20812                                           ! Debug: eq int = const 0 to unsigned short Z = [S+8+4] (used reg = )
20813 5AA3           31C0                       xor	ax,ax
20814 5AA5           8946         06            mov	6[bp],ax
20815                                           !BCC_EOS
20816                                           ! 3711     mouse_flags_1 = 0;
20817                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20818 5AA8           30C0                       xor	al,al
20819 5AAA           8846         FC            mov	-4[bp],al
20820                                           !BCC_EOS
20821                                           ! 3712     if (mouse_flags_2 & 0x80)
20822                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20823 5AAD           8A46         FB            mov	al,-5[bp]
20824 5AB0           24                     80  and	al,#$80
20825 5AB2           84C0                       test	al,al
20826 5AB4           74           06            je  	.509
20827                       00005AB6            .50A:
20828                                           ! 3713       make_farcall = 1;
20829                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+8+2] (used reg = )
20830 5AB6           B8                   0001  mov	ax,*1
20831 5AB9           8946         04            mov	4[bp],ax
20832                                           !BCC_EOS
20833                                           ! 3714   } else {
20834                       00005ABC            .509:
20835 5ABC           EB           07            jmp .50B
20836                       00005ABE            .504:
20837                                           ! 3715     mouse_flags_1++;
20838                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20839 5ABE           8A46         FC            mov	al,-4[bp]
20840 5AC1           40                         inc	ax
20841 5AC2           8846         FC            mov	-4[bp],al
20842                                           !BCC_EOS
20843                                           ! 3716   }
20844                                           ! 3717   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1)) = (mouse_flags_1);
20845                       00005AC5            .50B:
20846                                           ! Debug: eq unsigned char mouse_flags_1 = [S+8-6] to unsigned char = [+$26] (used reg = )
20847 5AC5           8A46         FC            mov	al,-4[bp]
20848 5AC8           A2         0026            mov	[$26],al
20849                                           !BCC_EOS
20850                                           ! 3718 }
20851 5ACB           89EC                       mov	sp,bp
20852 5ACD           5D                         pop	bp
20853 5ACE           C3                         ret
20854                                           ! 3719   int
20855                                           ! Register BX used in function int74_function
20856                                           ! 3720 int13_edd(DS, SI, device)
20857                                           ! 3721   Bit16u DS, SI;
20858                                           export	_int13_edd
20859                       00005ACF            _int13_edd:
20860                                           !BCC_EOS
20861                                           ! 3722   Bit8u device;
20862                                           !BCC_EOS
20863                                           ! 3723 {
20864                                           ! 3724   Bit32u lba_low, lba_high;
20865                                           !BCC_EOS
20866                                           ! 3725   Bit16u npc, nph, npspt, size, t13;
20867                                           !BCC_EOS
20868                                           ! 3726   Bit16u ebda_seg=get_ebda_seg();
20869 5ACF           55                         push	bp
20870 5AD0           89E5                       mov	bp,sp
20871 5AD2           83C4                   EC  add	sp,*-$14
20872                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
20873 5AD5           E8         AB8F            call	_get_ebda_seg
20874                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$16-$16] (used reg = )
20875 5AD8           8946         EC            mov	-$14[bp],ax
20876                                           !BCC_EOS
20877                                           ! 3727   Bit8u type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
20878 5ADB           4C                         dec	sp
20879                                           ! Debug: ptradd unsigned char device = [S+$17+6] to [8] struct  = const $142 (used reg = )
20880 5ADC           8A46         08            mov	al,8[bp]
20881 5ADF           30E4                       xor	ah,ah
20882 5AE1           B9                   001E  mov	cx,*$1E
20883 5AE4           F7E9                       imul	cx
20884 5AE6           89C3                       mov	bx,ax
20885                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
20886                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
20887                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$17-$17] (used reg = )
20888 5AE8           8A87       0142            mov	al,$142[bx]
20889 5AEC           8846         EB            mov	-$15[bp],al
20890                                           !BCC_EOS
20891                                           ! 3728   size
20892                                           ! 3728 =_read_word(SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20893 5AEF           4C                         dec	sp
20894                                           ! Debug: list unsigned short DS = [S+$18+2] (used reg = )
20895 5AF0           FF76         04            push	4[bp]
20896                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1A+4] (used reg = )
20897 5AF3           8B46         06            mov	ax,6[bp]
20898                                           ! Debug: list unsigned int = ax+0 (used reg = )
20899 5AF6           50                         push	ax
20900                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
20901 5AF7           E8         AAF3            call	__read_word
20902 5AFA           83C4                   04  add	sp,*4
20903                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$18-$12] (used reg = )
20904 5AFD           8946         F0            mov	-$10[bp],ax
20905                                           !BCC_EOS
20906                                           ! 3729   t13 = size == 74;
20907                                           ! Debug: logeq int = const $4A to unsigned short size = [S+$18-$12] (used reg = )
20908 5B00           8B46         F0            mov	ax,-$10[bp]
20909 5B03           3D                   004A  cmp	ax,*$4A
20910 5B06           75           04            jne	.50C
20911 5B08           B0                     01  mov	al,*1
20912 5B0A           EB           02            jmp	.50D
20913                       00005B0C            .50C:
20914 5B0C           30C0                       xor	al,al
20915                       00005B0E            .50D:
20916                                           ! Debug: eq char = al+0 to unsigned short t13 = [S+$18-$14] (used reg = )
20917 5B0E           30E4                       xor	ah,ah
20918 5B10           8946         EE            mov	-$12[bp],ax
20919                                           !BCC_EOS
20920                                           ! 3730   if(size < 26)
20921                                           ! Debug: lt int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20922 5B13           8B46         F0            mov	ax,-$10[bp]
20923 5B16           3D                   001A  cmp	ax,*$1A
20924 5B19           73           07            jae 	.50E
20925                       00005B1B            .50F:
20926                                           ! 3731     return 1;
20927 5B1B           B8                   0001  mov	ax,*1
20928 5B1E           89EC                       mov	sp,bp
20929 5B20           5D                         pop	bp
20930 5B21           C3                         ret
20931                                           !BCC_EOS
20932                                           ! 3732   if(size >= 26) {
20933                       00005B22            .50E:
20934                                           ! Debug: ge int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20935 5B22           8B46         F0            mov	ax,-$10[bp]
20936 5B25           3D                   001A  cmp	ax,*$1A
20937 5B28         0F82         01DB            blo 	.510
20938                       00005B2C            .511:
20939                                           ! 3733     Bit16u blksize, infos;
20940                                           !BCC_EOS
20941                                           ! 3734     _write_word(26, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20942 5B2C           83C4                   FC  add	sp,*-4
20943                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
20944 5B2F           FF76         04            push	4[bp]
20945                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1E+4] (used reg = )
20946 5B32           8B46         06            mov	ax,6[bp]
20947                                           ! Debug: list unsigned int = ax+0 (used reg = )
20948 5B35           50                         push	ax
20949                                           ! Debug: list int = const $1A (used reg = )
20950 5B36           B8                   001A  mov	ax,*$1A
20951 5B39           50                         push	ax
20952                                           ! Debug: func () void = _write_word+0 (used reg = )
20953 5B3A           E8         AAD1            call	__write_word
20954 5B3D           83C4                   06  add	sp,*6
20955                                           !BCC_EOS
20956                                           ! 3735     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
20957                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
20958 5B40           8A46         08            mov	al,8[bp]
20959 5B43           30E4                       xor	ah,ah
20960 5B45           B9                   001E  mov	cx,*$1E
20961 5B48           F7E9                       imul	cx
20962 5B4A           89C3                       mov	bx,ax
20963                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
20964                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
20965                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$1C-$1A] (used reg = )
20966 5B4C           8B9F       0148            mov	bx,$148[bx]
20967 5B50           895E         E8            mov	-$18[bp],bx
20968                                           !BCC_EOS
20969                                           ! 3736     if (type == 0x02)
20970                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1C-$17] (used reg = )
20971 5B53           8A46         EB            mov	al,-$15[bp]
20972 5B56           3C                     02  cmp	al,*2
20973 5B58         0F85         00DB            bne 	.512
20974                       00005B5C            .513:
20975                                           ! 3737     {
20976                                           ! 3738       npc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders));
20977                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
20978 5B5C           8A46         08            mov	al,8[bp]
20979 5B5F           30E4                       xor	ah,ah
20980 5B61           B9                   001E  mov	cx,*$1E
20981 5B64           F7E9                       imul	cx
20982 5B66           89C3                       mov	bx,ax
20983                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
20984                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
20985                                           ! Debug: eq unsigned short = [bx+$154] to unsigned short npc = [S+$1C-$C] (used reg = )
20986 5B68           8B9F       0154            mov	bx,$154[bx]
20987 5B6C           895E         F6            mov	-$A[bp],bx
20988                                           !BCC_EOS
20989                                           ! 3739       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
20990                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
20991 5B6F           8A46         08            mov	al,8[bp]
20992 5B72           30E4                       xor	ah,ah
20993 5B74           B9                   001E  mov	cx,*$1E
20994 5B77           F7E9                       imul	cx
20995 5B79           89C3                       mov	bx,ax
20996                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
20997                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
20998                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$1C-$E] (used reg = )
20999 5B7B           8B9F       0152            mov	bx,$152[bx]
21000 5B7F           895E         F4            mov	-$C[bp],bx
21001                                           !BCC_EOS
21002                                           ! 3740       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
21003                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21004 5B82           8A46         08            mov	al,8[bp]
21005 5B85           30E4                       xor	ah,ah
21006 5B87           B9                   001E  mov	cx,*$1E
21007 5B8A           F7E9                       imul	cx
21008 5B8C           89C3                       mov	bx,ax
21009                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21010                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
21011                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$1C-$10] (used reg = )
21012 5B8E           8B9F       0156            mov	bx,$156[bx]
21013 5B92           895E         F2            mov	-$E[bp],bx
21014                                           !BCC_EOS
21015                                           ! 3741       lba_low = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low));
21016                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21017 5B95           8A46         08            mov	al,8[bp]
21018 5B98           30E4                       xor	ah,ah
21019 5B9A           B9                   001E  mov	cx,*$1E
21020 5B9D           F7E9                       imul	cx
21021 5B9F           89C3                       mov	bx,ax
21022                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
21023                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
21024                                           ! Debug: eq unsigned long = [bx+$158] to unsigned long lba_low = [S+$1C-6] (used reg = )
21025 5BA1           8B87       0158            mov	ax,$158[bx]
21026 5BA5           8B9F       015A            mov	bx,$15A[bx]
21027 5BA9           8946         FC            mov	-4[bp],ax
21028 5BAC           895E         FE            mov	-2[bp],bx
21029                                           !BCC_EOS
21030                                           ! 3742       lba_high = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high));
21031                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21032 5BAF           8A46         08            mov	al,8[bp]
21033 5BB2           30E4                       xor	ah,ah
21034 5BB4           B9                   001E  mov	cx,*$1E
21035 5BB7           F7E9                       imul	cx
21036 5BB9           89C3                       mov	bx,ax
21037                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
21038                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
21039                                           ! Debug: eq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$1C-$A] (used reg = )
21040 5BBB           8B87       015C            mov	ax,$15C[bx]
21041 5BBF           8B9F       015E            mov	bx,$15E[bx]
21042 5BC3           8946         F8            mov	-8[bp],ax
21043 5BC6           895E         FA            mov	-6[bp],bx
21044                                           !BCC_EOS
21045                                           ! 3743       if (lba_high || (lba_low/npspt)/nph > 0x3fff)
21046 5BC9           8B46         F8            mov	ax,-8[bp]
21047 5BCC           8B5E         FA            mov	bx,-6[bp]
21048 5BCF           E8         A513            call	ltstl
21049 5BD2           75           50            jne 	.515
21050                       00005BD4            .516:
21051                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$1C-$E] (used reg = )
21052 5BD4           8B46         F4            mov	ax,-$C[bp]
21053 5BD7           31DB                       xor	bx,bx
21054 5BD9           53                         push	bx
21055 5BDA           50                         push	ax
21056                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21057 5BDB           8B46         F2            mov	ax,-$E[bp]
21058 5BDE           31DB                       xor	bx,bx
21059                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$20-6] (used reg = )
21060 5BE0           53                         push	bx
21061 5BE1           50                         push	ax
21062 5BE2           8B46         FC            mov	ax,-4[bp]
21063 5BE5           8B5E         FE            mov	bx,-2[bp]
21064 5BE8           8D7E         DE            lea	di,-$22[bp]
21065 5BEB           E8         A551            call	ldivul
21066 5BEE           83C4                   04  add	sp,*4
21067                                           ! Debug: div unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
21068 5BF1           8D7E         E2            lea	di,-$1E[bp]
21069 5BF4           E8         A548            call	ldivul
21070 5BF7           83C4                   04  add	sp,*4
21071                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
21072 5BFA           53                         push	bx
21073 5BFB           50                         push	ax
21074 5BFC           B8                   3FFF  mov	ax,#$3FFF
21075 5BFF           31DB                       xor	bx,bx
21076 5C01           53                         push	bx
21077 5C02           50                         push	ax
21078 5C03           8B46         E2            mov	ax,-$1E[bp]
21079 5C06           8B5E         E4            mov	bx,-$1C[bp]
21080 5C09           8D7E         DE            lea	di,-$22[bp]
21081 5C0C           E8         A48D            call	lcmpul
21082 5C0F           76           04            jbe	.517
21083 5C11           B0                     01  mov	al,*1
21084 5C13           EB           02            jmp	.518
21085                       00005C15            .517:
21086 5C15           30C0                       xor	al,al
21087                       00005C17            .518:
21088 5C17           83C4                   08  add	sp,*8
21089                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
21090 5C1A           30E4                       xor	ah,ah
21091 5C1C           99                         cwd
21092 5C1D           89D3                       mov	bx,dx
21093 5C1F           E8         A4C3            call	ltstl
21094 5C22           74           0D            je  	.514
21095                       00005C24            .515:
21096                                           ! 3744       {
21097                                           ! 3745         infos = 0 << 1;
21098                                           ! Debug: eq int = const 0 to unsigned short infos = [S+$1C-$1C] (used reg = )
21099 5C24           31C0                       xor	ax,ax
21100 5C26           8946         E6            mov	-$1A[bp],ax
21101                                           !BCC_EOS
21102                                           ! 3746         npc = 0x3fff;
21103                                           ! Debug: eq int = const $3FFF to unsigned short npc = [S+$1C-$C] (used reg = )
21104 5C29           B8                   3FFF  mov	ax,#$3FFF
21105 5C2C           8946         F6            mov	-$A[bp],ax
21106                                           !BCC_EOS
21107                                           ! 3747       }
21108                                           ! 3748       else
21109                                           ! 3749       {
21110 5C2F           EB           06            jmp .51A
21111                       00005C31            .514:
21112                                           ! 3750         infos = 1 << 1;
21113                                           ! Debug: eq int = const 2 to unsigned short infos = [S+$1C-$1C] (used reg = )
21114 5C31           B8                   0002  mov	ax,*2
21115 5C34           8946         E6            mov	-$1A[bp],ax
21116                                           !BCC_EOS
21117                                           ! 3751       }
21118                                           ! 3752     }
21119                       00005C37            .51A:
21120                                           ! 3753     if (type == 0x03)
21121                       00005C37            .512:
21122                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1C-$17] (used reg = )
21123 5C37           8A46         EB            mov	al,-$15[bp]
21124 5C3A           3C                     03  cmp	al,*3
21125 5C3C           75           30            jne 	.51B
21126                       00005C3E            .51C:
21127                                           ! 3754     {
21128                                           ! 3755       npc = 0xffffffff;
21129                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npc = [S+$1C-$C] (used reg = )
21130 5C3E           B8                   FFFF  mov	ax,#$FFFF
21131 5C41           8946         F6            mov	-$A[bp],ax
21132                                           !BCC_EOS
21133                                           ! 3756       nph = 0xffffffff;
21134                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short nph = [S+$1C-$E] (used reg = )
21135 5C44           B8                   FFFF  mov	ax,#$FFFF
21136 5C47           8946         F4            mov	-$C[bp],ax
21137                                           !BCC_EOS
21138                                           ! 3757       npspt = 0xffffffff;
21139                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npspt = [S+$1C-$10] (used reg = )
21140 5C4A           B8                   FFFF  mov	ax,#$FFFF
21141 5C4D           8946         F2            mov	-$E[bp],ax
21142                                           !BCC_EOS
21143                                           ! 3758       lba_low = 0xffffffff;
21144                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_low = [S+$1C-6] (used reg = )
21145 5C50           B8                   FFFF  mov	ax,#$FFFF
21146 5C53           BB                   FFFF  mov	bx,#$FFFF
21147 5C56           8946         FC            mov	-4[bp],ax
21148 5C59           895E         FE            mov	-2[bp],bx
21149                                           !BCC_EOS
21150                                           ! 3759       lba_high = 0xffffffff;
21151                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_high = [S+$1C-$A] (used reg = )
21152 5C5C           B8                   FFFF  mov	ax,#$FFFF
21153 5C5F           BB                   FFFF  mov	bx,#$FFFF
21154 5C62           8946         F8            mov	-8[bp],ax
21155 5C65           895E         FA            mov	-6[bp],bx
21156                                           !BCC_EOS
21157                                           ! 3760       infos = 1 << 2 | 1 << 4 |
21158                                           ! 3761                1 << 5 | 1 << 6;
21159                                           ! Debug: eq int = const $74 to unsigned short infos = [S+$1C-$1C] (used reg = )
21160 5C68           B8                   0074  mov	ax,*$74
21161 5C6B           8946         E6            mov	-$1A[bp],ax
21162                                           !BCC_EOS
21163                                           ! 3762     }
21164                                           ! 3763     _write_word(infos, SI+(Bit16u)&((dpt_t *) 0)->infos, DS);
21165                       00005C6E            .51B:
21166                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21167 5C6E           FF76         04            push	4[bp]
21168                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$1E+4] (used reg = )
21169 5C71           8B46         06            mov	ax,6[bp]
21170                                           ! Debug: list unsigned int = ax+2 (used reg = )
21171 5C74           40                         inc	ax
21172 5C75           40                         inc	ax
21173 5C76           50                         push	ax
21174                                           ! Debug: list unsigned short infos = [S+$20-$1C] (used reg = )
21175 5C77           FF76         E6            push	-$1A[bp]
21176                                           ! Debug: func () void = _write_word+0 (used reg = )
21177 5C7A           E8         A991            call	__write_word
21178 5C7D           83C4                   06  add	sp,*6
21179                                           !BCC_EOS
21180                                           ! 3764     _write_dword((Bit32u)npc, SI+(Bit16u)&((dpt_t *) 0)->cylinders, DS);
21181                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21182 5C80           FF76         04            push	4[bp]
21183                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$1E+4] (used reg = )
21184 5C83           8B46         06            mov	ax,6[bp]
21185                                           ! Debug: list unsigned int = ax+4 (used reg = )
21186 5C86           05                   0004  add	ax,*4
21187 5C89           50                         push	ax
21188                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$20-$C] (used reg = )
21189 5C8A           8B46         F6            mov	ax,-$A[bp]
21190 5C8D           31DB                       xor	bx,bx
21191                                           ! Debug: list unsigned long = bx+0 (used reg = )
21192 5C8F           53                         push	bx
21193 5C90           50                         push	ax
21194                                           ! Debug: func () void = _write_dword+0 (used reg = )
21195 5C91           E8         A3D3            call	__write_dword
21196 5C94           83C4                   08  add	sp,*8
21197                                           !BCC_EOS
21198                                           ! 3765     _write_dword((Bit32u)nph, SI+(Bit16u)&((dpt_t *) 0)->heads, DS);
21199                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21200 5C97           FF76         04            push	4[bp]
21201                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$1E+4] (used reg = )
21202 5C9A           8B46         06            mov	ax,6[bp]
21203                                           ! Debug: list unsigned int = ax+8 (used reg = )
21204 5C9D           05                   0008  add	ax,*8
21205 5CA0           50                         push	ax
21206                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$20-$E] (used reg = )
21207 5CA1           8B46         F4            mov	ax,-$C[bp]
21208 5CA4           31DB                       xor	bx,bx
21209                                           ! Debug: list unsigned long = bx+0 (used reg = )
21210 5CA6           53                         push	bx
21211 5CA7           50                         push	ax
21212                                           ! Debug: func () void = _write_dword+0 (used reg = )
21213 5CA8           E8         A3BC            call	__write_dword
21214 5CAB           83C4                   08  add	sp,*8
21215                                           !BCC_EOS
21216                                           ! 3766     _write_dword((Bit32u)npspt, SI+(Bit16u)&((dpt_t *) 0)->spt, DS);
21217                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21218 5CAE           FF76         04            push	4[bp]
21219                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$1E+4] (used reg = )
21220 5CB1           8B46         06            mov	ax,6[bp]
21221                                           ! Debug: list unsigned int = ax+$C (used reg = )
21222 5CB4           05                   000C  add	ax,*$C
21223 5CB7           50                         push	ax
21224                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21225 5CB8           8B46         F2            mov	ax,-$E[bp]
21226 5CBB           31DB                       xor	bx,bx
21227                                           ! Debug: list unsigned long = bx+0 (used reg = )
21228 5CBD           53                         push	bx
21229 5CBE           50                         push	ax
21230                                           ! Debug: func () void = _write_dword+0 (used reg = )
21231 5CBF           E8         A3A5            call	__write_dword
21232 5CC2           83C4                   08  add	sp,*8
21233                                           !BCC_EOS
21234                                           ! 3767     _write_dword(lba_low, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, DS);
21235                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21236 5CC5           FF76         04            push	4[bp]
21237                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$1E+4] (used reg = )
21238 5CC8           8B46         06            mov	ax,6[bp]
21239                                           ! Debug: list unsigned int = ax+$10 (used reg = )
21240 5CCB           05                   0010  add	ax,*$10
21241 5CCE           50                         push	ax
21242                                           ! Debug: list unsigned long lba_low = [S+$20-6] (used reg = )
21243 5CCF           FF76         FE            push	-2[bp]
21244 5CD2           FF76         FC            push	-4[bp]
21245                                           ! Debug: func () void = _write_dword+0 (used reg = )
21246 5CD5           E8         A38F            call	__write_dword
21247 5CD8           83C4                   08  add	sp,*8
21248                                           !BCC_EOS
21249                                           ! 3768     _write_dword(lba_high, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, DS);
21250                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21251 5CDB           FF76         04            push	4[bp]
21252                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$1E+4] (used reg = )
21253 5CDE           8B46         06            mov	ax,6[bp]
21254                                           ! Debug: list unsigned int = ax+$14 (used reg = )
21255 5CE1           05                   0014  add	ax,*$14
21256 5CE4           50                         push	ax
21257                                           ! Debug: list unsigned long lba_high = [S+$20-$A] (used reg = )
21258 5CE5           FF76         FA            push	-6[bp]
21259 5CE8           FF76         F8            push	-8[bp]
21260                                           ! Debug: func () void = _write_dword+0 (used reg = )
21261 5CEB           E8         A379            call	__write_dword
21262 5CEE           83C4                   08  add	sp,*8
21263                                           !BCC_EOS
21264                                           ! 3769     _write_word(blksize, SI+(Bit16u)&((dpt_t *) 0)->blksize, DS);
21265                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21266 5CF1           FF76         04            push	4[bp]
21267                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$1E+4] (used reg = )
21268 5CF4           8B46         06            mov	ax,6[bp]
21269                                           ! Debug: list unsigned int = ax+$18 (used reg = )
21270 5CF7           05                   0018  add	ax,*$18
21271 5CFA           50                         push	ax
21272                                           ! Debug: list unsigned short blksize = [S+$20-$1A] (used reg = )
21273 5CFB           FF76         E8            push	-$18[bp]
21274                                           ! Debug: func () void = _write_word+0 (used reg = )
21275 5CFE           E8         A90D            call	__write_word
21276 5D01           83C4                   06  add	sp,*6
21277                                           !BCC_EOS
21278                                           ! 3770   }
21279 5D04           83C4                   04  add	sp,*4
21280                                           ! 3771   if(size >= 30) {
21281                       00005D07            .510:
21282                                           ! Debug: ge int = const $1E to unsigned short size = [S+$18-$12] (used reg = )
21283 5D07           8B46         F0            mov	ax,-$10[bp]
21284 5D0A           3D                   001E  cmp	ax,*$1E
21285 5D0D         0F82         01BC            blo 	.51D
21286                       00005D11            .51E:
21287                                           ! 3772     Bit8u channel, dev, irq, mode, checksum, i, translation;
21288                                           !BCC_EOS
21289                                           ! 3773     Bit16u iobase1, iobase2, options;
21290                                           !BCC_EOS
21291                                           ! 3774     _write_word(30, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21292 5D11           83C4                   F2  add	sp,*-$E
21293                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21294 5D14           FF76         04            push	4[bp]
21295                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+4] (used reg = )
21296 5D17           8B46         06            mov	ax,6[bp]
21297                                           ! Debug: list unsigned int = ax+0 (used reg = )
21298 5D1A           50                         push	ax
21299                                           ! Debug: list int = const $1E (used reg = )
21300 5D1B           B8                   001E  mov	ax,*$1E
21301 5D1E           50                         push	ax
21302                                           ! Debug: func () void = _write_word+0 (used reg = )
21303 5D1F           E8         A8EC            call	__write_word
21304 5D22           83C4                   06  add	sp,*6
21305                                           !BCC_EOS
21306                                           ! 3775     _write_word(ebda_seg, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, DS);
21307                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21308 5D25           FF76         04            push	4[bp]
21309                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$28+4] (used reg = )
21310 5D28           8B46         06            mov	ax,6[bp]
21311                                           ! Debug: list unsigned int = ax+$1C (used reg = )
21312 5D2B           05                   001C  add	ax,*$1C
21313 5D2E           50                         push	ax
21314                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$16] (used reg = )
21315 5D2F           FF76         EC            push	-$14[bp]
21316                                           ! Debug: func () void = _write_word+0 (used reg = )
21317 5D32           E8         A8D9            call	__write_word
21318 5D35           83C4                   06  add	sp,*6
21319                                           !BCC_EOS
21320                                           ! 3776     _write_word(&((ebda_data_t *) 0)->ata.dpte, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, DS);
21321                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21322 5D38           FF76         04            push	4[bp]
21323                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$28+4] (used reg = )
21324 5D3B           8B46         06            mov	ax,6[bp]
21325                                           ! Debug: list unsigned int = ax+$1A (used reg = )
21326 5D3E           05                   001A  add	ax,*$1A
21327 5D41           50                         push	ax
21328                                           ! Debug: list * struct  = const $244 (used reg = )
21329 5D42           B8                   0244  mov	ax,#$244
21330 5D45           50                         push	ax
21331                                           ! Debug: func () void = _write_word+0 (used reg = )
21332 5D46           E8         A8C5            call	__write_word
21333 5D49           83C4                   06  add	sp,*6
21334                                           !BCC_EOS
21335                                           ! 3777     channel = device / 2;
21336                                           ! Debug: div int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21337 5D4C           8A46         08            mov	al,8[bp]
21338 5D4F           30E4                       xor	ah,ah
21339 5D51           D1E8                       shr	ax,*1
21340                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$26-$19] (used reg = )
21341 5D53           8846         E9            mov	-$17[bp],al
21342                                           !BCC_EOS
21343                                           ! 3778     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.chann
21344                                           ! 3778 els[channel].iobase1));
21345                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21346 5D56           8A46         E9            mov	al,-$17[bp]
21347 5D59           30E4                       xor	ah,ah
21348 5D5B           B1                     03  mov	cl,*3
21349 5D5D           D3E0                       shl	ax,cl
21350 5D5F           89C3                       mov	bx,ax
21351                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21352                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21353                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$26-$22] (used reg = )
21354 5D61           8B9F       0124            mov	bx,$124[bx]
21355 5D65           895E         E0            mov	-$20[bp],bx
21356                                           !BCC_EOS
21357                                           ! 3779     iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
21358                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21359 5D68           8A46         E9            mov	al,-$17[bp]
21360 5D6B           30E4                       xor	ah,ah
21361 5D6D           B1                     03  mov	cl,*3
21362 5D6F           D3E0                       shl	ax,cl
21363 5D71           89C3                       mov	bx,ax
21364                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
21365                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
21366                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$26-$24] (used reg = )
21367 5D73           8B9F       0126            mov	bx,$126[bx]
21368 5D77           895E         DE            mov	-$22[bp],bx
21369                                           !BCC_EOS
21370                                           ! 3780     irq = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq));
21371                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21372 5D7A           8A46         E9            mov	al,-$17[bp]
21373 5D7D           30E4                       xor	ah,ah
21374 5D7F           B1                     03  mov	cl,*3
21375 5D81           D3E0                       shl	ax,cl
21376 5D83           89C3                       mov	bx,ax
21377                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
21378                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
21379                                           ! Debug: eq unsigned char = [bx+$128] to unsigned char irq = [S+$26-$1B] (used reg = )
21380 5D85           8A87       0128            mov	al,$128[bx]
21381 5D89           8846         E7            mov	-$19[bp],al
21382                                           !BCC_EOS
21383                                           ! 3781     mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
21384                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21385 5D8C           8A46         08            mov	al,8[bp]
21386 5D8F           30E4                       xor	ah,ah
21387 5D91           B9                   001E  mov	cx,*$1E
21388 5D94           F7E9                       imul	cx
21389 5D96           89C3                       mov	bx,ax
21390                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
21391                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
21392                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$26-$1C] (used reg = )
21393 5D98           8A87       0146            mov	al,$146[bx]
21394 5D9C           8846         E6            mov	-$1A[bp],al
21395                                           !BCC_EOS
21396                                           ! 3782     translation = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation));
21397                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21398 5D9F           8A46         08            mov	al,8[bp]
21399 5DA2           30E4                       xor	ah,ah
21400 5DA4           B9                   001E  mov	cx,*$1E
21401 5DA7           F7E9                       imul	cx
21402 5DA9           89C3                       mov	bx,ax
21403                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
21404                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
21405                                           ! Debug: eq unsigned char = [bx+$14A] to unsigned char translation = [S+$26-$1F] (used reg = )
21406 5DAB           8A87       014A            mov	al,$14A[bx]
21407 5DAF           8846         E3            mov	-$1D[bp],al
21408                                           !BCC_EOS
21409                                           ! 3783     options = (1<<4);
21410                                           ! Debug: eq int = const $10 to unsigned short options = [S+$26-$26] (used reg = )
21411 5DB2           B8                   0010  mov	ax,*$10
21412 5DB5           8946         DC            mov	-$24[bp],ax
21413                                           !BCC_EOS
21414                                           ! 3784     options |= (mode==0x01?1:0)<<7;
21415                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$26-$1C] (used reg = )
21416 5DB8           8A46         E6            mov	al,-$1A[bp]
21417 5DBB           3C                     01  cmp	al,*1
21418 5DBD           75           04            jne 	.51F
21419                       00005DBF            .520:
21420 5DBF           B0                     01  mov	al,*1
21421 5DC1           EB           02            jmp .521
21422                       00005DC3            .51F:
21423 5DC3           30C0                       xor	al,al
21424                       00005DC5            .521:
21425                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
21426 5DC5           30E4                       xor	ah,ah
21427 5DC7           B1                     07  mov	cl,*7
21428 5DC9           D3E0                       shl	ax,cl
21429                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21430 5DCB           0B46         DC            or	ax,-$24[bp]
21431 5DCE           8946         DC            mov	-$24[bp],ax
21432                                           !BCC_EOS
21433                                           ! 3785     if (type == 0x02)
21434                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$26-$17] (used reg = )
21435 5DD1           8A46         EB            mov	al,-$15[bp]
21436 5DD4           3C                     02  cmp	al,*2
21437 5DD6           75           4F            jne 	.522
21438                       00005DD8            .523:
21439                                           ! 3786     {
21440                                           ! 3787       options |= (translation==0?0:1)<<3;
21441                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$26-$1F] (used reg = )
21442 5DD8           8A46         E3            mov	al,-$1D[bp]
21443 5DDB           84C0                       test	al,al
21444 5DDD           75           04            jne 	.524
21445                       00005DDF            .525:
21446 5DDF           30C0                       xor	al,al
21447 5DE1           EB           02            jmp .526
21448                       00005DE3            .524:
21449 5DE3           B0                     01  mov	al,*1
21450                       00005DE5            .526:
21451                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
21452 5DE5           30E4                       xor	ah,ah
21453 5DE7           B1                     03  mov	cl,*3
21454 5DE9           D3E0                       shl	ax,cl
21455                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21456 5DEB           0B46         DC            or	ax,-$24[bp]
21457 5DEE           8946         DC            mov	-$24[bp],ax
21458                                           !BCC_EOS
21459                                           ! 3788       options |= (translation==1?1:0)<<9;
21460                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$26-$1F] (used reg = )
21461 5DF1           8A46         E3            mov	al,-$1D[bp]
21462 5DF4           3C                     01  cmp	al,*1
21463 5DF6           75           04            jne 	.527
21464                       00005DF8            .528:
21465 5DF8           B0                     01  mov	al,*1
21466 5DFA           EB           02            jmp .529
21467                       00005DFC            .527:
21468 5DFC           30C0                       xor	al,al
21469                       00005DFE            .529:
21470                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21471 5DFE           30E4                       xor	ah,ah
21472 5E00           88C4                       mov	ah,al
21473 5E02           30C0                       xor	al,al
21474 5E04           D1E0                       shl	ax,*1
21475                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21476 5E06           0B46         DC            or	ax,-$24[bp]
21477 5E09           8946         DC            mov	-$24[bp],ax
21478                                           !BCC_EOS
21479                                           ! 3789       options |= (translation==3?3:0)<<9;
21480                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$26-$1F] (used reg = )
21481 5E0C           8A46         E3            mov	al,-$1D[bp]
21482 5E0F           3C                     03  cmp	al,*3
21483 5E11           75           04            jne 	.52A
21484                       00005E13            .52B:
21485 5E13           B0                     03  mov	al,*3
21486 5E15           EB           02            jmp .52C
21487                       00005E17            .52A:
21488 5E17           30C0                       xor	al,al
21489                       00005E19            .52C:
21490                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21491 5E19           30E4                       xor	ah,ah
21492 5E1B           88C4                       mov	ah,al
21493 5E1D           30C0                       xor	al,al
21494 5E1F           D1E0                       shl	ax,*1
21495                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21496 5E21           0B46         DC            or	ax,-$24[bp]
21497 5E24           8946         DC            mov	-$24[bp],ax
21498                                           !BCC_EOS
21499                                           ! 3790     }
21500                                           ! 3791     if (type == 0x03)
21501                       00005E27            .522:
21502                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$26-$17] (used reg = )
21503 5E27           8A46         EB            mov	al,-$15[bp]
21504 5E2A           3C                     03  cmp	al,*3
21505 5E2C           75           10            jne 	.52D
21506                       00005E2E            .52E:
21507                                           ! 3792     {
21508                                           ! 3793       options |= (1<<5);
21509                                           ! Debug: orab int = const $20 to unsigned short options = [S+$26-$26] (used reg = )
21510 5E2E           8B46         DC            mov	ax,-$24[bp]
21511 5E31           0C                     20  or	al,*$20
21512 5E33           8946         DC            mov	-$24[bp],ax
21513                                           !BCC_EOS
21514                                           ! 3794       options |= (1<<6);
21515                                           ! Debug: orab int = const $40 to unsigned short options = [S+$26-$26] (used reg = )
21516 5E36           8B46         DC            mov	ax,-$24[bp]
21517 5E39           0C                     40  or	al,*$40
21518 5E3B           8946         DC            mov	-$24[bp],ax
21519                                           !BCC_EOS
21520                                           ! 3795     }
21521                                           ! 3796     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase1)) = (iobase1);
21522                       00005E3E            .52D:
21523                                           ! Debug: eq unsigned short iobase1 = [S+$26-$22] to unsigned short = [+$244] (used reg = )
21524 5E3E           8B46         E0            mov	ax,-$20[bp]
21525 5E41           A3         0244            mov	[$244],ax
21526                                           !BCC_EOS
21527                                           ! 3797     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase2)) = (iobase2 + 6);
21528                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$26-$24] (used reg = )
21529 5E44           8B46         DE            mov	ax,-$22[bp]
21530                                           ! Debug: eq unsigned int = ax+6 to unsigned short = [+$246] (used reg = )
21531 5E47           05                   0006  add	ax,*6
21532 5E4A           A3         0246            mov	[$246],ax
21533                                           !BCC_EOS
21534                                           ! 3798     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.prefix)) = ((0xe | (device % 2))<<4);
21535                                           ! Debug: mod int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21536 5E4D           8A46         08            mov	al,8[bp]
21537 5E50           30E4                       xor	ah,ah
21538 5E52           24                     01  and	al,*1
21539                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
21540                                           ! Debug: expression subtree swapping
21541 5E54           0C                     0E  or	al,*$E
21542                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
21543 5E56           30E4                       xor	ah,ah
21544 5E58           B1                     04  mov	cl,*4
21545 5E5A           D3E0                       shl	ax,cl
21546                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$248] (used reg = )
21547 5E5C           A2         0248            mov	[$248],al
21548                                           !BCC_EOS
21549                                           ! 3799     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.unused)) = (0xcb);
21550                                           ! Debug: eq int = const $CB to unsigned char = [+$249] (used reg = )
21551 5E5F           B0                     CB  mov	al,#$CB
21552 5E61           A2         0249            mov	[$249],al
21553                                           !BCC_EOS
21554                                           ! 3800     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.irq)) = (irq);
21555                                           ! Debug: eq unsigned char irq = [S+$26-$1B] to unsigned char = [+$24A] (used reg = )
21556 5E64           8A46         E7            mov	al,-$19[bp]
21557 5E67           A2         024A            mov	[$24A],al
21558                                           !BCC_EOS
21559                                           ! 3801     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.blkcount)) = (1);
21560                                           ! Debug: eq int = const 1 to unsigned char = [+$24B] (used reg = )
21561 5E6A           B0                     01  mov	al,*1
21562 5E6C           A2         024B            mov	[$24B],al
21563                                           !BCC_EOS
21564                                           ! 3802     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.dma)) = (0);
21565                                           ! Debug: eq int = const 0 to unsigned char = [+$24C] (used reg = )
21566 5E6F           30C0                       xor	al,al
21567 5E71           A2         024C            mov	[$24C],al
21568                                           !BCC_EOS
21569                                           ! 3803     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.pio)) = (0);
21570                                           ! Debug: eq int = const 0 to unsigned char = [+$24D] (used reg = )
21571 5E74           30C0                       xor	al,al
21572 5E76           A2         024D            mov	[$24D],al
21573                                           !BCC_EOS
21574                                           ! 3804     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.options)) = (options);
21575                                           ! Debug: eq unsigned short options = [S+$26-$26] to unsigned short = [+$24E] (used reg = )
21576 5E79           8B46         DC            mov	ax,-$24[bp]
21577 5E7C           A3         024E            mov	[$24E],ax
21578                                           !BCC_EOS
21579                                           ! 3805     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.reserved)) = (0);
21580                                           ! Debug: eq int = const 0 to unsigned short = [+$250] (used reg = )
21581 5E7F           31C0                       xor	ax,ax
21582 5E81           A3         0250            mov	[$250],ax
21583                                           !BCC_EOS
21584                                           ! 3806     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.revision)) = (0x11);
21585                                           ! Debug: eq int = const $11 to unsigned char = [+$252] (used reg = )
21586 5E84           B0                     11  mov	al,*$11
21587 5E86           A2         0252            mov	[$252],al
21588                                           !BCC_EOS
21589                                           ! 3807     checksum=0;
21590                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21591 5E89           30C0                       xor	al,al
21592 5E8B           8846         E5            mov	-$1B[bp],al
21593                                           !BCC_EOS
21594                                           ! 3808     for (i=0; i<15; i++) checksum+=*((Bit8u *)(((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i));
21595                                           ! Debug: eq int = const 0 to unsigned char i = [S+$26-$1E] (used reg = )
21596 5E8E           30C0                       xor	al,al
21597 5E90           8846         E4            mov	-$1C[bp],al
21598                                           !BCC_EOS
21599                                           !BCC_EOS
21600 5E93           EB           1D            jmp .531
21601                       00005E95            .532:
21602                                           ! Debug: ptradd unsigned char i = [S+$26-$1E] to * unsigned char = const $244 (used reg = )
21603 5E95           8A46         E4            mov	al,-$1C[bp]
21604 5E98           30E4                       xor	ah,ah
21605                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = ax+$244 (used reg = )
21606 5E9A           89C3                       mov	bx,ax
21607                                           ! Debug: addab unsigned char = [bx+$244] to unsigned char checksum = [S+$26-$1D] (used reg = )
21608 5E9C           8A46         E5            mov	al,-$1B[bp]
21609 5E9F           30E4                       xor	ah,ah
21610 5EA1           0287       0244            add	al,$244[bx]
21611 5EA5           80D4                   00  adc	ah,*0
21612 5EA8           8846         E5            mov	-$1B[bp],al
21613                                           !BCC_EOS
21614                                           ! 3809     checksum = -checksum;
21615                       00005EAB            .530:
21616                                           ! Debug: postinc unsigned char i = [S+$26-$1E] (used reg = )
21617 5EAB           8A46         E4            mov	al,-$1C[bp]
21618 5EAE           40                         inc	ax
21619 5EAF           8846         E4            mov	-$1C[bp],al
21620                       00005EB2            .531:
21621                                           ! Debug: lt int = const $F to unsigned char i = [S+$26-$1E] (used reg = )
21622 5EB2           8A46         E4            mov	al,-$1C[bp]
21623 5EB5           3C                     0F  cmp	al,*$F
21624 5EB7           72           DC            jb 	.532
21625                       00005EB9            .533:
21626                       00005EB9            .52F:
21627                                           ! Debug: neg unsigned char checksum = [S+$26-$1D] (used reg = )
21628 5EB9           31C0                       xor	ax,ax
21629 5EBB           2A46         E5            sub	al,-$1B[bp]
21630 5EBE           80DC                   00  sbb	ah,*0
21631                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21632 5EC1           8846         E5            mov	-$1B[bp],al
21633                                           !BCC_EOS
21634                                           ! 3810     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.checksum)) = (checksum);
21635                                           ! Debug: eq unsigned char checksum = [S+$26-$1D] to unsigned char = [+$253] (used reg = )
21636 5EC4           8A46         E5            mov	al,-$1B[bp]
21637 5EC7           A2         0253            mov	[$253],al
21638                                           !BCC_EOS
21639                                           ! 3811   }
21640 5ECA           83C4                   0E  add	sp,*$E
21641                                           ! 3812   if(size >= 66) {
21642                       00005ECD            .51D:
21643                                           ! Debug: ge int = const $42 to unsigned short size = [S+$18-$12] (used reg = )
21644 5ECD           8B46         F0            mov	ax,-$10[bp]
21645 5ED0           3D                   0042  cmp	ax,*$42
21646 5ED3         0F82         0268            blo 	.534
21647                       00005ED7            .535:
21648                                           ! 3813     Bit8u channel, iface, checksum, i;
21649                                           !BCC_EOS
21650                                           ! 3814     Bit16u iobase1;
21651                                           !BCC_EOS
21652                                           ! 3815     channel = device / 2;
21653 5ED7           83C4                   FA  add	sp,*-6
21654                                           ! Debug: div int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
21655 5EDA           8A46         08            mov	al,8[bp]
21656 5EDD           30E4                       xor	ah,ah
21657 5EDF           D1E8                       shr	ax,*1
21658                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$19] (used reg = )
21659 5EE1           8846         E9            mov	-$17[bp],al
21660                                           !BCC_EOS
21661                                           ! 3816     iface = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface));
21662                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21663 5EE4           8A46         E9            mov	al,-$17[bp]
21664 5EE7           30E4                       xor	ah,ah
21665 5EE9           B1                     03  mov	cl,*3
21666 5EEB           D3E0                       shl	ax,cl
21667 5EED           89C3                       mov	bx,ax
21668                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
21669                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
21670                                           ! Debug: eq unsigned char = [bx+$122] to unsigned char iface = [S+$1E-$1A] (used reg = )
21671 5EEF           8A87       0122            mov	al,$122[bx]
21672 5EF3           8846         E8            mov	-$18[bp],al
21673                                           !BCC_EOS
21674                                           ! 3817     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21675                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21676 5EF6           8A46         E9            mov	al,-$17[bp]
21677 5EF9           30E4                       xor	ah,ah
21678 5EFB           B1                     03  mov	cl,*3
21679 5EFD           D3E0                       shl	ax,cl
21680 5EFF           89C3                       mov	bx,ax
21681                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21682                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21683                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$1E-$1E] (used reg = )
21684 5F01           8B9F       0124            mov	bx,$124[bx]
21685 5F05           895E         E4            mov	-$1C[bp],bx
21686                                           !BCC_EOS
21687                                           ! 3818     set_DS(DS);
21688                                           ! Debug: list unsigned short DS = [S+$1E+2] (used reg = )
21689 5F08           FF76         04            push	4[bp]
21690                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
21691 5F0B           E8         A74F            call	_set_DS
21692 5F0E           44                         inc	sp
21693 5F0F           44                         inc	sp
21694                                           !BCC_EOS
21695                                           ! 3819     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.key)) = (0xbedd);
21696                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$1E+4] (used reg = )
21697 5F10           8B46         06            mov	ax,6[bp]
21698                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$1E (used reg = )
21699 5F13           89C3                       mov	bx,ax
21700                                           ! Debug: eq unsigned int = const $BEDD to unsigned short = [bx+$1E] (used reg = )
21701 5F15           B8                   BEDD  mov	ax,#$BEDD
21702 5F18           8947         1E            mov	$1E[bx],ax
21703                                           !BCC_EOS
21704                                           ! 3820     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.dpi_length)) = (t13 ? 44 : 36);
21705 5F1B           8B46         EE            mov	ax,-$12[bp]
21706 5F1E           85C0                       test	ax,ax
21707 5F20           74           04            je  	.536
21708                       00005F22            .537:
21709 5F22           B0                     2C  mov	al,*$2C
21710 5F24           EB           02            jmp .538
21711                       00005F26            .536:
21712 5F26           B0                     24  mov	al,*$24
21713                       00005F28            .538:
21714 5F28           50                         push	ax
21715                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$20+4] (used reg = )
21716 5F29           8B46         06            mov	ax,6[bp]
21717                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$20 (used reg = )
21718 5F2C           89C3                       mov	bx,ax
21719                                           ! Debug: eq char (temp) = [S+$20-$20] to unsigned char = [bx+$20] (used reg = )
21720 5F2E           8A46         E2            mov	al,-$1E[bp]
21721 5F31           8847         20            mov	$20[bx],al
21722 5F34           44                         inc	sp
21723 5F35           44                         inc	sp
21724                                           !BCC_EOS
21725                                           ! 3821     *((Bit8
21726                                           ! 3821 u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved1)) = (0);
21727                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$1E+4] (used reg = )
21728 5F36           8B46         06            mov	ax,6[bp]
21729                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$21 (used reg = )
21730 5F39           89C3                       mov	bx,ax
21731                                           ! Debug: eq int = const 0 to unsigned char = [bx+$21] (used reg = )
21732 5F3B           30C0                       xor	al,al
21733 5F3D           8847         21            mov	$21[bx],al
21734                                           !BCC_EOS
21735                                           ! 3822     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved2)) = (0);
21736                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$1E+4] (used reg = )
21737 5F40           8B46         06            mov	ax,6[bp]
21738                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
21739 5F43           89C3                       mov	bx,ax
21740                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
21741 5F45           31C0                       xor	ax,ax
21742 5F47           8947         22            mov	$22[bx],ax
21743                                           !BCC_EOS
21744                                           ! 3823     if (iface==0x00) {
21745                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21746 5F4A           8A46         E8            mov	al,-$18[bp]
21747 5F4D           84C0                       test	al,al
21748 5F4F           75           2A            jne 	.539
21749                       00005F51            .53A:
21750                                           ! 3824       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[0])) = ('I');
21751                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$1E+4] (used reg = )
21752 5F51           8B46         06            mov	ax,6[bp]
21753                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
21754 5F54           89C3                       mov	bx,ax
21755                                           ! Debug: eq int = const $49 to unsigned char = [bx+$24] (used reg = )
21756 5F56           B0                     49  mov	al,*$49
21757 5F58           8847         24            mov	$24[bx],al
21758                                           !BCC_EOS
21759                                           ! 3825       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[1])) = ('S');
21760                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$1E+4] (used reg = )
21761 5F5B           8B46         06            mov	ax,6[bp]
21762                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
21763 5F5E           89C3                       mov	bx,ax
21764                                           ! Debug: eq int = const $53 to unsigned char = [bx+$25] (used reg = )
21765 5F60           B0                     53  mov	al,*$53
21766 5F62           8847         25            mov	$25[bx],al
21767                                           !BCC_EOS
21768                                           ! 3826       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[2])) = ('A');
21769                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$1E+4] (used reg = )
21770 5F65           8B46         06            mov	ax,6[bp]
21771                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$26 (used reg = )
21772 5F68           89C3                       mov	bx,ax
21773                                           ! Debug: eq int = const $41 to unsigned char = [bx+$26] (used reg = )
21774 5F6A           B0                     41  mov	al,*$41
21775 5F6C           8847         26            mov	$26[bx],al
21776                                           !BCC_EOS
21777                                           ! 3827       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[3])) = (' ');
21778                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$1E+4] (used reg = )
21779 5F6F           8B46         06            mov	ax,6[bp]
21780                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$27 (used reg = )
21781 5F72           89C3                       mov	bx,ax
21782                                           ! Debug: eq int = const $20 to unsigned char = [bx+$27] (used reg = )
21783 5F74           B0                     20  mov	al,*$20
21784 5F76           8847         27            mov	$27[bx],al
21785                                           !BCC_EOS
21786                                           ! 3828     }
21787                                           ! 3829     else {
21788 5F79           EB           00            jmp .53B
21789                       00005F7B            .539:
21790                                           ! 3830     }
21791                                           ! 3831     if (type == 0x02) {
21792                       00005F7B            .53B:
21793                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1E-$17] (used reg = )
21794 5F7B           8A46         EB            mov	al,-$15[bp]
21795 5F7E           3C                     02  cmp	al,*2
21796 5F80           75           53            jne 	.53C
21797                       00005F82            .53D:
21798                                           ! 3832         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21799                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21800 5F82           8B46         06            mov	ax,6[bp]
21801                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21802 5F85           89C3                       mov	bx,ax
21803                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21804 5F87           B0                     41  mov	al,*$41
21805 5F89           8847         28            mov	$28[bx],al
21806                                           !BCC_EOS
21807                                           ! 3833         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21808                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21809 5F8C           8B46         06            mov	ax,6[bp]
21810                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21811 5F8F           89C3                       mov	bx,ax
21812                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21813 5F91           B0                     54  mov	al,*$54
21814 5F93           8847         29            mov	$29[bx],al
21815                                           !BCC_EOS
21816                                           ! 3834         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21817                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21818 5F96           8B46         06            mov	ax,6[bp]
21819                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21820 5F99           89C3                       mov	bx,ax
21821                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21822 5F9B           B0                     41  mov	al,*$41
21823 5F9D           8847         2A            mov	$2A[bx],al
21824                                           !BCC_EOS
21825                                           ! 3835         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = (' ');
21826                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21827 5FA0           8B46         06            mov	ax,6[bp]
21828                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21829 5FA3           89C3                       mov	bx,ax
21830                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2B] (used reg = )
21831 5FA5           B0                     20  mov	al,*$20
21832 5FA7           8847         2B            mov	$2B[bx],al
21833                                           !BCC_EOS
21834                                           ! 3836         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = (' ');
21835                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21836 5FAA           8B46         06            mov	ax,6[bp]
21837                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21838 5FAD           89C3                       mov	bx,ax
21839                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2C] (used reg = )
21840 5FAF           B0                     20  mov	al,*$20
21841 5FB1           8847         2C            mov	$2C[bx],al
21842                                           !BCC_EOS
21843                                           ! 3837         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21844                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21845 5FB4           8B46         06            mov	ax,6[bp]
21846                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21847 5FB7           89C3                       mov	bx,ax
21848                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21849 5FB9           B0                     20  mov	al,*$20
21850 5FBB           8847         2D            mov	$2D[bx],al
21851                                           !BCC_EOS
21852                                           ! 3838         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21853                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21854 5FBE           8B46         06            mov	ax,6[bp]
21855                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21856 5FC1           89C3                       mov	bx,ax
21857                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21858 5FC3           B0                     20  mov	al,*$20
21859 5FC5           8847         2E            mov	$2E[bx],al
21860                                           !BCC_EOS
21861                                           ! 3839         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21862                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21863 5FC8           8B46         06            mov	ax,6[bp]
21864                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21865 5FCB           89C3                       mov	bx,ax
21866                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21867 5FCD           B0                     20  mov	al,*$20
21868 5FCF           8847         2F            mov	$2F[bx],al
21869                                           !BCC_EOS
21870                                           ! 3840     } else if (type == 0x03) {
21871 5FD2           E9         0059            br 	.53E
21872                       00005FD5            .53C:
21873                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1E-$17] (used reg = )
21874 5FD5           8A46         EB            mov	al,-$15[bp]
21875 5FD8           3C                     03  cmp	al,*3
21876 5FDA         0F85         0050            bne 	.53F
21877                       00005FDE            .540:
21878                                           ! 3841         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21879                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21880 5FDE           8B46         06            mov	ax,6[bp]
21881                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21882 5FE1           89C3                       mov	bx,ax
21883                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21884 5FE3           B0                     41  mov	al,*$41
21885 5FE5           8847         28            mov	$28[bx],al
21886                                           !BCC_EOS
21887                                           ! 3842         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21888                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21889 5FE8           8B46         06            mov	ax,6[bp]
21890                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21891 5FEB           89C3                       mov	bx,ax
21892                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21893 5FED           B0                     54  mov	al,*$54
21894 5FEF           8847         29            mov	$29[bx],al
21895                                           !BCC_EOS
21896                                           ! 3843         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21897                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21898 5FF2           8B46         06            mov	ax,6[bp]
21899                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21900 5FF5           89C3                       mov	bx,ax
21901                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21902 5FF7           B0                     41  mov	al,*$41
21903 5FF9           8847         2A            mov	$2A[bx],al
21904                                           !BCC_EOS
21905                                           ! 3844         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = ('P');
21906                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21907 5FFC           8B46         06            mov	ax,6[bp]
21908                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21909 5FFF           89C3                       mov	bx,ax
21910                                           ! Debug: eq int = const $50 to unsigned char = [bx+$2B] (used reg = )
21911 6001           B0                     50  mov	al,*$50
21912 6003           8847         2B            mov	$2B[bx],al
21913                                           !BCC_EOS
21914                                           ! 3845         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = ('I');
21915                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21916 6006           8B46         06            mov	ax,6[bp]
21917                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21918 6009           89C3                       mov	bx,ax
21919                                           ! Debug: eq int = const $49 to unsigned char = [bx+$2C] (used reg = )
21920 600B           B0                     49  mov	al,*$49
21921 600D           8847         2C            mov	$2C[bx],al
21922                                           !BCC_EOS
21923                                           ! 3846         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21924                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21925 6010           8B46         06            mov	ax,6[bp]
21926                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21927 6013           89C3                       mov	bx,ax
21928                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21929 6015           B0                     20  mov	al,*$20
21930 6017           8847         2D            mov	$2D[bx],al
21931                                           !BCC_EOS
21932                                           ! 3847         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21933                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21934 601A           8B46         06            mov	ax,6[bp]
21935                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21936 601D           89C3                       mov	bx,ax
21937                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21938 601F           B0                     20  mov	al,*$20
21939 6021           8847         2E            mov	$2E[bx],al
21940                                           !BCC_EOS
21941                                           ! 3848         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21942                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21943 6024           8B46         06            mov	ax,6[bp]
21944                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21945 6027           89C3                       mov	bx,ax
21946                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21947 6029           B0                     20  mov	al,*$20
21948 602B           8847         2F            mov	$2F[bx],al
21949                                           !BCC_EOS
21950                                           ! 3849     }
21951                                           ! 3850     if (iface==0x00) {
21952                       0000602E            .53F:
21953                       0000602E            .53E:
21954                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21955 602E           8A46         E8            mov	al,-$18[bp]
21956 6031           84C0                       test	al,al
21957 6033           75           26            jne 	.541
21958                       00006035            .542:
21959                                           ! 3851       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[0])) = (iobase1);
21960                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$1E+4] (used reg = )
21961 6035           8B46         06            mov	ax,6[bp]
21962                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$30 (used reg = )
21963 6038           89C3                       mov	bx,ax
21964                                           ! Debug: eq unsigned short iobase1 = [S+$1E-$1E] to unsigned short = [bx+$30] (used reg = )
21965 603A           8B46         E4            mov	ax,-$1C[bp]
21966 603D           8947         30            mov	$30[bx],ax
21967                                           !BCC_EOS
21968                                           ! 3852       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[2])) = (0);
21969                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$1E+4] (used reg = )
21970 6040           8B46         06            mov	ax,6[bp]
21971                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$32 (used reg = )
21972 6043           89C3                       mov	bx,ax
21973                                           ! Debug: eq int = const 0 to unsigned short = [bx+$32] (used reg = )
21974 6045           31C0                       xor	ax,ax
21975 6047           8947         32            mov	$32[bx],ax
21976                                           !BCC_EOS
21977                                           ! 3853       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)
21978                                           ! 3853 ->dpi.t13.iface_path[4])) = (0L);
21979                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$1E+4] (used reg = )
21980 604A           8B46         06            mov	ax,6[bp]
21981                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$34 (used reg = )
21982 604D           89C3                       mov	bx,ax
21983                                           ! Debug: eq long = const 0 to unsigned long = [bx+$34] (used reg = )
21984 604F           31C0                       xor	ax,ax
21985 6051           31F6                       xor	si,si
21986 6053           8947         34            mov	$34[bx],ax
21987 6056           8977         36            mov	$36[bx],si
21988                                           !BCC_EOS
21989                                           ! 3854     }
21990                                           ! 3855     else {
21991 6059           EB           00            jmp .543
21992                       0000605B            .541:
21993                                           ! 3856     }
21994                                           ! 3857     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[0])) = (device%2);
21995                       0000605B            .543:
21996                                           ! Debug: mod int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
21997 605B           8A46         08            mov	al,8[bp]
21998 605E           30E4                       xor	ah,ah
21999 6060           24                     01  and	al,*1
22000 6062           50                         push	ax
22001                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$20+4] (used reg = )
22002 6063           8B46         06            mov	ax,6[bp]
22003                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$38 (used reg = )
22004 6066           89C3                       mov	bx,ax
22005                                           ! Debug: eq unsigned char (temp) = [S+$20-$20] to unsigned char = [bx+$38] (used reg = )
22006 6068           8A46         E2            mov	al,-$1E[bp]
22007 606B           8847         38            mov	$38[bx],al
22008 606E           44                         inc	sp
22009 606F           44                         inc	sp
22010                                           !BCC_EOS
22011                                           ! 3858     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[1])) = (0);
22012                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$1E+4] (used reg = )
22013 6070           8B46         06            mov	ax,6[bp]
22014                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$39 (used reg = )
22015 6073           89C3                       mov	bx,ax
22016                                           ! Debug: eq int = const 0 to unsigned char = [bx+$39] (used reg = )
22017 6075           30C0                       xor	al,al
22018 6077           8847         39            mov	$39[bx],al
22019                                           !BCC_EOS
22020                                           ! 3859     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[2])) = (0);
22021                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$1E+4] (used reg = )
22022 607A           8B46         06            mov	ax,6[bp]
22023                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
22024 607D           89C3                       mov	bx,ax
22025                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
22026 607F           31C0                       xor	ax,ax
22027 6081           8947         3A            mov	$3A[bx],ax
22028                                           !BCC_EOS
22029                                           ! 3860     *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[4])) = (0L);
22030                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$1E+4] (used reg = )
22031 6084           8B46         06            mov	ax,6[bp]
22032                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$3C (used reg = )
22033 6087           89C3                       mov	bx,ax
22034                                           ! Debug: eq long = const 0 to unsigned long = [bx+$3C] (used reg = )
22035 6089           31C0                       xor	ax,ax
22036 608B           31F6                       xor	si,si
22037 608D           8947         3C            mov	$3C[bx],ax
22038 6090           8977         3E            mov	$3E[bx],si
22039                                           !BCC_EOS
22040                                           ! 3861     if (t13) {
22041 6093           8B46         EE            mov	ax,-$12[bp]
22042 6096           85C0                       test	ax,ax
22043 6098           74           1E            je  	.544
22044                       0000609A            .545:
22045                                           ! 3862       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[8])) = (0L);
22046                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22047 609A           8B46         06            mov	ax,6[bp]
22048                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$40 (used reg = )
22049 609D           89C3                       mov	bx,ax
22050                                           ! Debug: eq long = const 0 to unsigned long = [bx+$40] (used reg = )
22051 609F           31C0                       xor	ax,ax
22052 60A1           31F6                       xor	si,si
22053 60A3           8947         40            mov	$40[bx],ax
22054 60A6           8977         42            mov	$42[bx],si
22055                                           !BCC_EOS
22056                                           ! 3863       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[12])) = (0L);
22057                                           ! Debug: add unsigned short = const $44 to unsigned short SI = [S+$1E+4] (used reg = )
22058 60A9           8B46         06            mov	ax,6[bp]
22059                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$44 (used reg = )
22060 60AC           89C3                       mov	bx,ax
22061                                           ! Debug: eq long = const 0 to unsigned long = [bx+$44] (used reg = )
22062 60AE           31C0                       xor	ax,ax
22063 60B0           31F6                       xor	si,si
22064 60B2           8947         44            mov	$44[bx],ax
22065 60B5           8977         46            mov	$46[bx],si
22066                                           !BCC_EOS
22067                                           ! 3864     }
22068                                           ! 3865     if (t13)
22069                       000060B8            .544:
22070 60B8           8B46         EE            mov	ax,-$12[bp]
22071 60BB           85C0                       test	ax,ax
22072 60BD           74           0C            je  	.546
22073                       000060BF            .547:
22074                                           ! 3866       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved3)) = (0);
22075                                           ! Debug: add unsigned short = const $48 to unsigned short SI = [S+$1E+4] (used reg = )
22076 60BF           8B46         06            mov	ax,6[bp]
22077                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$48 (used reg = )
22078 60C2           89C3                       mov	bx,ax
22079                                           ! Debug: eq int = const 0 to unsigned char = [bx+$48] (used reg = )
22080 60C4           30C0                       xor	al,al
22081 60C6           8847         48            mov	$48[bx],al
22082                                           !BCC_EOS
22083                                           ! 3867     else
22084                                           ! 3868       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.reserved3)) = (0);
22085 60C9           EB           0A            jmp .548
22086                       000060CB            .546:
22087                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22088 60CB           8B46         06            mov	ax,6[bp]
22089                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$40 (used reg = )
22090 60CE           89C3                       mov	bx,ax
22091                                           ! Debug: eq int = const 0 to unsigned char = [bx+$40] (used reg = )
22092 60D0           30C0                       xor	al,al
22093 60D2           8847         40            mov	$40[bx],al
22094                                           !BCC_EOS
22095                                           ! 3869     checksum = 0;
22096                       000060D5            .548:
22097                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22098 60D5           30C0                       xor	al,al
22099 60D7           8846         E7            mov	-$19[bp],al
22100                                           !BCC_EOS
22101                                           ! 3870     for (i = 30; i < (t13 ? 73 : 65); i++) checksum += *((Bit8u *)(SI + i));
22102                                           ! Debug: eq int = const $1E to unsigned char i = [S+$1E-$1C] (used reg = )
22103 60DA           B0                     1E  mov	al,*$1E
22104 60DC           8846         E6            mov	-$1A[bp],al
22105                                           !BCC_EOS
22106                                           !BCC_EOS
22107 60DF           EB           1F            jmp .54B
22108                       000060E1            .54C:
22109                                           ! Debug: add unsigned char i = [S+$1E-$1C] to unsigned short SI = [S+$1E+4] (used reg = )
22110 60E1           8B46         06            mov	ax,6[bp]
22111 60E4           0246         E6            add	al,-$1A[bp]
22112 60E7           80D4                   00  adc	ah,*0
22113                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
22114 60EA           89C3                       mov	bx,ax
22115                                           ! Debug: addab unsigned char = [bx+0] to unsigned char checksum = [S+$1E-$1B] (used reg = )
22116 60EC           8A46         E7            mov	al,-$19[bp]
22117 60EF           30E4                       xor	ah,ah
22118 60F1           0207                       add	al,[bx]
22119 60F3           80D4                   00  adc	ah,*0
22120 60F6           8846         E7            mov	-$19[bp],al
22121                                           !BCC_EOS
22122                                           ! 3871     checksum = -checksum;
22123                       000060F9            .54A:
22124                                           ! Debug: postinc unsigned char i = [S+$1E-$1C] (used reg = )
22125 60F9           8A46         E6            mov	al,-$1A[bp]
22126 60FC           40                         inc	ax
22127 60FD           8846         E6            mov	-$1A[bp],al
22128                       00006100            .54B:
22129 6100           8B46         EE            mov	ax,-$12[bp]
22130 6103           85C0                       test	ax,ax
22131 6105           74           04            je  	.54E
22132                       00006107            .54F:
22133 6107           B0                     49  mov	al,*$49
22134 6109           EB           02            jmp .550
22135                       0000610B            .54E:
22136 610B           B0                     41  mov	al,*$41
22137                       0000610D            .550:
22138                                           ! Debug: lt char = al+0 to unsigned char i = [S+$1E-$1C] (used reg = )
22139 610D           3A46         E6            cmp	al,-$1A[bp]
22140 6110           77           CF            ja 	.54C
22141                       00006112            .54D:
22142                       00006112            .549:
22143                                           ! Debug: neg unsigned char checksum = [S+$1E-$1B] (used reg = )
22144 6112           31C0                       xor	ax,ax
22145 6114           2A46         E7            sub	al,-$19[bp]
22146 6117           80DC                   00  sbb	ah,*0
22147                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22148 611A           8846         E7            mov	-$19[bp],al
22149                                           !BCC_EOS
22150                                           ! 3872     if (t13)
22151 611D           8B46         EE            mov	ax,-$12[bp]
22152 6120           85C0                       test	ax,ax
22153 6122           74           0D            je  	.551
22154                       00006124            .552:
22155                                           ! 3873       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.checksum)) = (checksum);
22156                                           ! Debug: add unsigned short = const $49 to unsigned short SI = [S+$1E+4] (used reg = )
22157 6124           8B46         06            mov	ax,6[bp]
22158                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$49 (used reg = )
22159 6127           89C3                       mov	bx,ax
22160                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$49] (used reg = )
22161 6129           8A46         E7            mov	al,-$19[bp]
22162 612C           8847         49            mov	$49[bx],al
22163                                           !BCC_EOS
22164                                           ! 3874     else
22165                                           ! 3875       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.checksum)) = (checksum);
22166 612F           EB           0B            jmp .553
22167                       00006131            .551:
22168                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$1E+4] (used reg = )
22169 6131           8B46         06            mov	ax,6[bp]
22170                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$41 (used reg = )
22171 6134           89C3                       mov	bx,ax
22172                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$41] (used reg = )
22173 6136           8A46         E7            mov	al,-$19[bp]
22174 6139           8847         41            mov	$41[bx],al
22175                                           !BCC_EOS
22176                                           ! 3876   }
22177                       0000613C            .553:
22178 613C           83C4                   06  add	sp,*6
22179                                           ! 3877   return 0;
22180                       0000613F            .534:
22181 613F           31C0                       xor	ax,ax
22182 6141           89EC                       mov	sp,bp
22183 6143           5D                         pop	bp
22184 6144           C3                         ret
22185                                           !BCC_EOS
22186                                           ! 3878 }
22187                                           ! 3879   void
22188                                           ! Register BX used in function int13_edd
22189                                           ! 3880 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22190                                           ! 3881   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22191                                           export	_int13_harddisk
22192                       00006145            _int13_harddisk:
22193                                           !BCC_EOS
22194                                           ! 3882 {
22195                                           ! 3883   Bit32u lba_low, lba_high;
22196                                           !BCC_EOS
22197                                           ! 3884   Bit16u cylinder, head, sector;
22198                                           !BCC_EOS
22199                                           ! 3885   Bit16u segment, offset;
22200                                           !BCC_EOS
22201                                           ! 3886   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22202                                           !BCC_EOS
22203                                           ! 3887   Bit16u size, count;
22204                                           !BCC_EOS
22205                                           ! 3888   Bit8u device, status;
22206                                           !BCC_EOS
22207                                           ! 3889   ;
22208 6145           55                         push	bp
22209 6146           89E5                       mov	bp,sp
22210 6148           83C4                   DC  add	sp,*-$24
22211                                           !BCC_EOS
22212                                           ! 3890   _write_byte(0, 0x008e, 0x0040);
22213                                           ! Debug: list int = const $40 (used reg = )
22214 614B           B8                   0040  mov	ax,*$40
22215 614E           50                         push	ax
22216                                           ! Debug: list int = const $8E (used reg = )
22217 614F           B8                   008E  mov	ax,#$8E
22218 6152           50                         push	ax
22219                                           ! Debug: list int = const 0 (used reg = )
22220 6153           31C0                       xor	ax,ax
22221 6155           50                         push	ax
22222                                           ! Debug: func () void = _write_byte+0 (used reg = )
22223 6156           E8         A4A2            call	__write_byte
22224 6159           83C4                   06  add	sp,*6
22225                                           !BCC_EOS
22226                                           ! 3891   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
22227                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22228 615C           8A46         10            mov	al,$10[bp]
22229                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22230 615F           3C                     80  cmp	al,#$80
22231 6161           72           07            jb  	.555
22232                       00006163            .556:
22233                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22234 6163           8A46         10            mov	al,$10[bp]
22235                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22236 6166           3C                     88  cmp	al,#$88
22237 6168           72           20            jb  	.554
22238                       0000616A            .555:
22239                                           ! 3892     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22240                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22241 616A           8A46         10            mov	al,$10[bp]
22242                                           ! Debug: list unsigned char = al+0 (used reg = )
22243 616D           30E4                       xor	ah,ah
22244 616F           50                         push	ax
22245                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22246 6170           8A46         19            mov	al,$19[bp]
22247 6173           30E4                       xor	ah,ah
22248 6175           50                         push	ax
22249                                           ! Debug: list * char = .557+0 (used reg = )
22250 6176           BB                   D24B  mov	bx,#.557
22251 6179           53                         push	bx
22252                                           ! Debug: list int = const 4 (used reg = )
22253 617A           B8                   0004  mov	ax,*4
22254 617D           50                         push	ax
22255                                           ! Debug: func () void = bios_printf+0 (used reg = )
22256 617E           E8         A7B8            call	_bios_printf
22257 6181           83C4                   08  add	sp,*8
22258                                           !BCC_EOS
22259                                           ! 3893     goto int13_fail;
22260 6184           83C4                   00  add	sp,#..FFF1+$26
22261 6187           E9         0727            br 	.FFF1
22262                                           !BCC_EOS
22263                                           ! 3894   }
22264                                           ! 3895   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]));
22265                       0000618A            .554:
22266                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22267 618A           8A46         10            mov	al,$10[bp]
22268                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22269 618D           30E4                       xor	ah,ah
22270                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22271 618F           05                   FF80  add	ax,*-$80
22272 6192           89C3                       mov	bx,ax
22273                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22274                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
22275                                           ! Debug: eq unsigned char = [bx+$233] to unsigned char device = [S+$26-$25] (used reg = )
22276 6194           8A87       0233            mov	al,$233[bx]
22277 6198           8846         DD            mov	-$23[bp],al
22278                                           !BCC_EOS
22279                                           ! 3896   if (device >= (4*2)) {
22280                                           ! Debug: ge int = const 8 to unsigned char device = [S+$26-$25] (used reg = )
22281 619B           8A46         DD            mov	al,-$23[bp]
22282 619E           3C                     08  cmp	al,*8
22283 61A0           72           20            jb  	.558
22284                       000061A2            .559:
22285                                           ! 3897     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22286                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22287 61A2           8A46         10            mov	al,$10[bp]
22288                                           ! Debug: list unsigned char = al+0 (used reg = )
22289 61A5           30E4                       xor	ah,ah
22290 61A7           50                         push	ax
22291                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22292 61A8           8A46         19            mov	al,$19[bp]
22293 61AB           30E4                       xor	ah,ah
22294 61AD           50                         push	ax
22295                                           ! Debug: list * char = .55A+0 (used reg = )
22296 61AE           BB                   D20D  mov	bx,#.55A
22297 61B1           53                         push	bx
22298                                           ! Debug: list int = const 4 (used reg = )
22299 61B2           B8                   0004  mov	ax,*4
22300 61B5           50                         push	ax
22301                                           ! Debug: func () void = bios_printf+0 (used reg = )
22302 61B6           E8         A780            call	_bios_printf
22303 61B9           83C4                   08  add	sp,*8
22304                                           !BCC_EOS
22305                                           ! 3898     goto int13_fail;
22306 61BC           83C4                   00  add	sp,#..FFF1+$26
22307 61BF           E9         06EF            br 	.FFF1
22308                                           !BCC_EOS
22309                                           ! 3899   }
22310                                           ! 3900   switch (*(((Bit8u *)&AX)+1)) {
22311                       000061C2            .558:
22312 61C2           8A46         19            mov	al,$19[bp]
22313 61C5           E9         066E            br 	.55D
22314                                           ! 3901     case 0x00:
22315                                           ! 3902       ata_reset (device);
22316                       000061C8            .55E:
22317                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
22318 61C8           8A46         DD            mov	al,-$23[bp]
22319 61CB           30E4                       xor	ah,ah
22320 61CD           50                         push	ax
22321                                           ! Debug: func () void = ata_reset+0 (used reg = )
22322 61CE           E8         C689            call	_ata_reset
22323 61D1           44                         inc	sp
22324 61D2           44                         inc	sp
22325                                           !BCC_EOS
22326                                           ! 3903       goto int13_success;
22327 61D3           83C4                   00  add	sp,#..FFEF-..FFF0
22328 61D6           E9         06FD            br 	.FFEF
22329                                           !BCC_EOS
22330                                           ! 3904       break;
22331 61D9           E9         06D5            br 	.55B
22332                                           !BCC_EOS
22333                                           ! 3905     case 0x01:
22334                                           ! 3906       status = _read_byte(0x00
22335                       000061DC            .55F:
22336                                           ! 3906 74, 0x0040);
22337                                           ! Debug: list int = const $40 (used reg = )
22338 61DC           B8                   0040  mov	ax,*$40
22339 61DF           50                         push	ax
22340                                           ! Debug: list int = const $74 (used reg = )
22341 61E0           B8                   0074  mov	ax,*$74
22342 61E3           50                         push	ax
22343                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
22344 61E4           E8         A3F8            call	__read_byte
22345 61E7           83C4                   04  add	sp,*4
22346                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22347 61EA           8846         DC            mov	-$24[bp],al
22348                                           !BCC_EOS
22349                                           ! 3907       *(((Bit8u *)&AX)+1) = (status);
22350                                           ! Debug: eq unsigned char status = [S+$26-$26] to unsigned char AX = [S+$26+$17] (used reg = )
22351 61ED           8A46         DC            mov	al,-$24[bp]
22352 61F0           8846         19            mov	$19[bp],al
22353                                           !BCC_EOS
22354                                           ! 3908       _write_byte(0, 0x0074, 0x0040);
22355                                           ! Debug: list int = const $40 (used reg = )
22356 61F3           B8                   0040  mov	ax,*$40
22357 61F6           50                         push	ax
22358                                           ! Debug: list int = const $74 (used reg = )
22359 61F7           B8                   0074  mov	ax,*$74
22360 61FA           50                         push	ax
22361                                           ! Debug: list int = const 0 (used reg = )
22362 61FB           31C0                       xor	ax,ax
22363 61FD           50                         push	ax
22364                                           ! Debug: func () void = _write_byte+0 (used reg = )
22365 61FE           E8         A3FA            call	__write_byte
22366 6201           83C4                   06  add	sp,*6
22367                                           !BCC_EOS
22368                                           ! 3909       if (status) goto int13_fail_nostatus;
22369 6204           8A46         DC            mov	al,-$24[bp]
22370 6207           84C0                       test	al,al
22371 6209           74           08            je  	.560
22372                       0000620B            .561:
22373 620B           83C4                   00  add	sp,#..FFEE-..FFF0
22374 620E           E9         06B9            br 	.FFEE
22375                                           !BCC_EOS
22376                                           ! 3910       else goto int13_success_noah;
22377 6211           EB           06            jmp .562
22378                       00006213            .560:
22379 6213           83C4                   00  add	sp,#..FFED-..FFF0
22380 6216           E9         06C2            br 	.FFED
22381                                           !BCC_EOS
22382                                           ! 3911       break;
22383                       00006219            .562:
22384 6219           E9         0695            br 	.55B
22385                                           !BCC_EOS
22386                                           ! 3912     case 0x02:
22387                                           ! 3913     case 0x03:
22388                       0000621C            .563:
22389                                           ! 3914     case 0x04:
22390                       0000621C            .564:
22391                                           ! 3915       count = ( AX & 0x00ff );
22392                       0000621C            .565:
22393                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
22394 621C           8A46         18            mov	al,$18[bp]
22395                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$26-$24] (used reg = )
22396 621F           30E4                       xor	ah,ah
22397 6221           8946         DE            mov	-$22[bp],ax
22398                                           !BCC_EOS
22399                                           ! 3916       cylinder = *(((Bit8u *)&CX)+1);
22400                                           ! Debug: eq unsigned char CX = [S+$26+$15] to unsigned short cylinder = [S+$26-$C] (used reg = )
22401 6224           8A46         17            mov	al,$17[bp]
22402 6227           30E4                       xor	ah,ah
22403 6229           8946         F6            mov	-$A[bp],ax
22404                                           !BCC_EOS
22405                                           ! 3917       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
22406                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22407 622C           8A46         16            mov	al,$16[bp]
22408                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
22409 622F           30E4                       xor	ah,ah
22410                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
22411 6231           D1E0                       shl	ax,*1
22412 6233           D1E0                       shl	ax,*1
22413                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
22414 6235           25                   0300  and	ax,#$300
22415                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$26-$C] (used reg = )
22416 6238           0B46         F6            or	ax,-$A[bp]
22417 623B           8946         F6            mov	-$A[bp],ax
22418                                           !BCC_EOS
22419                                           ! 3918       sector = (( CX & 0x00ff ) & 0x3f);
22420                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22421 623E           8A46         16            mov	al,$16[bp]
22422                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
22423 6241           24                     3F  and	al,*$3F
22424                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$26-$10] (used reg = )
22425 6243           30E4                       xor	ah,ah
22426 6245           8946         F2            mov	-$E[bp],ax
22427                                           !BCC_EOS
22428                                           ! 3919       head = *(((Bit8u *)&DX)+1);
22429                                           ! Debug: eq unsigned char DX = [S+$26+$13] to unsigned short head = [S+$26-$E] (used reg = )
22430 6248           8A46         15            mov	al,$15[bp]
22431 624B           30E4                       xor	ah,ah
22432 624D           8946         F4            mov	-$C[bp],ax
22433                                           !BCC_EOS
22434                                           ! 3920       segment = ES;
22435                                           ! Debug: eq unsigned short ES = [S+$26+6] to unsigned short segment = [S+$26-$12] (used reg = )
22436 6250           8B46         08            mov	ax,8[bp]
22437 6253           8946         F0            mov	-$10[bp],ax
22438                                           !BCC_EOS
22439                                           ! 3921       offset = BX;
22440                                           ! Debug: eq unsigned short BX = [S+$26+$10] to unsigned short offset = [S+$26-$14] (used reg = )
22441 6256           8B46         12            mov	ax,$12[bp]
22442 6259           8946         EE            mov	-$12[bp],ax
22443                                           !BCC_EOS
22444                                           ! 3922       if ((count > 128) || (count == 0) || (sector == 0)) {
22445                                           ! Debug: gt int = const $80 to unsigned short count = [S+$26-$24] (used reg = )
22446 625C           8B46         DE            mov	ax,-$22[bp]
22447 625F           3D                   0080  cmp	ax,#$80
22448 6262           77           0E            ja  	.567
22449                       00006264            .569:
22450                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$26-$24] (used reg = )
22451 6264           8B46         DE            mov	ax,-$22[bp]
22452 6267           85C0                       test	ax,ax
22453 6269           74           07            je  	.567
22454                       0000626B            .568:
22455                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22456 626B           8B46         F2            mov	ax,-$E[bp]
22457 626E           85C0                       test	ax,ax
22458 6270           75           1A            jne 	.566
22459                       00006272            .567:
22460                                           ! 3923         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",*(((Bit8u *)&AX)+1));
22461                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
22462 6272           8A46         19            mov	al,$19[bp]
22463 6275           30E4                       xor	ah,ah
22464 6277           50                         push	ax
22465                                           ! Debug: list * char = .56A+0 (used reg = )
22466 6278           BB                   D1D5  mov	bx,#.56A
22467 627B           53                         push	bx
22468                                           ! Debug: list int = const 4 (used reg = )
22469 627C           B8                   0004  mov	ax,*4
22470 627F           50                         push	ax
22471                                           ! Debug: func () void = bios_printf+0 (used reg = )
22472 6280           E8         A6B6            call	_bios_printf
22473 6283           83C4                   06  add	sp,*6
22474                                           !BCC_EOS
22475                                           ! 3924         goto int13_fail;
22476 6286           83C4                   00  add	sp,#..FFF1-..FFF0
22477 6289           E9         0625            br 	.FFF1
22478                                           !BCC_EOS
22479                                           ! 3925       }
22480                                           ! 3926       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22481                       0000628C            .566:
22482                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22483 628C           8A46         DD            mov	al,-$23[bp]
22484 628F           30E4                       xor	ah,ah
22485 6291           B9                   001E  mov	cx,*$1E
22486 6294           F7E9                       imul	cx
22487 6296           89C3                       mov	bx,ax
22488                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22489                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22490                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22491 6298           8B9F       014E            mov	bx,$14E[bx]
22492 629C           895E         E6            mov	-$1A[bp],bx
22493                                           !BCC_EOS
22494                                           ! 3927       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22495                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22496 629F           8A46         DD            mov	al,-$23[bp]
22497 62A2           30E4                       xor	ah,ah
22498 62A4           B9                   001E  mov	cx,*$1E
22499 62A7           F7E9                       imul	cx
22500 62A9           89C3                       mov	bx,ax
22501                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22502                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22503                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22504 62AB           8B9F       014C            mov	bx,$14C[bx]
22505 62AF           895E         E4            mov	-$1C[bp],bx
22506                                           !BCC_EOS
22507                                           ! 3928       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22508                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22509 62B2           8A46         DD            mov	al,-$23[bp]
22510 62B5           30E4                       xor	ah,ah
22511 62B7           B9                   001E  mov	cx,*$1E
22512 62BA           F7E9                       imul	cx
22513 62BC           89C3                       mov	bx,ax
22514                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22515                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22516                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22517 62BE           8B9F       0150            mov	bx,$150[bx]
22518 62C2           895E         E2            mov	-$1E[bp],bx
22519                                           !BCC_EOS
22520                                           ! 3929       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
22521                                           ! Debug: ge unsigned short nlc = [S+$26-$1C] to unsigned short cylinder = [S+$26-$C] (used reg = )
22522 62C5           8B46         F6            mov	ax,-$A[bp]
22523 62C8           3B46         E6            cmp	ax,-$1A[bp]
22524 62CB           73           10            jae 	.56C
22525                       000062CD            .56E:
22526                                           ! Debug: ge unsigned short nlh = [S+$26-$1E] to unsigned short head = [S+$26-$E] (used reg = )
22527 62CD           8B46         F4            mov	ax,-$C[bp]
22528 62D0           3B46         E4            cmp	ax,-$1C[bp]
22529 62D3           73           08            jae 	.56C
22530                       000062D5            .56D:
22531                                           ! Debug: gt unsigned short nlspt = [S+$26-$20] to unsigned short sector = [S+$26-$10] (used reg = )
22532 62D5           8B46         F2            mov	ax,-$E[bp]
22533 62D8           3B46         E2            cmp	ax,-$1E[bp]
22534 62DB           76           23            jbe 	.56B
22535                       000062DD            .56C:
22536                                           ! 3930         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", *(((Bit8u *)&AX)+1), cylinder, head, sector);
22537                                           ! Debug: list unsigned short sector = [S+$26-$10] (used reg = )
22538 62DD           FF76         F2            push	-$E[bp]
22539                                           ! Debug: list unsigned short head = [S+$28-$E] (used reg = )
22540 62E0           FF76         F4            push	-$C[bp]
22541                                           ! Debug: list unsigned short cylinder = [S+$2A-$C] (used reg = )
22542 62E3           FF76         F6            push	-$A[bp]
22543                                           ! Debug: list unsigned char AX = [S+$2C+$17] (used reg = )
22544 62E6           8A46         19            mov	al,$19[bp]
22545 62E9           30E4                       xor	ah,ah
22546 62EB           50                         push	ax
22547                                           ! Debug: list * char = .56F+0 (used reg = )
22548 62EC           BB                   D18D  mov	bx,#.56F
22549 62EF           53                         push	bx
22550                                           ! Debug: list int = const 4 (used reg = )
22551 62F0           B8                   0004  mov	ax,*4
22552 62F3           50                         push	ax
22553                                           ! Debug: func () void = bios_printf+0 (used reg = )
22554 62F4           E8         A642            call	_bios_printf
22555 62F7           83C4                   0C  add	sp,*$C
22556                                           !BCC_EOS
22557                                           ! 3931         goto int13_fail;
22558 62FA           83C4                   00  add	sp,#..FFF1-..FFF0
22559 62FD           E9         05B1            br 	.FFF1
22560                                           !BCC_EOS
22561                                           ! 3932       }
22562                                           ! 3933       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
22563                       00006300            .56B:
22564                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$26+$17] (used reg = )
22565 6300           8A46         19            mov	al,$19[bp]
22566 6303           3C                     04  cmp	al,*4
22567 6305           75           06            jne 	.570
22568                       00006307            .571:
22569 6307           83C4                   00  add	sp,#..FFEF-..FFF0
22570 630A           E9         05C9            br 	.FFEF
22571                                           !BCC_EOS
22572                                           ! 3934       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
22573                       0000630D            .570:
22574                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22575 630D           8A46         DD            mov	al,-$23[bp]
22576 6310           30E4                       xor	ah,ah
22577 6312           B9                   001E  mov	cx,*$1E
22578 6315           F7E9                       imul	cx
22579 6317           89C3                       mov	bx,ax
22580                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
22581                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
22582                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$26-$18] (used reg = )
22583 6319           8B9F       0152            mov	bx,$152[bx]
22584 631D           895E         EA            mov	-$16[bp],bx
22585                                           !BCC_EOS
22586                                           ! 3935       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
22587                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22588 6320           8A46         DD            mov	al,-$23[bp]
22589 6323           30E4                       xor	ah,ah
22590 6325           B9                   001E  mov	cx,*$1E
22591 6328           F7E9                       imul	cx
22592 632A           89C3                       mov	bx,ax
22593                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
22594                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
22595                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$26-$1A] (used reg = )
22596 632C           8B9F       0156            mov	bx,$156[bx]
22597 6330           895E         E8            mov	-$18[bp],bx
22598                                           !BCC_EOS
22599                                           ! 3936       if ( (nph != nlh) || (npspt != nlspt)) {
22600                                           ! Debug: ne unsigned short nlh = [S+$26-$1E] to unsigned short nph = [S+$26-$18] (used reg = )
22601 6333           8B46         EA            mov	ax,-$16[bp]
22602 6336           3B46         E4            cmp	ax,-$1C[bp]
22603 6339           75           08            jne 	.573
22604                       0000633B            .574:
22605                                           ! Debug: ne unsigned short nlspt = [S+$26-$20] to unsigned short npspt = [S+$26-$1A] (used reg = )
22606 633B           8B46         E8            mov	ax,-$18[bp]
22607 633E           3B46         E2            cmp	ax,-$1E[bp]
22608 6341           74           72            je  	.572
22609                       00006343            .573:
22610                                           ! 3937         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
22611                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22612 6343           8B46         F2            mov	ax,-$E[bp]
22613 6346           31DB                       xor	bx,bx
22614 6348           53                         push	bx
22615 6349           50                         push	ax
22616                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2A-$20] (used reg = )
22617 634A           8B46         E2            mov	ax,-$1E[bp]
22618 634D           31DB                       xor	bx,bx
22619 634F           53                         push	bx
22620 6350           50                         push	ax
22621                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$2E-$E] (used reg = )
22622 6351           8B46         F4            mov	ax,-$C[bp]
22623 6354           31DB                       xor	bx,bx
22624 6356           53                         push	bx
22625 6357           50                         push	ax
22626                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$32-$1E] (used reg = )
22627 6358           8B46         E4            mov	ax,-$1C[bp]
22628 635B           31DB                       xor	bx,bx
22629 635D           53                         push	bx
22630 635E           50                         push	ax
22631                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$36-$C] (used reg = )
22632 635F           8B46         F6            mov	ax,-$A[bp]
22633 6362           31DB                       xor	bx,bx
22634                                           ! Debug: mul unsigned long (temp) = [S+$36-$36] to unsigned long = bx+0 (used reg = )
22635 6364           8D7E         CC            lea	di,-$E+..FFF0[bp]
22636 6367           E8         9D50            call	lmulul
22637 636A           83C4                   04  add	sp,*4
22638                                           ! Debug: add unsigned long (temp) = [S+$32-$32] to unsigned long = bx+0 (used reg = )
22639 636D           8D7E         D0            lea	di,-$A+..FFF0[bp]
22640 6370           E8         9D21            call	laddul
22641 6373           83C4                   04  add	sp,*4
22642                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
22643 6376           8D7E         D4            lea	di,-6+..FFF0[bp]
22644 6379           E8         9D3E            call	lmulul
22645 637C           83C4                   04  add	sp,*4
22646                                           ! Debug: add unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
22647 637F           8D7E         D8            lea	di,-2+..FFF0[bp]
22648 6382           E8         9D0F            call	laddul
22649 6385           83C4                   04  add	sp,*4
22650                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
22651 6388           53                         push	bx
22652 6389           50                         push	ax
22653 638A           B8                   0001  mov	ax,*1
22654 638D           31DB                       xor	bx,bx
22655 638F           53                         push	bx
22656 6390           50                         push	ax
22657 6391           8B46         D8            mov	ax,-2+..FFF0[bp]
22658 6394           8B5E         DA            mov	bx,0+..FFF0[bp]
22659 6397           8D7E         D4            lea	di,-6+..FFF0[bp]
22660 639A           E8         9D15            call	lsubul
22661 639D           83C4                   08  add	sp,*8
22662                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
22663 63A0           8946         FC            mov	-4[bp],ax
22664 63A3           895E         FE            mov	-2[bp],bx
22665                                           !BCC_EOS
22666                                           ! 3938         lba_high = 0;
22667                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$26-$A] (used reg = )
22668 63A6           31C0                       xor	ax,ax
22669 63A8           31DB                       xor	bx,bx
22670 63AA           8946         F8            mov	-8[bp],ax
22671 63AD           895E         FA            mov	-6[bp],bx
22672                                           !BCC_EOS
22673                                           ! 3939         sector = 0;
22674                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22675 63B0           31C0                       xor	ax,ax
22676 63B2           8946         F2            mov	-$E[bp],ax
22677                                           !BCC_EOS
22678                                           ! 3940       }
22679                                           ! 3941       if (*(((Bit8u *)&AX)+1) == 0x02)
22680                       000063B5            .572:
22681                                           ! Debug: logeq int = const 2 to unsigned char AX = [S+$26+$17] (used reg = )
22682 63B5           8A46         19            mov	al,$19[bp]
22683 63B8           3C                     02  cmp	al,*2
22684 63BA           75           36            jne 	.575
22685                       000063BC            .576:
22686                                           ! 3942         status=ata_cmd_data_io(0, device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22687                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22688 63BC           FF76         EE            push	-$12[bp]
22689                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22690 63BF           FF76         F0            push	-$10[bp]
22691                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22692 63C2           FF76         FA            push	-6[bp]
22693 63C5           FF76         F8            push	-8[bp]
22694                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22695 63C8           FF76         FE            push	-2[bp]
22696 63CB           FF76         FC            push	-4[bp]
22697                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22698 63CE           FF76         F2            push	-$E[bp]
22699                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22700 63D1           FF76         F4            push	-$C[bp]
22701                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22702 63D4           FF76         F6            push	-$A[bp]
22703                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22704 63D7           FF76         DE            push	-$22[bp]
22705                                           ! Debug: list int = const $20 (used reg = )
22706 63DA           B8                   0020  mov	ax,*$20
22707 63DD           50                         push	ax
22708                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22709 63DE           8A46         DD            mov	al,-$23[bp]
22710 63E1           30E4                       xor	ah,ah
22711 63E3           50                         push	ax
22712                                           ! Debug: list int = const 0 (used reg = )
22713 63E4           31C0                       xor	ax,ax
22714 63E6           50                         push	ax
22715                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22716 63E7           E8         C597            call	_ata_cmd_data_io
22717 63EA           83C4                   1A  add	sp,*$1A
22718                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22719 63ED           8846         DC            mov	-$24[bp],al
22720                                           !BCC_EOS
22721                                           ! 3943       else
22722                                           ! 3944         status=ata_cmd_data_io(1, device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22723 63F0           EB           35            jmp .577
22724                       000063F2            .575:
22725                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22726 63F2           FF76         EE            push	-$12[bp]
22727                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22728 63F5           FF76         F0            push	-$10[bp]
22729                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22730 63F8           FF76         FA            push	-6[bp]
22731 63FB           FF76         F8            push	-8[bp]
22732                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22733 63FE           FF76         FE            push	-2[bp]
22734 6401           FF76         FC            push	-4[bp]
22735                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22736 6404           FF76         F2            push	-$E[bp]
22737                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22738 6407           FF76         F4            push	-$C[bp]
22739                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22740 640A           FF76         F6            push	-$A[bp]
22741                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22742 640D           FF76         DE            push	-$22[bp]
22743                                           ! Debug: list int = const $30 (used reg = )
22744 6410           B8                   0030  mov	ax,*$30
22745 6413           50                         push	ax
22746                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22747 6414           8A46         DD            mov	al,-$23[bp]
22748 6417           30E4                       xor	ah,ah
22749 6419           50                         push	ax
22750                                           ! Debug: list int = const 1 (used reg = )
22751 641A           B8                   0001  mov	ax,*1
22752 641D           50                         push	ax
22753                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22754 641E           E8         C560            call	_ata_cmd_data_io
22755 6421           83C4                   1A  add	sp,*$1A
22756                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22757 6424           8846         DC            mov	-$24[bp],al
22758                                           !BCC_EOS
22759                                           ! 3945       *((Bit8u *)&AX) = (*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)));
22760                       00006427            .577:
22761                                           ! Debug: eq unsigned short = [+$254] to unsigned char AX = [S+$26+$16] (used reg = )
22762 6427           A0         0254            mov	al,[$254]
22763 642A           8846         18            mov	$18[bp],al
22764                                           !BCC_EOS
22765                                           ! 3946       if (status != 0) {
22766                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
22767 642D           8A46         DC            mov	al,-$24[bp]
22768 6430           84C0                       test	al,al
22769 6432           74           25            je  	.578
22770                       00006434            .579:
22771                                           ! 3947         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*
22772                                           ! 3947 (((Bit8u *)&AX)+1),status);
22773                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
22774 6434           8A46         DC            mov	al,-$24[bp]
22775 6437           30E4                       xor	ah,ah
22776 6439           50                         push	ax
22777                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22778 643A           8A46         19            mov	al,$19[bp]
22779 643D           30E4                       xor	ah,ah
22780 643F           50                         push	ax
22781                                           ! Debug: list * char = .57A+0 (used reg = )
22782 6440           BB                   D160  mov	bx,#.57A
22783 6443           53                         push	bx
22784                                           ! Debug: list int = const 4 (used reg = )
22785 6444           B8                   0004  mov	ax,*4
22786 6447           50                         push	ax
22787                                           ! Debug: func () void = bios_printf+0 (used reg = )
22788 6448           E8         A4EE            call	_bios_printf
22789 644B           83C4                   08  add	sp,*8
22790                                           !BCC_EOS
22791                                           ! 3948         *(((Bit8u *)&AX)+1) = (0x0c);
22792                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
22793 644E           B0                     0C  mov	al,*$C
22794 6450           8846         19            mov	$19[bp],al
22795                                           !BCC_EOS
22796                                           ! 3949         goto int13_fail_noah;
22797 6453           83C4                   00  add	sp,#..FFEC-..FFF0
22798 6456           E9         045D            br 	.FFEC
22799                                           !BCC_EOS
22800                                           ! 3950       }
22801                                           ! 3951       goto int13_success;
22802                       00006459            .578:
22803 6459           83C4                   00  add	sp,#..FFEF-..FFF0
22804 645C           E9         0477            br 	.FFEF
22805                                           !BCC_EOS
22806                                           ! 3952       break;
22807 645F           E9         044F            br 	.55B
22808                                           !BCC_EOS
22809                                           ! 3953     case 0x05:
22810                                           ! 3954       bios_printf(4, "format disk track called\n");
22811                       00006462            .57B:
22812                                           ! Debug: list * char = .57C+0 (used reg = )
22813 6462           BB                   D146  mov	bx,#.57C
22814 6465           53                         push	bx
22815                                           ! Debug: list int = const 4 (used reg = )
22816 6466           B8                   0004  mov	ax,*4
22817 6469           50                         push	ax
22818                                           ! Debug: func () void = bios_printf+0 (used reg = )
22819 646A           E8         A4CC            call	_bios_printf
22820 646D           83C4                   04  add	sp,*4
22821                                           !BCC_EOS
22822                                           ! 3955       goto int13_success;
22823 6470           83C4                   00  add	sp,#..FFEF-..FFF0
22824 6473           E9         0460            br 	.FFEF
22825                                           !BCC_EOS
22826                                           ! 3956       return;
22827 6476           89EC                       mov	sp,bp
22828 6478           5D                         pop	bp
22829 6479           C3                         ret
22830                                           !BCC_EOS
22831                                           ! 3957       break;
22832 647A           E9         0434            br 	.55B
22833                                           !BCC_EOS
22834                                           ! 3958     case 0x08:
22835                                           ! 3959       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22836                       0000647D            .57D:
22837                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22838 647D           8A46         DD            mov	al,-$23[bp]
22839 6480           30E4                       xor	ah,ah
22840 6482           B9                   001E  mov	cx,*$1E
22841 6485           F7E9                       imul	cx
22842 6487           89C3                       mov	bx,ax
22843                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22844                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22845                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22846 6489           8B9F       014E            mov	bx,$14E[bx]
22847 648D           895E         E6            mov	-$1A[bp],bx
22848                                           !BCC_EOS
22849                                           ! 3960       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22850                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22851 6490           8A46         DD            mov	al,-$23[bp]
22852 6493           30E4                       xor	ah,ah
22853 6495           B9                   001E  mov	cx,*$1E
22854 6498           F7E9                       imul	cx
22855 649A           89C3                       mov	bx,ax
22856                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22857                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22858                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22859 649C           8B9F       014C            mov	bx,$14C[bx]
22860 64A0           895E         E4            mov	-$1C[bp],bx
22861                                           !BCC_EOS
22862                                           ! 3961       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22863                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22864 64A3           8A46         DD            mov	al,-$23[bp]
22865 64A6           30E4                       xor	ah,ah
22866 64A8           B9                   001E  mov	cx,*$1E
22867 64AB           F7E9                       imul	cx
22868 64AD           89C3                       mov	bx,ax
22869                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22870                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22871                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22872 64AF           8B9F       0150            mov	bx,$150[bx]
22873 64B3           895E         E2            mov	-$1E[bp],bx
22874                                           !BCC_EOS
22875                                           ! 3962       count = *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount));
22876                                           ! Debug: eq unsigned char = [+$232] to unsigned short count = [S+$26-$24] (used reg = )
22877 64B6           A0         0232            mov	al,[$232]
22878 64B9           30E4                       xor	ah,ah
22879 64BB           8946         DE            mov	-$22[bp],ax
22880                                           !BCC_EOS
22881                                           ! 3963       nlc = nlc - 1;
22882                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22883 64BE           8B46         E6            mov	ax,-$1A[bp]
22884                                           ! Debug: eq unsigned int = ax-1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22885 64C1           48                         dec	ax
22886 64C2           8946         E6            mov	-$1A[bp],ax
22887                                           !BCC_EOS
22888                                           ! 3964       *((Bit8u *)&AX) = (0);
22889                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$16] (used reg = )
22890 64C5           30C0                       xor	al,al
22891 64C7           8846         18            mov	$18[bp],al
22892                                           !BCC_EOS
22893                                           ! 3965       *(((Bit8u *)&CX)+1) = (nlc & 0xff);
22894                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$26-$1C] (used reg = )
22895 64CA           8A46         E6            mov	al,-$1A[bp]
22896                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$15] (used reg = )
22897 64CD           8846         17            mov	$17[bp],al
22898                                           !BCC_EOS
22899                                           ! 3966       *((Bit8u *)&CX) = (((nlc >> 2) & 0xc0) | (nlspt & 0x3f));
22900                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$26-$20] (used reg = )
22901 64D0           8A46         E2            mov	al,-$1E[bp]
22902 64D3           24                     3F  and	al,*$3F
22903 64D5           50                         push	ax
22904                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$28-$1C] (used reg = )
22905 64D6           8B46         E6            mov	ax,-$1A[bp]
22906 64D9           D1E8                       shr	ax,*1
22907 64DB           D1E8                       shr	ax,*1
22908                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
22909 64DD           24                     C0  and	al,#$C0
22910                                           ! Debug: or unsigned char (temp) = [S+$28-$28] to unsigned char = al+0 (used reg = )
22911 64DF           0A46         DA            or	al,0+..FFF0[bp]
22912 64E2           44                         inc	sp
22913 64E3           44                         inc	sp
22914                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$14] (used reg = )
22915 64E4           8846         16            mov	$16[bp],al
22916                                           !BCC_EOS
22917                                           ! 3967       *(((Bit8u *)&DX)+1) = (nlh - 1);
22918                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$26-$1E] (used reg = )
22919 64E7           8B46         E4            mov	ax,-$1C[bp]
22920                                           ! Debug: eq unsigned int = ax-1 to unsigned char DX = [S+$26+$13] (used reg = )
22921 64EA           48                         dec	ax
22922 64EB           8846         15            mov	$15[bp],al
22923                                           !BCC_EOS
22924                                           ! 3968       *((Bit8u *)&DX) = (count);
22925                                           ! Debug: eq unsigned short count = [S+$26-$24] to unsigned char DX = [S+$26+$12] (used reg = )
22926 64EE           8A46         DE            mov	al,-$22[bp]
22927 64F1           8846         14            mov	$14[bp],al
22928                                           !BCC_EOS
22929                                           ! 3969       goto int13_success;
22930 64F4           83C4                   00  add	sp,#..FFEF-..FFF0
22931 64F7           E9         03DC            br 	.FFEF
22932                                           !BCC_EOS
22933                                           ! 3970       break;
22934 64FA           E9         03B4            br 	.55B
22935                                           !BCC_EOS
22936                                           ! 3971     case 0x10:
22937                                           ! 3972       status = inb(*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[device/2].iobase1)) + 7);
22938                       000064FD            .57E:
22939                                           ! Debug: div int = const 2 to unsigned char device = [S+$26-$25] (used reg = )
22940 64FD           8A46         DD            mov	al,-$23[bp]
22941 6500           30E4                       xor	ah,ah
22942 6502           D1E8                       shr	ax,*1
22943                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
22944 6504           B1                     03  mov	cl,*3
22945 6506           D3E0                       shl	ax,cl
22946 6508           89C3                       mov	bx,ax
22947                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
22948                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
22949                                           ! Debug: add int = const 7 to unsigned short = [bx+$124] (used reg = )
22950 650A           8B9F       0124            mov	bx,$124[bx]
22951                                           ! Debug: list unsigned int = bx+7 (used reg = )
22952 650E           83C3                   07  add	bx,*7
22953 6511           53                         push	bx
22954                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22955 6512           E8         A014            call	_inb
22956 6515           44                         inc	sp
22957 6516           44                         inc	sp
22958                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22959 6517           8846         DC            mov	-$24[bp],al
22960                                           !BCC_EOS
22961                                           ! 3973       if ( (status & (0x80 | 0x40)) == 0x40 ) {
22962                                           ! Debug: and int = const $C0 to unsigned char status = [S+$26-$26] (used reg = )
22963 651A           8A46         DC            mov	al,-$24[bp]
22964 651D           24                     C0  and	al,#$C0
22965                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
22966 651F           3C                     40  cmp	al,*$40
22967 6521           75           08            jne 	.57F
22968                       00006523            .580:
22969                                           ! 3974         goto int13_success;
22970 6523           83C4                   00  add	sp,#..FFEF-..FFF0
22971 6526           E9         03AD            br 	.FFEF
22972                                           !BCC_EOS
22973                                           ! 3975       }
22974                                           ! 3976       else {
22975 6529           EB           0B            jmp .581
22976                       0000652B            .57F:
22977                                           ! 3977         *(((Bit8u *)&AX)+1) = (0xAA);
22978                                           ! Debug: eq int = const $AA to unsigned char AX = [S+$26+$17] (used reg = )
22979 652B           B0                     AA  mov	al,#$AA
22980 652D           8846         19            mov	$19[bp],al
22981                                           !BCC_EOS
22982                                           ! 3978         goto int13_fail_noah;
22983 6530           83C4                   00  add	sp,#..FFEC-..FFF0
22984 6533           E9         0380            br 	.FFEC
22985                                           !BCC_EOS
22986                                           ! 3979       }
22987                                           ! 3980       break;
22988                       00006536            .581:
22989 6536           E9         0378            br 	.55B
22990                                           !BCC_EOS
22991                                           ! 3981     case 0x15:
22992                                           ! 3982       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22993                       00006539            .582:
22994                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22995 6539           8A46         DD            mov	al,-$23[bp]
22996 653C           30E4                       xor	ah,ah
22997 653E           B9                   001E  mov	cx,*$1E
22998 6541           F7E9                       imul	cx
22999 6543           89C3                       mov	bx,ax
23000                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23001                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
23002                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
23003 6545           8B9F       014E            mov	bx,$14E[bx]
23004 6549           895E         E6            mov	-$1A[bp],bx
23005                                           !BCC_EOS
23006                                           ! 3983       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
23007                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23008 654C           8A46         DD            mov	al,-$23[bp]
23009 654F           30E4                       xor	ah,ah
23010 6551           B9                   001E  mov	cx,*$1E
23011 6554           F7E9                       imul	cx
23012 6556           89C3                       mov	bx,ax
23013                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23014                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
23015                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
23016 6558           8B9F       014C            mov	bx,$14C[bx]
23017 655C           895E         E4            mov	-$1C[bp],bx
23018                                           !BCC_EOS
23019                                           ! 3984       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
23020                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23021 655F           8A46         DD            mov	al,-$23[bp]
23022 6562           30E4                       xor	ah,ah
23023 6564           B9                   001E  mov	cx,*$1E
23024 6567           F7E9                       imul	cx
23025 6569           89C3                       mov	bx,ax
23026                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23027                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
23028                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
23029 656B           8B9F       0150            mov	bx,$150[bx]
23030 656F           895E         E2            mov	-$1E[bp],bx
23031                                           !BCC_EOS
23032                                           ! 3985       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23033                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$26-$20] (used reg = )
23034 6572           8B46         E2            mov	ax,-$1E[bp]
23035 6575           31DB                       xor	bx,bx
23036 6577           53                         push	bx
23037 6578           50                         push	ax
23038                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2A-$1E] (used reg = )
23039 6579           8B46         E4            mov	ax,-$1C[bp]
23040 657C           31DB                       xor	bx,bx
23041 657E           53                         push	bx
23042 657F           50                         push	ax
23043                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$2E-$1C] (used reg = )
23044 6580           8B46         E6            mov	ax,-$1A[bp]
23045                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23046 6583           48                         dec	ax
23047 6584           31DB                       xor	bx,bx
23048                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
23049 6586           8D7E         D4            lea	di,-6+..FFF0[bp]
23050 6589           E8         9B2E            call	lmulul
23051 658C           83C4                   04  add	sp,*4
23052                                           ! Debug: mul unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
23053 658F           8D7E         D8            lea	di,-2+..FFF0[bp]
23054 6592           E8         9B25            call	lmulul
23055 6595           83C4                   04  add	sp,*4
23056                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23057 6598           8946         FC            mov	-4[bp],ax
23058 659B           895E         FE            mov	-2[bp],bx
23059                                           !BCC_EOS
23060                                           ! 3986       CX = *(((Bit16u *)&lba_low)+1);
23061                                           ! Debug: eq unsigned short lba_low = [S+$26-4] to unsigned short CX = [S+$26+$14] (used reg = )
23062 659E           8B46         FE            mov	ax,-2[bp]
23063 65A1           8946         16            mov	$16[bp],ax
23064                                           !BCC_EOS
23065                                           ! 3987       DX = *((Bit16u *)&lba_low);
23066                                           ! Debug: eq unsigned short lba_low = [S+$26-6] to unsigned short DX = [S+$26+$12] (used reg = )
23067 65A4           8B46         FC            mov	ax,-4[bp]
23068 65A7           8946         14            mov	$14[bp],ax
23069                                           !BCC_EOS
23070                                           ! 3988       *(((Bit8u *)&AX)+1) = (3);
23071                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$26+$17] (used reg = )
23072 65AA           B0                     03  mov	al,*3
23073 65AC           8846         19            mov	$19[bp],al
23074                                           !BCC_EOS
23075                                           ! 3989       goto int13_success_noah;
23076 65AF           83C4                   00  add	sp,#..FFED-..FFF0
23077 65B2           E9         0326            br 	.FFED
23078                                           !BCC_EOS
23079                                           ! 3990       break;
23080 65B5           E9         02F9            br 	.55B
23081                                           !BCC_EOS
23082                                           ! 3991     case 0x41:
23083                                           ! 3992       BX=0xaa55;
23084                       000065B8            .583:
23085                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$26+$10] (used reg = )
23086 65B8           B8                   AA55  mov	ax,#$AA55
23087 65BB           8946         12            mov	$12[bp],ax
23088                                           !BCC_EOS
23089                                           ! 3993       *(((Bit8u *)&AX)+1) = (0x30);
23090                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$26+$17] (used reg = )
23091 65BE           B0                     30  mov	al,*$30
23092 65C0           8846         19            mov	$19[bp],al
23093                                           !BCC_EOS
23094                                           ! 3994       CX=0x0007;
23095                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$26+$14] (used reg = )
23096 65C3           B8                   0007  mov	ax,*7
23097 65C6           8946         16            mov	$16[bp],ax
23098                                           !BCC_EOS
23099                                           ! 3995       goto int13_success_noah;
23100 65C9           83C4                   00  add	sp,#..FFED-..FFF0
23101 65CC           E9         030C            br 	.FFED
23102                                           !BCC_EOS
23103                                           ! 3996       break;
23104 65CF           E9         02DF            br 	.55B
23105                                           !BCC_EOS
23106                                           ! 3997     case 0x42:
23107                                           ! 3998     case 0x43:
23108                       000065D2            .584:
23109                                           ! 3999     case 0x44:
23110                       000065D2            .585:
23111                                           ! 4000     case 0x47:
23112                       000065D2            .586:
23113                                           ! 4001       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23114                       000065D2            .587:
23115                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23116 65D2           FF76         06            push	6[bp]
23117                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23118 65D5           8B46         0C            mov	ax,$C[bp]
23119                                           ! Debug: list unsigned int = ax+2 (used reg = )
23120 65D8           40                         inc	ax
23121 65D9           40                         inc	ax
23122 65DA           50                         push	ax
23123                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23124 65DB           E8         A00F            call	__read_word
23125 65DE           83C4                   04  add	sp,*4
23126                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$26-$24] (used reg = )
23127 65E1           8946         DE            mov	-$22[bp],ax
23128                                           !BCC_EOS
23129                                           ! 4002       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
23130                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23131 65E4           FF76         06            push	6[bp]
23132                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23133 65E7           8B46         0C            mov	ax,$C[bp]
23134                                           ! Debug: list unsigned int = ax+6 (used reg = )
23135 65EA           05                   0006  add	ax,*6
23136 65ED           50                         push	ax
23137                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23138 65EE           E8         9FFC            call	__read_word
23139 65F1           83C4                   04  add	sp,*4
23140                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$26-$12] (used reg = )
23141 65F4           8946         F0            mov	-$10[bp],ax
23142                                           !BCC_EOS
23143                                           ! 4003       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
23144                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23145 65F7           FF76         06            push	6[bp]
23146                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23147 65FA           8B46         0C            mov	ax,$C[bp]
23148                                           ! Debug: list unsigned int = ax+4 (used reg = )
23149 65FD           05                   0004  add	ax,*4
23150 6600           50                         push	ax
23151                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23152 6601           E8         9FE9            call	__read_word
23153 6604           83C4                   04  add	sp,*4
23154                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$26-$14] (used reg = )
23155 6607           8946         EE            mov	-$12[bp],ax
23156                                           !BCC_EOS
23157                                           ! 4004       lba_high=_read_dword(
23158                                           ! 4004 SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
23159                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23160 660A           FF76         06            push	6[bp]
23161                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23162 660D           8B46         0C            mov	ax,$C[bp]
23163                                           ! Debug: list unsigned int = ax+$C (used reg = )
23164 6610           05                   000C  add	ax,*$C
23165 6613           50                         push	ax
23166                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23167 6614           E8         9A3F            call	__read_dword
23168 6617           89D3                       mov	bx,dx
23169 6619           83C4                   04  add	sp,*4
23170                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$26-$A] (used reg = )
23171 661C           8946         F8            mov	-8[bp],ax
23172 661F           895E         FA            mov	-6[bp],bx
23173                                           !BCC_EOS
23174                                           ! 4005       if (lba_high > *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) ) {
23175                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23176 6622           8A46         DD            mov	al,-$23[bp]
23177 6625           30E4                       xor	ah,ah
23178 6627           B9                   001E  mov	cx,*$1E
23179 662A           F7E9                       imul	cx
23180 662C           89C3                       mov	bx,ax
23181                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23182                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23183                                           ! Debug: gt unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23184 662E           8B87       015C            mov	ax,$15C[bx]
23185 6632           8B9F       015E            mov	bx,$15E[bx]
23186 6636           8D7E         F8            lea	di,-8[bp]
23187 6639           E8         9A60            call	lcmpul
23188 663C           73           1A            jae 	.588
23189                       0000663E            .589:
23190                                           ! 4006         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23191                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23192 663E           8A46         19            mov	al,$19[bp]
23193 6641           30E4                       xor	ah,ah
23194 6643           50                         push	ax
23195                                           ! Debug: list * char = .58A+0 (used reg = )
23196 6644           BB                   D115  mov	bx,#.58A
23197 6647           53                         push	bx
23198                                           ! Debug: list int = const 4 (used reg = )
23199 6648           B8                   0004  mov	ax,*4
23200 664B           50                         push	ax
23201                                           ! Debug: func () void = bios_printf+0 (used reg = )
23202 664C           E8         A2EA            call	_bios_printf
23203 664F           83C4                   06  add	sp,*6
23204                                           !BCC_EOS
23205                                           ! 4007         goto int13_fail;
23206 6652           83C4                   00  add	sp,#..FFF1-..FFF0
23207 6655           E9         0259            br 	.FFF1
23208                                           !BCC_EOS
23209                                           ! 4008       }
23210                                           ! 4009       lba_low=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
23211                       00006658            .588:
23212                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23213 6658           FF76         06            push	6[bp]
23214                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
23215 665B           8B46         0C            mov	ax,$C[bp]
23216                                           ! Debug: list unsigned int = ax+8 (used reg = )
23217 665E           05                   0008  add	ax,*8
23218 6661           50                         push	ax
23219                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23220 6662           E8         99F1            call	__read_dword
23221 6665           89D3                       mov	bx,dx
23222 6667           83C4                   04  add	sp,*4
23223                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23224 666A           8946         FC            mov	-4[bp],ax
23225 666D           895E         FE            mov	-2[bp],bx
23226                                           !BCC_EOS
23227                                           ! 4010       if (lba_high == *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high))
23228                                           ! 4011           && lba_low >= *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) ) {
23229                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23230 6670           8A46         DD            mov	al,-$23[bp]
23231 6673           30E4                       xor	ah,ah
23232 6675           B9                   001E  mov	cx,*$1E
23233 6678           F7E9                       imul	cx
23234 667A           89C3                       mov	bx,ax
23235                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23236                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23237                                           ! Debug: logeq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23238 667C           8B87       015C            mov	ax,$15C[bx]
23239 6680           8B9F       015E            mov	bx,$15E[bx]
23240 6684           8D7E         F8            lea	di,-8[bp]
23241 6687           E8         9A12            call	lcmpul
23242 668A           75           36            jne 	.58B
23243                       0000668C            .58D:
23244                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23245 668C           8A46         DD            mov	al,-$23[bp]
23246 668F           30E4                       xor	ah,ah
23247 6691           B9                   001E  mov	cx,*$1E
23248 6694           F7E9                       imul	cx
23249 6696           89C3                       mov	bx,ax
23250                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
23251                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
23252                                           ! Debug: ge unsigned long = [bx+$158] to unsigned long lba_low = [S+$26-6] (used reg = )
23253 6698           8B87       0158            mov	ax,$158[bx]
23254 669C           8B9F       015A            mov	bx,$15A[bx]
23255 66A0           8D7E         FC            lea	di,-4[bp]
23256 66A3           E8         99F6            call	lcmpul
23257 66A6           77           1A            ja  	.58B
23258                       000066A8            .58C:
23259                                           ! 4012         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23260                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23261 66A8           8A46         19            mov	al,$19[bp]
23262 66AB           30E4                       xor	ah,ah
23263 66AD           50                         push	ax
23264                                           ! Debug: list * char = .58E+0 (used reg = )
23265 66AE           BB                   D0E4  mov	bx,#.58E
23266 66B1           53                         push	bx
23267                                           ! Debug: list int = const 4 (used reg = )
23268 66B2           B8                   0004  mov	ax,*4
23269 66B5           50                         push	ax
23270                                           ! Debug: func () void = bios_printf+0 (used reg = )
23271 66B6           E8         A280            call	_bios_printf
23272 66B9           83C4                   06  add	sp,*6
23273                                           !BCC_EOS
23274                                           ! 4013         goto int13_fail;
23275 66BC           83C4                   00  add	sp,#..FFF1-..FFF0
23276 66BF           E9         01EF            br 	.FFF1
23277                                           !BCC_EOS
23278                                           ! 4014       }
23279                                           ! 4015       if (( *(((Bit8u *)&AX)+1) == 0x44 ) || ( *(((Bit8u *)&AX)+1) == 0x47 ))
23280                       000066C2            .58B:
23281                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$26+$17] (used reg = )
23282 66C2           8A46         19            mov	al,$19[bp]
23283 66C5           3C                     44  cmp	al,*$44
23284 66C7           74           07            je  	.590
23285                       000066C9            .591:
23286                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$26+$17] (used reg = )
23287 66C9           8A46         19            mov	al,$19[bp]
23288 66CC           3C                     47  cmp	al,*$47
23289 66CE           75           06            jne 	.58F
23290                       000066D0            .590:
23291                                           ! 4016         goto int13_success;
23292 66D0           83C4                   00  add	sp,#..FFEF-..FFF0
23293 66D3           E9         0200            br 	.FFEF
23294                                           !BCC_EOS
23295                                           ! 4017       if (*(((Bit8u *)&AX)+1) == 0x42)
23296                       000066D6            .58F:
23297                                           ! Debug: logeq int = const $42 to unsigned char AX = [S+$26+$17] (used reg = )
23298 66D6           8A46         19            mov	al,$19[bp]
23299 66D9           3C                     42  cmp	al,*$42
23300 66DB           75           36            jne 	.592
23301                       000066DD            .593:
23302                                           ! 4018         status=ata_cmd_data_io(0, device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23303                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23304 66DD           FF76         EE            push	-$12[bp]
23305                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23306 66E0           FF76         F0            push	-$10[bp]
23307                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23308 66E3           FF76         FA            push	-6[bp]
23309 66E6           FF76         F8            push	-8[bp]
23310                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23311 66E9           FF76         FE            push	-2[bp]
23312 66EC           FF76         FC            push	-4[bp]
23313                                           ! Debug: list int = const 0 (used reg = )
23314 66EF           31C0                       xor	ax,ax
23315 66F1           50                         push	ax
23316                                           ! Debug: list int = const 0 (used reg = )
23317 66F2           31C0                       xor	ax,ax
23318 66F4           50                         push	ax
23319                                           ! Debug: list int = const 0 (used reg = )
23320 66F5           31C0                       xor	ax,ax
23321 66F7           50                         push	ax
23322                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23323 66F8           FF76         DE            push	-$22[bp]
23324                                           ! Debug: list int = const $20 (used reg = )
23325 66FB           B8                   0020  mov	ax,*$20
23326 66FE           50                         push	ax
23327                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23328 66FF           8A46         DD            mov	al,-$23[bp]
23329 6702           30E4                       xor	ah,ah
23330 6704           50                         push	ax
23331                                           ! Debug: list int = const 0 (used reg = )
23332 6705           31C0                       xor	ax,ax
23333 6707           50                         push	ax
23334                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23335 6708           E8         C276            call	_ata_cmd_data_io
23336 670B           83C4                   1A  add	sp,*$1A
23337                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23338 670E           8846         DC            mov	-$24[bp],al
23339                                           !BCC_EOS
23340                                           ! 4019       else
23341                                           ! 4020         status=ata_cmd_data_io(1, device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23342 6711           EB           35            jmp .594
23343                       00006713            .592:
23344                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23345 6713           FF76         EE            push	-$12[bp]
23346                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23347 6716           FF76         F0            push	-$10[bp]
23348                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23349 6719           FF76         FA            push	-6[bp]
23350 671C           FF76         F8            push	-8[bp]
23351                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23352 671F           FF76         FE            push	-2[bp]
23353 6722           FF76         FC            push	-4[bp]
23354                                           ! Debug: list int = const 0 (used reg = )
23355 6725           31C0                       xor	ax,ax
23356 6727           50                         push	ax
23357                                           ! Debug: list int = const 0 (used reg = )
23358 6728           31C0                       xor	ax,ax
23359 672A           50                         push	ax
23360                                           ! Debug: list int = const 0 (used reg = )
23361 672B           31C0                       xor	ax,ax
23362 672D           50                         push	ax
23363                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23364 672E           FF76         DE            push	-$22[bp]
23365                                           ! Debug: list int = const $30 (used reg = )
23366 6731           B8                   0030  mov	ax,*$30
23367 6734           50                         push	ax
23368                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23369 6735           8A46         DD            mov	al,-$23[bp]
23370 6738           30E4                       xor	ah,ah
23371 673A           50                         push	ax
23372                                           ! Debug: list int = const 1 (used reg = )
23373 673B           B8                   0001  mov	ax,*1
23374 673E           50                         push	ax
23375                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23376 673F           E8         C23F            call	_ata_cmd_data_io
23377 6742           83C4                   1A  add	sp,*$1A
23378                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23379 6745           8846         DC            mov	-$24[bp],al
23380                                           !BCC_EOS
23381                                           ! 4021       count=*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors));
23382                       00006748            .594:
23383                                           ! Debug: eq unsigned short = [+$254] to unsigned short count = [S+$26-$24] (used reg = )
23384 6748           A1         0254            mov	ax,[$254]
23385 674B           8946         DE            mov	-$22[bp],ax
23386                                           !BCC_EOS
23387                                           ! 4022       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23388                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23389 674E           FF76         06            push	6[bp]
23390                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23391 6751           8B46         0C            mov	ax,$C[bp]
23392                                           ! Debug: list unsigned int = ax+2 (used reg = )
23393 6754           40                         inc	ax
23394 6755           40                         inc	ax
23395 6756           50                         push	ax
23396                                           ! Debug: list unsigned short count = [S+$2A-$24] (used reg = )
23397 6757           FF76         DE            push	-$22[bp]
23398                                           ! Debug: func () void = _write_word+0 (used reg = )
23399 675A           E8         9EB1            call	__write_word
23400 675D           83C4                   06  add	sp,*6
23401                                           !BCC_EOS
23402                                           ! 4023       if (status != 0) {
23403                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
23404 6760           8A46         DC            mov	al,-$24[bp]
23405 6763           84C0                       test	al,al
23406 6765           74           25            je  	.595
23407                       00006767            .596:
23408                                           ! 4024         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
23409                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
23410 6767           8A46         DC            mov	al,-$24[bp]
23411 676A           30E4                       xor	ah,ah
23412 676C           50                         push	ax
23413                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
23414 676D           8A46         19            mov	al,$19[bp]
23415 6770           30E4                       xor	ah,ah
23416 6772           50                         push	ax
23417                                           ! Debug: list * char = .597+0 (used reg = )
23418 6773           BB                   D0B7  mov	bx,#.597
23419 6776           53                         push	bx
23420                                           ! Debug: list int = const 4 (used reg = )
23421 6777           B8                   0004  mov	ax,*4
23422 677A           50                         push	ax
23423                                           ! Debug: func () void = bios_printf+0 (used reg = )
23424 677B           E8         A1BB            call	_bios_printf
23425 677E           83C4                   08  add	sp,*8
23426                                           !BCC_EOS
23427                                           ! 4025         *(((Bit8u *)&AX)+1) = (0x0c);
23428                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
23429 6781           B0                     0C  mov	al,*$C
23430 6783           8846         19            mov	$19[bp],al
23431                                           !BCC_EOS
23432                                           ! 4026         goto int13_fail_noah;
23433 6786           83C4                   00  add	sp,#..FFEC-..FFF0
23434 6789           E9         012A            br 	.FFEC
23435                                           !BCC_EOS
23436                                           ! 4027       }
23437                                           ! 4028       goto int13_success;
23438                       0000678C            .595:
23439 678C           83C4                   00  add	sp,#..FFEF-..FFF0
23440 678F           E9         0144            br 	.FFEF
23441                                           !BCC_EOS
23442                                           ! 4029       break;
23443 6792           E9         011C            br 	.55B
23444                                           !BCC_EOS
23445                                           ! 4030     case 0x45:
23446                                           ! 4031     case 0x49:
23447                       00006795            .598:
23448                                           ! 4032       goto int13_success;
23449                       00006795            .599:
23450 6795           83C4                   00  add	sp,#..FFEF-..FFF0
23451 6798           E9         013B            br 	.FFEF
23452                                           !BCC_EOS
23453                                           ! 4033       break;
23454 679B           E9         0113            br 	.55B
23455                                           !BCC_EOS
23456                                           ! 4034     case 0x46:
23457                                           ! 4035       *(((Bit8u *)&AX)+1) = (0xb2);
23458                       0000679E            .59A:
23459                                           ! Debug: eq int = const $B2 to unsigned char AX = [S+$26+$17] (used reg = )
23460 679E           B0                     B2  mov	al,#$B2
23461 67A0           8846         19            mov	$19[bp],al
23462                                           !BCC_EOS
23463                                           ! 4036       goto int13_fail_noah;
23464 67A3           83C4                   00  add	sp,#..FFEC-..FFF0
23465 67A6           E9         010D            br 	.FFEC
23466                                           !BCC_EOS
23467                                           ! 4037       break;
23468 67A9           E9         0105            br 	.55B
23469                                           !BCC_EOS
23470                                           ! 4038     case 0x48:
23471                                           ! 4039       if (int13_edd(DS, SI, device))
23472                       000067AC            .59B:
23473                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
23474 67AC           8A46         DD            mov	al,-$23[bp]
23475 67AF           30E4                       xor	ah,ah
23476 67B1           50                         push	ax
23477                                           ! Debug: list unsigned short SI = [S+$28+$A] (used reg = )
23478 67B2           FF76         0C            push	$C[bp]
23479                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23480 67B5           FF76         06            push	6[bp]
23481                                           ! Debug: func () int = int13_edd+0 (used reg = )
23482 67B8           E8         F314            call	_int13_edd
23483 67BB           83C4                   06  add	sp,*6
23484 67BE           85C0                       test	ax,ax
23485 67C0           74           06            je  	.59C
23486                       000067C2            .59D:
23487                                           ! 4040         goto int13_fail;
23488 67C2           83C4                   00  add	sp,#..FFF1-..FFF0
23489 67C5           E9         00E9            br 	.FFF1
23490                                           !BCC_EOS
23491                                           ! 4041       goto int13_success;
23492                       000067C8            .59C:
23493 67C8           83C4                   00  add	sp,#..FFEF-..FFF0
23494 67CB           E9         0108            br 	.FFEF
23495                                           !BCC_EOS
23496                                           ! 4042       break;
23497 67CE           E9         00E0            br 	.55B
23498                                           !BCC_EOS
23499                                           ! 4043     case 0x4e:
23500                                           ! 4044       switch (( AX & 0x00ff )) {
23501                       000067D1            .59E:
23502                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
23503 67D1           8A46         18            mov	al,$18[bp]
23504 67D4           EB           10            jmp .5A1
23505                                           ! 4045         case 0x01:
23506                                           ! 4046         case 0x03:
23507                       000067D6            .5A2:
23508                                           ! 4047         case 0x04:
23509                       000067D6            .5A3:
23510                                           ! 4048         case 0x06:
23511                       000067D6            .5A4:
23512                                           ! 4049           goto int13_success;
23513                       000067D6            .5A5:
23514 67D6           83C4                   00  add	sp,#..FFEF-..FFF0
23515 67D9           E9         00FA            br 	.FFEF
23516                                           !BCC_EOS
23517                                           ! 4050           break;
23518 67DC           EB           1A            jmp .59F
23519                                           !BCC_EOS
23520                                           ! 4051         default:
23521                                           ! 4052           goto int13_fail;
23522                       000067DE            .5A6:
23523 67DE           83C4                   00  add	sp,#..FFF1-..FFF0
23524 67E1           E9         00CD            br 	.FFF1
23525                                           !BCC_EOS
23526                                           ! 4053       }
23527                                           ! 4054       break;
23528 67E4           EB           12            jmp .59F
23529                       000067E6            .5A1:
23530 67E6           2C                     01  sub	al,*1
23531 67E8           74           EC            je 	.5A2
23532 67EA           2C                     02  sub	al,*2
23533 67EC           74           E8            je 	.5A3
23534 67EE           2C                     01  sub	al,*1
23535 67F0           74           E4            je 	.5A4
23536 67F2           2C                     02  sub	al,*2
23537 67F4           74           E0            je 	.5A5
23538 67F6           EB           E6            jmp	.5A6
23539                       000067F8            .59F:
23540 67F8           E9         00B6            br 	.55B
23541                                           !BCC_EOS
23542                                           ! 4055     case 0x09:
23543                                           ! 4056     case 0x0c:
23544                       000067FB            .5A7:
23545                                           ! 4057     case 0x0d:
23546                       000067FB            .5A8:
23547                                           ! 4058     case 0x11:
23548                       000067FB            .5A9:
23549                                           ! 4059     case 0x14:
23550                       000067FB            .5AA:
23551                                           ! 4060       bios_printf(4, "int13_harddisk: function %02xh unimplemented, ret
23552                       000067FB            .5AB:
23553                                           ! 4060 urns success\n", *(((Bit8u *)&AX)+1));
23554                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23555 67FB           8A46         19            mov	al,$19[bp]
23556 67FE           30E4                       xor	ah,ah
23557 6800           50                         push	ax
23558                                           ! Debug: list * char = .5AC+0 (used reg = )
23559 6801           BB                   D078  mov	bx,#.5AC
23560 6804           53                         push	bx
23561                                           ! Debug: list int = const 4 (used reg = )
23562 6805           B8                   0004  mov	ax,*4
23563 6808           50                         push	ax
23564                                           ! Debug: func () void = bios_printf+0 (used reg = )
23565 6809           E8         A12D            call	_bios_printf
23566 680C           83C4                   06  add	sp,*6
23567                                           !BCC_EOS
23568                                           ! 4061       goto int13_success;
23569 680F           83C4                   00  add	sp,#..FFEF-..FFF0
23570 6812           E9         00C1            br 	.FFEF
23571                                           !BCC_EOS
23572                                           ! 4062       break;
23573 6815           E9         0099            br 	.55B
23574                                           !BCC_EOS
23575                                           ! 4063     case 0x0a:
23576                                           ! 4064     case 0x0b:
23577                       00006818            .5AD:
23578                                           ! 4065     case 0x18:
23579                       00006818            .5AE:
23580                                           ! 4066     case 0x50:
23581                       00006818            .5AF:
23582                                           ! 4067     default:
23583                       00006818            .5B0:
23584                                           ! 4068       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
23585                       00006818            .5B1:
23586                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23587 6818           8A46         19            mov	al,$19[bp]
23588 681B           30E4                       xor	ah,ah
23589 681D           50                         push	ax
23590                                           ! Debug: list * char = .5B2+0 (used reg = )
23591 681E           BB                   D03E  mov	bx,#.5B2
23592 6821           53                         push	bx
23593                                           ! Debug: list int = const 4 (used reg = )
23594 6822           B8                   0004  mov	ax,*4
23595 6825           50                         push	ax
23596                                           ! Debug: func () void = bios_printf+0 (used reg = )
23597 6826           E8         A110            call	_bios_printf
23598 6829           83C4                   06  add	sp,*6
23599                                           !BCC_EOS
23600                                           ! 4069       goto int13_fail;
23601 682C           83C4                   00  add	sp,#..FFF1-..FFF0
23602 682F           E9         007F            jmp .FFF1
23603                                           !BCC_EOS
23604                                           ! 4070       break;
23605 6832           EB           7D            jmp .55B
23606                                           !BCC_EOS
23607                                           ! 4071   }
23608                                           ! 4072 int13_fail:
23609 6834           EB           7B            jmp .55B
23610                       00006836            .55D:
23611 6836           2C                     00  sub	al,*0
23612 6838           72           DE            jb 	.5B1
23613 683A           3C                     18  cmp	al,*$18
23614 683C           77           3D            ja  	.5B3
23615 683E           30E4                       xor	ah,ah
23616 6840           D1E0                       shl	ax,*1
23617 6842           89C3                       mov	bx,ax
23618 6844           2E                         seg	cs
23619 6845           FFA7       6849            br	.5B4[bx]
23620                       00006849            .5B4:
23621 6849                      61C8            .word	.55E
23622 684B                      61DC            .word	.55F
23623 684D                      621C            .word	.563
23624 684F                      621C            .word	.564
23625 6851                      621C            .word	.565
23626 6853                      6462            .word	.57B
23627 6855                      6818            .word	.5B1
23628 6857                      6818            .word	.5B1
23629 6859                      647D            .word	.57D
23630 685B                      67FB            .word	.5A7
23631 685D                      6818            .word	.5AD
23632 685F                      6818            .word	.5AE
23633 6861                      67FB            .word	.5A8
23634 6863                      67FB            .word	.5A9
23635 6865                      6818            .word	.5B1
23636 6867                      6818            .word	.5B1
23637 6869                      64FD            .word	.57E
23638 686B                      67FB            .word	.5AA
23639 686D                      6818            .word	.5B1
23640 686F                      6818            .word	.5B1
23641 6871                      67FB            .word	.5AB
23642 6873                      6539            .word	.582
23643 6875                      6818            .word	.5B1
23644 6877                      6818            .word	.5B1
23645 6879                      6818            .word	.5AF
23646                       0000687B            .5B3:
23647 687B           2C                     41  sub	al,*$41
23648 687D           72           99            jb 	.5B1
23649 687F           3C                     0F  cmp	al,*$F
23650 6881           77           2B            ja  	.5B5
23651 6883           30E4                       xor	ah,ah
23652 6885           D1E0                       shl	ax,*1
23653 6887           89C3                       mov	bx,ax
23654 6889           2E                         seg	cs
23655 688A           FFA7       688E            br	.5B6[bx]
23656                       0000688E            .5B6:
23657 688E                      65B8            .word	.583
23658 6890                      65D2            .word	.584
23659 6892                      65D2            .word	.585
23660 6894                      65D2            .word	.586
23661 6896                      6795            .word	.598
23662 6898                      679E            .word	.59A
23663 689A                      65D2            .word	.587
23664 689C                      67AC            .word	.59B
23665 689E                      6795            .word	.599
23666 68A0                      6818            .word	.5B1
23667 68A2                      6818            .word	.5B1
23668 68A4                      6818            .word	.5B1
23669 68A6                      6818            .word	.5B1
23670 68A8                      67D1            .word	.59E
23671 68AA                      6818            .word	.5B1
23672 68AC                      6818            .word	.5B0
23673                       000068AE            .5B5:
23674 68AE           E9         FF67            br 	.5B1
23675                       000068B1            .55B:
23676                       FFFFFFDA            ..FFF0	=	-$26
23677                       000068B1            .FFF1:
23678                       FFFFFFDA            ..FFF1	=	-$26
23679                                           ! 4073   *(((Bit8u *)&AX)+1) = (0x01);
23680                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$26+$17] (used reg = )
23681 68B1           B0                     01  mov	al,*1
23682 68B3           8846         19            mov	$19[bp],al
23683                                           !BCC_EOS
23684                                           ! 4074 int13_fail_noah:
23685                       000068B6            .FFEC:
23686                       FFFFFFDA            ..FFEC	=	-$26
23687                                           ! 4075   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
23688                                           ! Debug: list int = const $40 (used reg = )
23689 68B6           B8                   0040  mov	ax,*$40
23690 68B9           50                         push	ax
23691                                           ! Debug: list int = const $74 (used reg = )
23692 68BA           B8                   0074  mov	ax,*$74
23693 68BD           50                         push	ax
23694                                           ! Debug: list unsigned char AX = [S+$2A+$17] (used reg = )
23695 68BE           8A46         19            mov	al,$19[bp]
23696 68C1           30E4                       xor	ah,ah
23697 68C3           50                         push	ax
23698                                           ! Debug: func () void = _write_byte+0 (used reg = )
23699 68C4           E8         9D34            call	__write_byte
23700 68C7           83C4                   06  add	sp,*6
23701                                           !BCC_EOS
23702                                           ! 4076 int13_fail_nostatus:
23703                       000068CA            .FFEE:
23704                       FFFFFFDA            ..FFEE	=	-$26
23705                                           ! 4077   FLAGS |= 0x0001;
23706                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23707 68CA           8B46         1E            mov	ax,$1E[bp]
23708 68CD           0C                     01  or	al,*1
23709 68CF           8946         1E            mov	$1E[bp],ax
23710                                           !BCC_EOS
23711                                           ! 4078   return;
23712 68D2           89EC                       mov	sp,bp
23713 68D4           5D                         pop	bp
23714 68D5           C3                         ret
23715                                           !BCC_EOS
23716                                           ! 4079 int13_success:
23717                       000068D6            .FFEF:
23718                       FFFFFFDA            ..FFEF	=	-$26
23719                                           ! 4080   *(((Bit8u *)&AX)+1) = (0x00);
23720                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$17] (used reg = )
23721 68D6           30C0                       xor	al,al
23722 68D8           8846         19            mov	$19[bp],al
23723                                           !BCC_EOS
23724                                           ! 4081 int13_success_noah:
23725                       000068DB            .FFED:
23726                       FFFFFFDA            ..FFED	=	-$26
23727                                           ! 4082   _write_byte(0x00, 0x0074, 0x0040);
23728                                           ! Debug: list int = const $40 (used reg = )
23729 68DB           B8                   0040  mov	ax,*$40
23730 68DE           50                         push	ax
23731                                           ! Debug: list int = const $74 (used reg = )
23732 68DF           B8                   0074  mov	ax,*$74
23733 68E2           50                         push	ax
23734                                           ! Debug: list int = const 0 (used reg = )
23735 68E3           31C0                       xor	ax,ax
23736 68E5           50                         push	ax
23737                                           ! Debug: func () void = _write_byte+0 (used reg = )
23738 68E6           E8         9D12            call	__write_byte
23739 68E9           83C4                   06  add	sp,*6
23740                                           !BCC_EOS
23741                                           ! 4083   FLAGS &= 0xfffe;
23742                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23743 68EC           8B46         1E            mov	ax,$1E[bp]
23744 68EF           24                     FE  and	al,#$FE
23745 68F1           8946         1E            mov	$1E[bp],ax
23746                                           !BCC_EOS
23747                                           ! 4084 }
23748 68F4           89EC                       mov	sp,bp
23749 68F6           5D                         pop	bp
23750 68F7           C3                         ret
23751                                           ! 4085   void
23752                                           ! Register BX used in function int13_harddisk
23753                                           ! 4086 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23754                                           ! 4087   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23755                                           export	_int13_cdrom
23756                       000068F8            _int13_cdrom:
23757                                           !BCC_EOS
23758                                           ! 4088 {
23759                                           ! 4089   Bit8u device, status, locks;
23760                                           !BCC_EOS
23761                                           ! 4090   Bit8u atacmd[12];
23762                                           !BCC_EOS
23763                                           ! 4091   Bit32u lba;
23764                                           !BCC_EOS
23765                                           ! 4092   Bit16u count, segment, offset, i, size;
23766                                           !BCC_EOS
23767                                           ! 4093   ;
23768 68F8           55                         push	bp
23769 68F9           89E5                       mov	bp,sp
23770 68FB           83C4                   E2  add	sp,*-$1E
23771                                           !BCC_EOS
23772                                           ! 4094   _write_byte(0x00, 0x0074, 0x0040);
23773                                           ! Debug: list int = const $40 (used reg = )
23774 68FE           B8                   0040  mov	ax,*$40
23775 6901           50                         push	ax
23776                                           ! Debug: list int = const $74 (used reg = )
23777 6902           B8                   0074  mov	ax,*$74
23778 6905           50                         push	ax
23779                                           ! Debug: list int = const 0 (used reg = )
23780 6906           31C0                       xor	ax,ax
23781 6908           50                         push	ax
23782                                           ! Debug: func () void = _write_byte+0 (used reg = )
23783 6909           E8         9CEF            call	__write_byte
23784 690C           83C4                   06  add	sp,*6
23785                                           !BCC_EOS
23786                                           ! 4095   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
23787                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23788 690F           8A46         10            mov	al,$10[bp]
23789                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
23790 6912           3C                     E0  cmp	al,#$E0
23791 6914           72           07            jb  	.5B8
23792                       00006916            .5B9:
23793                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23794 6916           8A46         10            mov	al,$10[bp]
23795                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
23796 6919           3C                     E8  cmp	al,#$E8
23797 691B           72           20            jb  	.5B7
23798                       0000691D            .5B8:
23799                                           ! 4096     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23800                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23801 691D           8A46         10            mov	al,$10[bp]
23802                                           ! Debug: list unsigned char = al+0 (used reg = )
23803 6920           30E4                       xor	ah,ah
23804 6922           50                         push	ax
23805                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23806 6923           8A46         19            mov	al,$19[bp]
23807 6926           30E4                       xor	ah,ah
23808 6928           50                         push	ax
23809                                           ! Debug: list * char = .5BA+0 (used reg = )
23810 6929           BB                   D00A  mov	bx,#.5BA
23811 692C           53                         push	bx
23812                                           ! Debug: list int = const 4 (used reg = )
23813 692D           B8                   0004  mov	ax,*4
23814 6930           50                         push	ax
23815                                           ! Debug: func () void = bios_printf+0 (used reg = )
23816 6931           E8         A005            call	_bios_printf
23817 6934           83C4                   08  add	sp,*8
23818                                           !BCC_EOS
23819                                           ! 4097     goto int13_fail;
23820 6937           83C4                   00  add	sp,#..FFEB+$20
23821 693A           E9         0469            br 	.FFEB
23822                                           !BCC_EOS
23823                                           ! 4098   }
23824                                           ! 4099   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]));
23825                       0000693D            .5B7:
23826                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23827 693D           8A46         10            mov	al,$10[bp]
23828                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
23829 6940           30E4                       xor	ah,ah
23830                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
23831 6942           05                   FF20  add	ax,#-$E0
23832 6945           89C3                       mov	bx,ax
23833                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
23834                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
23835                                           ! Debug: eq unsigned char = [bx+$23C] to unsigned char device = [S+$20-3] (used reg = )
23836 6947           8A87       023C            mov	al,$23C[bx]
23837 694B           8846         FF            mov	-1[bp],al
23838                                           !BCC_EOS
23839                                           ! 4100   if (device >= (4*2)) {
23840                                           ! Debug: ge int = const 8 to unsigned char device = [S+$20-3] (used reg = )
23841 694E           8A46         FF            mov	al,-1[bp]
23842 6951           3C                     08  cmp	al,*8
23843 6953           72           20            jb  	.5BB
23844                       00006955            .5BC:
23845                                           ! 4101     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23846                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23847 6955           8A46         10            mov	al,$10[bp]
23848                                           ! Debug: list unsigned char = al+0 (used reg = )
23849 6958           30E4                       xor	ah,ah
23850 695A           50                         push	ax
23851                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23852 695B           8A46         19            mov	al,$19[bp]
23853 695E           30E4                       xor	ah,ah
23854 6960           50                         push	ax
23855                                           ! Debug: list * char = .5BD+0 (used reg = )
23856 6961           BB                   CFCF  mov	bx,#.5BD
23857 6964           53                         push	bx
23858                                           ! Debug: list int = const 4 (used reg = )
23859 6965           B8                   0004  mov	ax,*4
23860 6968           50                         push	ax
23861                                           ! Debug: func () void = bios_printf+0 (used reg = )
23862 6969           E8         9FCD            call	_bios_printf
23863 696C           83C4                   08  add	sp,*8
23864                                           !BCC_EOS
23865                                           ! 4102     goto int13_fail;
23866 696F           83C4                   00  add	sp,#..FFEB+$20
23867 6972           E9         0431            br 	.FFEB
23868                                           !BCC_EOS
23869                                           ! 4103   }
23870                                           ! 4104   switch (*(((Bit8u *)&AX)+1)) {
23871                       00006975            .5BB:
23872 6975           8A46         19            mov	al,$19[bp]
23873 6978           E9         03B0            br 	.5C0
23874                                           ! 4105     case 0x00:
23875                                           ! 4106     case 0x09:
23876                       0000697B            .5C1:
23877                                           ! 4107     case 0x0c:
23878                       0000697B            .5C2:
23879                                           ! 4108     case 0x0d:
23880                       0000697B            .5C3:
23881                                           ! 4109     case 0x10:
23882                       0000697B            .5C4:
23883                                           ! 4110     case 0x11:
23884                       0000697B            .5C5:
23885                                           ! 4111     case 0x14:
23886                       0000697B            .5C6:
23887                                           ! 4112     case 0x16:
23888                       0000697B            .5C7:
23889                                           ! 4113       goto int13_success;
23890                       0000697B            .5C8:
23891 697B           83C4                   00  add	sp,#..FFE9-..FFEA
23892 697E           E9         044A            br 	.FFE9
23893                                           !BCC_EOS
23894                                           ! 4114       break;
23895 6981           E9         0422            br 	.5BE
23896                                           !BCC_EOS
23897                                           ! 4115     case 0x03:
23898                                           ! 4116     case 0x05:
23899                       00006984            .5C9:
23900                                           ! 4117     case 0x43:
23901                       00006984            .5CA:
23902                                           ! 4118       *(((Bit8u *)&AX)+1) = (0x03);
23903                       00006984            .5CB:
23904                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$20+$17] (used reg = )
23905 6984           B0                     03  mov	al,*3
23906 6986           8846         19            mov	$19[bp],al
23907                                           !BCC_EOS
23908                                           ! 4119       goto int13_fail_noah;
23909 6989           83C4                   00  add	sp,#..FFE8-..FFEA
23910 698C           E9         041C            br 	.FFE8
23911                                           !BCC_EOS
23912                                           ! 4120       break;
23913 698F           E9         0414            br 	.5BE
23914                                           !BCC_EOS
23915                                           ! 4121     case 0x01:
23916                                           ! 4122       status = _read_byte(0x0074, 0x0040);
23917                       00006992            .5CC:
23918                                           ! Debug: list int = const $40 (used reg = )
23919 6992           B8                   0040  mov	ax,*$40
23920 6995           50                         push	ax
23921                                           ! Debug: list int = const $74 (used reg = )
23922 6996           B8                   0074  mov	ax,*$74
23923 6999           50                         push	ax
23924                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
23925 699A           E8         9C42            call	__read_byte
23926 699D           83C4                   04  add	sp,*4
23927                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-4] (used reg = )
23928 69A0           8846         FE            mov	-2[bp],al
23929                                           !BCC_EOS
23930                                           ! 4123       *(((Bit8u *)&AX)+1) = (status);
23931                                           ! Debug: eq unsigned char status = [S+$20-4] to unsigned char AX = [S+$20+$17] (used reg = )
23932 69A3           8A46         FE            mov	al,-2[bp]
23933 69A6           8846         19            mov	$19[bp],al
23934                                           !BCC_EOS
23935                                           ! 4124       _write_byte(0, 0x0074, 0x0040);
23936                                           ! Debug: list int = const $40 (used reg = )
23937 69A9           B8                   0040  mov	ax,*$40
23938 69AC           50                         push	ax
23939                                           ! Debug: list int = const $74 (used reg = )
23940 69AD           B8                   0074  mov	ax,*$74
23941 69B0           50                         push	ax
23942                                           ! Debug: list int = const 0 (used reg = )
23943 69B1           31C0                       xor	ax,ax
23944 69B3           50                         push	ax
23945                                           ! Debug: func () void = _write_byte+0 (used reg = )
23946 69B4           E8         9C44            call	__write_byte
23947 69B7           83C4                   06  add	sp,*6
23948                                           !BCC_EOS
23949                                           ! 4125       if (status) goto int13_fail_nostatus;
23950 69BA           8A46         FE            mov	al,-2[bp]
23951 69BD           84C0                       test	al,al
23952 69BF           74           08            je  	.5CD
23953                       000069C1            .5CE:
23954 69C1           83C4                   00  add	sp,#..FFE7-..FFEA
23955 69C4           E9         03F8            br 	.FFE7
23956                                           !BCC_EOS
23957                                           ! 4126       else goto int13_success_noah;
23958 69C7           EB           06            jmp .5CF
23959                       000069C9            .5CD:
23960 69C9           83C4                   00  add	sp,#..FFE6-..FFEA
23961 69CC           E9         0401            br 	.FFE6
23962                                           !BCC_EOS
23963                                           ! 4127       break;
23964                       000069CF            .5CF:
23965 69CF           E9         03D4            br 	.5BE
23966                                           !BCC_EOS
23967                                           ! 4128     case 0x15:
23968                                           ! 4129       *(((Bit8u *)&AX)+1) = (0x02);
23969                       000069D2            .5D0:
23970                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$20+$17] (used reg = )
23971 69D2           B0                     02  mov	al,*2
23972 69D4           8846         19            mov	$19[bp],al
23973                                           !BCC_EOS
23974                                           ! 4130       goto int13_fail_noah;
23975 69D7           83C4                   00  add	sp,#..FFE8-..FFEA
23976 69DA           E9         03CE            br 	.FFE8
23977                                           !BCC_EOS
23978                                           ! 4131       break;
23979 69DD           E9         03C6            br 	.5BE
23980                                           !BCC_EOS
23981                                           ! 4132     case 0x41:
23982                                           ! 4133       BX=0xaa55;
23983                       000069E0            .5D1:
23984                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$20+$10] (used reg = )
23985 69E0           B8                   AA55  mov	ax,#$AA55
23986 69E3           8946         12            mov	$12[bp],ax
23987                                           !BCC_EOS
23988                                           ! 4134       *(((Bit8u *)&AX)+1)
23989                                           ! 4134  = (0x30);
23990                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$20+$17] (used reg = )
23991 69E6           B0                     30  mov	al,*$30
23992 69E8           8846         19            mov	$19[bp],al
23993                                           !BCC_EOS
23994                                           ! 4135       CX=0x0007;
23995                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$20+$14] (used reg = )
23996 69EB           B8                   0007  mov	ax,*7
23997 69EE           8946         16            mov	$16[bp],ax
23998                                           !BCC_EOS
23999                                           ! 4136       goto int13_success_noah;
24000 69F1           83C4                   00  add	sp,#..FFE6-..FFEA
24001 69F4           E9         03D9            br 	.FFE6
24002                                           !BCC_EOS
24003                                           ! 4137       break;
24004 69F7           E9         03AC            br 	.5BE
24005                                           !BCC_EOS
24006                                           ! 4138     case 0x42:
24007                                           ! 4139     case 0x44:
24008                       000069FA            .5D2:
24009                                           ! 4140     case 0x47:
24010                       000069FA            .5D3:
24011                                           ! 4141       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24012                       000069FA            .5D4:
24013                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24014 69FA           FF76         06            push	6[bp]
24015                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24016 69FD           8B46         0C            mov	ax,$C[bp]
24017                                           ! Debug: list unsigned int = ax+2 (used reg = )
24018 6A00           40                         inc	ax
24019 6A01           40                         inc	ax
24020 6A02           50                         push	ax
24021                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24022 6A03           E8         9BE7            call	__read_word
24023 6A06           83C4                   04  add	sp,*4
24024                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24025 6A09           8946         EA            mov	-$16[bp],ax
24026                                           !BCC_EOS
24027                                           ! 4142       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
24028                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24029 6A0C           FF76         06            push	6[bp]
24030                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
24031 6A0F           8B46         0C            mov	ax,$C[bp]
24032                                           ! Debug: list unsigned int = ax+6 (used reg = )
24033 6A12           05                   0006  add	ax,*6
24034 6A15           50                         push	ax
24035                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24036 6A16           E8         9BD4            call	__read_word
24037 6A19           83C4                   04  add	sp,*4
24038                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$20-$1A] (used reg = )
24039 6A1C           8946         E8            mov	-$18[bp],ax
24040                                           !BCC_EOS
24041                                           ! 4143       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
24042                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24043 6A1F           FF76         06            push	6[bp]
24044                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
24045 6A22           8B46         0C            mov	ax,$C[bp]
24046                                           ! Debug: list unsigned int = ax+4 (used reg = )
24047 6A25           05                   0004  add	ax,*4
24048 6A28           50                         push	ax
24049                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24050 6A29           E8         9BC1            call	__read_word
24051 6A2C           83C4                   04  add	sp,*4
24052                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$20-$1C] (used reg = )
24053 6A2F           8946         E6            mov	-$1A[bp],ax
24054                                           !BCC_EOS
24055                                           ! 4144       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
24056                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24057 6A32           FF76         06            push	6[bp]
24058                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
24059 6A35           8B46         0C            mov	ax,$C[bp]
24060                                           ! Debug: list unsigned int = ax+$C (used reg = )
24061 6A38           05                   000C  add	ax,*$C
24062 6A3B           50                         push	ax
24063                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24064 6A3C           E8         9617            call	__read_dword
24065 6A3F           89D3                       mov	bx,dx
24066 6A41           83C4                   04  add	sp,*4
24067                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24068 6A44           8946         EC            mov	-$14[bp],ax
24069 6A47           895E         EE            mov	-$12[bp],bx
24070                                           !BCC_EOS
24071                                           ! 4145       if (lba != 0L) {
24072                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$20-$16] (used reg = )
24073                                           ! Debug: expression subtree swapping
24074 6A4A           31C0                       xor	ax,ax
24075 6A4C           31DB                       xor	bx,bx
24076 6A4E           53                         push	bx
24077 6A4F           50                         push	ax
24078 6A50           8B46         EC            mov	ax,-$14[bp]
24079 6A53           8B5E         EE            mov	bx,-$12[bp]
24080 6A56           8D7E         DE            lea	di,-2+..FFEA[bp]
24081 6A59           E8         9640            call	lcmpul
24082 6A5C           8D66         E2            lea	sp,2+..FFEA[bp]
24083 6A5F           74           1A            je  	.5D5
24084                       00006A61            .5D6:
24085                                           ! 4146         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",*(((Bit8u *)&AX)+1));
24086                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24087 6A61           8A46         19            mov	al,$19[bp]
24088 6A64           30E4                       xor	ah,ah
24089 6A66           50                         push	ax
24090                                           ! Debug: list * char = .5D7+0 (used reg = )
24091 6A67           BB                   CF9D  mov	bx,#.5D7
24092 6A6A           53                         push	bx
24093                                           ! Debug: list int = const 7 (used reg = )
24094 6A6B           B8                   0007  mov	ax,*7
24095 6A6E           50                         push	ax
24096                                           ! Debug: func () void = bios_printf+0 (used reg = )
24097 6A6F           E8         9EC7            call	_bios_printf
24098 6A72           83C4                   06  add	sp,*6
24099                                           !BCC_EOS
24100                                           ! 4147         goto int13_fail;
24101 6A75           83C4                   00  add	sp,#..FFEB-..FFEA
24102 6A78           E9         032B            br 	.FFEB
24103                                           !BCC_EOS
24104                                           ! 4148       }
24105                                           ! 4149       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
24106                       00006A7B            .5D5:
24107                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24108 6A7B           FF76         06            push	6[bp]
24109                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
24110 6A7E           8B46         0C            mov	ax,$C[bp]
24111                                           ! Debug: list unsigned int = ax+8 (used reg = )
24112 6A81           05                   0008  add	ax,*8
24113 6A84           50                         push	ax
24114                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24115 6A85           E8         95CE            call	__read_dword
24116 6A88           89D3                       mov	bx,dx
24117 6A8A           83C4                   04  add	sp,*4
24118                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24119 6A8D           8946         EC            mov	-$14[bp],ax
24120 6A90           895E         EE            mov	-$12[bp],bx
24121                                           !BCC_EOS
24122                                           ! 4150       if ((*(((Bit8u *)&AX)+1) == 0x44) || (*(((Bit8u *)&AX)+1) == 0x47))
24123                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$20+$17] (used reg = )
24124 6A93           8A46         19            mov	al,$19[bp]
24125 6A96           3C                     44  cmp	al,*$44
24126 6A98           74           07            je  	.5D9
24127                       00006A9A            .5DA:
24128                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$20+$17] (used reg = )
24129 6A9A           8A46         19            mov	al,$19[bp]
24130 6A9D           3C                     47  cmp	al,*$47
24131 6A9F           75           06            jne 	.5D8
24132                       00006AA1            .5D9:
24133                                           ! 4151         goto int13_success;
24134 6AA1           83C4                   00  add	sp,#..FFE9-..FFEA
24135 6AA4           E9         0324            br 	.FFE9
24136                                           !BCC_EOS
24137                                           ! 4152       _memsetb(0,atacmd,get_SS(),12);
24138                       00006AA7            .5D8:
24139                                           ! Debug: list int = const $C (used reg = )
24140 6AA7           B8                   000C  mov	ax,*$C
24141 6AAA           50                         push	ax
24142                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24143 6AAB           E8         9BAC            call	_get_SS
24144                                           ! Debug: list unsigned short = ax+0 (used reg = )
24145 6AAE           50                         push	ax
24146                                           ! Debug: list * unsigned char atacmd = S+$24-$11 (used reg = )
24147 6AAF           8D5E         F1            lea	bx,-$F[bp]
24148 6AB2           53                         push	bx
24149                                           ! Debug: list int = const 0 (used reg = )
24150 6AB3           31C0                       xor	ax,ax
24151 6AB5           50                         push	ax
24152                                           ! Debug: func () void = _memsetb+0 (used reg = )
24153 6AB6           E8         9547            call	__memsetb
24154 6AB9           83C4                   08  add	sp,*8
24155                                           !BCC_EOS
24156                                           ! 4153       atacmd[0]=0x28;
24157                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$20-$11] (used reg = )
24158 6ABC           B0                     28  mov	al,*$28
24159 6ABE           8846         F1            mov	-$F[bp],al
24160                                           !BCC_EOS
24161                                           ! 4154       atacmd[7]=*(((Bit8u *)&count)+1);
24162                                           ! Debug: eq unsigned char count = [S+$20-$17] to unsigned char atacmd = [S+$20-$A] (used reg = )
24163 6AC1           8A46         EB            mov	al,-$15[bp]
24164 6AC4           8846         F8            mov	-8[bp],al
24165                                           !BCC_EOS
24166                                           ! 4155       atacmd[8]=*((Bit8u *)&count);
24167                                           ! Debug: eq unsigned char count = [S+$20-$18] to unsigned char atacmd = [S+$20-9] (used reg = )
24168 6AC7           8A46         EA            mov	al,-$16[bp]
24169 6ACA           8846         F9            mov	-7[bp],al
24170                                           !BCC_EOS
24171                                           ! 4156       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
24172                                           ! Debug: eq unsigned char lba = [S+$20-$13] to unsigned char atacmd = [S+$20-$F] (used reg = )
24173 6ACD           8A46         EF            mov	al,-$11[bp]
24174 6AD0           8846         F3            mov	-$D[bp],al
24175                                           !BCC_EOS
24176                                           ! 4157       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
24177                                           ! Debug: eq unsigned char lba = [S+$20-$14] to unsigned char atacmd = [S+$20-$E] (used reg = )
24178 6AD3           8A46         EE            mov	al,-$12[bp]
24179 6AD6           8846         F4            mov	-$C[bp],al
24180                                           !BCC_EOS
24181                                           ! 4158       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
24182                                           ! Debug: eq unsigned char lba = [S+$20-$15] to unsigned char atacmd = [S+$20-$D] (used reg = )
24183 6AD9           8A46         ED            mov	al,-$13[bp]
24184 6ADC           8846         F5            mov	-$B[bp],al
24185                                           !BCC_EOS
24186                                           ! 4159       atacmd[5]=*((Bit8u *)&lba);
24187                                           ! Debug: eq unsigned char lba = [S+$20-$16] to unsigned char atacmd = [S+$20-$C] (used reg = )
24188 6ADF           8A46         EC            mov	al,-$14[bp]
24189 6AE2           8846         F6            mov	-$A[bp],al
24190                                           !BCC_EOS
24191                                           ! 4160       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
24192                                           ! Debug: list unsigned short offset = [S+$20-$1C] (used reg = )
24193 6AE5           FF76         E6            push	-$1A[bp]
24194                                           ! Debug: list unsigned short segment = [S+$22-$1A] (used reg = )
24195 6AE8           FF76         E8            push	-$18[bp]
24196                                           ! Debug: list int = const 1 (used reg = )
24197 6AEB           B8                   0001  mov	ax,*1
24198 6AEE           50                         push	ax
24199                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$26-$18] (used reg = )
24200 6AEF           8B46         EA            mov	ax,-$16[bp]
24201 6AF2           31DB                       xor	bx,bx
24202                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
24203 6AF4           53                         push	bx
24204 6AF5           50                         push	ax
24205 6AF6           B8                   0800  mov	ax,#$800
24206 6AF9           31DB                       xor	bx,bx
24207 6AFB           53                         push	bx
24208 6AFC           50                         push	ax
24209 6AFD           8B46         D8            mov	ax,-8+..FFEA[bp]
24210 6B00           8B5E         DA            mov	bx,-6+..FFEA[bp]
24211 6B03           8D7E         D4            lea	di,-$C+..FFEA[bp]
24212 6B06           E8         95B1            call	lmulul
24213 6B09           83C4                   08  add	sp,*8
24214                                           ! Debug: list unsigned long = bx+0 (used reg = )
24215 6B0C           53                         push	bx
24216 6B0D           50                         push	ax
24217                                           ! Debug: list int = const 0 (used reg = )
24218 6B0E           31C0                       xor	ax,ax
24219 6B10           50                         push	ax
24220                                           ! Debug: list * unsigned char atacmd = S+$2C-$11 (used reg = )
24221 6B11           8D5E         F1            lea	bx,-$F[bp]
24222 6B14           53                         push	bx
24223                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24224 6B15           E8         9B42            call	_get_SS
24225                                           ! Debug: list unsigned short = ax+0 (used reg = )
24226 6B18           50                         push	ax
24227                                           ! Debug: list int = const $C (used reg = )
24228 6B19           B8                   000C  mov	ax,*$C
24229 6B1C           50                         push	ax
24230                                           ! Debug: list unsigned char device = [S+$32-3] (used reg = )
24231 6B1D           8A46         FF            mov	al,-1[bp]
24232 6B20           30E4                       xor	ah,ah
24233 6B22           50                         push	ax
24234                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
24235 6B23           E8         C220            call	_ata_cmd_packet
24236 6B26           83C4                   14  add	sp,*$14
24237                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$20-4] (used reg = )
24238 6B29           8846         FE            mov	-2[bp],al
24239                                           !BCC_EOS
24240                                           ! 4161       count = (Bit16u)(*((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) >> 11);
24241                                           ! Debug: sr int = const $B to unsigned long = [+$256] (used reg = )
24242 6B2C           A1         0256            mov	ax,[$256]
24243 6B2F           8B1E       0258            mov	bx,[$258]
24244 6B33           88E0                       mov	al,ah
24245 6B35           88DC                       mov	ah,bl
24246 6B37           88FB                       mov	bl,bh
24247 6B39           28FF                       sub	bh,bh
24248 6B3B           BF                   0003  mov	di,*3
24249 6B3E           E8         95B9            call	lsrul
24250                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
24251                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24252 6B41           8946         EA            mov	-$16[bp],ax
24253                                           !BCC_EOS
24254                                           ! 4162       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24255                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24256 6B44           FF76         06            push	6[bp]
24257                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24258 6B47           8B46         0C            mov	ax,$C[bp]
24259                                           ! Debug: list unsigned int = ax+2 (used reg = )
24260 6B4A           40                         inc	ax
24261 6B4B           40                         inc	ax
24262 6B4C           50                         push	ax
24263                                           ! Debug: list unsigned short count = [S+$24-$18] (used reg = )
24264 6B4D           FF76         EA            push	-$16[bp]
24265                                           ! Debug: func () void = _write_word+0 (used reg = )
24266 6B50           E8         9ABB            call	__write_word
24267 6B53           83C4                   06  add	sp,*6
24268                                           !BCC_EOS
24269                                           ! 4163       if (status != 0) {
24270                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24271 6B56           8A46         FE            mov	al,-2[bp]
24272 6B59           84C0                       test	al,al
24273 6B5B           74           25            je  	.5DB
24274                       00006B5D            .5DC:
24275                                           ! 4164         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",*(((Bit8u *)&AX)+1),status);
24276                                           ! Debug: list unsigned char status = [S+$20-4] (used reg = )
24277 6B5D           8A46         FE            mov	al,-2[bp]
24278 6B60           30E4                       xor	ah,ah
24279 6B62           50                         push	ax
24280                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
24281 6B63           8A46         19            mov	al,$19[bp]
24282 6B66           30E4                       xor	ah,ah
24283 6B68           50                         push	ax
24284                                           ! Debug: list * char = .5DD+0 (used reg = )
24285 6B69           BB                   CF72  mov	bx,#.5DD
24286 6B6C           53                         push	bx
24287                                           ! Debug: list int = const 4 (used reg = )
24288 6B6D           B8                   0004  mov	ax,*4
24289 6B70           50                         push	ax
24290                                           ! Debug: func () void = bios_printf+0 (used reg = )
24291 6B71           E8         9DC5            call	_bios_printf
24292 6B74           83C4                   08  add	sp,*8
24293                                           !BCC_EOS
24294                                           ! 4165         *(((Bit8u *)&AX)+1) = (0x0c);
24295                                           ! Debug: eq int = const $C to unsigned char AX = [S+$20+$17] (used reg = )
24296 6B77           B0                     0C  mov	al,*$C
24297 6B79           8846         19            mov	$19[bp],al
24298                                           !BCC_EOS
24299                                           ! 4166         goto int13_fail_noah;
24300 6B7C           83C4                   00  add	sp,#..FFE8-..FFEA
24301 6B7F           E9         0229            br 	.FFE8
24302                                           !BCC_EOS
24303                                           ! 4167       }
24304                                           ! 4168       goto int13_success;
24305                       00006B82            .5DB:
24306 6B82           83C4                   00  add	sp,#..FFE9-..FFEA
24307 6B85           E9         0243            br 	.FFE9
24308                                           !BCC_EOS
24309                                           ! 4169       break;
24310 6B88           E9         021B            br 	.5BE
24311                                           !BCC_EOS
24312                                           ! 4170     case 0x45:
24313                                           ! 4171       if (( AX & 0x00ff ) > 2) goto int13_fail;
24314                       00006B8B            .5DE:
24315                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24316 6B8B           8A46         18            mov	al,$18[bp]
24317                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
24318 6B8E           3C                     02  cmp	al,*2
24319 6B90           76           06            jbe 	.5DF
24320                       00006B92            .5E0:
24321 6B92           83C4                   00  add	sp,#..FFEB-..FFEA
24322 6B95           E9         020E            br 	.FFEB
24323                                           !BCC_EOS
24324                                           ! 4172       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24325                       00006B98            .5DF:
24326                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24327 6B98           8A46         FF            mov	al,-1[bp]
24328 6B9B           30E4                       xor	ah,ah
24329 6B9D           B9                   001E  mov	cx,*$1E
24330 6BA0           F7E9                       imul	cx
24331 6BA2           89C3                       mov	bx,ax
24332                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24333                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24334                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24335 6BA4           8A87       0145            mov	al,$145[bx]
24336 6BA8           8846         FD            mov	-3[bp],al
24337                                           !BCC_EOS
24338                                           ! 4173       switch (( AX & 0x00ff )) {
24339                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24340 6BAB           8A46         18            mov	al,$18[bp]
24341 6BAE           E9         0095            br 	.5E3
24342                                           ! 4174         case 0 :
24343                                           ! 4175           if (locks == 0xff) {
24344                       00006BB1            .5E4:
24345                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$20-5] (used reg = )
24346 6BB1           8A46         FD            mov	al,-3[bp]
24347 6BB4           3C                     FF  cmp	al,#$FF
24348 6BB6           75           10            jne 	.5E5
24349                       00006BB8            .5E6:
24350                                           ! 4176             *(((Bit8u *)&AX)+1) = (0xb4);
24351                                           ! Debug: eq int = const $B4 to unsigned char AX = [S+$20+$17] (used reg = )
24352 6BB8           B0                     B4  mov	al,#$B4
24353 6BBA           8846         19            mov	$19[bp],al
24354                                           !BCC_EOS
24355                                           ! 4177             *((Bit8u *)&AX) = (1);
24356                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24357 6BBD           B0                     01  mov	al,*1
24358 6BBF           8846         18            mov	$18[bp],al
24359                                           !BCC_EOS
24360                                           ! 4178             goto int13_fail_noah;
24361 6BC2           83C4                   00  add	sp,#..FFE8-..FFEA
24362 6BC5           E9         01E3            br 	.FFE8
24363                                           !BCC_EOS
24364                                           ! 4179           }
24365                                           ! 4180           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (++locks);
24366                       00006BC8            .5E5:
24367                                           ! Debug: preinc unsigned char locks = [S+$20-5] (used reg = )
24368 6BC8           8A46         FD            mov	al,-3[bp]
24369 6BCB           40                         inc	ax
24370 6BCC           8846         FD            mov	-3[bp],al
24371 6BCF           50                         push	ax
24372                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24373 6BD0           8A46         FF            mov	al,-1[bp]
24374 6BD3           30E4                       xor	ah,ah
24375 6BD5           B9                   001E  mov	cx,*$1E
24376 6BD8           F7E9                       imul	cx
24377 6BDA           89C3                       mov	bx,ax
24378                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24379                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24380                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24381 6BDC           8A46         E0            mov	al,0+..FFEA[bp]
24382 6BDF           8887       0145            mov	$145[bx],al
24383 6BE3           44                         inc	sp
24384 6BE4           44                         inc	sp
24385                                           !BCC_EOS
24386                                           ! 4181           *((Bit8u *)&AX) = (1);
24387                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24388 6BE5           B0                     01  mov	al,*1
24389 6BE7           8846         18            mov	$18[bp],al
24390                                           !BCC_EOS
24391                                           ! 4182           break;
24392 6BEA           EB           68            jmp .5E1
24393                                           !BCC_EOS
24394                                           ! 4183         case 1 :
24395                                           ! 4184           if (lo
24396                       00006BEC            .5E7:
24397                                           ! 4184 cks == 0x00) {
24398                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24399 6BEC           8A46         FD            mov	al,-3[bp]
24400 6BEF           84C0                       test	al,al
24401 6BF1           75           10            jne 	.5E8
24402                       00006BF3            .5E9:
24403                                           ! 4185             *(((Bit8u *)&AX)+1) = (0xb0);
24404                                           ! Debug: eq int = const $B0 to unsigned char AX = [S+$20+$17] (used reg = )
24405 6BF3           B0                     B0  mov	al,#$B0
24406 6BF5           8846         19            mov	$19[bp],al
24407                                           !BCC_EOS
24408                                           ! 4186             *((Bit8u *)&AX) = (0);
24409                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$16] (used reg = )
24410 6BF8           30C0                       xor	al,al
24411 6BFA           8846         18            mov	$18[bp],al
24412                                           !BCC_EOS
24413                                           ! 4187             goto int13_fail_noah;
24414 6BFD           83C4                   00  add	sp,#..FFE8-..FFEA
24415 6C00           E9         01A8            br 	.FFE8
24416                                           !BCC_EOS
24417                                           ! 4188           }
24418                                           ! 4189           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (--locks);
24419                       00006C03            .5E8:
24420                                           ! Debug: predec unsigned char locks = [S+$20-5] (used reg = )
24421 6C03           8A46         FD            mov	al,-3[bp]
24422 6C06           48                         dec	ax
24423 6C07           8846         FD            mov	-3[bp],al
24424 6C0A           50                         push	ax
24425                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24426 6C0B           8A46         FF            mov	al,-1[bp]
24427 6C0E           30E4                       xor	ah,ah
24428 6C10           B9                   001E  mov	cx,*$1E
24429 6C13           F7E9                       imul	cx
24430 6C15           89C3                       mov	bx,ax
24431                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24432                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24433                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24434 6C17           8A46         E0            mov	al,0+..FFEA[bp]
24435 6C1A           8887       0145            mov	$145[bx],al
24436 6C1E           44                         inc	sp
24437 6C1F           44                         inc	sp
24438                                           !BCC_EOS
24439                                           ! 4190           *((Bit8u *)&AX) = (locks==0?0:1);
24440                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24441 6C20           8A46         FD            mov	al,-3[bp]
24442 6C23           84C0                       test	al,al
24443 6C25           75           04            jne 	.5EA
24444                       00006C27            .5EB:
24445 6C27           30C0                       xor	al,al
24446 6C29           EB           02            jmp .5EC
24447                       00006C2B            .5EA:
24448 6C2B           B0                     01  mov	al,*1
24449                       00006C2D            .5EC:
24450                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24451 6C2D           8846         18            mov	$18[bp],al
24452                                           !BCC_EOS
24453                                           ! 4191           break;
24454 6C30           EB           22            jmp .5E1
24455                                           !BCC_EOS
24456                                           ! 4192         case 2 :
24457                                           ! 4193           *((Bit8u *)&AX) = (locks==0?0:1);
24458                       00006C32            .5ED:
24459                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24460 6C32           8A46         FD            mov	al,-3[bp]
24461 6C35           84C0                       test	al,al
24462 6C37           75           04            jne 	.5EE
24463                       00006C39            .5EF:
24464 6C39           30C0                       xor	al,al
24465 6C3B           EB           02            jmp .5F0
24466                       00006C3D            .5EE:
24467 6C3D           B0                     01  mov	al,*1
24468                       00006C3F            .5F0:
24469                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24470 6C3F           8846         18            mov	$18[bp],al
24471                                           !BCC_EOS
24472                                           ! 4194           break;
24473 6C42           EB           10            jmp .5E1
24474                                           !BCC_EOS
24475                                           ! 4195       }
24476                                           ! 4196       goto int13_success;
24477 6C44           EB           0E            jmp .5E1
24478                       00006C46            .5E3:
24479 6C46           2C                     00  sub	al,*0
24480 6C48         0F84         FF65            beq 	.5E4
24481 6C4C           2C                     01  sub	al,*1
24482 6C4E           74           9C            je 	.5E7
24483 6C50           2C                     01  sub	al,*1
24484 6C52           74           DE            je 	.5ED
24485                       00006C54            .5E1:
24486 6C54           83C4                   00  add	sp,#..FFE9-..FFEA
24487 6C57           E9         0171            br 	.FFE9
24488                                           !BCC_EOS
24489                                           ! 4197       break;
24490 6C5A           E9         0149            br 	.5BE
24491                                           !BCC_EOS
24492                                           ! 4198     case 0x46:
24493                                           ! 4199       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24494                       00006C5D            .5F1:
24495                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24496 6C5D           8A46         FF            mov	al,-1[bp]
24497 6C60           30E4                       xor	ah,ah
24498 6C62           B9                   001E  mov	cx,*$1E
24499 6C65           F7E9                       imul	cx
24500 6C67           89C3                       mov	bx,ax
24501                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24502                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24503                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24504 6C69           8A87       0145            mov	al,$145[bx]
24505 6C6D           8846         FD            mov	-3[bp],al
24506                                           !BCC_EOS
24507                                           ! 4200       if (locks != 0) {
24508                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24509 6C70           8A46         FD            mov	al,-3[bp]
24510 6C73           84C0                       test	al,al
24511 6C75           74           0B            je  	.5F2
24512                       00006C77            .5F3:
24513                                           ! 4201         *(((Bit8u *)&AX)+1) = (0xb1);
24514                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24515 6C77           B0                     B1  mov	al,#$B1
24516 6C79           8846         19            mov	$19[bp],al
24517                                           !BCC_EOS
24518                                           ! 4202         goto int13_fail_noah;
24519 6C7C           83C4                   00  add	sp,#..FFE8-..FFEA
24520 6C7F           E9         0129            br 	.FFE8
24521                                           !BCC_EOS
24522                                           ! 4203       }
24523                                           ! 4204 #asm
24524                       00006C82            .5F2:
24525                                           !BCC_EOS
24526                                           !BCC_ASM
24527                       0000002C            _int13_cdrom.BP	set	$2C
24528                       0000000E            .int13_cdrom.BP	set	$E
24529                       00000022            _int13_cdrom.EHBX	set	$22
24530                       00000004            .int13_cdrom.EHBX	set	4
24531                       0000003A            _int13_cdrom.CS	set	$3A
24532                       0000001C            .int13_cdrom.CS	set	$1C
24533                       00000008            _int13_cdrom.count	set	8
24534                       FFFFFFEA            .int13_cdrom.count	set	-$16
24535                       00000034            _int13_cdrom.CX	set	$34
24536                       00000016            .int13_cdrom.CX	set	$16
24537                       00000006            _int13_cdrom.segment	set	6
24538                       FFFFFFE8            .int13_cdrom.segment	set	-$18
24539                       00000028            _int13_cdrom.DI	set	$28
24540                       0000000A            .int13_cdrom.DI	set	$A
24541                       0000003C            _int13_cdrom.FLAGS	set	$3C
24542                       0000001E            .int13_cdrom.FLAGS	set	$1E
24543                       00000024            _int13_cdrom.DS	set	$24
24544                       00000006            .int13_cdrom.DS	set	6
24545                       0000002E            _int13_cdrom.ELDX	set	$2E
24546                       00000010            .int13_cdrom.ELDX	set	$10
24547                       00000032            _int13_cdrom.DX	set	$32
24548                       00000014            .int13_cdrom.DX	set	$14
24549                       00000000            _int13_cdrom.size	set	0
24550                       FFFFFFE2            .int13_cdrom.size	set	-$1E
24551                       00000002            _int13_cdrom.i	set	2
24552                       FFFFFFE4            .int13_cdrom.i	set	-$1C
24553                       0000001D            _int13_cdrom.device	set	$1D
24554                       FFFFFFFF            .int13_cdrom.device	set	-1
24555                       00000026            _int13_cdrom.ES	set	$26
24556                       00000008            .int13_cdrom.ES	set	8
24557                       0000002A            _int13_cdrom.SI	set	$2A
24558                       0000000C            .int13_cdrom.SI	set	$C
24559                       00000038            _int13_cdrom.IP	set	$38
24560                       0000001A            .int13_cdrom.IP	set	$1A
24561                       0000000A            _int13_cdrom.lba	set	$A
24562                       FFFFFFEC            .int13_cdrom.lba	set	-$14
24563                       0000001C            _int13_cdrom.status	set	$1C
24564                       FFFFFFFE            .int13_cdrom.status	set	-2
24565                       0000000F            _int13_cdrom.atacmd	set	$F
24566                       FFFFFFF1            .int13_cdrom.atacmd	set	-$F
24567                       00000036            _int13_cdrom.AX	set	$36
24568                       00000018            .int13_cdrom.AX	set	$18
24569                       00000004            _int13_cdrom.offset	set	4
24570                       FFFFFFE6            .int13_cdrom.offset	set	-$1A
24571                       00000030            _int13_cdrom.BX	set	$30
24572                       00000012            .int13_cdrom.BX	set	$12
24573                       0000001B            _int13_cdrom.locks	set	$1B
24574                       FFFFFFFD            .int13_cdrom.locks	set	-3
24575 6C82           55                                 push bp
24576 6C83           89E5                               mov bp, sp
24577 6C85           B4                     52          mov ah, #0x52
24578 6C87           CD                     15          int #0x15
24579 6C89           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
24580 6C8C           73           06                    jnc int13_cdrom_rme_end
24581 6C8E           C706       001C      0001          mov _int13_cdrom.status, #1
24582                       00006C94            int13_cdrom_rme_end:
24583 6C94           5D                                 pop bp
24584                                           ! 4214 endasm
24585                                           !BCC_ENDASM
24586                                           !BCC_EOS
24587                                           ! 4215       if (status != 0) {
24588                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24589 6C95           8A46         FE            mov	al,-2[bp]
24590 6C98           84C0                       test	al,al
24591 6C9A           74           0B            je  	.5F4
24592                       00006C9C            .5F5:
24593                                           ! 4216         *(((Bit8u *)&AX)+1) = (0xb1);
24594                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24595 6C9C           B0                     B1  mov	al,#$B1
24596 6C9E           8846         19            mov	$19[bp],al
24597                                           !BCC_EOS
24598                                           ! 4217         goto int13_fail_noah;
24599 6CA1           83C4                   00  add	sp,#..FFE8-..FFEA
24600 6CA4           E9         0104            br 	.FFE8
24601                                           !BCC_EOS
24602                                           ! 4218       }
24603                                           ! 4219       goto int13_success;
24604                       00006CA7            .5F4:
24605 6CA7           83C4                   00  add	sp,#..FFE9-..FFEA
24606 6CAA           E9         011E            br 	.FFE9
24607                                           !BCC_EOS
24608                                           ! 4220       break;
24609 6CAD           E9         00F6            br 	.5BE
24610                                           !BCC_EOS
24611                                           ! 4221     case 0x48:
24612                                           ! 4222       if (int13_edd(DS, SI, device))
24613                       00006CB0            .5F6:
24614                                           ! Debug: list unsigned char device = [S+$20-3] (used reg = )
24615 6CB0           8A46         FF            mov	al,-1[bp]
24616 6CB3           30E4                       xor	ah,ah
24617 6CB5           50                         push	ax
24618                                           ! Debug: list unsigned short SI = [S+$22+$A] (used reg = )
24619 6CB6           FF76         0C            push	$C[bp]
24620                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24621 6CB9           FF76         06            push	6[bp]
24622                                           ! Debug: func () int = int13_edd+0 (used reg = )
24623 6CBC           E8         EE10            call	_int13_edd
24624 6CBF           83C4                   06  add	sp,*6
24625 6CC2           85C0                       test	ax,ax
24626 6CC4           74           06            je  	.5F7
24627                       00006CC6            .5F8:
24628                                           ! 4223         goto int13_fail;
24629 6CC6           83C4                   00  add	sp,#..FFEB-..FFEA
24630 6CC9           E9         00DA            br 	.FFEB
24631                                           !BCC_EOS
24632                                           ! 4224       goto int13_success;
24633                       00006CCC            .5F7:
24634 6CCC           83C4                   00  add	sp,#..FFE9-..FFEA
24635 6CCF           E9         00F9            br 	.FFE9
24636                                           !BCC_EOS
24637                                           ! 4225       break;
24638 6CD2           E9         00D1            br 	.5BE
24639                                           !BCC_EOS
24640                                           ! 4226     case 0x49:
24641                                           ! 4227       *(((Bit8u *)&AX)+1) = (06);
24642                       00006CD5            .5F9:
24643                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$20+$17] (used reg = )
24644 6CD5           B0                     06  mov	al,*6
24645 6CD7           8846         19            mov	$19[bp],al
24646                                           !BCC_EOS
24647                                           ! 4228       goto int13_fail_nostatus;
24648 6CDA           83C4                   00  add	sp,#..FFE7-..FFEA
24649 6CDD           E9         00DF            br 	.FFE7
24650                                           !BCC_EOS
24651                                           ! 4229       break;
24652 6CE0           E9         00C3            br 	.5BE
24653                                           !BCC_EOS
24654                                           ! 4230     case 0x4e:
24655                                           ! 4231       switch (( AX & 0x00ff )) {
24656                       00006CE3            .5FA:
24657                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24658 6CE3           8A46         18            mov	al,$18[bp]
24659 6CE6           EB           10            jmp .5FD
24660                                           ! 4232         case 0x01:
24661                                           ! 4233         case 0x03:
24662                       00006CE8            .5FE:
24663                                           ! 4234         case 0x04:
24664                       00006CE8            .5FF:
24665                                           ! 4235         case 0x06:
24666                       00006CE8            .600:
24667                                           ! 4236           goto int13_success;
24668                       00006CE8            .601:
24669 6CE8           83C4                   00  add	sp,#..FFE9-..FFEA
24670 6CEB           E9         00DD            br 	.FFE9
24671                                           !BCC_EOS
24672                                           ! 4237           break;
24673 6CEE           EB           1A            jmp .5FB
24674                                           !BCC_EOS
24675                                           ! 4238         default:
24676                                           ! 4239           goto int13_fail;
24677                       00006CF0            .602:
24678 6CF0           83C4                   00  add	sp,#..FFEB-..FFEA
24679 6CF3           E9         00B0            br 	.FFEB
24680                                           !BCC_EOS
24681                                           ! 4240       }
24682                                           ! 4241       break;
24683 6CF6           EB           12            jmp .5FB
24684                       00006CF8            .5FD:
24685 6CF8           2C                     01  sub	al,*1
24686 6CFA           74           EC            je 	.5FE
24687 6CFC           2C                     02  sub	al,*2
24688 6CFE           74           E8            je 	.5FF
24689 6D00           2C                     01  sub	al,*1
24690 6D02           74           E4            je 	.600
24691 6D04           2C                     02  sub	al,*2
24692 6D06           74           E0            je 	.601
24693 6D08           EB           E6            jmp	.602
24694                       00006D0A            .5FB:
24695 6D0A           E9         0099            br 	.5BE
24696                                           !BCC_EOS
24697                                           ! 4242     case 0x02:
24698                                           ! 4243     case 0x04:
24699                       00006D0D            .603:
24700                                           ! 4244     case 0x08:
24701                       00006D0D            .604:
24702                                           ! 4245     case 0x0a:
24703                       00006D0D            .605:
24704                                           ! 4246     case 0x0b:
24705                       00006D0D            .606:
24706                                           ! 4247     case 0x18:
24707                       00006D0D            .607:
24708                                           ! 4248     case 0x50:
24709                       00006D0D            .608:
24710                                           ! 4249     default:
24711                       00006D0D            .609:
24712                                           ! 4250       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
24713                       00006D0D            .60A:
24714                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24715 6D0D           8A46         19            mov	al,$19[bp]
24716 6D10           30E4                       xor	ah,ah
24717 6D12           50                         push	ax
24718                                           ! Debug: list * char = .60B+0 (used reg = )
24719 6D13           BB                   CF50  mov	bx,#.60B
24720 6D16           53                         push	bx
24721                                           ! Debug: list int = const 4 (used reg = )
24722 6D17           B8                   0004  mov	ax,*4
24723 6D1A           50                         push	ax
24724                                           ! Debug: func () void = bios_printf+0 (used reg = )
24725 6D1B           E8         9C1B            call	_bios_printf
24726 6D1E           83C4                   06  add	sp,*6
24727                                           !BCC_EOS
24728                                           ! 4251       goto int13_fail;
24729 6D21           83C4                   00  add	sp,#..FFEB-..FFEA
24730 6D24           E9         007F            jmp .FFEB
24731                                           !BCC_EOS
24732                                           ! 4252       break;
24733 6D27           EB           7D            jmp .5BE
24734                                           !BCC_EOS
24735                                           ! 4253   }
24736                                           ! 4254 int13_fail:
24737 6D29           EB           7B            jmp .5BE
24738                       00006D2B            .5C0:
24739 6D2B           2C                     00  sub	al,*0
24740 6D2D           72           DE            jb 	.60A
24741 6D2F           3C                     18  cmp	al,*$18
24742 6D31           77           3D            ja  	.60C
24743 6D33           30E4                       xor	ah,ah
24744 6D35           D1E0                       shl	ax,*1
24745 6D37           89C3                       mov	bx,ax
24746 6D39           2E                         seg	cs
24747 6D3A           FFA7       6D3E            br	.60D[bx]
24748                       00006D3E            .60D:
24749 6D3E                      697B            .word	.5C1
24750 6D40                      6992            .word	.5CC
24751 6D42                      6D0D            .word	.603
24752 6D44                      6984            .word	.5C9
24753 6D46                      6D0D            .word	.604
24754 6D48                      6984            .word	.5CA
24755 6D4A                      6D0D            .word	.60A
24756 6D4C                      6D0D            .word	.60A
24757 6D4E                      6D0D            .word	.605
24758 6D50                      697B            .word	.5C2
24759 6D52                      6D0D            .word	.606
24760 6D54                      6D0D            .word	.607
24761 6D56                      697B            .word	.5C3
24762 6D58                      697B            .word	.5C4
24763 6D5A                      6D0D            .word	.60A
24764 6D5C                      6D0D            .word	.60A
24765 6D5E                      697B            .word	.5C5
24766 6D60                      697B            .word	.5C6
24767 6D62                      6D0D            .word	.60A
24768 6D64                      6D0D            .word	.60A
24769 6D66                      697B            .word	.5C7
24770 6D68                      69D2            .word	.5D0
24771 6D6A                      697B            .word	.5C8
24772 6D6C                      6D0D            .word	.60A
24773 6D6E                      6D0D            .word	.608
24774                       00006D70            .60C:
24775 6D70           2C                     41  sub	al,*$41
24776 6D72           72           99            jb 	.60A
24777 6D74           3C                     0F  cmp	al,*$F
24778 6D76           77           2B            ja  	.60E
24779 6D78           30E4                       xor	ah,ah
24780 6D7A           D1E0                       shl	ax,*1
24781 6D7C           89C3                       mov	bx,ax
24782 6D7E           2E                         seg	cs
24783 6D7F           FFA7       6D83            br	.60F[bx]
24784                       00006D83            .60F:
24785 6D83                      69E0            .word	.5D1
24786 6D85                      69FA            .word	.5D2
24787 6D87                      6984            .word	.5CB
24788 6D89                      69FA            .word	.5D3
24789 6D8B                      6B8B            .word	.5DE
24790 6D8D                      6C5D            .word	.5F1
24791 6D8F                      69FA            .word	.5D4
24792 6D91                      6CB0            .word	.5F6
24793 6D93                      6CD5            .word	.5F9
24794 6D95                      6D0D            .word	.60A
24795 6D97                      6D0D            .word	.60A
24796 6D99                      6D0D            .word	.60A
24797 6D9B                      6D0D            .word	.60A
24798 6D9D                      6CE3            .word	.5FA
24799 6D9F                      6D0D            .word	.60A
24800 6DA1                      6D0D            .word	.609
24801                       00006DA3            .60E:
24802 6DA3           E9         FF67            br 	.60A
24803                       00006DA6            .5BE:
24804                       FFFFFFE0            ..FFEA	=	-$20
24805                       00006DA6            .FFEB:
24806                       FFFFFFE0            ..FFEB	=	-$20
24807                                           ! 4255   *(((Bit8u *)&AX)+1) = (0x01);
24808                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$17] (used reg = )
24809 6DA6           B0                     01  mov	al,*1
24810 6DA8           8846         19            mov	$19[bp],al
24811                                           !BCC_EOS
24812                                           ! 4256 int13_fail_noah:
24813                       00006DAB            .FFE8:
24814                       FFFFFFE0            ..FFE8	=	-$20
24815                                           ! 4257   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
24816                                           ! Debug: list int = const $40 (used reg = )
24817 6DAB           B8                   0040  mov	ax,*$40
24818 6DAE           50                         push	ax
24819                                           ! Debug: list int = const $74 (used reg = )
24820 6DAF           B8                   0074  mov	ax,*$74
24821 6DB2           50                         push	ax
24822                                           ! Debug: list unsigned char AX = [S+$24+$17] (used reg = )
24823 6DB3           8A46         19            mov	al,$19[bp]
24824 6DB6           30E4                       xor	ah,ah
24825 6DB8           50                         push	ax
24826                                           ! Debug: func () void = _write_byte+0 (used reg = )
24827 6DB9           E8         983F            call	__write_byte
24828 6DBC           83C4                   06  add	sp,*6
24829                                           !BCC_EOS
24830                                           ! 4258 int13_fail_nostatus:
24831                       00006DBF            .FFE7:
24832                       FFFFFFE0            ..FFE7	=	-$20
24833                                           ! 4259   FLAGS |= 0x0001;
24834                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24835 6DBF           8B46         1E            mov	ax,$1E[bp]
24836 6DC2           0C                     01  or	al,*1
24837 6DC4           8946         1E            mov	$1E[bp],ax
24838                                           !BCC_EOS
24839                                           ! 4260   return;
24840 6DC7           89EC                       mov	sp,bp
24841 6DC9           5D                         pop	bp
24842 6DCA           C3                         ret
24843                                           !BCC_EOS
24844                                           ! 4261 int13_success:
24845                       00006DCB            .FFE9:
24846                       FFFFFFE0            ..FFE9	=	-$20
24847                                           ! 4262   *(((Bit8u *)&AX)+1) = (0x00);
24848                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$17] (used reg = )
24849 6DCB           30C0                       xor	al,al
24850 6DCD           8846         19            mov	$19[bp],al
24851                                           !BCC_EOS
24852                                           ! 4263 int13_success_noah:
24853                       00006DD0            .FFE6:
24854                       FFFFFFE0            ..FFE6	=	-$20
24855                                           ! 4264   _write_byte(0x00, 0x0074, 0x0040);
24856                                           ! Debug: list int = const $40 (used reg = )
24857 6DD0           B8                   0040  mov	ax,*$40
24858 6DD3           50                         push	ax
24859                                           ! Debug: list int = const $74 (used reg = )
24860 6DD4           B8                   0074  mov	ax,*$74
24861 6DD7           50                         push	ax
24862                                           ! Debug: list int = const 0 (used reg = )
24863 6DD8           31C0                       xor	ax,ax
24864 6DDA           50                         push	ax
24865                                           ! Debug: func () void = _write_byte+0 (used reg = )
24866 6DDB           E8         981D            call	__write_byte
24867 6DDE           83C4                   06  add	sp,*6
24868                                           !BCC_EOS
24869                                           ! 4265   FLAGS &= 0xfffe;
24870                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24871 6DE1           8B46         1E            mov	ax,$1E[bp]
24872 6DE4           24                     FE  and	al,#$FE
24873 6DE6           8946         1E            mov	$1E[bp],ax
24874                                           !BCC_EOS
24875                                           ! 4266 }
24876 6DE9           89EC                       mov	sp,bp
24877 6DEB           5D                         pop	bp
24878 6DEC           C3                         ret
24879                                           ! 4267   void
24880                                           ! Register BX used in function int13_cdrom
24881                                           ! 4268 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
24882                                           ! 4269   Bit16u DS, ES, DI, SI
24883                                           export	_int13_eltorito
24884                       00006DED            _int13_eltorito:
24885                                           ! 4269 , BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
24886                                           !BCC_EOS
24887                                           ! 4270 {
24888                                           ! 4271   Bit16u ebda_seg=get_ebda_seg();
24889 6DED           55                         push	bp
24890 6DEE           89E5                       mov	bp,sp
24891 6DF0           4C                         dec	sp
24892 6DF1           4C                         dec	sp
24893                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
24894 6DF2           E8         9872            call	_get_ebda_seg
24895                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
24896 6DF5           8946         FE            mov	-2[bp],ax
24897                                           !BCC_EOS
24898                                           ! 4272   ;
24899                                           !BCC_EOS
24900                                           ! 4273   switch (*(((Bit8u *)&AX)+1)) {
24901 6DF8           8A46         17            mov	al,$17[bp]
24902 6DFB           E9         0191            br 	.612
24903                                           ! 4274     case 0x4a:
24904                                           ! 4275     case 0x4c:
24905                       00006DFE            .613:
24906                                           ! 4276     case 0x4d:
24907                       00006DFE            .614:
24908                                           ! 4277       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
24909                       00006DFE            .615:
24910                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
24911 6DFE           FF76         16            push	$16[bp]
24912                                           ! Debug: list * char = .616+0 (used reg = )
24913 6E01           BB                   CF1F  mov	bx,#.616
24914 6E04           53                         push	bx
24915                                           ! Debug: list int = const 7 (used reg = )
24916 6E05           B8                   0007  mov	ax,*7
24917 6E08           50                         push	ax
24918                                           ! Debug: func () void = bios_printf+0 (used reg = )
24919 6E09           E8         9B2D            call	_bios_printf
24920 6E0C           83C4                   06  add	sp,*6
24921                                           !BCC_EOS
24922                                           ! 4278       goto int13_fail;
24923 6E0F           83C4                   00  add	sp,#..FFE4-..FFE5
24924 6E12           E9         0194            br 	.FFE4
24925                                           !BCC_EOS
24926                                           ! 4279       break;
24927 6E15           E9         0191            br 	.610
24928                                           !BCC_EOS
24929                                           ! 4280     case 0x4b:
24930                                           ! 4281       *((Bit8u *)(SI+0x00)) = (0x13);
24931                       00006E18            .617:
24932                                           ! Debug: add int = const 0 to unsigned short SI = [S+4+8] (used reg = )
24933 6E18           8B46         0A            mov	ax,$A[bp]
24934                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
24935 6E1B           89C3                       mov	bx,ax
24936                                           ! Debug: eq int = const $13 to unsigned char = [bx+0] (used reg = )
24937 6E1D           B0                     13  mov	al,*$13
24938 6E1F           8807                       mov	[bx],al
24939                                           !BCC_EOS
24940                                           ! 4282       *((Bit8u *)(SI+0x01)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.media, ebda_seg));
24941                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24942 6E21           FF76         FE            push	-2[bp]
24943                                           ! Debug: list * unsigned char = const $25B (used reg = )
24944 6E24           B8                   025B  mov	ax,#$25B
24945 6E27           50                         push	ax
24946                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24947 6E28           E8         97B4            call	__read_byte
24948 6E2B           83C4                   04  add	sp,*4
24949 6E2E           50                         push	ax
24950                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
24951 6E2F           8B46         0A            mov	ax,$A[bp]
24952                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
24953 6E32           89C3                       mov	bx,ax
24954                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+1] (used reg = )
24955 6E34           8A46         FC            mov	al,0+..FFE5[bp]
24956 6E37           8847         01            mov	1[bx],al
24957 6E3A           44                         inc	sp
24958 6E3B           44                         inc	sp
24959                                           !BCC_EOS
24960                                           ! 4283       *((Bit8u *)(SI+0x02)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
24961                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24962 6E3C           FF76         FE            push	-2[bp]
24963                                           ! Debug: list * unsigned char = const $25C (used reg = )
24964 6E3F           B8                   025C  mov	ax,#$25C
24965 6E42           50                         push	ax
24966                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24967 6E43           E8         9799            call	__read_byte
24968 6E46           83C4                   04  add	sp,*4
24969 6E49           50                         push	ax
24970                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
24971 6E4A           8B46         0A            mov	ax,$A[bp]
24972                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+2 (used reg = )
24973 6E4D           89C3                       mov	bx,ax
24974                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+2] (used reg = )
24975 6E4F           8A46         FC            mov	al,0+..FFE5[bp]
24976 6E52           8847         02            mov	2[bx],al
24977 6E55           44                         inc	sp
24978 6E56           44                         inc	sp
24979                                           !BCC_EOS
24980                                           ! 4284       *((Bit8u *)(SI+0x03)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.controller_index, ebda_seg));
24981                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24982 6E57           FF76         FE            push	-2[bp]
24983                                           ! Debug: list * unsigned char = const $25D (used reg = )
24984 6E5A           B8                   025D  mov	ax,#$25D
24985 6E5D           50                         push	ax
24986                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24987 6E5E           E8         977E            call	__read_byte
24988 6E61           83C4                   04  add	sp,*4
24989 6E64           50                         push	ax
24990                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
24991 6E65           8B46         0A            mov	ax,$A[bp]
24992                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+3 (used reg = )
24993 6E68           89C3                       mov	bx,ax
24994                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+3] (used reg = )
24995 6E6A           8A46         FC            mov	al,0+..FFE5[bp]
24996 6E6D           8847         03            mov	3[bx],al
24997 6E70           44                         inc	sp
24998 6E71           44                         inc	sp
24999                                           !BCC_EOS
25000                                           ! 4285       *((Bit32u *)(SI+0x04)) = (_read_dword(&((ebda_data_t *) 0)->cdemu.ilba, ebda_seg));
25001                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25002 6E72           FF76         FE            push	-2[bp]
25003                                           ! Debug: list * unsigned long = const $260 (used reg = )
25004 6E75           B8                   0260  mov	ax,#$260
25005 6E78           50                         push	ax
25006                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
25007 6E79           E8         91DA            call	__read_dword
25008 6E7C           89D3                       mov	bx,dx
25009 6E7E           83C4                   04  add	sp,*4
25010 6E81           53                         push	bx
25011 6E82           50                         push	ax
25012                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
25013 6E83           8B46         0A            mov	ax,$A[bp]
25014                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+4 (used reg = )
25015 6E86           89C3                       mov	bx,ax
25016                                           ! Debug: eq unsigned long (temp) = [S+8-8] to unsigned long = [bx+4] (used reg = )
25017 6E88           8B46         FA            mov	ax,-2+..FFE5[bp]
25018 6E8B           8B76         FC            mov	si,0+..FFE5[bp]
25019 6E8E           8947         04            mov	4[bx],ax
25020 6E91           8977         06            mov	6[bx],si
25021 6E94           83C4                   04  add	sp,*4
25022                                           !BCC_EOS
25023                                           ! 4286       *((Bit16u *)(SI+0x08)) = (_read_word(&((ebda_data_t *) 0)->cdemu.device_spec, ebda_seg));
25024                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25025 6E97           FF76         FE            push	-2[bp]
25026                                           ! Debug: list * unsigned short = const $25E (used reg = )
25027 6E9A           B8                   025E  mov	ax,#$25E
25028 6E9D           50                         push	ax
25029                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25030 6E9E           E8         974C            call	__read_word
25031 6EA1           83C4                   04  add	sp,*4
25032 6EA4           50                         push	ax
25033                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
25034 6EA5           8B46         0A            mov	ax,$A[bp]
25035                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
25036 6EA8           89C3                       mov	bx,ax
25037                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+8] (used reg = )
25038 6EAA           8B46         FC            mov	ax,0+..FFE5[bp]
25039 6EAD           8947         08            mov	8[bx],ax
25040 6EB0           44                         inc	sp
25041 6EB1           44                         inc	sp
25042                                           !BCC_EOS
25043                                           ! 4287       *((Bit16u *)(SI+0x0a)) = (_read_word(&((ebda_data_t *) 0)->cdemu.buffer_segment, ebda_seg));
25044                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25045 6EB2           FF76         FE            push	-2[bp]
25046                                           ! Debug: list * unsigned short = const $264 (used reg = )
25047 6EB5           B8                   0264  mov	ax,#$264
25048 6EB8           50                         push	ax
25049                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25050 6EB9           E8         9731            call	__read_word
25051 6EBC           83C4                   04  add	sp,*4
25052 6EBF           50                         push	ax
25053                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
25054 6EC0           8B46         0A            mov	ax,$A[bp]
25055                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
25056 6EC3           89C3                       mov	bx,ax
25057                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$A] (used reg = )
25058 6EC5           8B46         FC            mov	ax,0+..FFE5[bp]
25059 6EC8           8947         0A            mov	$A[bx],ax
25060 6ECB           44                         inc	sp
25061 6ECC           44                         inc	sp
25062                                           !BCC_EOS
25063                                           ! 4288       *((Bit16u *)(SI+0x0c)) = (_read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg));
25064                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25065 6ECD           FF76         FE            push	-2[bp]
25066                                           ! Debug: list * unsigned short = const $266 (used reg = )
25067 6ED0           B8                   0266  mov	ax,#$266
25068 6ED3           50                         push	ax
25069                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25070 6ED4           E8         9716            call	__read_word
25071 6ED7           83C4                   04  add	sp,*4
25072 6EDA           50                         push	ax
25073                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
25074 6EDB           8B46         0A            mov	ax,$A[bp]
25075                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
25076 6EDE           89C3                       mov	bx,ax
25077                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$C] (used reg = )
25078 6EE0           8B46         FC            mov	ax,0+..FFE5[bp]
25079 6EE3           8947         0C            mov	$C[bx],ax
25080 6EE6           44                         inc	sp
25081 6EE7           44                         inc	sp
25082                                           !BCC_EOS
25083                                           ! 4289       *((Bit16u *)(SI+0x0e)) = (_read_word(&((ebda_data_t *) 0)->cdemu.sector_count, ebda_seg));
25084                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25085 6EE8           FF76         FE            push	-2[bp]
25086                                           ! Debug: list * unsigned short = const $268 (used reg = )
25087 6EEB           B8                   0268  mov	ax,#$268
25088 6EEE           50                         push	ax
25089                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25090 6EEF           E8         96FB            call	__read_word
25091 6EF2           83C4                   04  add	sp,*4
25092 6EF5           50                         push	ax
25093                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
25094 6EF6           8B46         0A            mov	ax,$A[bp]
25095                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
25096 6EF9           89C3                       mov	bx,ax
25097                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$E] (used reg = )
25098 6EFB           8B46         FC            mov	ax,0+..FFE5[bp]
25099 6EFE           8947         0E            mov	$E[bx],ax
25100 6F01           44                         inc	sp
25101 6F02           44                         inc	sp
25102                                           !BCC_EOS
25103                                           ! 4290       *((Bit8u *)(SI+0x10)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders, ebda_seg));
25104                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25105 6F03           FF76         FE            push	-2[bp]
25106                                           ! Debug: list * unsigned short = const $26C (used reg = )
25107 6F06           B8                   026C  mov	ax,#$26C
25108 6F09           50                         push	ax
25109                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25110 6F0A           E8         96D2            call	__read_byte
25111 6F0D           83C4                   04  add	sp,*4
25112 6F10           50                         push	ax
25113                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
25114 6F11           8B46         0A            mov	ax,$A[bp]
25115                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$10 (used reg = )
25116 6F14           89C3                       mov	bx,ax
25117                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$10] (used reg = )
25118 6F16           8A46         FC            mov	al,0+..FFE5[bp]
25119 6F19           8847         10            mov	$10[bx],al
25120 6F1C           44                         inc	sp
25121 6F1D           44                         inc	sp
25122                                           !BCC_EOS
25123                                           ! 4291       *((Bit8u *)(SI+0x11)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.spt, ebda_seg));
25124                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25125 6F1E           FF76         FE            push	-2[bp]
25126                                           ! Debug: list * unsigned short = const $26E (used reg = )
25127 6F21           B8                   026E  mov	ax,#$26E
25128 6F24           50                         push	ax
25129                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25130 6F25           E8         96B7            call	__read_byte
25131 6F28           83C4                   04  add	sp,*4
25132 6F2B           50                         push	ax
25133                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
25134 6F2C           8B46         0A            mov	ax,$A[bp]
25135                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$11 (used reg = )
25136 6F2F           89C3                       mov	bx,ax
25137                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$11] (used reg = )
25138 6F31           8A46         FC            mov	al,0+..FFE5[bp]
25139 6F34           8847         11            mov	$11[bx],al
25140 6F37           44                         inc	sp
25141 6F38           44                         inc	sp
25142                                           !BCC_EOS
25143                                           ! 4292       *((Bit8u *)(SI+0x12)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.heads, ebda_seg));
25144                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25145 6F39           FF76         FE            push	-2[bp]
25146                                           ! Debug: list * unsigned short = const $26A (used reg = )
25147 6F3C           B8                   026A  mov	ax,#$26A
25148 6F3F           50                         push	ax
25149                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25150 6F40           E8         969C            call	__read_byte
25151 6F43           83C4                   04  add	sp,*4
25152 6F46           50                         push	ax
25153                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
25154 6F47           8B46         0A            mov	ax,$A[bp]
25155                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$12 (used reg = )
25156 6F4A           89C3                       mov	bx,ax
25157                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$12] (used reg = )
25158 6F4C           8A46         FC            mov	al,0+..FFE5[bp]
25159 6F4F           8847         12            mov	$12[bx],al
25160 6F52           44                         inc	sp
25161 6F53           44                         inc	sp
25162                                           !BCC_EOS
25163                                           ! 4293       if(( AX & 0x00ff ) == 0x00) {
25164                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
25165 6F54           8A46         16            mov	al,$16[bp]
25166                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
25167 6F57           84C0                       test	al,al
25168 6F59           75           10            jne 	.618
25169                       00006F5B            .619:
25170                                           ! 4294         _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
25171                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25172 6F5B           FF76         FE            push	-2[bp]
25173                                           ! Debug: list * unsigned char = const $25A (used reg = )
25174 6F5E           B8                   025A  mov	ax,#$25A
25175 6F61           50                         push	ax
25176                                           ! Debug: list int = const 0 (used reg = )
25177 6F62           31C0                       xor	ax,ax
25178 6F64           50                         push	ax
25179                                           ! Debug: func () void = _write_byte+0 (used reg = )
25180 6F65           E8         9693            call	__write_byte
25181 6F68           83C4                   06  add	sp,*6
25182                                           !BCC_EOS
25183                                           ! 4295       }
25184                                           ! 4296       goto int13_success;
25185                       00006F6B            .618:
25186 6F6B           83C4                   00  add	sp,#..FFE3-..FFE5
25187 6F6E           EB           5E            jmp .FFE3
25188                                           !BCC_EOS
25189                                           ! 4297       break;
25190 6F70           EB           37            jmp .610
25191                                           !BCC_EOS
25192                                           ! 4298     default:
25193                                           ! 4299       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
25194                       00006F72            .61A:
25195                                           ! Debug: list unsigned char AX = [S+4+$15] (used reg = )
25196 6F72           8A46         17            mov	al,$17[bp]
25197 6F75           30E4                       xor	ah,ah
25198 6F77           50                         push	ax
25199                                           ! Debug: list * char = .61B+0 (used reg = )
25200 6F78           BB                   CEFA  mov	bx,#.61B
25201 6F7B           53                         push	bx
25202                                           ! Debug: list int = const 4 (used reg = )
25203 6F7C           B8                   0004  mov	ax,*4
25204 6F7F           50                         push	ax
25205                                           ! Debug: func () void = bios_printf+0 (used reg = )
25206 6F80           E8         99B6            call	_bios_printf
25207 6F83           83C4                   06  add	sp,*6
25208                                           !BCC_EOS
25209                                           ! 4300       goto int13_fail;
25210 6F86           83C4                   00  add	sp,#..FFE4-..FFE5
25211 6F89           EB           1E            jmp .FFE4
25212                                           !BCC_EOS
25213                                           ! 4301       break;
25214 6F8B           EB           1C            jmp .610
25215                                           !BCC_EOS
25216                                           ! 4302   }
25217                                           ! 4303 int13_fail:
25218 6F8D           EB           1A            jmp .610
25219                       00006F8F            .612:
25220 6F8F           2C                     4A  sub	al,*$4A
25221 6F91         0F84         FE69            beq 	.613
25222 6F95           2C                     01  sub	al,*1
25223 6F97         0F84         FE7D            beq 	.617
25224 6F9B           2C                     01  sub	al,*1
25225 6F9D         0F84         FE5D            beq 	.614
25226 6FA1           2C                     01  sub	al,*1
25227 6FA3         0F84         FE57            beq 	.615
25228 6FA7           EB           C9            jmp	.61A
25229                       00006FA9            .610:
25230                       FFFFFFFC            ..FFE5	=	-4
25231                       00006FA9            .FFE4:
25232                       FFFFFFFC            ..FFE4	=	-4
25233                                           ! 4304   *(((Bit8u *)&AX)+1) = (0x01);
25234                                           ! Debug: eq int = const 1 to unsigned char AX = [S+4+$15] (used reg = )
25235 6FA9           B0                     01  mov	al,*1
25236 6FAB           8846         17            mov	$17[bp],al
25237                                           !BCC_EOS
25238                                           ! 4305   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
25239                                           ! Debug: list int = const $40 (used reg = )
25240 6FAE           B8                   0040  mov	ax,*$40
25241 6FB1           50                         push	ax
25242                                           ! Debug: list int = const $74 (used reg = )
25243 6FB2           B8                   0074  mov	ax,*$74
25244 6FB5           50                         push	ax
25245                                           ! Debug: list unsigned char AX = [S+8+$15] (used reg = )
25246 6FB6           8A46         17            mov	al,$17[bp]
25247 6FB9           30E4                       xor	ah,ah
25248 6FBB           50                         push	ax
25249                                           ! Debug: func () void = _write_byte+0 (used reg = )
25250 6FBC           E8         963C            call	__write_byte
25251 6FBF           83C4                   06  add	sp,*6
25252                                           !BCC_EOS
25253                                           ! 4306   FLAGS |= 0x0001;
25254                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
25255 6FC2           8B46         1C            mov	ax,$1C[bp]
25256 6FC5           0C                     01  or	al,*1
25257 6FC7           8946         1C            mov	$1C[bp],ax
25258                                           !BCC_EOS
25259                                           ! 4307   return;
25260 6FCA           89EC                       mov	sp,bp
25261 6FCC           5D                         pop	bp
25262 6FCD           C3                         ret
25263                                           !BCC_EOS
25264                                           ! 4308 int13_success:
25265                       00006FCE            .FFE3:
25266                       FFFFFFFC            ..FFE3	=	-4
25267                                           ! 4309   *(((Bit8u *)&AX)+1) = (0x00);
25268                                           ! Debug: eq int = const 0 to unsigned char AX = [S+4+$15] (used reg = )
25269 6FCE           30C0                       xor	al,al
25270 6FD0           8846         17            mov	$17[bp],al
25271                                           !BCC_EOS
25272                                           ! 4310   _write_byte(0x00, 0x0074, 0x0040);
25273                                           ! Debug: list int = const $40 (used reg = )
25274 6FD3           B8                   0040  mov	ax,*$40
25275 6FD6           50                         push	ax
25276                                           ! Debug: list int = const $74 (used reg = )
25277 6FD7           B8                   0074  mov	ax,*$74
25278 6FDA           50                         push	ax
25279                                           ! Debug: list int = const 0 (used reg = )
25280 6FDB           31C0                       xor	ax,ax
25281 6FDD           50                         push	ax
25282                                           ! Debug: func () void = _write_byte+0 (used reg = )
25283 6FDE           E8         961A            call	__write_byte
25284 6FE1           83C4                   06  add	sp,*6
25285                                           !BCC_EOS
25286                                           ! 4311   FLAGS &= 0xfffe;
25287                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
25288 6FE4           8B46         1C            mov	ax,$1C[bp]
25289 6FE7           24                     FE  and	al,#$FE
25290 6FE9           8946         1C            mov	$1C[bp],ax
25291                                           !BCC_EOS
25292                                           ! 4312 }
25293 6FEC           89EC                       mov	sp,bp
25294 6FEE           5D                         pop	bp
25295 6FEF           C3                         ret
25296                                           ! 4313   void
25297                                           ! Register BX used in function int13_eltorito
25298                                           ! 4314 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
25299                                           ! 4315   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS,
25300                                           export	_int13_cdemu
25301                       00006FF0            _int13_cdemu:
25302                                           ! 4315  FLAGS;
25303                                           !BCC_EOS
25304                                           ! 4316 {
25305                                           ! 4317   Bit8u device, status;
25306                                           !BCC_EOS
25307                                           ! 4318   Bit16u vheads, vspt, vcylinders;
25308                                           !BCC_EOS
25309                                           ! 4319   Bit16u head, sector, cylinder, nbsectors, count;
25310                                           !BCC_EOS
25311                                           ! 4320   Bit32u vlba, ilba, slba, elba, lba;
25312                                           !BCC_EOS
25313                                           ! 4321   Bit16u before, segment, offset;
25314                                           !BCC_EOS
25315                                           ! 4322   Bit8u atacmd[12];
25316                                           !BCC_EOS
25317                                           ! 4323   ;
25318 6FF0           55                         push	bp
25319 6FF1           89E5                       mov	bp,sp
25320 6FF3           83C4                   C8  add	sp,*-$38
25321                                           !BCC_EOS
25322                                           ! 4324   device = *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) * 2;
25323                                           ! Debug: mul int = const 2 to unsigned char = [+$25D] (used reg = )
25324 6FF6           A0         025D            mov	al,[$25D]
25325 6FF9           30E4                       xor	ah,ah
25326 6FFB           D1E0                       shl	ax,*1
25327                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$3A-3] (used reg = )
25328 6FFD           8846         FF            mov	-1[bp],al
25329                                           !BCC_EOS
25330                                           ! 4325   device += *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec));
25331                                           ! Debug: addab unsigned char = [+$25E] to unsigned char device = [S+$3A-3] (used reg = )
25332 7000           8A46         FF            mov	al,-1[bp]
25333 7003           30E4                       xor	ah,ah
25334 7005           0206       025E            add	al,[$25E]
25335 7009           80D4                   00  adc	ah,*0
25336 700C           8846         FF            mov	-1[bp],al
25337                                           !BCC_EOS
25338                                           ! 4326   _write_byte(0x00, 0x0074, 0x0040);
25339                                           ! Debug: list int = const $40 (used reg = )
25340 700F           B8                   0040  mov	ax,*$40
25341 7012           50                         push	ax
25342                                           ! Debug: list int = const $74 (used reg = )
25343 7013           B8                   0074  mov	ax,*$74
25344 7016           50                         push	ax
25345                                           ! Debug: list int = const 0 (used reg = )
25346 7017           31C0                       xor	ax,ax
25347 7019           50                         push	ax
25348                                           ! Debug: func () void = _write_byte+0 (used reg = )
25349 701A           E8         95DE            call	__write_byte
25350 701D           83C4                   06  add	sp,*6
25351                                           !BCC_EOS
25352                                           ! 4327   if( (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) ==0) ||
25353                                           ! 4328       (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) != ( DX & 0x00ff ))) {
25354                                           ! Debug: logeq int = const 0 to unsigned char = [+$25A] (used reg = )
25355 7020           A0         025A            mov	al,[$25A]
25356 7023           84C0                       test	al,al
25357 7025           74           09            je  	.61D
25358                       00007027            .61E:
25359                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25360 7027           8A46         12            mov	al,$12[bp]
25361                                           ! Debug: ne unsigned char = al+0 to unsigned char = [+$25C] (used reg = )
25362                                           ! Debug: expression subtree swapping
25363 702A           3A06       025C            cmp	al,[$25C]
25364 702E           74           20            je  	.61C
25365                       00007030            .61D:
25366                                           ! 4329     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", *(((Bit8u *)&AX)+1), ( DX & 0x00ff ));
25367                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25368 7030           8A46         12            mov	al,$12[bp]
25369                                           ! Debug: list unsigned char = al+0 (used reg = )
25370 7033           30E4                       xor	ah,ah
25371 7035           50                         push	ax
25372                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25373 7036           8A46         17            mov	al,$17[bp]
25374 7039           30E4                       xor	ah,ah
25375 703B           50                         push	ax
25376                                           ! Debug: list * char = .61F+0 (used reg = )
25377 703C           BB                   CEBB  mov	bx,#.61F
25378 703F           53                         push	bx
25379                                           ! Debug: list int = const 4 (used reg = )
25380 7040           B8                   0004  mov	ax,*4
25381 7043           50                         push	ax
25382                                           ! Debug: func () void = bios_printf+0 (used reg = )
25383 7044           E8         98F2            call	_bios_printf
25384 7047           83C4                   08  add	sp,*8
25385                                           !BCC_EOS
25386                                           ! 4330     goto int13_fail;
25387 704A           83C4                   00  add	sp,#..FFE2+$3A
25388 704D           E9         03CA            br 	.FFE2
25389                                           !BCC_EOS
25390                                           ! 4331   }
25391                                           ! 4332   switch (*(((Bit8u *)&AX)+1)) {
25392                       00007050            .61C:
25393 7050           8A46         17            mov	al,$17[bp]
25394 7053           E9         0349            br 	.622
25395                                           ! 4333     case 0x00:
25396                                           ! 4334     case 0x09:
25397                       00007056            .623:
25398                                           ! 4335     case 0x0c:
25399                       00007056            .624:
25400                                           ! 4336     case 0x0d:
25401                       00007056            .625:
25402                                           ! 4337     case 0x10:
25403                       00007056            .626:
25404                                           ! 4338     case 0x11:
25405                       00007056            .627:
25406                                           ! 4339     case 0x14:
25407                       00007056            .628:
25408                                           ! 4340     case 0x16:
25409                       00007056            .629:
25410                                           ! 4341       goto int13_success;
25411                       00007056            .62A:
25412 7056           83C4                   00  add	sp,#..FFE0-..FFE1
25413 7059           E9         03E3            br 	.FFE0
25414                                           !BCC_EOS
25415                                           ! 4342       break;
25416 705C           E9         03BB            br 	.620
25417                                           !BCC_EOS
25418                                           ! 4343     case 0x03:
25419                                           ! 4344     case 0x05:
25420                       0000705F            .62B:
25421                                           ! 4345       *(((Bit8u *)&AX)+1) = (0x03);
25422                       0000705F            .62C:
25423                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
25424 705F           B0                     03  mov	al,*3
25425 7061           8846         17            mov	$17[bp],al
25426                                           !BCC_EOS
25427                                           ! 4346       goto int13_fail_noah;
25428 7064           83C4                   00  add	sp,#..FFDF-..FFE1
25429 7067           E9         03B5            br 	.FFDF
25430                                           !BCC_EOS
25431                                           ! 4347       break;
25432 706A           E9         03AD            br 	.620
25433                                           !BCC_EOS
25434                                           ! 4348     case 0x01:
25435                                           ! 4349       status=_read_byte(0x0074, 0x0040);
25436                       0000706D            .62D:
25437                                           ! Debug: list int = const $40 (used reg = )
25438 706D           B8                   0040  mov	ax,*$40
25439 7070           50                         push	ax
25440                                           ! Debug: list int = const $74 (used reg = )
25441 7071           B8                   0074  mov	ax,*$74
25442 7074           50                         push	ax
25443                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25444 7075           E8         9567            call	__read_byte
25445 7078           83C4                   04  add	sp,*4
25446                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$3A-4] (used reg = )
25447 707B           8846         FE            mov	-2[bp],al
25448                                           !BCC_EOS
25449                                           ! 4350       *(((Bit8u *)&AX)+1) = (status);
25450                                           ! Debug: eq unsigned char status = [S+$3A-4] to unsigned char AX = [S+$3A+$15] (used reg = )
25451 707E           8A46         FE            mov	al,-2[bp]
25452 7081           8846         17            mov	$17[bp],al
25453                                           !BCC_EOS
25454                                           ! 4351       _write_byte(0, 0x0074, 0x0040);
25455                                           ! Debug: list int = const $40 (used reg = )
25456 7084           B8                   0040  mov	ax,*$40
25457 7087           50                         push	ax
25458                                           ! Debug: list int = const $74 (used reg = )
25459 7088           B8                   0074  mov	ax,*$74
25460 708B           50                         push	ax
25461                                           ! Debug: list int = const 0 (used reg = )
25462 708C           31C0                       xor	ax,ax
25463 708E           50                         push	ax
25464                                           ! Debug: func () void = _write_byte+0 (used reg = )
25465 708F           E8         9569            call	__write_byte
25466 7092           83C4                   06  add	sp,*6
25467                                           !BCC_EOS
25468                                           ! 4352       if (status) goto int13_fail_nostatus;
25469 7095           8A46         FE            mov	al,-2[bp]
25470 7098           84C0                       test	al,al
25471 709A           74           08            je  	.62E
25472                       0000709C            .62F:
25473 709C           83C4                   00  add	sp,#..FFDE-..FFE1
25474 709F           E9         0391            br 	.FFDE
25475                                           !BCC_EOS
25476                                           ! 4353       else goto int13_success_noah;
25477 70A2           EB           06            jmp .630
25478                       000070A4            .62E:
25479 70A4           83C4                   00  add	sp,#..FFDD-..FFE1
25480 70A7           E9         039A            br 	.FFDD
25481                                           !BCC_EOS
25482                                           ! 4354       break;
25483                       000070AA            .630:
25484 70AA           E9         036D            br 	.620
25485                                           !BCC_EOS
25486                                           ! 4355     case 0x02:
25487                                           ! 4356     case 0x04:
25488                       000070AD            .631:
25489                                           ! 4357       vspt = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25490                       000070AD            .632:
25491                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25492 70AD           A1         026E            mov	ax,[$26E]
25493 70B0           8946         FA            mov	-6[bp],ax
25494                                           !BCC_EOS
25495                                           ! 4358       vcylinders = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
25496                                           ! Debug: eq unsigned short = [+$26C] to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25497 70B3           A1         026C            mov	ax,[$26C]
25498 70B6           8946         F8            mov	-8[bp],ax
25499                                           !BCC_EOS
25500                                           ! 4359       vheads = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads));
25501                                           ! Debug: eq unsigned short = [+$26A] to unsigned short vheads = [S+$3A-6] (used reg = )
25502 70B9           A1         026A            mov	ax,[$26A]
25503 70BC           8946         FC            mov	-4[bp],ax
25504                                           !BCC_EOS
25505                                           ! 4360       ilba = *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba));
25506                                           ! Debug: eq unsigned long = [+$260] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25507 70BF           A1         0260            mov	ax,[$260]
25508 70C2           8B1E       0262            mov	bx,[$262]
25509 70C6           8946         E6            mov	-$1A[bp],ax
25510 70C9           895E         E8            mov	-$18[bp],bx
25511                                           !BCC_EOS
25512                                           ! 4361       sector = ( CX & 0x00ff ) & 0x003f;
25513                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25514 70CC           8A46         14            mov	al,$14[bp]
25515                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
25516 70CF           24                     3F  and	al,*$3F
25517                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$3A-$E] (used reg = )
25518 70D1           30E4                       xor	ah,ah
25519 70D3           8946         F4            mov	-$C[bp],ax
25520                                           !BCC_EOS
25521                                           ! 4362       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | *(((Bit8u *)&CX)+1);
25522                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25523 70D6           8A46         14            mov	al,$14[bp]
25524                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
25525 70D9           24                     C0  and	al,#$C0
25526                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
25527 70DB           30E4                       xor	ah,ah
25528 70DD           D1E0                       shl	ax,*1
25529 70DF           D1E0                       shl	ax,*1
25530                                           ! Debug: or unsigned char CX = [S+$3A+$13] to unsigned int = ax+0 (used reg = )
25531 70E1           0A46         15            or	al,$15[bp]
25532                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$3A-$10] (used reg = )
25533 70E4           8946         F2            mov	-$E[bp],ax
25534                                           !BCC_EOS
25535                                           ! 4363       head = *(((Bit8u *)&DX)+1);
25536                                           ! Debug: eq unsigned char DX = [S+$3A+$11] to unsigned short head = [S+$3A-$C] (used reg = )
25537 70E7           8A46         13            mov	al,$13[bp]
25538 70EA           30E4                       xor	ah,ah
25539 70EC           8946         F6            mov	-$A[bp],ax
25540                                           !BCC_EOS
25541                                           ! 4364       nbsectors = ( AX & 0x00ff );
25542                                           ! Debug: and int = const $FF to unsigned short AX = [S+$3A+$14] (used reg = )
25543 70EF           8A46         16            mov	al,$16[bp]
25544                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25545 70F2           30E4                       xor	ah,ah
25546 70F4           8946         F0            mov	-$10[bp],ax
25547                                           !BCC_EOS
25548                                           ! 4365       segment = ES;
25549                                           ! Debug: eq unsigned short ES = [S+$3A+4] to unsigned short segment = [S+$3A-$2C] (used reg = )
25550 70F7           8B46         06            mov	ax,6[bp]
25551 70FA           8946         D6            mov	-$2A[bp],ax
25552                                           !BCC_EOS
25553                                           ! 4366       offset = BX;
25554                                           ! Debug: eq unsigned short BX = [S+$3A+$E] to unsigned short offset = [S+$3A-$2E] (used reg = )
25555 70FD           8B46         10            mov	ax,$10[bp]
25556 7100           8946         D4            mov	-$2C[bp],ax
25557                                           !BCC_EOS
25558                                           ! 4367       if(nbsectors==0) goto int13_success;
25559                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25560 7103           8B46         F0            mov	ax,-$10[bp]
25561 7106           85C0                       test	ax,ax
25562 7108           75           06            jne 	.633
25563                       0000710A            .634:
25564 710A           83C4                   00  add	sp,#..FFE0-..FFE1
25565 710D           E9         032F            br 	.FFE0
25566                                           !BCC_EOS
25567                                           ! 4368       if ((sector > vspt)
25568                       00007110            .633:
25569                                           ! 4369        || (cylinder >= vcylinders)
25570                                           ! 4370        || (head >= vheads)) {
25571                                           ! Debug: gt unsigned short vspt = [S+$3A-8] to unsigned short sector = [S+$3A-$E] (used reg = )
25572 7110           8B46         F4            mov	ax,-$C[bp]
25573 7113           3B46         FA            cmp	ax,-6[bp]
25574 7116           77           10            ja  	.636
25575                       00007118            .638:
25576                                           ! Debug: ge unsigned short vcylinders = [S+$3A-$A] to unsigned short cylinder = [S+$3A-$10] (used reg = )
25577 7118           8B46         F2            mov	ax,-$E[bp]
25578 711B           3B46         F8            cmp	ax,-8[bp]
25579 711E           73           08            jae 	.636
25580                       00007120            .637:
25581                                           ! Debug: ge unsigned short vheads = [S+$3A-6] to unsigned short head = [S+$3A-$C] (used reg = )
25582 7120           8B46         F6            mov	ax,-$A[bp]
25583 7123           3B46         FC            cmp	ax,-4[bp]
25584 7126           72           06            jb  	.635
25585                       00007128            .636:
25586                                           ! 4371         goto int13_fail;
25587 7128           83C4                   00  add	sp,#..FFE2-..FFE1
25588 712B           E9         02EC            br 	.FFE2
25589                                           !BCC_EOS
25590                                           ! 4372       }
25591                                           ! 4373       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
25592                       0000712E            .635:
25593                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$3A+$15] (used reg = )
25594 712E           8A46         17            mov	al,$17[bp]
25595 7131           3C                     04  cmp	al,*4
25596 7133           75           06            jne 	.639
25597                       00007135            .63A:
25598 7135           83C4                   00  add	sp,#..FFE0-..FFE1
25599 7138           E9         0304            br 	.FFE0
25600                                           !BCC_EOS
25601                                           ! 4374       segment = ES+(BX / 16);
25602                       0000713B            .639:
25603                                           ! Debug: div int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25604 713B           8B46         10            mov	ax,$10[bp]
25605 713E           B1                     04  mov	cl,*4
25606 7140           D3E8                       shr	ax,cl
25607                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$3A+4] (used reg = )
25608                                           ! Debug: expression subtree swapping
25609 7142           0346         06            add	ax,6[bp]
25610                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$3A-$2C] (used reg = )
25611 7145           8946         D6            mov	-$2A[bp],ax
25612                                           !BCC_EOS
25613                                           ! 4375       offset = BX % 16;
25614                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25615 7148           8B46         10            mov	ax,$10[bp]
25616 714B           24                     0F  and	al,*$F
25617                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$3A-$2E] (used reg = )
25618 714D           30E4                       xor	ah,ah
25619 714F           8946         D4            mov	-$2C[bp],ax
25620                                           !BCC_EOS
25621                                           ! 4376       vlba=(
25622                                           ! 4376 (((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
25623                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$3A-$E] (used reg = )
25624 7152           8B46         F4            mov	ax,-$C[bp]
25625                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
25626 7155           48                         dec	ax
25627 7156           31DB                       xor	bx,bx
25628 7158           53                         push	bx
25629 7159           50                         push	ax
25630                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3E-8] (used reg = )
25631 715A           8B46         FA            mov	ax,-6[bp]
25632 715D           31DB                       xor	bx,bx
25633 715F           53                         push	bx
25634 7160           50                         push	ax
25635                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$42-$C] (used reg = )
25636 7161           8B46         F6            mov	ax,-$A[bp]
25637 7164           31DB                       xor	bx,bx
25638 7166           53                         push	bx
25639 7167           50                         push	ax
25640                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$46-6] (used reg = )
25641 7168           8B46         FC            mov	ax,-4[bp]
25642 716B           31DB                       xor	bx,bx
25643 716D           53                         push	bx
25644 716E           50                         push	ax
25645                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$4A-$10] (used reg = )
25646 716F           8B46         F2            mov	ax,-$E[bp]
25647 7172           31DB                       xor	bx,bx
25648                                           ! Debug: mul unsigned long (temp) = [S+$4A-$4A] to unsigned long = bx+0 (used reg = )
25649 7174           8D7E         B8            lea	di,-$E+..FFE1[bp]
25650 7177           E8         8F40            call	lmulul
25651 717A           83C4                   04  add	sp,*4
25652                                           ! Debug: add unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
25653 717D           8D7E         BC            lea	di,-$A+..FFE1[bp]
25654 7180           E8         8F11            call	laddul
25655 7183           83C4                   04  add	sp,*4
25656                                           ! Debug: mul unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
25657 7186           8D7E         C0            lea	di,-6+..FFE1[bp]
25658 7189           E8         8F2E            call	lmulul
25659 718C           83C4                   04  add	sp,*4
25660                                           ! Debug: add unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
25661 718F           8D7E         C4            lea	di,-2+..FFE1[bp]
25662 7192           E8         8EFF            call	laddul
25663 7195           83C4                   04  add	sp,*4
25664                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25665 7198           8946         EA            mov	-$16[bp],ax
25666 719B           895E         EC            mov	-$14[bp],bx
25667                                           !BCC_EOS
25668                                           ! 4377       *((Bit8u *)&AX) = (nbsectors);
25669                                           ! Debug: eq unsigned short nbsectors = [S+$3A-$12] to unsigned char AX = [S+$3A+$14] (used reg = )
25670 719E           8A46         F0            mov	al,-$10[bp]
25671 71A1           8846         16            mov	$16[bp],al
25672                                           !BCC_EOS
25673                                           ! 4378       slba = (Bit32u)vlba/4;
25674                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$3A-$18] (used reg = )
25675 71A4           B8                   0004  mov	ax,*4
25676 71A7           31DB                       xor	bx,bx
25677 71A9           53                         push	bx
25678 71AA           50                         push	ax
25679 71AB           8B46         EA            mov	ax,-$16[bp]
25680 71AE           8B5E         EC            mov	bx,-$14[bp]
25681 71B1           8D7E         C4            lea	di,-2+..FFE1[bp]
25682 71B4           E8         8F88            call	ldivul
25683 71B7           83C4                   04  add	sp,*4
25684                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$3A-$20] (used reg = )
25685 71BA           8946         E2            mov	-$1E[bp],ax
25686 71BD           895E         E4            mov	-$1C[bp],bx
25687                                           !BCC_EOS
25688                                           ! 4379       before= (Bit16u)vlba%4;
25689                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$3A-$18] (used reg = )
25690 71C0           8B46         EA            mov	ax,-$16[bp]
25691 71C3           24                     03  and	al,*3
25692                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$3A-$2A] (used reg = )
25693 71C5           30E4                       xor	ah,ah
25694 71C7           8946         D8            mov	-$28[bp],ax
25695                                           !BCC_EOS
25696                                           ! 4380       elba = (Bit32u)(vlba+nbsectors-1)/4;
25697                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25698 71CA           8B46         F0            mov	ax,-$10[bp]
25699 71CD           31DB                       xor	bx,bx
25700                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25701                                           ! Debug: expression subtree swapping
25702 71CF           8D7E         EA            lea	di,-$16[bp]
25703 71D2           E8         8EBF            call	laddul
25704                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
25705 71D5           53                         push	bx
25706 71D6           50                         push	ax
25707 71D7           B8                   0001  mov	ax,*1
25708 71DA           31DB                       xor	bx,bx
25709 71DC           53                         push	bx
25710 71DD           50                         push	ax
25711 71DE           8B46         C4            mov	ax,-2+..FFE1[bp]
25712 71E1           8B5E         C6            mov	bx,0+..FFE1[bp]
25713 71E4           8D7E         C0            lea	di,-6+..FFE1[bp]
25714 71E7           E8         8EC8            call	lsubul
25715 71EA           83C4                   08  add	sp,*8
25716                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
25717                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
25718 71ED           53                         push	bx
25719 71EE           50                         push	ax
25720 71EF           B8                   0004  mov	ax,*4
25721 71F2           31DB                       xor	bx,bx
25722 71F4           53                         push	bx
25723 71F5           50                         push	ax
25724 71F6           8B46         C4            mov	ax,-2+..FFE1[bp]
25725 71F9           8B5E         C6            mov	bx,0+..FFE1[bp]
25726 71FC           8D7E         C0            lea	di,-6+..FFE1[bp]
25727 71FF           E8         8F3D            call	ldivul
25728 7202           83C4                   08  add	sp,*8
25729                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$3A-$24] (used reg = )
25730 7205           8946         DE            mov	-$22[bp],ax
25731 7208           895E         E0            mov	-$20[bp],bx
25732                                           !BCC_EOS
25733                                           ! 4381       _memsetb(0,atacmd,get_SS(),12);
25734                                           ! Debug: list int = const $C (used reg = )
25735 720B           B8                   000C  mov	ax,*$C
25736 720E           50                         push	ax
25737                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25738 720F           E8         9448            call	_get_SS
25739                                           ! Debug: list unsigned short = ax+0 (used reg = )
25740 7212           50                         push	ax
25741                                           ! Debug: list * unsigned char atacmd = S+$3E-$3A (used reg = )
25742 7213           8D5E         C8            lea	bx,-$38[bp]
25743 7216           53                         push	bx
25744                                           ! Debug: list int = const 0 (used reg = )
25745 7217           31C0                       xor	ax,ax
25746 7219           50                         push	ax
25747                                           ! Debug: func () void = _memsetb+0 (used reg = )
25748 721A           E8         8DE3            call	__memsetb
25749 721D           83C4                   08  add	sp,*8
25750                                           !BCC_EOS
25751                                           ! 4382       atacmd[0]=0x28;
25752                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$3A-$3A] (used reg = )
25753 7220           B0                     28  mov	al,*$28
25754 7222           8846         C8            mov	-$38[bp],al
25755                                           !BCC_EOS
25756                                           ! 4383       count = (Bit16u)(elba-slba)+1;
25757                                           ! Debug: sub unsigned long slba = [S+$3A-$20] to unsigned long elba = [S+$3A-$24] (used reg = )
25758 7225           8B46         DE            mov	ax,-$22[bp]
25759 7228           8B5E         E0            mov	bx,-$20[bp]
25760 722B           8D7E         E2            lea	di,-$1E[bp]
25761 722E           E8         8E81            call	lsubul
25762                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
25763                                           ! Debug: add int = const 1 to unsigned short = ax+0 (used reg = )
25764                                           ! Debug: eq unsigned int = ax+1 to unsigned short count = [S+$3A-$14] (used reg = )
25765 7231           40                         inc	ax
25766 7232           8946         EE            mov	-$12[bp],ax
25767                                           !BCC_EOS
25768                                           ! 4384       atacmd[7]=*(((Bit8u *)&count)+1);
25769                                           ! Debug: eq unsigned char count = [S+$3A-$13] to unsigned char atacmd = [S+$3A-$33] (used reg = )
25770 7235           8A46         EF            mov	al,-$11[bp]
25771 7238           8846         CF            mov	-$31[bp],al
25772                                           !BCC_EOS
25773                                           ! 4385       atacmd[8]=*((Bit8u *)&count);
25774                                           ! Debug: eq unsigned char count = [S+$3A-$14] to unsigned char atacmd = [S+$3A-$32] (used reg = )
25775 723B           8A46         EE            mov	al,-$12[bp]
25776 723E           8846         D0            mov	-$30[bp],al
25777                                           !BCC_EOS
25778                                           ! 4386       lba = ilba+slba;
25779                                           ! Debug: add unsigned long slba = [S+$3A-$20] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25780 7241           8B46         E6            mov	ax,-$1A[bp]
25781 7244           8B5E         E8            mov	bx,-$18[bp]
25782 7247           8D7E         E2            lea	di,-$1E[bp]
25783 724A           E8         8E47            call	laddul
25784                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$3A-$28] (used reg = )
25785 724D           8946         DA            mov	-$26[bp],ax
25786 7250           895E         DC            mov	-$24[bp],bx
25787                                           !BCC_EOS
25788                                           ! 4387       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
25789                                           ! Debug: eq unsigned char lba = [S+$3A-$25] to unsigned char atacmd = [S+$3A-$38] (used reg = )
25790 7253           8A46         DD            mov	al,-$23[bp]
25791 7256           8846         CA            mov	-$36[bp],al
25792                                           !BCC_EOS
25793                                           ! 4388       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
25794                                           ! Debug: eq unsigned char lba = [S+$3A-$26] to unsigned char atacmd = [S+$3A-$37] (used reg = )
25795 7259           8A46         DC            mov	al,-$24[bp]
25796 725C           8846         CB            mov	-$35[bp],al
25797                                           !BCC_EOS
25798                                           ! 4389       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
25799                                           ! Debug: eq unsigned char lba = [S+$3A-$27] to unsigned char atacmd = [S+$3A-$36] (used reg = )
25800 725F           8A46         DB            mov	al,-$25[bp]
25801 7262           8846         CC            mov	-$34[bp],al
25802                                           !BCC_EOS
25803                                           ! 4390       atacmd[5]=*((Bit8u *)&lba);
25804                                           ! Debug: eq unsigned char lba = [S+$3A-$28] to unsigned char atacmd = [S+$3A-$35] (used reg = )
25805 7265           8A46         DA            mov	al,-$26[bp]
25806 7268           8846         CD            mov	-$33[bp],al
25807                                           !BCC_EOS
25808                                           ! 4391       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
25809                                           ! Debug: list unsigned short offset = [S+$3A-$2E] (used reg = )
25810 726B           FF76         D4            push	-$2C[bp]
25811                                           ! Debug: list unsigned short segment = [S+$3C-$2C] (used reg = )
25812 726E           FF76         D6            push	-$2A[bp]
25813                                           ! Debug: list int = const 1 (used reg = )
25814 7271           B8                   0001  mov	ax,*1
25815 7274           50                         push	ax
25816                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$40-$12] (used reg = )
25817 7275           8B46         F0            mov	ax,-$10[bp]
25818 7278           31DB                       xor	bx,bx
25819                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
25820 727A           53                         push	bx
25821 727B           50                         push	ax
25822 727C           B8                   0200  mov	ax,#$200
25823 727F           31DB                       xor	bx,bx
25824 7281           53                         push	bx
25825 7282           50                         push	ax
25826 7283           8B46         BE            mov	ax,-8+..FFE1[bp]
25827 7286           8B5E         C0            mov	bx,-6+..FFE1[bp]
25828 7289           8D7E         BA            lea	di,-$C+..FFE1[bp]
25829 728C           E8         8E2B            call	lmulul
25830 728F           83C4                   08  add	sp,*8
25831                                           ! Debug: list unsigned long = bx+0 (used reg = )
25832 7292           53                         push	bx
25833 7293           50                         push	ax
25834                                           ! Debug: mul int = const $200 to unsigned short before = [S+$44-$2A] (used reg = )
25835 7294           8B46         D8            mov	ax,-$28[bp]
25836 7297           B9                   0200  mov	cx,#$200
25837 729A           F7E9                       imul	cx
25838                                           ! Debug: list unsigned int = ax+0 (used reg = )
25839 729C           50                         push	ax
25840                                           ! Debug: list * unsigned char atacmd = S+$46-$3A (used reg = )
25841 729D           8D5E         C8            lea	bx,-$38[bp]
25842 72A0           53                         push	bx
25843                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25844 72A1           E8         93B6            call	_get_SS
25845                                           ! Debug: list unsigned short = ax+0 (used reg = )
25846 72A4           50                         push	ax
25847                                           ! Debug: list int = const $C (used reg = )
25848 72A5           B8                   000C  mov	ax,*$C
25849 72A8           50                         push	ax
25850                                           ! Debug: list unsigned char device = [S+$4C-3] (used reg = )
25851 72A9           8A46         FF            mov	al,-1[bp]
25852 72AC           30E4                       xor	ah,ah
25853 72AE           50                         push	ax
25854                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
25855 72AF           E8         BA94            call	_ata_cmd_packet
25856 72B2           83C4                   14  add	sp,*$14
25857                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$3A-4] (used reg = )
25858 72B5           8846         FE            mov	-2[bp],al
25859                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
25860 72B8           84C0                       test	al,al
25861 72BA           74           2A            je  	.63B
25862                       000072BC            .63C:
25863                                           ! 4392         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
25864                                           ! Debug: list unsigned char status = [S+$3A-4] (used reg = )
25865 72BC           8A46         FE            mov	al,-2[bp]
25866 72BF           30E4                       xor	ah,ah
25867 72C1           50                         push	ax
25868                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25869 72C2           8A46         17            mov	al,$17[bp]
25870 72C5           30E4                       xor	ah,ah
25871 72C7           50                         push	ax
25872                                           ! Debug: list * char = .63D+0 (used reg = )
25873 72C8           BB                   CE91  mov	bx,#.63D
25874 72CB           53                         push	bx
25875                                           ! Debug: list int = const 4 (used reg = )
25876 72CC           B8                   0004  mov	ax,*4
25877 72CF           50                         push	ax
25878                                           ! Debug: func () void = bios_printf+0 (used reg = )
25879 72D0           E8         9666            call	_bios_printf
25880 72D3           83C4                   08  add	sp,*8
25881                                           !BCC_EOS
25882                                           ! 4393         *(((Bit8u *)&AX)+1) = (0x02);
25883                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$3A+$15] (used reg = )
25884 72D6           B0                     02  mov	al,*2
25885 72D8           8846         17            mov	$17[bp],al
25886                                           !BCC_EOS
25887                                           ! 4394         *((Bit8u *)&AX) = (0);
25888                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25889 72DB           30C0                       xor	al,al
25890 72DD           8846         16            mov	$16[bp],al
25891                                           !BCC_EOS
25892                                           ! 4395         goto int13_fail_noah;
25893 72E0           83C4                   00  add	sp,#..FFDF-..FFE1
25894 72E3           E9         0139            br 	.FFDF
25895                                           !BCC_EOS
25896                                           ! 4396       }
25897                                           ! 4397       goto int13_success;
25898                       000072E6            .63B:
25899 72E6           83C4                   00  add	sp,#..FFE0-..FFE1
25900 72E9           E9         0153            br 	.FFE0
25901                                           !BCC_EOS
25902                                           ! 4398       break;
25903 72EC           E9         012B            br 	.620
25904                                           !BCC_EOS
25905                                           ! 4399     case 0x08:
25906                                           ! 4400       vspt=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25907                       000072EF            .63E:
25908                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25909 72EF           A1         026E            mov	ax,[$26E]
25910 72F2           8946         FA            mov	-6[bp],ax
25911                                           !BCC_EOS
25912                                           ! 4401       vcylinders=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) - 1;
25913                                           ! Debug: sub int = const 1 to unsigned short = [+$26C] (used reg = )
25914 72F5           A1         026C            mov	ax,[$26C]
25915                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25916 72F8           48                         dec	ax
25917 72F9           8946         F8            mov	-8[bp],ax
25918                                           !BCC_EOS
25919                                           ! 4402       vheads=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) - 1;
25920                                           ! Debug: sub int = const 1 to unsigned short = [+$26A] (used reg = )
25921 72FC           A1         026A            mov	ax,[$26A]
25922                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$3A-6] (used reg = )
25923 72FF           48                         dec	ax
25924 7300           8946         FC            mov	-4[bp],ax
25925                                           !BCC_EOS
25926                                           ! 4403       *((Bit8u *)&AX) = (0x00);
25927                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25928 7303           30C0                       xor	al,al
25929 7305           8846         16            mov	$16[bp],al
25930                                           !BCC_EOS
25931                                           ! 4404       *((Bit8u *)&BX) = (0x00);
25932                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$3A+$E] (used reg = )
25933 7308           30C0                       xor	al,al
25934 730A           8846         10            mov	$10[bp],al
25935                                           !BCC_EOS
25936                                           ! 4405       *(((Bit8u *)&CX)+1) = (vcylinders & 0xff);
25937                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25938 730D           8A46         F8            mov	al,-8[bp]
25939                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$13] (used reg = )
25940 7310           8846         15            mov	$15[bp],al
25941                                           !BCC_EOS
25942                                           ! 4406       *((Bit8u *)&CX) = (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f));
25943                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$3A-8] (used reg = )
25944 7313           8A46         FA            mov	al,-6[bp]
25945 7316           24                     3F  and	al,*$3F
25946 7318           50                         push	ax
25947                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$3C-$A] (used reg = )
25948 7319           8B46         F8            mov	ax,-8[bp]
25949 731C           D1E8                       shr	ax,*1
25950 731E           D1E8                       shr	ax,*1
25951                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
25952 7320           24                     C0  and	al,#$C0
25953                                           ! Debug: or unsigned char (temp) = [S+$3C-$3C] to unsigned char = al+0 (used reg = )
25954 7322           0A46         C6            or	al,0+..FFE1[bp]
25955 7325           44                         inc	sp
25956 7326           44                         inc	sp
25957                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$12] (used reg = )
25958 7327           8846         14            mov	$14[bp],al
25959                                           !BCC_EOS
25960                                           ! 4407       *(((Bit8u *)&DX)+1) = (vheads);
25961                                           ! Debug: eq unsigned short vheads = [S+$3A-6] to unsigned char DX = [S+$3A+$11] (used reg = )
25962 732A           8A46         FC            mov	al,-4[bp]
25963 732D           8846         13            mov	$13[bp],al
25964                                           !BCC_EOS
25965                                           ! 4408       *((Bit8u *)&DX) = (0x02);
25966                                           ! Debug: eq int = const 2 to unsigned char DX = [S+$3A+$10] (used reg = )
25967 7330           B0                     02  mov	al,*2
25968 7332           8846         12            mov	$12[bp],al
25969                                           !BCC_EOS
25970                                           ! 4409       switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
25971 7335           A0         025B            mov	al,[$25B]
25972 7338           EB           17            jmp .641
25973                                           ! 4410         case 0x01: *((Bit8u *)&BX) = (0x02); break;
25974                       0000733A            .642:
25975                                           ! Debug: eq int = const 2 to unsigned char BX = [S+$3A+$E] (used reg = )
25976 733A           B0                     02  mov	al,*2
25977 733C           8846         10            mov	$10[bp],al
25978                                           !BCC_EOS
25979 733F           EB           1C            jmp .63F
25980                                           !BCC_EOS
25981                                           ! 4411         case 0x02: *((Bit8u *)&BX) = (0x04); break;
25982                       00007341            .643:
25983                                           ! Debug: eq int = const 4 to unsigned char BX = [S+$3A+$E] (used reg = )
25984 7341           B0                     04  mov	al,*4
25985 7343           8846         10            mov	$10[bp],al
25986                                           !BCC_EOS
25987 7346           EB           15            jmp .63F
25988                                           !BCC_EOS
25989                                           ! 4412         case 0x03: *((Bit8u *)&BX) = (0x06); break;
25990                       00007348            .644:
25991                                           ! Debug: eq int = const 6 to unsigned char BX = [S+$3A+$E] (used reg = )
25992 7348           B0                     06  mov	al,*6
25993 734A           8846         10            mov	$10[bp],al
25994                                           !BCC_EOS
25995 734D           EB           0E            jmp .63F
25996                                           !BCC_EOS
25997                                           ! 4413     }
25998                                           ! 4414 #asm
25999 734F           EB           0C            jmp .63F
26000                       00007351            .641:
26001 7351           2C                     01  sub	al,*1
26002 7353           74           E5            je 	.642
26003 7355           2C                     01  sub	al,*1
26004 7357           74           E8            je 	.643
26005 7359           2C                     01  sub	al,*1
26006 735B           74           EB            je 	.644
26007                       0000735D            .63F:
26008                                           !BCC_EOS
26009                                           !BCC_ASM
26010                       00000044            _int13_cdemu.BP	set	$44
26011                       0000000C            .int13_cdemu.BP	set	$C
26012                       00000052            _int13_cdemu.CS	set	$52
26013                       0000001A            .int13_cdemu.CS	set	$1A
26014                       00000028            _int13_cdemu.nbsectors	set	$28
26015                       FFFFFFF0            .int13_cdemu.nbsectors	set	-$10
26016                       00000026            _int13_cdemu.count	set	$26
26017                       FFFFFFEE            .int13_cdemu.count	set	-$12
26018                       0000004C            _int13_cdemu.CX	set	$4C
26019                       00000014            .int13_cdemu.CX	set	$14
26020                       00000016            _int13_cdemu.elba	set	$16
26021                       FFFFFFDE            .int13_cdemu.elba	set	-$22
26022                       0000000E            _int13_cdemu.segment	set	$E
26023                       FFFFFFD6            .int13_cdemu.segment	set	-$2A
26024                       00000040            _int13_cdemu.DI	set	$40
26025                       00000008            .int13_cdemu.DI	set	8
26026                       00000054            _int13_cdemu.FLAGS	set	$54
26027                       0000001C            .int13_cdemu.FLAGS	set	$1C
26028                       00000030            _int13_cdemu.vcylinders	set	$30
26029                       FFFFFFF8            .int13_cdemu.vcylinders	set	-8
26030                       0000002C            _int13_cdemu.sector	set	$2C
26031                       FFFFFFF4            .int13_cdemu.sector	set	-$C
26032                       0000003C            _int13_cdemu.DS	set	$3C
26033                       00000004            .int13_cdemu.DS	set	4
26034                       0000002E            _int13_cdemu.head	set	$2E
26035                       FFFFFFF6            .int13_cdemu.head	set	-$A
26036                       0000002A            _int13_cdemu.cylinder	set	$2A
26037                       FFFFFFF2            .int13_cdemu.cylinder	set	-$E
26038                       0000004A            _int13_cdemu.DX	set	$4A
26039                       00000012            .int13_cdemu.DX	set	$12
26040                       00000037            _int13_cdemu.device	set	$37
26041                       FFFFFFFF            .int13_cdemu.device	set	-1
26042                       0000003E            _int13_cdemu.ES	set	$3E
26043                       00000006            .int13_cdemu.ES	set	6
26044                       00000032            _int13_cdemu.vspt	set	$32
26045                       FFFFFFFA            .int13_cdemu.vspt	set	-6
26046                       00000022            _int13_cdemu.vlba	set	$22
26047                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
26048                       00000042            _int13_cdemu.SI	set	$42
26049                       0000000A            .int13_cdemu.SI	set	$A
26050                       00000050            _int13_cdemu.IP	set	$50
26051                       00000018            .int13_cdemu.IP	set	$18
26052                       00000012            _int13_cdemu.lba	set	$12
26053                       FFFFFFDA            .int13_cdemu.lba	set	-$26
26054                       00000036            _int13_cdemu.status	set	$36
26055                       FFFFFFFE            .int13_cdemu.status	set	-2
26056                       00000000            _int13_cdemu.atacmd	set	0
26057                       FFFFFFC8            .int13_cdemu.atacmd	set	-$38
26058                       0000004E            _int13_cdemu.AX	set	$4E
26059                       00000016            .int13_cdemu.AX	set	$16
26060                       0000001E            _int13_cdemu.ilba	set	$1E
26061                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
26062                       00000010            _int13_cdemu.before	set	$10
26063                       FFFFFFD8            .int13_cdemu.before	set	-$28
26064                       0000000C            _int13_cdemu.offset	set	$C
26065                       FFFFFFD4            .int13_cdemu.offset	set	-$2C
26066                       0000001A            _int13_cdemu.slba	set	$1A
26067                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
26068                       00000046            _int13_cdemu.SP	set	$46
26069                       0000000E            .int13_cdemu.SP	set	$E
26070                       00000034            _int13_cdemu.vheads	set	$34
26071                       FFFFFFFC            .int13_cdemu.vheads	set	-4
26072                       00000048            _int13_cdemu.BX	set	$48
26073                       00000010            .int13_cdemu.BX	set	$10
26074 735D           55                               push bp
26075 735E           89E5                             mov bp, sp
26076 7360           B8                   EFDE        mov ax, #diskette_param_table2
26077 7363           8946         42                  mov _int13_cdemu.DI+2[bp], ax
26078 7366           8C4E         40                  mov _int13_cdemu.ES+2[bp], cs
26079 7369           5D                               pop bp
26080                                           ! 4421 endasm
26081                                           !BCC_ENDASM
26082                                           !BCC_EOS
26083                                           ! 4422       goto int13_success;
26084 736A           83C4                   00  add	sp,#..FFE0-..FFE1
26085 736D           E9         00CF            br 	.FFE0
26086                                           !BCC_EOS
26087                                           ! 4423       break;
26088 7370           E9         00A7            br 	.620
26089                                           !BCC_EOS
26090                                           ! 4424     case 0x15:
26091                                           ! 4425       *(((Bit8u *)&AX)+1) = (0x03);
26092                       00007373            .645:
26093                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
26094 7373           B0                     03  mov	al,*3
26095 7375           8846         17            mov	$17[bp],al
26096                                           !BCC_EOS
26097                                           ! 4426       goto int13_success_noah;
26098 7378           83C4                   00  add	sp,#..FFDD-..FFE1
26099 737B           E9         00C6            br 	.FFDD
26100                                           !BCC_EOS
26101                                           ! 4427       break;
26102 737E           E9         0099            br 	.620
26103                                           !BCC_EOS
26104                                           ! 4428     case 0x0a:
26105                                           ! 4429     case 0x0b:
26106                       00007381            .646:
26107                                           ! 4430     case 0x18:
26108                       00007381            .647:
26109                                           ! 4431     
26110                                           ! 4431 case 0x41:
26111                       00007381            .648:
26112                                           ! 4432     case 0x42:
26113                       00007381            .649:
26114                                           ! 4433     case 0x43:
26115                       00007381            .64A:
26116                                           ! 4434     case 0x44:
26117                       00007381            .64B:
26118                                           ! 4435     case 0x45:
26119                       00007381            .64C:
26120                                           ! 4436     case 0x46:
26121                       00007381            .64D:
26122                                           ! 4437     case 0x47:
26123                       00007381            .64E:
26124                                           ! 4438     case 0x48:
26125                       00007381            .64F:
26126                                           ! 4439     case 0x49:
26127                       00007381            .650:
26128                                           ! 4440     case 0x4e:
26129                       00007381            .651:
26130                                           ! 4441     case 0x50:
26131                       00007381            .652:
26132                                           ! 4442     default:
26133                       00007381            .653:
26134                                           ! 4443       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
26135                       00007381            .654:
26136                                           ! Debug: list unsigned char AX = [S+$3A+$15] (used reg = )
26137 7381           8A46         17            mov	al,$17[bp]
26138 7384           30E4                       xor	ah,ah
26139 7386           50                         push	ax
26140                                           ! Debug: list * char = .655+0 (used reg = )
26141 7387           BB                   CE59  mov	bx,#.655
26142 738A           53                         push	bx
26143                                           ! Debug: list int = const 4 (used reg = )
26144 738B           B8                   0004  mov	ax,*4
26145 738E           50                         push	ax
26146                                           ! Debug: func () void = bios_printf+0 (used reg = )
26147 738F           E8         95A7            call	_bios_printf
26148 7392           83C4                   06  add	sp,*6
26149                                           !BCC_EOS
26150                                           ! 4444       goto int13_fail;
26151 7395           83C4                   00  add	sp,#..FFE2-..FFE1
26152 7398           E9         007F            jmp .FFE2
26153                                           !BCC_EOS
26154                                           ! 4445       break;
26155 739B           EB           7D            jmp .620
26156                                           !BCC_EOS
26157                                           ! 4446   }
26158                                           ! 4447 int13_fail:
26159 739D           EB           7B            jmp .620
26160                       0000739F            .622:
26161 739F           2C                     00  sub	al,*0
26162 73A1           72           DE            jb 	.654
26163 73A3           3C                     18  cmp	al,*$18
26164 73A5           77           3D            ja  	.656
26165 73A7           30E4                       xor	ah,ah
26166 73A9           D1E0                       shl	ax,*1
26167 73AB           89C3                       mov	bx,ax
26168 73AD           2E                         seg	cs
26169 73AE           FFA7       73B2            br	.657[bx]
26170                       000073B2            .657:
26171 73B2                      7056            .word	.623
26172 73B4                      706D            .word	.62D
26173 73B6                      70AD            .word	.631
26174 73B8                      705F            .word	.62B
26175 73BA                      70AD            .word	.632
26176 73BC                      705F            .word	.62C
26177 73BE                      7381            .word	.654
26178 73C0                      7381            .word	.654
26179 73C2                      72EF            .word	.63E
26180 73C4                      7056            .word	.624
26181 73C6                      7381            .word	.646
26182 73C8                      7381            .word	.647
26183 73CA                      7056            .word	.625
26184 73CC                      7056            .word	.626
26185 73CE                      7381            .word	.654
26186 73D0                      7381            .word	.654
26187 73D2                      7056            .word	.627
26188 73D4                      7056            .word	.628
26189 73D6                      7381            .word	.654
26190 73D8                      7381            .word	.654
26191 73DA                      7056            .word	.629
26192 73DC                      7373            .word	.645
26193 73DE                      7056            .word	.62A
26194 73E0                      7381            .word	.654
26195 73E2                      7381            .word	.648
26196                       000073E4            .656:
26197 73E4           2C                     41  sub	al,*$41
26198 73E6           72           99            jb 	.654
26199 73E8           3C                     0F  cmp	al,*$F
26200 73EA           77           2B            ja  	.658
26201 73EC           30E4                       xor	ah,ah
26202 73EE           D1E0                       shl	ax,*1
26203 73F0           89C3                       mov	bx,ax
26204 73F2           2E                         seg	cs
26205 73F3           FFA7       73F7            br	.659[bx]
26206                       000073F7            .659:
26207 73F7                      7381            .word	.649
26208 73F9                      7381            .word	.64A
26209 73FB                      7381            .word	.64B
26210 73FD                      7381            .word	.64C
26211 73FF                      7381            .word	.64D
26212 7401                      7381            .word	.64E
26213 7403                      7381            .word	.64F
26214 7405                      7381            .word	.650
26215 7407                      7381            .word	.651
26216 7409                      7381            .word	.654
26217 740B                      7381            .word	.654
26218 740D                      7381            .word	.654
26219 740F                      7381            .word	.654
26220 7411                      7381            .word	.652
26221 7413                      7381            .word	.654
26222 7415                      7381            .word	.653
26223                       00007417            .658:
26224 7417           E9         FF67            br 	.654
26225                       0000741A            .620:
26226                       FFFFFFC6            ..FFE1	=	-$3A
26227                       0000741A            .FFE2:
26228                       FFFFFFC6            ..FFE2	=	-$3A
26229                                           ! 4448   *(((Bit8u *)&AX)+1) = (0x01);
26230                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$3A+$15] (used reg = )
26231 741A           B0                     01  mov	al,*1
26232 741C           8846         17            mov	$17[bp],al
26233                                           !BCC_EOS
26234                                           ! 4449 int13_fail_noah:
26235                       0000741F            .FFDF:
26236                       FFFFFFC6            ..FFDF	=	-$3A
26237                                           ! 4450   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
26238                                           ! Debug: list int = const $40 (used reg = )
26239 741F           B8                   0040  mov	ax,*$40
26240 7422           50                         push	ax
26241                                           ! Debug: list int = const $74 (used reg = )
26242 7423           B8                   0074  mov	ax,*$74
26243 7426           50                         push	ax
26244                                           ! Debug: list unsigned char AX = [S+$3E+$15] (used reg = )
26245 7427           8A46         17            mov	al,$17[bp]
26246 742A           30E4                       xor	ah,ah
26247 742C           50                         push	ax
26248                                           ! Debug: func () void = _write_byte+0 (used reg = )
26249 742D           E8         91CB            call	__write_byte
26250 7430           83C4                   06  add	sp,*6
26251                                           !BCC_EOS
26252                                           ! 4451 int13_fail_nostatus:
26253                       00007433            .FFDE:
26254                       FFFFFFC6            ..FFDE	=	-$3A
26255                                           ! 4452   FLAGS |= 0x0001;
26256                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26257 7433           8B46         1C            mov	ax,$1C[bp]
26258 7436           0C                     01  or	al,*1
26259 7438           8946         1C            mov	$1C[bp],ax
26260                                           !BCC_EOS
26261                                           ! 4453   return;
26262 743B           89EC                       mov	sp,bp
26263 743D           5D                         pop	bp
26264 743E           C3                         ret
26265                                           !BCC_EOS
26266                                           ! 4454 int13_success:
26267                       0000743F            .FFE0:
26268                       FFFFFFC6            ..FFE0	=	-$3A
26269                                           ! 4455   *(((Bit8u *)&AX)+1) = (0x00);
26270                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$15] (used reg = )
26271 743F           30C0                       xor	al,al
26272 7441           8846         17            mov	$17[bp],al
26273                                           !BCC_EOS
26274                                           ! 4456 int13_success_noah:
26275                       00007444            .FFDD:
26276                       FFFFFFC6            ..FFDD	=	-$3A
26277                                           ! 4457   _write_byte(0x00, 0x0074, 0x0040);
26278                                           ! Debug: list int = const $40 (used reg = )
26279 7444           B8                   0040  mov	ax,*$40
26280 7447           50                         push	ax
26281                                           ! Debug: list int = const $74 (used reg = )
26282 7448           B8                   0074  mov	ax,*$74
26283 744B           50                         push	ax
26284                                           ! Debug: list int = const 0 (used reg = )
26285 744C           31C0                       xor	ax,ax
26286 744E           50                         push	ax
26287                                           ! Debug: func () void = _write_byte+0 (used reg = )
26288 744F           E8         91A9            call	__write_byte
26289 7452           83C4                   06  add	sp,*6
26290                                           !BCC_EOS
26291                                           ! 4458   FLAGS &= 0xfffe;
26292                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26293 7455           8B46         1C            mov	ax,$1C[bp]
26294 7458           24                     FE  and	al,#$FE
26295 745A           8946         1C            mov	$1C[bp],ax
26296                                           !BCC_EOS
26297                                           ! 4459 }
26298 745D           89EC                       mov	sp,bp
26299 745F           5D                         pop	bp
26300 7460           C3                         ret
26301                                           ! 4460 void floppy_reset_controller()
26302                                           ! Register BX used in function int13_cdemu
26303                                           ! 4461 {
26304                                           export	_floppy_reset_controller
26305                       00007461            _floppy_reset_controller:
26306                                           ! 4462   Bit8u val8;
26307                                           !BCC_EOS
26308                                           ! 4463   val8 = inb(0x03f2);
26309 7461           55                         push	bp
26310 7462           89E5                       mov	bp,sp
26311 7464           4C                         dec	sp
26312 7465           4C                         dec	sp
26313                                           ! Debug: list int = const $3F2 (used reg = )
26314 7466           B8                   03F2  mov	ax,#$3F2
26315 7469           50                         push	ax
26316                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26317 746A           E8         90BC            call	_inb
26318 746D           44                         inc	sp
26319 746E           44                         inc	sp
26320                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26321 746F           8846         FF            mov	-1[bp],al
26322                                           !BCC_EOS
26323                                           ! 4464   outb(0x03f2, val8 & ~0x04);
26324                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
26325 7472           8A46         FF            mov	al,-1[bp]
26326 7475           24                     FB  and	al,#$FB
26327                                           ! Debug: list unsigned char = al+0 (used reg = )
26328 7477           30E4                       xor	ah,ah
26329 7479           50                         push	ax
26330                                           ! Debug: list int = const $3F2 (used reg = )
26331 747A           B8                   03F2  mov	ax,#$3F2
26332 747D           50                         push	ax
26333                                           ! Debug: func () void = outb+0 (used reg = )
26334 747E           E8         90BE            call	_outb
26335 7481           83C4                   04  add	sp,*4
26336                                           !BCC_EOS
26337                                           ! 4465   outb(0x03f2, val8 | 0x04);
26338                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
26339 7484           8A46         FF            mov	al,-1[bp]
26340 7487           0C                     04  or	al,*4
26341                                           ! Debug: list unsigned char = al+0 (used reg = )
26342 7489           30E4                       xor	ah,ah
26343 748B           50                         push	ax
26344                                           ! Debug: list int = const $3F2 (used reg = )
26345 748C           B8                   03F2  mov	ax,#$3F2
26346 748F           50                         push	ax
26347                                           ! Debug: func () void = outb+0 (used reg = )
26348 7490           E8         90AC            call	_outb
26349 7493           83C4                   04  add	sp,*4
26350                                           !BCC_EOS
26351                                           ! 4466   do {
26352                       00007496            .65C:
26353                                           ! 4467     val8 = inb(0x03f4);
26354                                           ! Debug: list int = const $3F4 (used reg = )
26355 7496           B8                   03F4  mov	ax,#$3F4
26356 7499           50                         push	ax
26357                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26358 749A           E8         908C            call	_inb
26359 749D           44                         inc	sp
26360 749E           44                         inc	sp
26361                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26362 749F           8846         FF            mov	-1[bp],al
26363                                           !BCC_EOS
26364                                           ! 4468   } while ((val8 & 0xc0) != 0x80);
26365                       000074A2            .65B:
26366                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
26367 74A2           8A46         FF            mov	al,-1[bp]
26368 74A5           24                     C0  and	al,#$C0
26369                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26370 74A7           3C                     80  cmp	al,#$80
26371 74A9           75           EB            jne	.65C
26372                       000074AB            .65D:
26373                                           !BCC_EOS
26374                                           ! 4469 }
26375                       000074AB            .65A:
26376 74AB           89EC                       mov	sp,bp
26377 74AD           5D                         pop	bp
26378 74AE           C3                         ret
26379                                           ! 4470 void floppy_prepare_controller(drive)
26380                                           ! 4471   Bit16u drive;
26381                                           export	_floppy_prepare_controller
26382                       000074AF            _floppy_prepare_controller:
26383                                           !BCC_EOS
26384                                           ! 4472 {
26385                                           ! 4473   Bit8u val8, dor, prev_reset;
26386                                           !BCC_EOS
26387                                           ! 4474   val8 = *((Bit8u *)(0x003e));
26388 74AF           55                         push	bp
26389 74B0           89E5                       mov	bp,sp
26390 74B2           83C4                   FC  add	sp,*-4
26391                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26392 74B5           A0         003E            mov	al,[$3E]
26393 74B8           8846         FF            mov	-1[bp],al
26394                                           !BCC_EOS
26395                                           ! 4475   val8 &= 0x7f;
26396                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26397 74BB           8A46         FF            mov	al,-1[bp]
26398 74BE           24                     7F  and	al,*$7F
26399 74C0           8846         FF            mov	-1[bp],al
26400                                           !BCC_EOS
26401                                           ! 4476   *((Bit8u *)(0x003e)) = (val8);
26402                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26403 74C3           8A46         FF            mov	al,-1[bp]
26404 74C6           A2         003E            mov	[$3E],al
26405                                           !BCC_EOS
26406                                           ! 4477   prev_reset = inb(0x03f2) & 0x04;
26407                                           ! Debug: list int = const $3F2 (used reg = )
26408 74C9           B8                   03F2  mov	ax,#$3F2
26409 74CC           50                         push	ax
26410                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26411 74CD           E8         9059            call	_inb
26412 74D0           44                         inc	sp
26413 74D1           44                         inc	sp
26414                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
26415 74D2           24                     04  and	al,*4
26416                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
26417 74D4           8846         FD            mov	-3[bp],al
26418                                           !BCC_EOS
26419                                           ! 4478   if (drive)
26420 74D7           8B46         04            mov	ax,4[bp]
26421 74DA           85C0                       test	ax,ax
26422 74DC           74           07            je  	.65E
26423                       000074DE            .65F:
26424                                           ! 4479     dor = 0x20;
26425                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
26426 74DE           B0                     20  mov	al,*$20
26427 74E0           8846         FE            mov	-2[bp],al
26428                                           !BCC_EOS
26429                                           ! 4480   else
26430                                           ! 4481     dor = 0x10;
26431 74E3           EB           05            jmp .660
26432                       000074E5            .65E:
26433                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
26434 74E5           B0                     10  mov	al,*$10
26435 74E7           8846         FE            mov	-2[bp],al
26436                                           !BCC_EOS
26437                                           ! 4482   dor |= 0x0c;
26438                       000074EA            .660:
26439                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
26440 74EA           8A46         FE            mov	al,-2[bp]
26441 74ED           0C                     0C  or	al,*$C
26442 74EF           8846         FE            mov	-2[bp],al
26443                                           !BCC_EOS
26444                                           ! 4483   dor |= drive;
26445                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
26446 74F2           8B46         04            mov	ax,4[bp]
26447 74F5           0A46         FE            or	al,-2[bp]
26448 74F8           8846         FE            mov	-2[bp],al
26449                                           !BCC_EOS
26450                                           ! 4484   outb(0x03f2, dor);
26451                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
26452 74FB           8A46         FE            mov	al,-2[bp]
26453 74FE           30E4                       xor	ah,ah
26454 7500           50                         push	ax
26455                                           ! Debug: list int = const $3F2 (used reg = )
26456 7501           B8                   03F2  mov	ax,#$3F2
26457 7504           50                         push	ax
26458                                           ! Debug: func () void = outb+0 (used reg = )
26459 7505           E8         9037            call	_outb
26460 7508           83C4                   04  add	sp,*4
26461                                           !BCC_EOS
26462                                           ! 4485   *((Bit8u *)(0x40)) = (37);
26463                                           ! Debug: eq int = const $25 to unsigned char = [+$40] (used reg = )
26464 750B           B0                     25  mov	al,*$25
26465 750D           A2         0040            mov	[$40],al
26466                                           !BCC_EOS
26467                                           ! 4486   do {
26468                       00007510            .663:
26469                                           ! 4487     val8 = inb(0x03f4);
26470                                           ! Debug: list int = const $3F4 (used reg = )
26471 7510           B8                   03F4  mov	ax,#$3F4
26472 7513           50                         push	ax
26473                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26474 7514           E8         9012            call	_inb
26475 7517           44                         inc	sp
26476 7518           44                         inc	sp
26477                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26478 7519           8846         FF            mov	-1[bp],al
26479                                           !BCC_EOS
26480                                           ! 4488   } while ( (val8 & 0xc0) != 0x80 );
26481                       0000751C            .662:
26482                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
26483 751C           8A46         FF            mov	al,-1[bp]
26484 751F           24                     C0  and	al,#$C0
26485                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26486 7521           3C                     80  cmp	al,#$80
26487 7523           75           EB            jne	.663
26488                       00007525            .664:
26489                                           !BCC_EOS
26490                                           ! 4489   if (prev_reset == 0) {
26491                       00007525            .661:
26492                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
26493 7525           8A46         FD            mov	al,-3[bp]
26494 7528           84C0                       test	al,al
26495 752A           75           1F            jne 	.665
26496                       0000752C            .666:
26497                                           ! 4490 #asm
26498                                           !BCC_EOS
26499                                           !BCC_ASM
26500                       00000002            _floppy_prepare_controller.dor	set	2
26501                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26502                       00000001            _floppy_prepare_controller.prev_reset	set	1
26503                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26504                       00000003            _floppy_prepare_controller.val8	set	3
26505                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26506                       00000008            _floppy_prepare_controller.drive	set	8
26507                       00000004            .floppy_prepare_controller.drive	set	4
26508 752C           FB                             sti
26509                                           ! 4492 endasm
26510                                           !BCC_ENDASM
26511                                           !BCC_EOS
26512                                           ! 4493     do {
26513                       0000752D            .669:
26514                                           ! 4494       val8 = *((Bit8u *)(0x003e));
26515                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26516 752D           A0         003E            mov	al,[$3E]
26517 7530           8846         FF            mov	-1[bp],al
26518                                           !BCC_EOS
26519                                           ! 4495     } while ( (val8 & 0x80) == 0 );
26520                       00007533            .668:
26521                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
26522 7533           8A46         FF            mov	al,-1[bp]
26523 7536           24                     80  and	al,#$80
26524                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26525 7538           84C0                       test	al,al
26526 753A           74           F1            je 	.669
26527                       0000753C            .66A:
26528                                           !BCC_EOS
26529                                           ! 4496     val8 &= 0x7f;
26530                       0000753C            .667:
26531                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26532 753C           8A46         FF            mov	al,-1[bp]
26533 753F           24                     7F  and	al,*$7F
26534 7541           8846         FF            mov	-1[bp],al
26535                                           !BCC_EOS
26536                                           ! 4497 #asm
26537                                           !BCC_EOS
26538                                           !BCC_ASM
26539                       00000002            _floppy_prepare_controller.dor	set	2
26540                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26541                       00000001            _floppy_prepare_controller.prev_reset	set	1
26542                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26543                       00000003            _floppy_prepare_controller.val8	set	3
26544                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26545                       00000008            _floppy_prepare_controller.drive	set	8
26546                       00000004            .floppy_prepare_controller.drive	set	4
26547 7544           FA                             cli
26548                                           ! 4499 endasm
26549                                           !BCC_ENDASM
26550                                           !BCC_EOS
26551                                           ! 4500     *((Bit8u *)(0x003e)) = (val8);
26552                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26553 7545           8A46         FF            mov	al,-1[bp]
26554 7548           A2         003E            mov	[$3E],al
26555                                           !BCC_EOS
26556                                           ! 4501   }
26557                                           ! 4502 }
26558                       0000754B            .665:
26559 754B           89EC                       mov	sp,bp
26560 754D           5D                         pop	bp
26561 754E           C3                         ret
26562                                           ! 4503   bx_bool
26563                                           ! 4504 floppy_media_known(drive)
26564                                           ! 4505   Bit16u drive;
26565                                           export	_floppy_media_known
26566                       0000754F            _floppy_media_known:
26567                                           !BCC_EOS
26568                                           ! 4506 {
26569                                           ! 4507   Bit8u val8;
26570                                           !BCC_EOS
26571                                           ! 4508   Bit16u media_state_offset;
26572                                           !BCC_EOS
26573                                           ! 4509   val8 = *((Bit8u *)(0x003e));
26574 754F           55                         push	bp
26575 7550           89E5                       mov	bp,sp
26576 7552           83C4                   FC  add	sp,*-4
26577                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26578 7555           A0         003E            mov	al,[$3E]
26579 7558           8846         FF            mov	-1[bp],al
26580                                           !BCC_EOS
26581                                           ! 4510   if (drive)
26582 755B           8B46         04            mov	ax,4[bp]
26583 755E           85C0                       test	ax,ax
26584 7560           74           0A            je  	.66B
26585                       00007562            .66C:
26586                                           ! 4511     val8 >>= 1;
26587                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26588 7562           8A46         FF            mov	al,-1[bp]
26589 7565           30E4                       xor	ah,ah
26590 7567           D1E8                       shr	ax,*1
26591 7569           8846         FF            mov	-1[bp],al
26592                                           !BCC_EOS
26593                                           ! 4512   val8 &= 0x01;
26594                       0000756C            .66B:
26595                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26596 756C           8A46         FF            mov	al,-1[bp]
26597 756F           24                     01  and	al,*1
26598 7571           8846         FF            mov	-1[bp],al
26599                                           !BCC_EOS
26600                                           ! 4513   if (val8 == 0)
26601                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26602 7574           8A46         FF            mov	al,-1[bp]
26603 7577           84C0                       test	al,al
26604 7579           75           06            jne 	.66D
26605                       0000757B            .66E:
26606                                           ! 4514     return(0);
26607 757B           31C0                       xor	ax,ax
26608 757D           89EC                       mov	sp,bp
26609 757F           5D                         pop	bp
26610 7580           C3                         ret
26611                                           !BCC_EOS
26612                                           ! 4515   media_state_offset = 0x0090;
26613                       00007581            .66D:
26614                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
26615 7581           B8                   0090  mov	ax,#$90
26616 7584           8946         FC            mov	-4[bp],ax
26617                                           !BCC_EOS
26618                                           ! 4516   if (drive)
26619 7587           8B46         04            mov	ax,4[bp]
26620 758A           85C0                       test	ax,ax
26621 758C           74           07            je  	.66F
26622                       0000758E            .670:
26623                                           ! 4517     media_state_offset += 1;
26624                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
26625 758E           8B46         FC            mov	ax,-4[bp]
26626 7591           40                         inc	ax
26627 7592           8946         FC            mov	-4[bp],ax
26628                                           !BCC_EOS
26629                                           ! 4518   val8 = *((Bit8u *)(media_state_offset));
26630                       00007595            .66F:
26631 7595           8B5E         FC            mov	bx,-4[bp]
26632                                           ! Debug: eq unsigned char = [bx+0] to unsigned char val8 = [S+6-3] (used reg = )
26633 7598           8A07                       mov	al,[bx]
26634 759A           8846         FF            mov	-1[bp],al
26635                                           !BCC_EOS
26636                                           ! 4519   val8 = (val8 >> 4) & 0x01;
26637                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
26638 759D           8A46         FF            mov	al,-1[bp]
26639 75A0           30E4                       xor	ah,ah
26640 75A2           B1                     04  mov	cl,*4
26641 75A4           D3E8                       shr	ax,cl
26642                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
26643 75A6           24                     01  and	al,*1
26644                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26645 75A8           8846         FF            mov	-1[bp],al
26646                                           !BCC_EOS
26647                                           ! 4520   if (val8 == 0)
26648                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26649 75AB           8A46         FF            mov	al,-1[bp]
26650 75AE           84C0                       test	al,al
26651 75B0           75           06            jne 	.671
26652                       000075B2            .672:
26653                                           ! 4521     return(0);
26654 75B2           31C0                       xor	ax,ax
26655 75B4           89EC                       mov	sp,bp
26656 75B6           5D                         pop	bp
26657 75B7           C3                         ret
26658                                           !BCC_EOS
26659                                           ! 4522   return(1);
26660                       000075B8            .671:
26661 75B8           B8                   0001  mov	ax,*1
26662 75BB           89EC                       mov	sp,bp
26663 75BD           5D                         pop	bp
26664 75BE           C3                         ret
26665                                           !BCC_EOS
26666                                           ! 4523 }
26667                                           ! 4524   bx_bool
26668                                           ! Register BX used in function floppy_media_known
26669                                           ! 4525 floppy_media_sense(drive)
26670                                           ! 4526   Bit16u drive;
26671                                           export	_floppy_media_sense
26672                       000075BF            _floppy_media_sense:
26673                                           !BCC_EOS
26674                                           ! 4527 {
26675                                           ! 4528   bx_bool retval;
26676                                           !BCC_EOS
26677                                           ! 4529   Bit16u media_state_offset;
26678                                           !BCC_EOS
26679                                           ! 4530   Bit8u drive_type, config_data, media_state;
26680                                           !BCC_EOS
26681                                           ! 4531   if (floppy_drive_recal(drive) == 0) {
26682 75BF           55                         push	bp
26683 75C0           89E5                       mov	bp,sp
26684 75C2           83C4                   F8  add	sp,*-8
26685                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
26686 75C5           FF76         04            push	4[bp]
26687                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
26688 75C8           E8         00E4            call	_floppy_drive_recal
26689 75CB           44                         inc	sp
26690 75CC           44                         inc	sp
26691                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
26692 75CD           85C0                       test	ax,ax
26693 75CF           75           06            jne 	.673
26694                       000075D1            .674:
26695                                           ! 4532     return(0);
26696 75D1           31C0                       xor	ax,ax
26697 75D3           89EC                       mov	sp,bp
26698 75D5           5D                         pop	bp
26699 75D6           C3                         ret
26700                                           !BCC_EOS
26701                                           ! 4533   }
26702                                           ! 4534   drive_type = inb_cmos(0x10);
26703                       000075D7            .673:
26704                                           ! Debug: list int = const $10 (used reg = )
26705 75D7           B8                   0010  mov	ax,*$10
26706 75DA           50                         push	ax
26707                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
26708 75DB           E8         8F90            call	_inb_cmos
26709 75DE           44                         inc	sp
26710 75DF           44                         inc	sp
26711                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
26712 75E0           8846         FB            mov	-5[bp],al
26713                                           !BCC_EOS
26714                                           ! 4535   if
26715                                           ! 4535  (drive == 0)
26716                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26717 75E3           8B46         04            mov	ax,4[bp]
26718 75E6           85C0                       test	ax,ax
26719 75E8           75           0E            jne 	.675
26720                       000075EA            .676:
26721                                           ! 4536     drive_type >>= 4;
26722                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
26723 75EA           8A46         FB            mov	al,-5[bp]
26724 75ED           30E4                       xor	ah,ah
26725 75EF           B1                     04  mov	cl,*4
26726 75F1           D3E8                       shr	ax,cl
26727 75F3           8846         FB            mov	-5[bp],al
26728                                           !BCC_EOS
26729                                           ! 4537   else
26730                                           ! 4538     drive_type &= 0x0f;
26731 75F6           EB           08            jmp .677
26732                       000075F8            .675:
26733                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
26734 75F8           8A46         FB            mov	al,-5[bp]
26735 75FB           24                     0F  and	al,*$F
26736 75FD           8846         FB            mov	-5[bp],al
26737                                           !BCC_EOS
26738                                           ! 4539   switch(drive_type) {
26739                       00007600            .677:
26740 7600           8A46         FB            mov	al,-5[bp]
26741 7603           EB           5B            jmp .67A
26742                                           ! 4540     case 1:
26743                                           ! 4541     case 2:
26744                       00007605            .67B:
26745                                           ! 4542       config_data = 0x00;
26746                       00007605            .67C:
26747                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26748 7605           30C0                       xor	al,al
26749 7607           8846         FA            mov	-6[bp],al
26750                                           !BCC_EOS
26751                                           ! 4543       media_state = 0x25;
26752                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
26753 760A           B0                     25  mov	al,*$25
26754 760C           8846         F9            mov	-7[bp],al
26755                                           !BCC_EOS
26756                                           ! 4544       retval = 1;
26757                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26758 760F           B8                   0001  mov	ax,*1
26759 7612           8946         FE            mov	-2[bp],ax
26760                                           !BCC_EOS
26761                                           ! 4545       break;
26762 7615           EB           6E            jmp .678
26763                                           !BCC_EOS
26764                                           ! 4546     case 3:
26765                                           ! 4547     case 4:
26766                       00007617            .67D:
26767                                           ! 4548       config_data = 0x00;
26768                       00007617            .67E:
26769                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26770 7617           30C0                       xor	al,al
26771 7619           8846         FA            mov	-6[bp],al
26772                                           !BCC_EOS
26773                                           ! 4549       media_state = 0x17;
26774                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
26775 761C           B0                     17  mov	al,*$17
26776 761E           8846         F9            mov	-7[bp],al
26777                                           !BCC_EOS
26778                                           ! 4550       retval = 1;
26779                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26780 7621           B8                   0001  mov	ax,*1
26781 7624           8946         FE            mov	-2[bp],ax
26782                                           !BCC_EOS
26783                                           ! 4551       break;
26784 7627           EB           5C            jmp .678
26785                                           !BCC_EOS
26786                                           ! 4552     case 5:
26787                                           ! 4553       config_data = 0xCC;
26788                       00007629            .67F:
26789                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
26790 7629           B0                     CC  mov	al,#$CC
26791 762B           8846         FA            mov	-6[bp],al
26792                                           !BCC_EOS
26793                                           ! 4554       media_state = 0xD7;
26794                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
26795 762E           B0                     D7  mov	al,#$D7
26796 7630           8846         F9            mov	-7[bp],al
26797                                           !BCC_EOS
26798                                           ! 4555       retval = 1;
26799                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26800 7633           B8                   0001  mov	ax,*1
26801 7636           8946         FE            mov	-2[bp],ax
26802                                           !BCC_EOS
26803                                           ! 4556       break;
26804 7639           EB           4A            jmp .678
26805                                           !BCC_EOS
26806                                           ! 4557     case 6:
26807                                           ! 4558     case 7:
26808                       0000763B            .680:
26809                                           ! 4559     case 8:
26810                       0000763B            .681:
26811                                           ! 4560       config_data = 0x00;
26812                       0000763B            .682:
26813                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26814 763B           30C0                       xor	al,al
26815 763D           8846         FA            mov	-6[bp],al
26816                                           !BCC_EOS
26817                                           ! 4561       media_state = 0x27;
26818                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
26819 7640           B0                     27  mov	al,*$27
26820 7642           8846         F9            mov	-7[bp],al
26821                                           !BCC_EOS
26822                                           ! 4562       retval = 1;
26823                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26824 7645           B8                   0001  mov	ax,*1
26825 7648           8946         FE            mov	-2[bp],ax
26826                                           !BCC_EOS
26827                                           ! 4563       break;
26828 764B           EB           38            jmp .678
26829                                           !BCC_EOS
26830                                           ! 4564     default:
26831                                           ! 4565       config_data = 0x00;
26832                       0000764D            .683:
26833                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26834 764D           30C0                       xor	al,al
26835 764F           8846         FA            mov	-6[bp],al
26836                                           !BCC_EOS
26837                                           ! 4566       media_state = 0x00;
26838                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
26839 7652           30C0                       xor	al,al
26840 7654           8846         F9            mov	-7[bp],al
26841                                           !BCC_EOS
26842                                           ! 4567       retval = 0;
26843                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
26844 7657           31C0                       xor	ax,ax
26845 7659           8946         FE            mov	-2[bp],ax
26846                                           !BCC_EOS
26847                                           ! 4568       break;
26848 765C           EB           27            jmp .678
26849                                           !BCC_EOS
26850                                           ! 4569   }
26851                                           ! 4570   if (drive == 0)
26852 765E           EB           25            jmp .678
26853                       00007660            .67A:
26854 7660           2C                     01  sub	al,*1
26855 7662           72           E9            jb 	.683
26856 7664           3C                     07  cmp	al,*7
26857 7666           77           1B            ja  	.684
26858 7668           30E4                       xor	ah,ah
26859 766A           D1E0                       shl	ax,*1
26860 766C           89C3                       mov	bx,ax
26861 766E           2E                         seg	cs
26862 766F           FFA7       7673            br	.685[bx]
26863                       00007673            .685:
26864 7673                      7605            .word	.67B
26865 7675                      7605            .word	.67C
26866 7677                      7617            .word	.67D
26867 7679                      7617            .word	.67E
26868 767B                      7629            .word	.67F
26869 767D                      763B            .word	.680
26870 767F                      763B            .word	.681
26871 7681                      763B            .word	.682
26872                       00007683            .684:
26873 7683           EB           C8            jmp	.683
26874                       00007685            .678:
26875                       FFFFFFF6            ..FFDC	=	-$A
26876                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26877 7685           8B46         04            mov	ax,4[bp]
26878 7688           85C0                       test	ax,ax
26879 768A           75           08            jne 	.686
26880                       0000768C            .687:
26881                                           ! 4571     media_state_offset = 0x90;
26882                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26883 768C           B8                   0090  mov	ax,#$90
26884 768F           8946         FC            mov	-4[bp],ax
26885                                           !BCC_EOS
26886                                           ! 4572   else
26887                                           ! 4573     media_state_offset = 0x91;
26888 7692           EB           06            jmp .688
26889                       00007694            .686:
26890                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26891 7694           B8                   0091  mov	ax,#$91
26892 7697           8946         FC            mov	-4[bp],ax
26893                                           !BCC_EOS
26894                                           ! 4574   *((Bit8u *)(0x008B)) = (config_data);
26895                       0000769A            .688:
26896                                           ! Debug: eq unsigned char config_data = [S+$A-8] to unsigned char = [+$8B] (used reg = )
26897 769A           8A46         FA            mov	al,-6[bp]
26898 769D           A2         008B            mov	[$8B],al
26899                                           !BCC_EOS
26900                                           ! 4575   *((Bit8u *)(media_state_offset)) = (media_state);
26901 76A0           8B5E         FC            mov	bx,-4[bp]
26902                                           ! Debug: eq unsigned char media_state = [S+$A-9] to unsigned char = [bx+0] (used reg = )
26903 76A3           8A46         F9            mov	al,-7[bp]
26904 76A6           8807                       mov	[bx],al
26905                                           !BCC_EOS
26906                                           ! 4576   return(retval);
26907 76A8           8B46         FE            mov	ax,-2[bp]
26908 76AB           89EC                       mov	sp,bp
26909 76AD           5D                         pop	bp
26910 76AE           C3                         ret
26911                                           !BCC_EOS
26912                                           ! 4577 }
26913                                           ! 4578   bx_bool
26914                                           ! Register BX used in function floppy_media_sense
26915                                           ! 4579 floppy_drive_recal(drive)
26916                                           ! 4580   Bit16u drive;
26917                                           export	_floppy_drive_recal
26918                       000076AF            _floppy_drive_recal:
26919                                           !BCC_EOS
26920                                           ! 4581 {
26921                                           ! 4582   Bit8u val8;
26922                                           !BCC_EOS
26923                                           ! 4583   Bit16u curr_cyl_offset;
26924                                           !BCC_EOS
26925                                           ! 4584   floppy_prepare_controller(drive);
26926 76AF           55                         push	bp
26927 76B0           89E5                       mov	bp,sp
26928 76B2           83C4                   FC  add	sp,*-4
26929                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
26930 76B5           FF76         04            push	4[bp]
26931                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
26932 76B8           E8         FDF4            call	_floppy_prepare_controller
26933 76BB           44                         inc	sp
26934 76BC           44                         inc	sp
26935                                           !BCC_EOS
26936                                           ! 4585   outb(0x03f5, 0x07);
26937                                           ! Debug: list int = const 7 (used reg = )
26938 76BD           B8                   0007  mov	ax,*7
26939 76C0           50                         push	ax
26940                                           ! Debug: list int = const $3F5 (used reg = )
26941 76C1           B8                   03F5  mov	ax,#$3F5
26942 76C4           50                         push	ax
26943                                           ! Debug: func () void = outb+0 (used reg = )
26944 76C5           E8         8E77            call	_outb
26945 76C8           83C4                   04  add	sp,*4
26946                                           !BCC_EOS
26947                                           ! 4586   outb(0x03f5, drive);
26948                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
26949 76CB           FF76         04            push	4[bp]
26950                                           ! Debug: list int = const $3F5 (used reg = )
26951 76CE           B8                   03F5  mov	ax,#$3F5
26952 76D1           50                         push	ax
26953                                           ! Debug: func () void = outb+0 (used reg = )
26954 76D2           E8         8E6A            call	_outb
26955 76D5           83C4                   04  add	sp,*4
26956                                           !BCC_EOS
26957                                           ! 4587 #asm
26958                                           !BCC_EOS
26959                                           !BCC_ASM
26960                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
26961                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
26962                       00000003            _floppy_drive_recal.val8	set	3
26963                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
26964                       00000008            _floppy_drive_recal.drive	set	8
26965                       00000004            .floppy_drive_recal.drive	set	4
26966 76D8           FB                           sti
26967                                           ! 4589 endasm
26968                                           !BCC_ENDASM
26969                                           !BCC_EOS
26970                                           ! 4590   do {
26971                       000076D9            .68B:
26972                                           ! 4591     val8 = (*((Bit8u *)(0x003e)) & 0x80);
26973                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
26974 76D9           A0         003E            mov	al,[$3E]
26975 76DC           24                     80  and	al,#$80
26976                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26977 76DE           8846         FF            mov	-1[bp],al
26978                                           !BCC_EOS
26979                                           ! 4592   } while ( val8 == 0 );
26980                       000076E1            .68A:
26981                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26982 76E1           8A46         FF            mov	al,-1[bp]
26983 76E4           84C0                       test	al,al
26984 76E6           74           F1            je 	.68B
26985                       000076E8            .68C:
26986                                           !BCC_EOS
26987                                           ! 4593   val8 = 0;
26988                       000076E8            .689:
26989                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26990 76E8           30C0                       xor	al,al
26991 76EA           8846         FF            mov	-1[bp],al
26992                                           !BCC_EOS
26993                                           ! 4594 #asm
26994                                           !BCC_EOS
26995                                           !BCC_ASM
26996                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
26997                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
26998                       00000003            _floppy_drive_recal.val8	set	3
26999                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27000                       00000008            _floppy_drive_recal.drive	set	8
27001                       00000004            .floppy_drive_recal.drive	set	4
27002 76ED           FA                           cli
27003                                           ! 4596 endasm
27004                                           !BCC_ENDASM
27005                                           !BCC_EOS
27006                                           ! 4597   val8 = *((Bit8u *)(0x003e));
27007                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
27008 76EE           A0         003E            mov	al,[$3E]
27009 76F1           8846         FF            mov	-1[bp],al
27010                                           !BCC_EOS
27011                                           ! 4598   val8 &= 0x7f;
27012                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
27013 76F4           8A46         FF            mov	al,-1[bp]
27014 76F7           24                     7F  and	al,*$7F
27015 76F9           8846         FF            mov	-1[bp],al
27016                                           !BCC_EOS
27017                                           ! 4599   if (drive) {
27018 76FC           8B46         04            mov	ax,4[bp]
27019 76FF           85C0                       test	ax,ax
27020 7701           74           10            je  	.68D
27021                       00007703            .68E:
27022                                           ! 4600     val8 |= 0x02;
27023                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
27024 7703           8A46         FF            mov	al,-1[bp]
27025 7706           0C                     02  or	al,*2
27026 7708           8846         FF            mov	-1[bp],al
27027                                           !BCC_EOS
27028                                           ! 4601     curr_cyl_offset = 0x0095;
27029                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27030 770B           B8                   0095  mov	ax,#$95
27031 770E           8946         FC            mov	-4[bp],ax
27032                                           !BCC_EOS
27033                                           ! 4602   } else {
27034 7711           EB           0E            jmp .68F
27035                       00007713            .68D:
27036                                           ! 4603     val8 |= 0x01;
27037                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27038 7713           8A46         FF            mov	al,-1[bp]
27039 7716           0C                     01  or	al,*1
27040 7718           8846         FF            mov	-1[bp],al
27041                                           !BCC_EOS
27042                                           ! 4604     curr_cyl_offset = 0x0094;
27043                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27044 771B           B8                   0094  mov	ax,#$94
27045 771E           8946         FC            mov	-4[bp],ax
27046                                           !BCC_EOS
27047                                           ! 4605   }
27048                                           ! 4606   *((Bit8u *)(0x003e)) = (val8);
27049                       00007721            .68F:
27050                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
27051 7721           8A46         FF            mov	al,-1[bp]
27052 7724           A2         003E            mov	[$3E],al
27053                                           !BCC_EOS
27054                                           ! 4607   *((Bit8u *)(curr_cyl_offset)) = (0);
27055 7727           8B5E         FC            mov	bx,-4[bp]
27056                                           ! Debug: eq int = const 0 to unsigned char = [bx+0] (used reg = )
27057 772A           30C0                       xor	al,al
27058 772C           8807                       mov	[bx],al
27059                                           !BCC_EOS
27060                                           ! 4608   return(1);
27061 772E           B8                   0001  mov	ax,*1
27062 7731           89EC                       mov	sp,bp
27063 7733           5D                         pop	bp
27064 7734           C3                         ret
27065                                           !BCC_EOS
27066                                           ! 4609 }
27067                                           ! 4610   bx_bool
27068                                           ! Register BX used in function floppy_drive_recal
27069                                           ! 4611 floppy_drive_exists(drive)
27070                                           ! 4612   Bit16u drive;
27071                                           export	_floppy_drive_exists
27072                       00007735            _floppy_drive_exists:
27073                                           !BCC_EOS
27074                                           ! 4613 {
27075                                           ! 4614   Bit8u drive_type;
27076                                           !BCC_EOS
27077                                           ! 4615   drive_type = inb_cmos(0x10);
27078 7735           55                         push	bp
27079 7736           89E5                       mov	bp,sp
27080 7738           4C                         dec	sp
27081 7739           4C                         dec	sp
27082                                           ! Debug: list int = const $10 (used reg = )
27083 773A           B8                   0010  mov	ax,*$10
27084 773D           50                         push	ax
27085                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27086 773E           E8         8E2D            call	_inb_cmos
27087 7741           44                         inc	sp
27088 7742           44                         inc	sp
27089                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
27090 7743           8846         FF            mov	-1[bp],al
27091                                           !BCC_EOS
27092                                           ! 4616   if (drive == 0)
27093                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
27094 7746           8B46         04            mov	ax,4[bp]
27095 7749           85C0                       test	ax,ax
27096 774B           75           0E            jne 	.690
27097                       0000774D            .691:
27098                                           ! 4617     drive_type >>= 4;
27099                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
27100 774D           8A46         FF            mov	al,-1[bp]
27101 7750           30E4                       xor	ah,ah
27102 7752           B1                     04  mov	cl,*4
27103 7754           D3E8                       shr	ax,cl
27104 7756           8846         FF            mov	-1[bp],al
27105                                           !BCC_EOS
27106                                           ! 4618   else
27107                                           ! 4619     drive_type &= 0x0f;
27108 7759           EB           08            jmp .692
27109                       0000775B            .690:
27110                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
27111 775B           8A46         FF            mov	al,-1[bp]
27112 775E           24                     0F  and	al,*$F
27113 7760           8846         FF            mov	-1[bp],al
27114                                           !BCC_EOS
27115                                           ! 4620   if ( drive_type == 0 )
27116                       00007763            .692:
27117                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
27118 7763           8A46         FF            mov	al,-1[bp]
27119 7766           84C0                       test	al,al
27120 7768           75           08            jne 	.693
27121                       0000776A            .694:
27122                                           ! 4621     return(0);
27123 776A           31C0                       xor	ax,ax
27124 776C           89EC                       mov	sp,bp
27125 776E           5D                         pop	bp
27126 776F           C3                         ret
27127                                           !BCC_EOS
27128                                           ! 4622   else
27129                                           ! 4623     return(1);
27130 7770           EB           07            jmp .695
27131                       00007772            .693:
27132 7772           B8                   0001  mov	ax,*1
27133 7775           89EC                       mov	sp,bp
27134 7777           5D                         pop	bp
27135 7778           C3                         ret
27136                                           !BCC_EOS
27137                                           ! 4624 }
27138                       00007779            .695:
27139 7779           89EC                       mov	sp,bp
27140 777B           5D                         pop	bp
27141 777C           C3                         ret
27142                                           ! 4625   void
27143                                           ! 4626 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
27144                                           ! 4627   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
27145                                           export	_int13_diskette_function
27146                       0000777D            _int13_diskette_function:
27147                                           !BCC_EOS
27148                                           ! 4628 {
27149                                           ! 4629   Bit8u drive, num_sectors, track, sector, head, status;
27150                                           !BCC_EOS
27151                                           ! 4630   Bit16u base_address, base_count, base_es;
27152                                           !BCC_EOS
27153                                           ! 4631   Bit8u page, mode_register, val8, dor;
27154                                           !BCC_EOS
27155                                           ! 4632   Bit8u return_status[7];
27156                                           !BCC_EOS
27157                                           ! 4633   Bit8u drive_type, num_floppies, ah, spt;
27158                                           !BCC_EOS
27159                                           ! 4634   Bit16u es, last_addr, maxCyl;
27160                                           !BCC_EOS
27161                                           ! 4635   ;
27162 777D           55                         push	bp
27163 777E           89E5                       mov	bp,sp
27164 7780           83C4                   DE  add	sp,*-$22
27165                                           !BCC_EOS
27166                                           ! 4636   ah = *(((Bit8u *)&AX)+1);
27167                                           ! Debug: eq unsigned char AX = [S+$24+$15] to unsigned char ah = [S+$24-$1C] (used reg = )
27168 7783           8A46         17            mov	al,$17[bp]
27169 7786           8846         E6            mov	-$1A[bp],al
27170                                           !BCC_EOS
27171                                           ! 4637  
27172                                           ! 4637  switch ( ah ) {
27173 7789           8A46         E6            mov	al,-$1A[bp]
27174 778C           E9         0E5A            br 	.698
27175                                           ! 4638     case 0x00:
27176                                           ! 4639 ;
27177                       0000778F            .699:
27178                                           !BCC_EOS
27179                                           ! 4640       drive = ( ELDX & 0x00ff );
27180                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27181 778F           8A46         0E            mov	al,$E[bp]
27182                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27183 7792           8846         FF            mov	-1[bp],al
27184                                           !BCC_EOS
27185                                           ! 4641       if (drive > 1) {
27186                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27187 7795           8A46         FF            mov	al,-1[bp]
27188 7798           3C                     01  cmp	al,*1
27189 779A           76           1A            jbe 	.69A
27190                       0000779C            .69B:
27191                                           ! 4642         *(((Bit8u *)&AX)+1) = (1);
27192                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27193 779C           B0                     01  mov	al,*1
27194 779E           8846         17            mov	$17[bp],al
27195                                           !BCC_EOS
27196                                           ! 4643         set_diskette_ret_status(1);
27197                                           ! Debug: list int = const 1 (used reg = )
27198 77A1           B8                   0001  mov	ax,*1
27199 77A4           50                         push	ax
27200                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27201 77A5           E8         0E84            call	_set_diskette_ret_status
27202 77A8           44                         inc	sp
27203 77A9           44                         inc	sp
27204                                           !BCC_EOS
27205                                           ! 4644         FLAGS |= 0x0001;
27206                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27207 77AA           8B46         1C            mov	ax,$1C[bp]
27208 77AD           0C                     01  or	al,*1
27209 77AF           8946         1C            mov	$1C[bp],ax
27210                                           !BCC_EOS
27211                                           ! 4645         return;
27212 77B2           89EC                       mov	sp,bp
27213 77B4           5D                         pop	bp
27214 77B5           C3                         ret
27215                                           !BCC_EOS
27216                                           ! 4646       }
27217                                           ! 4647       drive_type = inb_cmos(0x10);
27218                       000077B6            .69A:
27219                                           ! Debug: list int = const $10 (used reg = )
27220 77B6           B8                   0010  mov	ax,*$10
27221 77B9           50                         push	ax
27222                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27223 77BA           E8         8DB1            call	_inb_cmos
27224 77BD           44                         inc	sp
27225 77BE           44                         inc	sp
27226                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27227 77BF           8846         E8            mov	-$18[bp],al
27228                                           !BCC_EOS
27229                                           ! 4648       if (drive == 0)
27230                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
27231 77C2           8A46         FF            mov	al,-1[bp]
27232 77C5           84C0                       test	al,al
27233 77C7           75           0E            jne 	.69C
27234                       000077C9            .69D:
27235                                           ! 4649         drive_type >>= 4;
27236                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27237 77C9           8A46         E8            mov	al,-$18[bp]
27238 77CC           30E4                       xor	ah,ah
27239 77CE           B1                     04  mov	cl,*4
27240 77D0           D3E8                       shr	ax,cl
27241 77D2           8846         E8            mov	-$18[bp],al
27242                                           !BCC_EOS
27243                                           ! 4650       else
27244                                           ! 4651         drive_type &= 0x0f;
27245 77D5           EB           08            jmp .69E
27246                       000077D7            .69C:
27247                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
27248 77D7           8A46         E8            mov	al,-$18[bp]
27249 77DA           24                     0F  and	al,*$F
27250 77DC           8846         E8            mov	-$18[bp],al
27251                                           !BCC_EOS
27252                                           ! 4652       if (drive_type == 0) {
27253                       000077DF            .69E:
27254                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27255 77DF           8A46         E8            mov	al,-$18[bp]
27256 77E2           84C0                       test	al,al
27257 77E4           75           1A            jne 	.69F
27258                       000077E6            .6A0:
27259                                           ! 4653         *(((Bit8u *)&AX)+1) = (0x80);
27260                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27261 77E6           B0                     80  mov	al,#$80
27262 77E8           8846         17            mov	$17[bp],al
27263                                           !BCC_EOS
27264                                           ! 4654         set_diskette_ret_status(0x80);
27265                                           ! Debug: list int = const $80 (used reg = )
27266 77EB           B8                   0080  mov	ax,#$80
27267 77EE           50                         push	ax
27268                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27269 77EF           E8         0E3A            call	_set_diskette_ret_status
27270 77F2           44                         inc	sp
27271 77F3           44                         inc	sp
27272                                           !BCC_EOS
27273                                           ! 4655         FLAGS |= 0x0001;
27274                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27275 77F4           8B46         1C            mov	ax,$1C[bp]
27276 77F7           0C                     01  or	al,*1
27277 77F9           8946         1C            mov	$1C[bp],ax
27278                                           !BCC_EOS
27279                                           ! 4656         return;
27280 77FC           89EC                       mov	sp,bp
27281 77FE           5D                         pop	bp
27282 77FF           C3                         ret
27283                                           !BCC_EOS
27284                                           ! 4657       }
27285                                           ! 4658       *(((Bit8u *)&AX)+1) = (0);
27286                       00007800            .69F:
27287                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
27288 7800           30C0                       xor	al,al
27289 7802           8846         17            mov	$17[bp],al
27290                                           !BCC_EOS
27291                                           ! 4659       set_diskette_ret_status(0);
27292                                           ! Debug: list int = const 0 (used reg = )
27293 7805           31C0                       xor	ax,ax
27294 7807           50                         push	ax
27295                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27296 7808           E8         0E21            call	_set_diskette_ret_status
27297 780B           44                         inc	sp
27298 780C           44                         inc	sp
27299                                           !BCC_EOS
27300                                           ! 4660       FLAGS &= 0xfffe;
27301                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27302 780D           8B46         1C            mov	ax,$1C[bp]
27303 7810           24                     FE  and	al,#$FE
27304 7812           8946         1C            mov	$1C[bp],ax
27305                                           !BCC_EOS
27306                                           ! 4661       set_diskette_current_cyl(drive, 0);
27307                                           ! Debug: list int = const 0 (used reg = )
27308 7815           31C0                       xor	ax,ax
27309 7817           50                         push	ax
27310                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
27311 7818           8A46         FF            mov	al,-1[bp]
27312 781B           30E4                       xor	ah,ah
27313 781D           50                         push	ax
27314                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
27315 781E           E8         0E23            call	_set_diskette_current_cyl
27316 7821           83C4                   04  add	sp,*4
27317                                           !BCC_EOS
27318                                           ! 4662       return;
27319 7824           89EC                       mov	sp,bp
27320 7826           5D                         pop	bp
27321 7827           C3                         ret
27322                                           !BCC_EOS
27323                                           ! 4663     case 0x01:
27324                                           ! 4664       FLAGS &= 0xfffe;
27325                       00007828            .6A1:
27326                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27327 7828           8B46         1C            mov	ax,$1C[bp]
27328 782B           24                     FE  and	al,#$FE
27329 782D           8946         1C            mov	$1C[bp],ax
27330                                           !BCC_EOS
27331                                           ! 4665       val8 = *((Bit8u *)(0x0041));
27332                                           ! Debug: eq unsigned char = [+$41] to unsigned char val8 = [S+$24-$11] (used reg = )
27333 7830           A0         0041            mov	al,[$41]
27334 7833           8846         F1            mov	-$F[bp],al
27335                                           !BCC_EOS
27336                                           ! 4666       *(((Bit8u *)&AX)+1) = (val8);
27337                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char AX = [S+$24+$15] (used reg = )
27338 7836           8A46         F1            mov	al,-$F[bp]
27339 7839           8846         17            mov	$17[bp],al
27340                                           !BCC_EOS
27341                                           ! 4667       if (val8) {
27342 783C           8A46         F1            mov	al,-$F[bp]
27343 783F           84C0                       test	al,al
27344 7841           74           08            je  	.6A2
27345                       00007843            .6A3:
27346                                           ! 4668         FLAGS |= 0x0001;
27347                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27348 7843           8B46         1C            mov	ax,$1C[bp]
27349 7846           0C                     01  or	al,*1
27350 7848           8946         1C            mov	$1C[bp],ax
27351                                           !BCC_EOS
27352                                           ! 4669       }
27353                                           ! 4670       return;
27354                       0000784B            .6A2:
27355 784B           89EC                       mov	sp,bp
27356 784D           5D                         pop	bp
27357 784E           C3                         ret
27358                                           !BCC_EOS
27359                                           ! 4671     case 0x02:
27360                                           ! 4672     case 0x03:
27361                       0000784F            .6A4:
27362                                           ! 4673     case 0x04:
27363                       0000784F            .6A5:
27364                                           ! 4674       num_sectors = ( AX & 0x00ff );
27365                       0000784F            .6A6:
27366                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
27367 784F           8A46         16            mov	al,$16[bp]
27368                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27369 7852           8846         FE            mov	-2[bp],al
27370                                           !BCC_EOS
27371                                           ! 4675       track = *(((Bit8u *)&CX)+1);
27372                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
27373 7855           8A46         15            mov	al,$15[bp]
27374 7858           8846         FD            mov	-3[bp],al
27375                                           !BCC_EOS
27376                                           ! 4676       sector = ( CX & 0x00ff );
27377                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
27378 785B           8A46         14            mov	al,$14[bp]
27379                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$24-6] (used reg = )
27380 785E           8846         FC            mov	-4[bp],al
27381                                           !BCC_EOS
27382                                           ! 4677       head = *(((Bit8u *)&DX)+1);
27383                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
27384 7861           8A46         13            mov	al,$13[bp]
27385 7864           8846         FB            mov	-5[bp],al
27386                                           !BCC_EOS
27387                                           ! 4678       drive = ( ELDX & 0x00ff );
27388                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27389 7867           8A46         0E            mov	al,$E[bp]
27390                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27391 786A           8846         FF            mov	-1[bp],al
27392                                           !BCC_EOS
27393                                           ! 4679       if ((drive > 1) || (head > 1) || (sector == 0) ||
27394                                           ! 4680           (num_sectors == 0) || (num_sectors > 72)) {
27395                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27396 786D           8A46         FF            mov	al,-1[bp]
27397 7870           3C                     01  cmp	al,*1
27398 7872           77           1C            ja  	.6A8
27399                       00007874            .6AC:
27400                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
27401 7874           8A46         FB            mov	al,-5[bp]
27402 7877           3C                     01  cmp	al,*1
27403 7879           77           15            ja  	.6A8
27404                       0000787B            .6AB:
27405                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$24-6] (used reg = )
27406 787B           8A46         FC            mov	al,-4[bp]
27407 787E           84C0                       test	al,al
27408 7880           74           0E            je  	.6A8
27409                       00007882            .6AA:
27410                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27411 7882           8A46         FE            mov	al,-2[bp]
27412 7885           84C0                       test	al,al
27413 7887           74           07            je  	.6A8
27414                       00007889            .6A9:
27415                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$24-4] (used reg = )
27416 7889           8A46         FE            mov	al,-2[bp]
27417 788C           3C                     48  cmp	al,*$48
27418 788E           76           2D            jbe 	.6A7
27419                       00007890            .6A8:
27420                                           ! 4681         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
27421                                           ! Debug: list * char = .6AD+0 (used reg = )
27422 7890           BB                   CE1E  mov	bx,#.6AD
27423 7893           53                         push	bx
27424                                           ! Debug: list int = const 4 (used reg = )
27425 7894           B8                   0004  mov	ax,*4
27426 7897           50                         push	ax
27427                                           ! Debug: func () void = bios_printf+0 (used reg = )
27428 7898           E8         909E            call	_bios_printf
27429 789B           83C4                   04  add	sp,*4
27430                                           !BCC_EOS
27431                                           ! 4682         *(((Bit8u *)&AX)+1) = (1);
27432                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27433 789E           B0                     01  mov	al,*1
27434 78A0           8846         17            mov	$17[bp],al
27435                                           !BCC_EOS
27436                                           ! 4683         set_diskette_ret_status(1);
27437                                           ! Debug: list int = const 1 (used reg = )
27438 78A3           B8                   0001  mov	ax,*1
27439 78A6           50                         push	ax
27440                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27441 78A7           E8         0D82            call	_set_diskette_ret_status
27442 78AA           44                         inc	sp
27443 78AB           44                         inc	sp
27444                                           !BCC_EOS
27445                                           ! 4684         *((Bit8u *)&AX) = (0);
27446                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27447 78AC           30C0                       xor	al,al
27448 78AE           8846         16            mov	$16[bp],al
27449                                           !BCC_EOS
27450                                           ! 4685         FLAGS |= 0x0001;
27451                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27452 78B1           8B46         1C            mov	ax,$1C[bp]
27453 78B4           0C                     01  or	al,*1
27454 78B6           8946         1C            mov	$1C[bp],ax
27455                                           !BCC_EOS
27456                                           ! 4686         return;
27457 78B9           89EC                       mov	sp,bp
27458 78BB           5D                         pop	bp
27459 78BC           C3                         ret
27460                                           !BCC_EOS
27461                                           ! 4687       }
27462                                           ! 4688       if (floppy_drive_exists(drive) == 0) {
27463                       000078BD            .6A7:
27464                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27465 78BD           8A46         FF            mov	al,-1[bp]
27466 78C0           30E4                       xor	ah,ah
27467 78C2           50                         push	ax
27468                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
27469 78C3           E8         FE6F            call	_floppy_drive_exists
27470 78C6           44                         inc	sp
27471 78C7           44                         inc	sp
27472                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27473 78C8           85C0                       test	ax,ax
27474 78CA           75           1F            jne 	.6AE
27475                       000078CC            .6AF:
27476                                           ! 4689         *(((Bit8u *)&AX)+1) = (0x80);
27477                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27478 78CC           B0                     80  mov	al,#$80
27479 78CE           8846         17            mov	$17[bp],al
27480                                           !BCC_EOS
27481                                           ! 4690         set_diskette_ret_status(0x80);
27482                                           ! Debug: list int = const $80 (used reg = )
27483 78D1           B8                   0080  mov	ax,#$80
27484 78D4           50                         push	ax
27485                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27486 78D5           E8         0D54            call	_set_diskette_ret_status
27487 78D8           44                         inc	sp
27488 78D9           44                         inc	sp
27489                                           !BCC_EOS
27490                                           ! 4691         *((Bit8u *)&AX) = (0);
27491                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27492 78DA           30C0                       xor	al,al
27493 78DC           8846         16            mov	$16[bp],al
27494                                           !BCC_EOS
27495                                           ! 4692         FLAGS |= 0x0001;
27496                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27497 78DF           8B46         1C            mov	ax,$1C[bp]
27498 78E2           0C                     01  or	al,*1
27499 78E4           8946         1C            mov	$1C[bp],ax
27500                                           !BCC_EOS
27501                                           ! 4693         return;
27502 78E7           89EC                       mov	sp,bp
27503 78E9           5D                         pop	bp
27504 78EA           C3                         ret
27505                                           !BCC_EOS
27506                                           ! 4694       }
27507                                           ! 4695       if (floppy_media_known(drive) == 0) {
27508                       000078EB            .6AE:
27509                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27510 78EB           8A46         FF            mov	al,-1[bp]
27511 78EE           30E4                       xor	ah,ah
27512 78F0           50                         push	ax
27513                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
27514 78F1           E8         FC5B            call	_floppy_media_known
27515 78F4           44                         inc	sp
27516 78F5           44                         inc	sp
27517                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27518 78F6           85C0                       test	ax,ax
27519 78F8           75           2E            jne 	.6B0
27520                       000078FA            .6B1:
27521                                           ! 4696         if (floppy_media_sense(drive) == 0) {
27522                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27523 78FA           8A46         FF            mov	al,-1[bp]
27524 78FD           30E4                       xor	ah,ah
27525 78FF           50                         push	ax
27526                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
27527 7900           E8         FCBC            call	_floppy_media_sense
27528 7903           44                         inc	sp
27529 7904           44                         inc	sp
27530                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27531 7905           85C0                       test	ax,ax
27532 7907           75           1F            jne 	.6B2
27533                       00007909            .6B3:
27534                                           ! 4697           *(((Bit8u *)&AX)+1) = (0x0C);
27535                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
27536 7909           B0                     0C  mov	al,*$C
27537 790B           8846         17            mov	$17[bp],al
27538                                           !BCC_EOS
27539                                           ! 4698           set_diskette_ret_status(0x0C);
27540                                           ! Debug: list int = const $C (used reg = )
27541 790E           B8                   000C  mov	ax,*$C
27542 7911           50                         push	ax
27543                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27544 7912           E8         0D17            call	_set_diskette_ret_status
27545 7915           44                         inc	sp
27546 7916           44                         inc	sp
27547                                           !BCC_EOS
27548                                           ! 4699           *((Bit8u *)&AX) = (0);
27549                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27550 7917           30C0                       xor	al,al
27551 7919           8846         16            mov	$16[bp],al
27552                                           !BCC_EOS
27553                                           ! 4700           FLAGS |= 0x0001;
27554                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27555 791C           8B46         1C            mov	ax,$1C[bp]
27556 791F           0C                     01  or	al,*1
27557 7921           8946         1C            mov	$1C[bp],ax
27558                                           !BCC_EOS
27559                                           ! 4701           return;
27560 7924           89EC                       mov	sp,bp
27561 7926           5D                         pop	bp
27562 7927           C3                         ret
27563                                           !BCC_EOS
27564                                           ! 4702         }
27565                                           ! 4703       }
27566                       00007928            .6B2:
27567                                           ! 4704       if(ah == 0x04) {
27568                       00007928            .6B0:
27569                                           ! Debug: logeq int = const 4 to unsigned char ah = [S+$24-$1C] (used reg = )
27570 7928           8A46         E6            mov	al,-$1A[bp]
27571 792B           3C                     04  cmp	al,*4
27572 792D           75           06            jne 	.6B4
27573                       0000792F            .6B5:
27574                                           ! 4705         goto floppy_return_success;
27575 792F           83C4                   00  add	sp,#..FFDA-..FFDB
27576 7932           E9         034C            br 	.FFDA
27577                                           !BCC_EOS
27578                                           ! 4706       }
27579                                           ! 4707       page = (ES >> 12);
27580                       00007935            .6B4:
27581                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
27582 7935           8B46         06            mov	ax,6[bp]
27583 7938           88E0                       mov	al,ah
27584 793A           30E4                       xor	ah,ah
27585 793C           B1                     04  mov	cl,*4
27586 793E           D3E8                       shr	ax,cl
27587                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
27588 7940           8846         F3            mov	-$D[bp],al
27589                                           !BCC_EOS
27590                                           ! 4708       base_es = (ES << 4);
27591                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
27592 7943           8B46         06            mov	ax,6[bp]
27593 7946           B1                     04  mov	cl,*4
27594 7948           D3E0                       shl	ax,cl
27595                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
27596 794A           8946         F4            mov	-$C[bp],ax
27597                                           !BCC_EOS
27598                                           ! 4709       base_address = base_es + BX;
27599                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
27600 794D           8B46         F4            mov	ax,-$C[bp]
27601 7950           0346         10            add	ax,$10[bp]
27602                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
27603 7953           8946         F8            mov	-8[bp],ax
27604                                           !BCC_EOS
27605                                           ! 4710       if ( base_address < base_es ) {
27606                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
27607 7956           8B46         F8            mov	ax,-8[bp]
27608 7959           3B46         F4            cmp	ax,-$C[bp]
27609 795C           73           07            jae 	.6B6
27610                       0000795E            .6B7:
27611                                           ! 4711         page++;
27612                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
27613 795E           8A46         F3            mov	al,-$D[bp]
27614 7961           40                         inc	ax
27615 7962           8846         F3            mov	-$D[bp],al
27616                                           !BCC_EOS
27617                                           ! 4712 
27618                                           ! 4712       }
27619                                           ! 4713       base_count = (num_sectors * 512) - 1;
27620                       00007965            .6B6:
27621                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$24-4] (used reg = )
27622 7965           8A46         FE            mov	al,-2[bp]
27623 7968           30E4                       xor	ah,ah
27624 796A           B9                   0200  mov	cx,#$200
27625 796D           F7E9                       imul	cx
27626                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27627                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
27628 796F           48                         dec	ax
27629 7970           8946         F6            mov	-$A[bp],ax
27630                                           !BCC_EOS
27631                                           ! 4714       last_addr = base_address + base_count;
27632                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
27633 7973           8B46         F8            mov	ax,-8[bp]
27634 7976           0346         F6            add	ax,-$A[bp]
27635                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
27636 7979           8946         E0            mov	-$20[bp],ax
27637                                           !BCC_EOS
27638                                           ! 4715       if (last_addr < base_address) {
27639                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
27640 797C           8B46         E0            mov	ax,-$20[bp]
27641 797F           3B46         F8            cmp	ax,-8[bp]
27642 7982           73           1F            jae 	.6B8
27643                       00007984            .6B9:
27644                                           ! 4716         *(((Bit8u *)&AX)+1) = (0x09);
27645                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
27646 7984           B0                     09  mov	al,*9
27647 7986           8846         17            mov	$17[bp],al
27648                                           !BCC_EOS
27649                                           ! 4717         set_diskette_ret_status(0x09);
27650                                           ! Debug: list int = const 9 (used reg = )
27651 7989           B8                   0009  mov	ax,*9
27652 798C           50                         push	ax
27653                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27654 798D           E8         0C9C            call	_set_diskette_ret_status
27655 7990           44                         inc	sp
27656 7991           44                         inc	sp
27657                                           !BCC_EOS
27658                                           ! 4718         *((Bit8u *)&AX) = (0);
27659                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27660 7992           30C0                       xor	al,al
27661 7994           8846         16            mov	$16[bp],al
27662                                           !BCC_EOS
27663                                           ! 4719         FLAGS |= 0x0001;
27664                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27665 7997           8B46         1C            mov	ax,$1C[bp]
27666 799A           0C                     01  or	al,*1
27667 799C           8946         1C            mov	$1C[bp],ax
27668                                           !BCC_EOS
27669                                           ! 4720         return;
27670 799F           89EC                       mov	sp,bp
27671 79A1           5D                         pop	bp
27672 79A2           C3                         ret
27673                                           !BCC_EOS
27674                                           ! 4721       }
27675                                           ! 4722       ;
27676                       000079A3            .6B8:
27677                                           !BCC_EOS
27678                                           ! 4723       outb(0x000a, 0x06);
27679                                           ! Debug: list int = const 6 (used reg = )
27680 79A3           B8                   0006  mov	ax,*6
27681 79A6           50                         push	ax
27682                                           ! Debug: list int = const $A (used reg = )
27683 79A7           B8                   000A  mov	ax,*$A
27684 79AA           50                         push	ax
27685                                           ! Debug: func () void = outb+0 (used reg = )
27686 79AB           E8         8B91            call	_outb
27687 79AE           83C4                   04  add	sp,*4
27688                                           !BCC_EOS
27689                                           ! 4724   ;
27690                                           !BCC_EOS
27691                                           ! 4725       outb(0x000c, 0x00);
27692                                           ! Debug: list int = const 0 (used reg = )
27693 79B1           31C0                       xor	ax,ax
27694 79B3           50                         push	ax
27695                                           ! Debug: list int = const $C (used reg = )
27696 79B4           B8                   000C  mov	ax,*$C
27697 79B7           50                         push	ax
27698                                           ! Debug: func () void = outb+0 (used reg = )
27699 79B8           E8         8B84            call	_outb
27700 79BB           83C4                   04  add	sp,*4
27701                                           !BCC_EOS
27702                                           ! 4726       outb(0x0004, base_address);
27703                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
27704 79BE           FF76         F8            push	-8[bp]
27705                                           ! Debug: list int = const 4 (used reg = )
27706 79C1           B8                   0004  mov	ax,*4
27707 79C4           50                         push	ax
27708                                           ! Debug: func () void = outb+0 (used reg = )
27709 79C5           E8         8B77            call	_outb
27710 79C8           83C4                   04  add	sp,*4
27711                                           !BCC_EOS
27712                                           ! 4727       outb(0x0004, *(((Bit8u *)&base_address)+1));
27713                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
27714 79CB           8A46         F9            mov	al,-7[bp]
27715 79CE           30E4                       xor	ah,ah
27716 79D0           50                         push	ax
27717                                           ! Debug: list int = const 4 (used reg = )
27718 79D1           B8                   0004  mov	ax,*4
27719 79D4           50                         push	ax
27720                                           ! Debug: func () void = outb+0 (used reg = )
27721 79D5           E8         8B67            call	_outb
27722 79D8           83C4                   04  add	sp,*4
27723                                           !BCC_EOS
27724                                           ! 4728   ;
27725                                           !BCC_EOS
27726                                           ! 4729       outb(0x000c, 0x00);
27727                                           ! Debug: list int = const 0 (used reg = )
27728 79DB           31C0                       xor	ax,ax
27729 79DD           50                         push	ax
27730                                           ! Debug: list int = const $C (used reg = )
27731 79DE           B8                   000C  mov	ax,*$C
27732 79E1           50                         push	ax
27733                                           ! Debug: func () void = outb+0 (used reg = )
27734 79E2           E8         8B5A            call	_outb
27735 79E5           83C4                   04  add	sp,*4
27736                                           !BCC_EOS
27737                                           ! 4730       outb(0x0005, base_count);
27738                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
27739 79E8           FF76         F6            push	-$A[bp]
27740                                           ! Debug: list int = const 5 (used reg = )
27741 79EB           B8                   0005  mov	ax,*5
27742 79EE           50                         push	ax
27743                                           ! Debug: func () void = outb+0 (used reg = )
27744 79EF           E8         8B4D            call	_outb
27745 79F2           83C4                   04  add	sp,*4
27746                                           !BCC_EOS
27747                                           ! 4731       outb(0x0005, *(((Bit8u *)&base_count)+1));
27748                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
27749 79F5           8A46         F7            mov	al,-9[bp]
27750 79F8           30E4                       xor	ah,ah
27751 79FA           50                         push	ax
27752                                           ! Debug: list int = const 5 (used reg = )
27753 79FB           B8                   0005  mov	ax,*5
27754 79FE           50                         push	ax
27755                                           ! Debug: func () void = outb+0 (used reg = )
27756 79FF           E8         8B3D            call	_outb
27757 7A02           83C4                   04  add	sp,*4
27758                                           !BCC_EOS
27759                                           ! 4732       if (ah == 0x02) {
27760                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
27761 7A05           8A46         E6            mov	al,-$1A[bp]
27762 7A08           3C                     02  cmp	al,*2
27763 7A0A           75           5C            jne 	.6BA
27764                       00007A0C            .6BB:
27765                                           ! 4733         mode_register = 0x46;
27766                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$24-$10] (used reg = )
27767 7A0C           B0                     46  mov	al,*$46
27768 7A0E           8846         F2            mov	-$E[bp],al
27769                                           !BCC_EOS
27770                                           ! 4734   ;
27771                                           !BCC_EOS
27772                                           ! 4735         outb(0x000b, mode_register);
27773                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27774 7A11           8A46         F2            mov	al,-$E[bp]
27775 7A14           30E4                       xor	ah,ah
27776 7A16           50                         push	ax
27777                                           ! Debug: list int = const $B (used reg = )
27778 7A17           B8                   000B  mov	ax,*$B
27779 7A1A           50                         push	ax
27780                                           ! Debug: func () void = outb+0 (used reg = )
27781 7A1B           E8         8B21            call	_outb
27782 7A1E           83C4                   04  add	sp,*4
27783                                           !BCC_EOS
27784                                           ! 4736   ;
27785                                           !BCC_EOS
27786                                           ! 4737         outb(0x0081, page);
27787                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27788 7A21           8A46         F3            mov	al,-$D[bp]
27789 7A24           30E4                       xor	ah,ah
27790 7A26           50                         push	ax
27791                                           ! Debug: list int = const $81 (used reg = )
27792 7A27           B8                   0081  mov	ax,#$81
27793 7A2A           50                         push	ax
27794                                           ! Debug: func () void = outb+0 (used reg = )
27795 7A2B           E8         8B11            call	_outb
27796 7A2E           83C4                   04  add	sp,*4
27797                                           !BCC_EOS
27798                                           ! 4738   ;
27799                                           !BCC_EOS
27800                                           ! 4739         outb(0x000a, 0x02);
27801                                           ! Debug: list int = const 2 (used reg = )
27802 7A31           B8                   0002  mov	ax,*2
27803 7A34           50                         push	ax
27804                                           ! Debug: list int = const $A (used reg = )
27805 7A35           B8                   000A  mov	ax,*$A
27806 7A38           50                         push	ax
27807                                           ! Debug: func () void = outb+0 (used reg = )
27808 7A39           E8         8B03            call	_outb
27809 7A3C           83C4                   04  add	sp,*4
27810                                           !BCC_EOS
27811                                           ! 4740         ;
27812                                           !BCC_EOS
27813                                           ! 4741         outb(0x000a, 0x02);
27814                                           ! Debug: list int = const 2 (used reg = )
27815 7A3F           B8                   0002  mov	ax,*2
27816 7A42           50                         push	ax
27817                                           ! Debug: list int = const $A (used reg = )
27818 7A43           B8                   000A  mov	ax,*$A
27819 7A46           50                         push	ax
27820                                           ! Debug: func () void = outb+0 (used reg = )
27821 7A47           E8         8AF5            call	_outb
27822 7A4A           83C4                   04  add	sp,*4
27823                                           !BCC_EOS
27824                                           ! 4742         floppy_prepare_controller(drive);
27825                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27826 7A4D           8A46         FF            mov	al,-1[bp]
27827 7A50           30E4                       xor	ah,ah
27828 7A52           50                         push	ax
27829                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27830 7A53           E8         FA59            call	_floppy_prepare_controller
27831 7A56           44                         inc	sp
27832 7A57           44                         inc	sp
27833                                           !BCC_EOS
27834                                           ! 4743         outb(0x03f5, 0xe6);
27835                                           ! Debug: list int = const $E6 (used reg = )
27836 7A58           B8                   00E6  mov	ax,#$E6
27837 7A5B           50                         push	ax
27838                                           ! Debug: list int = const $3F5 (used reg = )
27839 7A5C           B8                   03F5  mov	ax,#$3F5
27840 7A5F           50                         push	ax
27841                                           ! Debug: func () void = outb+0 (used reg = )
27842 7A60           E8         8ADC            call	_outb
27843 7A63           83C4                   04  add	sp,*4
27844                                           !BCC_EOS
27845                                           ! 4744       } else {
27846 7A66           EB           4C            jmp .6BC
27847                       00007A68            .6BA:
27848                                           ! 4745         mode_register = 0x4a;
27849                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
27850 7A68           B0                     4A  mov	al,*$4A
27851 7A6A           8846         F2            mov	-$E[bp],al
27852                                           !BCC_EOS
27853                                           ! 4746         outb(0x000b, mode_register);
27854                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27855 7A6D           8A46         F2            mov	al,-$E[bp]
27856 7A70           30E4                       xor	ah,ah
27857 7A72           50                         push	ax
27858                                           ! Debug: list int = const $B (used reg = )
27859 7A73           B8                   000B  mov	ax,*$B
27860 7A76           50                         push	ax
27861                                           ! Debug: func () void = outb+0 (used reg = )
27862 7A77           E8         8AC5            call	_outb
27863 7A7A           83C4                   04  add	sp,*4
27864                                           !BCC_EOS
27865                                           ! 4747         outb(0x0081, page);
27866                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27867 7A7D           8A46         F3            mov	al,-$D[bp]
27868 7A80           30E4                       xor	ah,ah
27869 7A82           50                         push	ax
27870                                           ! Debug: list int = const $81 (used reg = )
27871 7A83           B8                   0081  mov	ax,#$81
27872 7A86           50                         push	ax
27873                                           ! Debug: func () void = outb+0 (used reg = )
27874 7A87           E8         8AB5            call	_outb
27875 7A8A           83C4                   04  add	sp,*4
27876                                           !BCC_EOS
27877                                           ! 4748         ;
27878                                           !BCC_EOS
27879                                           ! 4749         outb(0x000a, 0x02);
27880                                           ! Debug: list int = const 2 (used reg = )
27881 7A8D           B8                   0002  mov	ax,*2
27882 7A90           50                         push	ax
27883                                           ! Debug: list int = const $A (used reg = )
27884 7A91           B8                   000A  mov	ax,*$A
27885 7A94           50                         push	ax
27886                                           ! Debug: func () void = outb+0 (used reg = )
27887 7A95           E8         8AA7            call	_outb
27888 7A98           83C4                   04  add	sp,*4
27889                                           !BCC_EOS
27890                                           ! 4750         floppy_prepare_controller(drive);
27891                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27892 7A9B           8A46         FF            mov	al,-1[bp]
27893 7A9E           30E4                       xor	ah,ah
27894 7AA0           50                         push	ax
27895                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27896 7AA1           E8         FA0B            call	_floppy_prepare_controller
27897 7AA4           44                         inc	sp
27898 7AA5           44                         inc	sp
27899                                           !BCC_EOS
27900                                           ! 4751         outb(0x03f5, 0xc5);
27901                                           ! Debug: list int = const $C5 (used reg = )
27902 7AA6           B8                   00C5  mov	ax,#$C5
27903 7AA9           50                         push	ax
27904                                           ! Debug: list int = const $3F5 (used reg = )
27905 7AAA           B8                   03F5  mov	ax,#$3F5
27906 7AAD           50                         push	ax
27907                                           ! Debug: func () void = outb+0 (used reg = )
27908 7AAE           E8         8A8E            call	_outb
27909 7AB1           83C4                   04  add	sp,*4
27910                                           !BCC_EOS
27911                                           ! 4752       }
27912                                           ! 4753       outb(0x03f5, (head << 2) | drive);
27913                       00007AB4            .6BC:
27914                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
27915 7AB4           8A46         FB            mov	al,-5[bp]
27916 7AB7           30E4                       xor	ah,ah
27917 7AB9           D1E0                       shl	ax,*1
27918 7ABB           D1E0                       shl	ax,*1
27919                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
27920 7ABD           0A46         FF            or	al,-1[bp]
27921                                           ! Debug: list unsigned int = ax+0 (used reg = )
27922 7AC0           50                         push	ax
27923                                           ! Debug: list int = const $3F5 (used reg = )
27924 7AC1           B8                   03F5  mov	ax,#$3F5
27925 7AC4           50                         push	ax
27926                                           ! Debug: func () void = outb+0 (used reg = )
27927 7AC5           E8         8A77            call	_outb
27928 7AC8           83C4                   04  add	sp,*4
27929                                           !BCC_EOS
27930                                           ! 4754       outb(0x03f5, track);
27931                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
27932 7ACB           8A46         FD            mov	al,-3[bp]
27933 7ACE           30E4                       xor	ah,ah
27934 7AD0           50                         push	ax
27935                                           ! Debug: list int = const $3F5 (used reg = )
27936 7AD1           B8                   03F5  mov	ax,#$3F5
27937 7AD4           50                         push	ax
27938                                           ! Debug: func () void = outb+0 (used reg = )
27939 7AD5           E8         8A67            call	_outb
27940 7AD8           83C4                   04  add	sp,*4
27941                                           !BCC_EOS
27942                                           ! 4755       outb(0x03f5, head);
27943                                           ! Debug: list unsigned char head = [S+$24-7] (used reg = )
27944 7ADB           8A46         FB            mov	al,-5[bp]
27945 7ADE           30E4                       xor	ah,ah
27946 7AE0           50                         push	ax
27947                                           ! Debug: list int = const $3F5 (used reg = )
27948 7AE1           B8                   03F5  mov	ax,#$3F5
27949 7AE4           50                         push	ax
27950                                           ! Debug: func () void = outb+0 (used reg = )
27951 7AE5           E8         8A57            call	_outb
27952 7AE8           83C4                   04  add	sp,*4
27953                                           !BCC_EOS
27954                                           ! 4756       outb(0x03f5, sector);
27955                                           ! Debug: list unsigned char sector = [S+$24-6] (used reg = )
27956 7AEB           8A46         FC            mov	al,-4[bp]
27957 7AEE           30E4                       xor	ah,ah
27958 7AF0           50                         push	ax
27959                                           ! Debug: list int = const $3F5 (used reg = )
27960 7AF1           B8                   03F5  mov	ax,#$3F5
27961 7AF4           50                         push	ax
27962                                           ! Debug: func () void = outb+0 (used reg = )
27963 7AF5           E8         8A47            call	_outb
27964 7AF8           83C4                   04  add	sp,*4
27965                                           !BCC_EOS
27966                                           ! 4757       outb(0x03f5, 2);
27967                                           ! Debug: list int = const 2 (used reg = )
27968 7AFB           B8                   0002  mov	ax,*2
27969 7AFE           50                         push	ax
27970                                           ! Debug: list int = const $3F5 (used reg = )
27971 7AFF           B8                   03F5  mov	ax,#$3F5
27972 7B02           50                         push	ax
27973                                           ! Debug: func () void = outb+0 (used reg = )
27974 7B03           E8         8A39            call	_outb
27975 7B06           83C4                   04  add	sp,*4
27976                                           !BCC_EOS
27977                                           ! 4758       outb(0x03f5, sector + num_sectors - 1);
27978                                           ! Debug: add unsigned char num_sectors = [S+$24-4] to unsigned char sector = [S+$24-6] (used reg = )
27979 7B09           8A46         FC            mov	al,-4[bp]
27980 7B0C           30E4                       xor	ah,ah
27981 7B0E           0246         FE            add	al,-2[bp]
27982 7B11           80D4                   00  adc	ah,*0
27983                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27984                                           ! Debug: list unsigned int = ax-1 (used reg = )
27985 7B14           48                         dec	ax
27986 7B15           50                         push	ax
27987                                           ! Debug: list int = const $3F5 (used reg = )
27988 7B16           B8                   03F5  mov	ax,#$3F5
27989 7B19           50                         push	ax
27990                                           ! Debug: func () void = outb+0 (used reg = )
27991 7B1A           E8         8A22            call	_outb
27992 7B1D           83C4                   04  add	sp,*4
27993                                           !BCC_EOS
27994                                           ! 4759       outb(0x03f5, 0);
27995                                           ! Debug: list int = const 0 (used reg = )
27996 7B20           31C0                       xor	ax,ax
27997 7B22           50                         push	ax
27998                                           ! Debug: list int = const $3F5 (used reg = )
27999 7B23           B8                   03F5  mov	ax,#$3F5
28000 7B26           50                         push	ax
28001                                           ! Debug: func () void = outb+0 (used reg = )
28002 7B27           E8         8A15            call	_outb
28003 7B2A           83C4                   04  add	sp,*4
28004                                           !BCC_EOS
28005                                           ! 4760       outb(0x03f5, 0xff);
28006                                           ! Debug: list int = const $FF (used reg = )
28007 7B2D           B8                   00FF  mov	ax,#$FF
28008 7B30           50                         push	ax
28009                                           ! Debug: list int = const $3F5 (used reg = )
28010 7B31           B8                   03F5  mov	ax,#$3F5
28011 7B34           50                         push	ax
28012                                           ! Debug: func () void = outb+0 (used reg = )
28013 7B35           E8         8A07            call	_outb
28014 7B38           83C4                   04  add	sp,*4
28015                                           !BCC_EOS
28016                                           ! 4761 #asm
28017                                           !BCC_EOS
28018                                           !BCC_ASM
28019                       0000002E            _int13_diskette_function.BP	set	$2E
28020                       0000000C            .int13_diskette_function.BP	set	$C
28021                       0000003C            _int13_diskette_function.CS	set	$3C
28022                       0000001A            .int13_diskette_function.CS	set	$1A
28023                       00000036            _int13_diskette_function.CX	set	$36
28024                       00000014            .int13_diskette_function.CX	set	$14
28025                       0000001A            _int13_diskette_function.base_address	set	$1A
28026                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28027                       0000002A            _int13_diskette_function.DI	set	$2A
28028                       00000008            .int13_diskette_function.DI	set	8
28029                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28030                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28031                       00000018            _int13_diskette_function.base_count	set	$18
28032                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28033                       0000001E            _int13_diskette_function.sector	set	$1E
28034                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28035                       00000026            _int13_diskette_function.DS	set	$26
28036                       00000004            .int13_diskette_function.DS	set	4
28037                       0000001D            _int13_diskette_function.head	set	$1D
28038                       FFFFFFFB            .int13_diskette_function.head	set	-5
28039                       00000030            _int13_diskette_function.ELDX	set	$30
28040                       0000000E            .int13_diskette_function.ELDX	set	$E
28041                       00000012            _int13_diskette_function.dor	set	$12
28042                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28043                       00000034            _int13_diskette_function.DX	set	$34
28044                       00000012            .int13_diskette_function.DX	set	$12
28045                       0000000B            _int13_diskette_function.return_status	set	$B
28046                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28047                       00000004            _int13_diskette_function.es	set	4
28048                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28049                       00000014            _int13_diskette_function.mode_register	set	$14
28050                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28051                       00000028            _int13_diskette_function.ES	set	$28
28052                       00000006            .int13_diskette_function.ES	set	6
28053                       00000016            _int13_diskette_function.base_es	set	$16
28054                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28055                       0000001F            _int13_diskette_function.track	set	$1F
28056                       FFFFFFFD            .int13_diskette_function.track	set	-3
28057                       0000002C            _int13_diskette_function.SI	set	$2C
28058                       0000000A            .int13_diskette_function.SI	set	$A
28059                       0000000A            _int13_diskette_function.drive_type	set	$A
28060                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28061                       00000020            _int13_diskette_function.num_sectors	set	$20
28062                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28063                       0000003A            _int13_diskette_function.IP	set	$3A
28064                       00000018            .int13_diskette_function.IP	set	$18
28065                       00000007            _int13_diskette_function.spt	set	7
28066                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28067                       0000001C            _int13_diskette_function.status	set	$1C
28068                       FFFFFFFA            .int13_diskette_function.status	set	-6
28069                       00000000            _int13_diskette_function.maxCyl	set	0
28070                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28071                       00000038            _int13_diskette_function.AX	set	$38
28072                       00000016            .int13_diskette_function.AX	set	$16
28073                       00000013            _int13_diskette_function.val8	set	$13
28074                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28075                       00000002            _int13_diskette_function.last_addr	set	2
28076                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28077                       00000015            _int13_diskette_function.page	set	$15
28078                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28079                       00000008            _int13_diskette_function.ah	set	8
28080                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28081                       00000021            _int13_diskette_function.drive	set	$21
28082                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28083                       00000009            _int13_diskette_function.num_floppies	set	9
28084                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28085                       00000032            _int13_diskette_function.BX	set	$32
28086                       00000010            .int13_diskette_function.BX	set	$10
28087 7B3B           FB                               sti
28088                                           ! 4763 endasm
28089                                           !BCC_ENDASM
28090                                           !BCC_EOS
28091                                           ! 4764       do {
28092                       00007B3C            .6BF:
28093                                           ! 4765         val8 = *((Bit8u *)(0x0040));
28094                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
28095 7B3C           A0         0040            mov	al,[$40]
28096 7B3F           8846         F1            mov	-$F[bp],al
28097                                           !BCC_EOS
28098                                           ! 4766         if (val8 == 0) {
28099                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28100 7B42           8A46         F1            mov	al,-$F[bp]
28101 7B45           84C0                       test	al,al
28102 7B47           75           22            jne 	.6C0
28103                       00007B49            .6C1:
28104                                           ! 4767           floppy_reset_controller();
28105                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
28106 7B49           E8         F915            call	_floppy_reset_controller
28107                                           !BCC_EOS
28108                                           ! 4768           *(((Bit8u *)&AX)+1) = (0x80);
28109                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28110 7B4C           B0                     80  mov	al,#$80
28111 7B4E           8846         17            mov	$17[bp],al
28112                                           !BCC_EOS
28113                                           ! 4769           set_diskette_ret_status(0x80);
28114                                           ! Debug: list int = const $80 (used reg = )
28115 7B51           B8                   0080  mov	ax,#$80
28116 7B54           50                         push	ax
28117                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28118 7B55           E8         0AD4            call	_set_diskette_ret_status
28119 7B58           44                         inc	sp
28120 7B59           44                         inc	sp
28121                                           !BCC_EOS
28122                                           ! 4770           *((Bit8u *)&AX) = (0);
28123                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28124 7B5A           30C0                       xor	al,al
28125 7B5C           8846         16            mov	$16[bp],al
28126                                           !BCC_EOS
28127                                           ! 4771           FLAGS |= 0x0001;
28128                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28129 7B5F           8B46         1C            mov	ax,$1C[bp]
28130 7B62           0C                     01  or	al,*1
28131 7B64           8946         1C            mov	$1C[bp],ax
28132                                           !BCC_EOS
28133                                           ! 4772           return;
28134 7B67           89EC                       mov	sp,bp
28135 7B69           5D                         pop	bp
28136 7B6A           C3                         ret
28137                                           !BCC_EOS
28138                                           ! 4773         }
28139                                           ! 4774         val8 = (*((Bit8u *)(0x003e)) & 0x80);
28140                       00007B6B            .6C0:
28141                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
28142 7B6B           A0         003E            mov	al,[$3E]
28143 7B6E           24                     80  and	al,#$80
28144                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28145 7B70           8846         F1            mov	-$F[bp],al
28146                                           !BCC_EOS
28147                                           ! 4775       } while ( val8 == 0 );
28148                       00007B73            .6BE:
28149                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28150 7B73           8A46         F1            mov	al,-$F[bp]
28151 7B76           84C0                       test	al,al
28152 7B78           74           C2            je 	.6BF
28153                       00007B7A            .6C2:
28154                                           !BCC_EOS
28155                                           ! 4776       val8 = 0;
28156                       00007B7A            .6BD:
28157                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28158 7B7A           30C0                       xor	al,al
28159 7B7C           8846         F1            mov	-$F[bp],al
28160                                           !BCC_EOS
28161                                           ! 4777 #asm
28162                                           !BCC_EOS
28163                                           !BCC_ASM
28164                       0000002E            _int13_diskette_function.BP	set	$2E
28165                       0000000C            .int13_diskette_function.BP	set	$C
28166                       0000003C            _int13_diskette_function.CS	set	$3C
28167                       0000001A            .int13_diskette_function.CS	set	$1A
28168                       00000036            _int13_diskette_function.CX	set	$36
28169                       00000014            .int13_diskette_function.CX	set	$14
28170                       0000001A            _int13_diskette_function.base_address	set	$1A
28171                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28172                       0000002A            _int13_diskette_function.DI	set	$2A
28173                       00000008            .int13_diskette_function.DI	set	8
28174                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28175                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28176                       00000018            _int13_diskette_function.base_count	set	$18
28177                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28178                       0000001E            _int13_diskette_function.sector	set	$1E
28179                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28180                       00000026            _int13_diskette_function.DS	set	$26
28181                       00000004            .int13_diskette_function.DS	set	4
28182                       0000001D            _int13_diskette_function.head	set	$1D
28183                       FFFFFFFB            .int13_diskette_function.head	set	-5
28184                       00000030            _int13_diskette_function.ELDX	set	$30
28185                       0000000E            .int13_diskette_function.ELDX	set	$E
28186                       00000012            _int13_diskette_function.dor	set	$12
28187                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28188                       00000034            _int13_diskette_function.DX	set	$34
28189                       00000012            .int13_diskette_function.DX	set	$12
28190                       0000000B            _int13_diskette_function.return_status	set	$B
28191                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28192                       00000004            _int13_diskette_function.es	set	4
28193                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28194                       00000014            _int13_diskette_function.mode_register	set	$14
28195                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28196                       00000028            _int13_diskette_function.ES	set	$28
28197                       00000006            .int13_diskette_function.ES	set	6
28198                       00000016            _int13_diskette_function.base_es	set	$16
28199                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28200                       0000001F            _int13_diskette_function.track	set	$1F
28201                       FFFFFFFD            .int13_diskette_function.track	set	-3
28202                       0000002C            _int13_diskette_function.SI	set	$2C
28203                       0000000A            .int13_diskette_function.SI	set	$A
28204                       0000000A            _int13_diskette_function.drive_type	set	$A
28205                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28206                       00000020            _int13_diskette_function.num_sectors	set	$20
28207                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28208                       0000003A            _int13_diskette_function.IP	set	$3A
28209                       00000018            .int13_diskette_function.IP	set	$18
28210                       00000007            _int13_diskette_function.spt	set	7
28211                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28212                       0000001C            _int13_diskette_function.status	set	$1C
28213                       FFFFFFFA            .int13_diskette_function.status	set	-6
28214                       00000000            _int13_diskette_function.maxCyl	set	0
28215                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28216                       00000038            _int13_diskette_function.AX	set	$38
28217                       00000016            .int13_diskette_function.AX	set	$16
28218                       00000013            _int13_diskette_function.val8	set	$13
28219                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28220                       00000002            _int13_diskette_function.last_addr	set	2
28221                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28222                       00000015            _int13_diskette_function.page	set	$15
28223                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28224                       00000008            _int13_diskette_function.ah	set	8
28225                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28226                       00000021            _int13_diskette_function.drive	set	$21
28227                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28228                       00000009            _int13_diskette_function.num_floppies	set	9
28229                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28230                       00000032            _int13_diskette_function.BX	set	$32
28231                       00000010            .int13_diskette_function.BX	set	$10
28232 7B7F           FA                               cli
28233                                           ! 4779 endasm
28234                                           !BCC_ENDASM
28235                                           !BCC_EOS
28236                                           ! 4780       val8 = *((Bit8u *)(0x003e));
28237                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
28238 7B80           A0         003E            mov	al,[$3E]
28239 7B83           8846         F1            mov	-$F[bp],al
28240                                           !BCC_EOS
28241                                           ! 4781       val8 &= 0x7f;
28242                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
28243 7B86           8A46         F1            mov	al,-$F[bp]
28244 7B89           24                     7F  and	al,*$7F
28245 7B8B           8846         F1            mov	-$F[bp],al
28246                                           !BCC_EOS
28247                                           ! 4782       *((Bit8u *)(0x003e)) = (val8);
28248                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
28249 7B8E           8A46         F1            mov	al,-$F[bp]
28250 7B91           A2         003E            mov	[$3E],al
28251                                           !BCC_EOS
28252                                           ! 4783       val8 = inb(0x03f4);
28253                                           ! Debug: list int = const $3F4 (used reg = )
28254 7B94           B8                   03F4  mov	ax,#$3F4
28255 7B97           50                         push	ax
28256                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28257 7B98           E8         898E            call	_inb
28258 7B9B           44                         inc	sp
28259 7B9C           44                         inc	sp
28260                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28261 7B9D           8846         F1            mov	-$F[bp],al
28262                                           !BCC_EOS
28263                                           ! 4784       if ( (val8 & 0xc0) != 0xc0 )
28264                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
28265 7BA0           8A46         F1            mov	al,-$F[bp]
28266 7BA3           24                     C0  and	al,#$C0
28267                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
28268 7BA5           3C                     C0  cmp	al,#$C0
28269 7BA7           74           0E            je  	.6C3
28270                       00007BA9            .6C4:
28271                                           ! 4785         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
28272                                           ! Debug: list * char = .6C5+0 (used reg = )
28273 7BA9           BB                   CDFE  mov	bx,#.6C5
28274 7BAC           53                         push	bx
28275                                           ! Debug: list int = const 7 (used reg = )
28276 7BAD           B8                   0007  mov	ax,*7
28277 7BB0           50                         push	ax
28278                                           ! Debug: func () void = bios_printf+0 (used reg = )
28279 7BB1           E8         8D85            call	_bios_printf
28280 7BB4           83C4                   04  add	sp,*4
28281                                           !BCC_EOS
28282                                           ! 4786       return_status[0] = inb(0x03f5);
28283                       00007BB7            .6C3:
28284                                           ! Debug: list int = const $3F5 (used reg = )
28285 7BB7           B8                   03F5  mov	ax,#$3F5
28286 7BBA           50                         push	ax
28287                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28288 7BBB           E8         896B            call	_inb
28289 7BBE           44                         inc	sp
28290 7BBF           44                         inc	sp
28291                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
28292 7BC0           8846         E9            mov	-$17[bp],al
28293                                           !BCC_EOS
28294                                           ! 4787       return_status[1] = inb(0x03f5);
28295                                           ! Debug: list int = const $3F5 (used reg = )
28296 7BC3           B8                   03F5  mov	ax,#$3F5
28297 7BC6           50                         push	ax
28298                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28299 7BC7           E8         895F            call	_inb
28300 7BCA           44                         inc	sp
28301 7BCB           44                         inc	sp
28302                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
28303 7BCC           8846         EA            mov	-$16[bp],al
28304                                           !BCC_EOS
28305                                           ! 4788       return_status[2] = inb(0x03f5);
28306                                           ! Debug: list int = const $3F5 (used reg = )
28307 7BCF           B8                   03F5  mov	ax,#$3F5
28308 7BD2           50                         push	ax
28309                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28310 7BD3           E8         8953            call	_inb
28311 7BD6           44                         inc	sp
28312 7BD7           44                         inc	sp
28313                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
28314 7BD8           8846         EB            mov	-$15[bp],al
28315                                           !BCC_EOS
28316                                           ! 4789       retu
28317                                           ! 4789 rn_status[3] = inb(0x03f5);
28318                                           ! Debug: list int = const $3F5 (used reg = )
28319 7BDB           B8                   03F5  mov	ax,#$3F5
28320 7BDE           50                         push	ax
28321                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28322 7BDF           E8         8947            call	_inb
28323 7BE2           44                         inc	sp
28324 7BE3           44                         inc	sp
28325                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
28326 7BE4           8846         EC            mov	-$14[bp],al
28327                                           !BCC_EOS
28328                                           ! 4790       return_status[4] = inb(0x03f5);
28329                                           ! Debug: list int = const $3F5 (used reg = )
28330 7BE7           B8                   03F5  mov	ax,#$3F5
28331 7BEA           50                         push	ax
28332                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28333 7BEB           E8         893B            call	_inb
28334 7BEE           44                         inc	sp
28335 7BEF           44                         inc	sp
28336                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
28337 7BF0           8846         ED            mov	-$13[bp],al
28338                                           !BCC_EOS
28339                                           ! 4791       return_status[5] = inb(0x03f5);
28340                                           ! Debug: list int = const $3F5 (used reg = )
28341 7BF3           B8                   03F5  mov	ax,#$3F5
28342 7BF6           50                         push	ax
28343                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28344 7BF7           E8         892F            call	_inb
28345 7BFA           44                         inc	sp
28346 7BFB           44                         inc	sp
28347                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
28348 7BFC           8846         EE            mov	-$12[bp],al
28349                                           !BCC_EOS
28350                                           ! 4792       return_status[6] = inb(0x03f5);
28351                                           ! Debug: list int = const $3F5 (used reg = )
28352 7BFF           B8                   03F5  mov	ax,#$3F5
28353 7C02           50                         push	ax
28354                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28355 7C03           E8         8923            call	_inb
28356 7C06           44                         inc	sp
28357 7C07           44                         inc	sp
28358                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
28359 7C08           8846         EF            mov	-$11[bp],al
28360                                           !BCC_EOS
28361                                           ! 4793       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
28362                                           ! Debug: list int = const 7 (used reg = )
28363 7C0B           B8                   0007  mov	ax,*7
28364 7C0E           50                         push	ax
28365                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
28366 7C0F           E8         8A48            call	_get_SS
28367                                           ! Debug: list unsigned short = ax+0 (used reg = )
28368 7C12           50                         push	ax
28369                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
28370 7C13           8D5E         E9            lea	bx,-$17[bp]
28371 7C16           53                         push	bx
28372                                           ! Debug: list int = const $40 (used reg = )
28373 7C17           B8                   0040  mov	ax,*$40
28374 7C1A           50                         push	ax
28375                                           ! Debug: list int = const $42 (used reg = )
28376 7C1B           B8                   0042  mov	ax,*$42
28377 7C1E           50                         push	ax
28378                                           ! Debug: func () void = _memcpyb+0 (used reg = )
28379 7C1F           E8         83F9            call	__memcpyb
28380 7C22           83C4                   0A  add	sp,*$A
28381                                           !BCC_EOS
28382                                           ! 4794       if ( (return_status[0] & 0xc0) != 0 ) {
28383                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
28384 7C25           8A46         E9            mov	al,-$17[bp]
28385 7C28           24                     C0  and	al,#$C0
28386                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28387 7C2A           84C0                       test	al,al
28388 7C2C           74           53            je  	.6C6
28389                       00007C2E            .6C7:
28390                                           ! 4795         if (ah == 0x02) {
28391                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
28392 7C2E           8A46         E6            mov	al,-$1A[bp]
28393 7C31           3C                     02  cmp	al,*2
28394 7C33           75           21            jne 	.6C8
28395                       00007C35            .6C9:
28396                                           ! 4796           *(((Bit8u *)&AX)+1) = (0x20);
28397                                           ! Debug: eq int = const $20 to unsigned char AX = [S+$24+$15] (used reg = )
28398 7C35           B0                     20  mov	al,*$20
28399 7C37           8846         17            mov	$17[bp],al
28400                                           !BCC_EOS
28401                                           ! 4797           set_diskette_ret_status(0x20);
28402                                           ! Debug: list int = const $20 (used reg = )
28403 7C3A           B8                   0020  mov	ax,*$20
28404 7C3D           50                         push	ax
28405                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28406 7C3E           E8         09EB            call	_set_diskette_ret_status
28407 7C41           44                         inc	sp
28408 7C42           44                         inc	sp
28409                                           !BCC_EOS
28410                                           ! 4798           *((Bit8u *)&AX) = (0);
28411                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28412 7C43           30C0                       xor	al,al
28413 7C45           8846         16            mov	$16[bp],al
28414                                           !BCC_EOS
28415                                           ! 4799           FLAGS |= 0x0001;
28416                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28417 7C48           8B46         1C            mov	ax,$1C[bp]
28418 7C4B           0C                     01  or	al,*1
28419 7C4D           8946         1C            mov	$1C[bp],ax
28420                                           !BCC_EOS
28421                                           ! 4800           return;
28422 7C50           89EC                       mov	sp,bp
28423 7C52           5D                         pop	bp
28424 7C53           C3                         ret
28425                                           !BCC_EOS
28426                                           ! 4801         } else {
28427 7C54           EB           2B            jmp .6CA
28428                       00007C56            .6C8:
28429                                           ! 4802           if ( (return_status[1] & 0x02) != 0 ) {
28430                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
28431 7C56           8A46         EA            mov	al,-$16[bp]
28432 7C59           24                     02  and	al,*2
28433                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28434 7C5B           84C0                       test	al,al
28435 7C5D           74           14            je  	.6CB
28436                       00007C5F            .6CC:
28437                                           ! 4803             AX = 0x0300;
28438                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
28439 7C5F           B8                   0300  mov	ax,#$300
28440 7C62           8946         16            mov	$16[bp],ax
28441                                           !BCC_EOS
28442                                           ! 4804             FLAGS |= 0x0001;
28443                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28444 7C65           8B46         1C            mov	ax,$1C[bp]
28445 7C68           0C                     01  or	al,*1
28446 7C6A           8946         1C            mov	$1C[bp],ax
28447                                           !BCC_EOS
28448                                           ! 4805             return;
28449 7C6D           89EC                       mov	sp,bp
28450 7C6F           5D                         pop	bp
28451 7C70           C3                         ret
28452                                           !BCC_EOS
28453                                           ! 4806           } else {
28454 7C71           EB           0E            jmp .6CD
28455                       00007C73            .6CB:
28456                                           ! 4807             bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
28457                                           ! Debug: list * char = .6CE+0 (used reg = )
28458 7C73           BB                   CDD8  mov	bx,#.6CE
28459 7C76           53                         push	bx
28460                                           ! Debug: list int = const 7 (used reg = )
28461 7C77           B8                   0007  mov	ax,*7
28462 7C7A           50                         push	ax
28463                                           ! Debug: func () void = bios_printf+0 (used reg = )
28464 7C7B           E8         8CBB            call	_bios_printf
28465 7C7E           83C4                   04  add	sp,*4
28466                                           !BCC_EOS
28467                                           ! 4808           }
28468                                           ! 4809         }
28469                       00007C81            .6CD:
28470                                           ! 4810       }
28471                       00007C81            .6CA:
28472                                           ! 4811 floppy_return_success:
28473                       00007C81            .6C6:
28474                       00007C81            .FFDA:
28475                                           ! 4812       set_diskette_current_cyl(drive, track);
28476                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
28477 7C81           8A46         FD            mov	al,-3[bp]
28478 7C84           30E4                       xor	ah,ah
28479 7C86           50                         push	ax
28480                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
28481 7C87           8A46         FF            mov	al,-1[bp]
28482 7C8A           30E4                       xor	ah,ah
28483 7C8C           50                         push	ax
28484                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
28485 7C8D           E8         09B4            call	_set_diskette_current_cyl
28486 7C90           83C4                   04  add	sp,*4
28487                                           !BCC_EOS
28488                                           ! 4813       *(((Bit8u *)&AX)+1) = (0x00);
28489                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
28490 7C93           30C0                       xor	al,al
28491 7C95           8846         17            mov	$17[bp],al
28492                                           !BCC_EOS
28493                                           ! 4814       FLAGS &= 0xfffe;
28494                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28495 7C98           8B46         1C            mov	ax,$1C[bp]
28496 7C9B           24                     FE  and	al,#$FE
28497 7C9D           8946         1C            mov	$1C[bp],ax
28498                                           !BCC_EOS
28499                                           ! 4815       break;
28500 7CA0           E9         0985            br 	.696
28501                                           !BCC_EOS
28502                                           ! 4816     case 0x05:
28503                                           ! 4817 ;
28504                       00007CA3            .6CF:
28505                                           !BCC_EOS
28506                                           ! 4818       num_sectors = ( AX & 0x00ff );
28507                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
28508 7CA3           8A46         16            mov	al,$16[bp]
28509                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28510 7CA6           8846         FE            mov	-2[bp],al
28511                                           !BCC_EOS
28512                                           ! 4819       track = *(((Bit8u *)&CX)+1);
28513                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
28514 7CA9           8A46         15            mov	al,$15[bp]
28515 7CAC           8846         FD            mov	-3[bp],al
28516                                           !BCC_EOS
28517                                           ! 4820       head = *(((Bit8u *)&DX)+1);
28518                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
28519 7CAF           8A46         13            mov	al,$13[bp]
28520 7CB2           8846         FB            mov	-5[bp],al
28521                                           !BCC_EOS
28522                                           ! 4821       drive = ( ELDX & 0x00ff );
28523                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
28524 7CB5           8A46         0E            mov	al,$E[bp]
28525                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
28526 7CB8           8846         FF            mov	-1[bp],al
28527                                           !BCC_EOS
28528                                           ! 4822       if ((drive > 1) || (head > 1) || (track > 79) ||
28529                                           ! 4823           (num_sectors == 0) || (num_sectors > 18)) {
28530                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
28531 7CBB           8A46         FF            mov	al,-1[bp]
28532 7CBE           3C                     01  cmp	al,*1
28533 7CC0           77           1C            ja  	.6D1
28534                       00007CC2            .6D5:
28535                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
28536 7CC2           8A46         FB            mov	al,-5[bp]
28537 7CC5           3C                     01  cmp	al,*1
28538 7CC7           77           15            ja  	.6D1
28539                       00007CC9            .6D4:
28540                                           ! Debug: gt int = const $4F to unsigned char track = [S+$24-5] (used reg = )
28541 7CC9           8A46         FD            mov	al,-3[bp]
28542 7CCC           3C                     4F  cmp	al,*$4F
28543 7CCE           77           0E            ja  	.6D1
28544                       00007CD0            .6D3:
28545                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28546 7CD0           8A46         FE            mov	al,-2[bp]
28547 7CD3           84C0                       test	al,al
28548 7CD5           74           07            je  	.6D1
28549                       00007CD7            .6D2:
28550                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$24-4] (used reg = )
28551 7CD7           8A46         FE            mov	al,-2[bp]
28552 7CDA           3C                     12  cmp	al,*$12
28553 7CDC           76           16            jbe 	.6D0
28554                       00007CDE            .6D1:
28555                                           ! 4824         *(((Bit8u *)&AX)+1) = (1);
28556                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
28557 7CDE           B0                     01  mov	al,*1
28558 7CE0           8846         17            mov	$17[bp],al
28559                                           !BCC_EOS
28560                                           ! 4825         set_diskette_ret_status(1);
28561                                           ! Debug: list int = const 1 (used reg = )
28562 7CE3           B8                   0001  mov	ax,*1
28563 7CE6           50                         push	ax
28564                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28565 7CE7           E8         0942            call	_set_diskette_ret_status
28566 7CEA           44                         inc	sp
28567 7CEB           44                         inc	sp
28568                                           !BCC_EOS
28569                                           ! 4826         FLAGS |= 0x0001;
28570                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28571 7CEC           8B46         1C            mov	ax,$1C[bp]
28572 7CEF           0C                     01  or	al,*1
28573 7CF1           8946         1C            mov	$1C[bp],ax
28574                                           !BCC_EOS
28575                                           ! 4827       }
28576                                           ! 4828       if (floppy_drive_exists(drive) == 0) {
28577                       00007CF4            .6D0:
28578                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28579 7CF4           8A46         FF            mov	al,-1[bp]
28580 7CF7           30E4                       xor	ah,ah
28581 7CF9           50                         push	ax
28582                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
28583 7CFA           E8         FA38            call	_floppy_drive_exists
28584 7CFD           44                         inc	sp
28585 7CFE           44                         inc	sp
28586                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28587 7CFF           85C0                       test	ax,ax
28588 7D01           75           1A            jne 	.6D6
28589                       00007D03            .6D7:
28590                                           ! 4829         *(((Bit8u *)&AX)+1) = (0x80);
28591                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28592 7D03           B0                     80  mov	al,#$80
28593 7D05           8846         17            mov	$17[bp],al
28594                                           !BCC_EOS
28595                                           ! 4830         set_diskette_ret_status(0x80);
28596                                           ! Debug: list int = const $80 (used reg = )
28597 7D08           B8                   0080  mov	ax,#$80
28598 7D0B           50                         push	ax
28599                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28600 7D0C           E8         091D            call	_set_diskette_ret_status
28601 7D0F           44                         inc	sp
28602 7D10           44                         inc	sp
28603                                           !BCC_EOS
28604                                           ! 4831         FLAGS |= 0x0001;
28605                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28606 7D11           8B46         1C            mov	ax,$1C[bp]
28607 7D14           0C                     01  or	al,*1
28608 7D16           8946         1C            mov	$1C[bp],ax
28609                                           !BCC_EOS
28610                                           ! 4832         return;
28611 7D19           89EC                       mov	sp,bp
28612 7D1B           5D                         pop	bp
28613 7D1C           C3                         ret
28614                                           !BCC_EOS
28615                                           ! 4833       }
28616                                           ! 4834       if (floppy_media_known(drive) == 0) {
28617                       00007D1D            .6D6:
28618                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28619 7D1D           8A46         FF            mov	al,-1[bp]
28620 7D20           30E4                       xor	ah,ah
28621 7D22           50                         push	ax
28622                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
28623 7D23           E8         F829            call	_floppy_media_known
28624 7D26           44                         inc	sp
28625 7D27           44                         inc	sp
28626                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28627 7D28           85C0                       test	ax,ax
28628 7D2A           75           2E            jne 	.6D8
28629                       00007D2C            .6D9:
28630                                           ! 4835         if (floppy_media_sense(drive) == 0) {
28631                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28632 7D2C           8A46         FF            mov	al,-1[bp]
28633 7D2F           30E4                       xor	ah,ah
28634 7D31           50                         push	ax
28635                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
28636 7D32           E8         F88A            call	_floppy_media_sense
28637 7D35           44                         inc	sp
28638 7D36           44                         inc	sp
28639                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28640 7D37           85C0                       test	ax,ax
28641 7D39           75           1F            jne 	.6DA
28642                       00007D3B            .6DB:
28643                                           ! 4836           *(((Bit8u *)&AX)+1) = (0x0C);
28644                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
28645 7D3B           B0                     0C  mov	al,*$C
28646 7D3D           8846         17            mov	$17[bp],al
28647                                           !BCC_EOS
28648                                           ! 4837           set_diskette_ret_status(0x0C);
28649                                           ! Debug: list int = const $C (used reg = )
28650 7D40           B8                   000C  mov	ax,*$C
28651 7D43           50                         push	ax
28652                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28653 7D44           E8         08E5            call	_set_diskette_ret_status
28654 7D47           44                         inc	sp
28655 7D48           44                         inc	sp
28656                                           !BCC_EOS
28657                                           ! 4838           *((Bit8u *)&AX) = (0);
28658                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28659 7D49           30C0                       xor	al,al
28660 7D4B           8846         16            mov	$16[bp],al
28661                                           !BCC_EOS
28662                                           ! 4839           FLAGS |= 0x0001;
28663                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28664 7D4E           8B46         1C            mov	ax,$1C[bp]
28665 7D51           0C                     01  or	al,*1
28666 7D53           8946         1C            mov	$1C[bp],ax
28667                                           !BCC_EOS
28668                                           ! 4840           return;
28669 7D56           89EC                       mov	sp,bp
28670 7D58           5D                         pop	bp
28671 7D59           C3                         ret
28672                                           !BCC_EOS
28673                                           ! 4841         }
28674                                           ! 4842       }
28675                       00007D5A            .6DA:
28676                                           ! 4843       page = (ES >> 12);
28677                       00007D5A            .6D8:
28678                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
28679 7D5A           8B46         06            mov	ax,6[bp]
28680 7D5D           88E0                       mov	al,ah
28681 7D5F           30E4                       xor	ah,ah
28682 7D61           B1                     04  mov	cl,*4
28683 7D63           D3E8                       shr	ax,cl
28684                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
28685 7D65           8846         F3            mov	-$D[bp],al
28686                                           !BCC_EOS
28687                                           ! 4844       base_es = (ES << 4);
28688                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
28689 7D68           8B46         06            mov	ax,6[bp]
28690 7D6B           B1                     04  mov	cl,*4
28691 7D6D           D3E0                       shl	ax,cl
28692                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
28693 7D6F           8946         F4            mov	-$C[bp],ax
28694                                           !BCC_EOS
28695                                           ! 4845       base_address = base_es + BX;
28696                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
28697 7D72           8B46         F4            mov	ax,-$C[bp]
28698 7D75           0346         10            add	ax,$10[bp]
28699                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
28700 7D78           8946         F8            mov	-8[bp],ax
28701                                           !BCC_EOS
28702                                           ! 4846       if ( base_address < base_es ) {
28703                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
28704 7D7B           8B46         F8            mov	ax,-8[bp]
28705 7D7E           3B46         F4            cmp	ax,-$C[bp]
28706 7D81           73           07            jae 	.6DC
28707                       00007D83            .6DD:
28708                                           ! 4847         page++;
28709                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
28710 7D83           8A46         F3            mov	al,-$D[bp]
28711 7D86           40                         inc	ax
28712 7D87           8846         F3            mov	-$D[bp],al
28713                                           !BCC_EOS
28714                                           ! 4848       }
28715                                           ! 4849       base_count = (num_sectors * 4) - 1;
28716                       00007D8A            .6DC:
28717                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$24-4] (used reg = )
28718 7D8A           8A46         FE            mov	al,-2[bp]
28719 7D8D           30E4                       xor	ah,ah
28720 7D8F           D1E0                       shl	ax,*1
28721 7D91           D1E0                       shl	ax,*1
28722                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28723                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
28724 7D93           48                         dec	ax
28725 7D94           8946         F6            mov	-$A[bp],ax
28726                                           !BCC_EOS
28727                                           ! 4850       last_addr = base_address + base_count;
28728                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
28729 7D97           8B46         F8            mov	ax,-8[bp]
28730 7D9A           0346         F6            add	ax,-$A[bp]
28731                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
28732 7D9D           8946         E0            mov	-$20[bp],ax
28733                                           !BCC_EOS
28734                                           ! 4851       if (last_addr < base_address) {
28735                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
28736 7DA0           8B46         E0            mov	ax,-$20[bp]
28737 7DA3           3B46         F8            cmp	ax,-8[bp]
28738 7DA6           73           1F            jae 	.6DE
28739                       00007DA8            .6DF:
28740                                           ! 4852         *(((Bit8u *)&AX)+1) = (0x09);
28741                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
28742 7DA8           B0                     09  mov	al,*9
28743 7DAA           8846         17            mov	$17[bp],al
28744                                           !BCC_EOS
28745                                           ! 4853         set_diskette_ret_status(0x09);
28746                                           ! Debug: list int = const 9 (used reg = )
28747 7DAD           B8                   0009  mov	ax,*9
28748 7DB0           50                         push	ax
28749                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28750 7DB1           E8         0878            call	_set_diskette_ret_status
28751 7DB4           44                         inc	sp
28752 7DB5           44                         inc	sp
28753                                           !BCC_EOS
28754                                           ! 4854         *((Bit8u *)&AX) = (0);
28755                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28756 7DB6           30C0                       xor	al,al
28757 7DB8           8846         16            mov	$16[bp],al
28758                                           !BCC_EOS
28759                                           ! 4855         FLAGS |= 0x
28760                                           ! 4855 0001;
28761                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28762 7DBB           8B46         1C            mov	ax,$1C[bp]
28763 7DBE           0C                     01  or	al,*1
28764 7DC0           8946         1C            mov	$1C[bp],ax
28765                                           !BCC_EOS
28766                                           ! 4856         return;
28767 7DC3           89EC                       mov	sp,bp
28768 7DC5           5D                         pop	bp
28769 7DC6           C3                         ret
28770                                           !BCC_EOS
28771                                           ! 4857       }
28772                                           ! 4858       outb(0x000a, 0x06);
28773                       00007DC7            .6DE:
28774                                           ! Debug: list int = const 6 (used reg = )
28775 7DC7           B8                   0006  mov	ax,*6
28776 7DCA           50                         push	ax
28777                                           ! Debug: list int = const $A (used reg = )
28778 7DCB           B8                   000A  mov	ax,*$A
28779 7DCE           50                         push	ax
28780                                           ! Debug: func () void = outb+0 (used reg = )
28781 7DCF           E8         876D            call	_outb
28782 7DD2           83C4                   04  add	sp,*4
28783                                           !BCC_EOS
28784                                           ! 4859       outb(0x000c, 0x00);
28785                                           ! Debug: list int = const 0 (used reg = )
28786 7DD5           31C0                       xor	ax,ax
28787 7DD7           50                         push	ax
28788                                           ! Debug: list int = const $C (used reg = )
28789 7DD8           B8                   000C  mov	ax,*$C
28790 7DDB           50                         push	ax
28791                                           ! Debug: func () void = outb+0 (used reg = )
28792 7DDC           E8         8760            call	_outb
28793 7DDF           83C4                   04  add	sp,*4
28794                                           !BCC_EOS
28795                                           ! 4860       outb(0x0004, base_address);
28796                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
28797 7DE2           FF76         F8            push	-8[bp]
28798                                           ! Debug: list int = const 4 (used reg = )
28799 7DE5           B8                   0004  mov	ax,*4
28800 7DE8           50                         push	ax
28801                                           ! Debug: func () void = outb+0 (used reg = )
28802 7DE9           E8         8753            call	_outb
28803 7DEC           83C4                   04  add	sp,*4
28804                                           !BCC_EOS
28805                                           ! 4861       outb(0x0004, *(((Bit8u *)&base_address)+1));
28806                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
28807 7DEF           8A46         F9            mov	al,-7[bp]
28808 7DF2           30E4                       xor	ah,ah
28809 7DF4           50                         push	ax
28810                                           ! Debug: list int = const 4 (used reg = )
28811 7DF5           B8                   0004  mov	ax,*4
28812 7DF8           50                         push	ax
28813                                           ! Debug: func () void = outb+0 (used reg = )
28814 7DF9           E8         8743            call	_outb
28815 7DFC           83C4                   04  add	sp,*4
28816                                           !BCC_EOS
28817                                           ! 4862       outb(0x000c, 0x00);
28818                                           ! Debug: list int = const 0 (used reg = )
28819 7DFF           31C0                       xor	ax,ax
28820 7E01           50                         push	ax
28821                                           ! Debug: list int = const $C (used reg = )
28822 7E02           B8                   000C  mov	ax,*$C
28823 7E05           50                         push	ax
28824                                           ! Debug: func () void = outb+0 (used reg = )
28825 7E06           E8         8736            call	_outb
28826 7E09           83C4                   04  add	sp,*4
28827                                           !BCC_EOS
28828                                           ! 4863       outb(0x0005, base_count);
28829                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
28830 7E0C           FF76         F6            push	-$A[bp]
28831                                           ! Debug: list int = const 5 (used reg = )
28832 7E0F           B8                   0005  mov	ax,*5
28833 7E12           50                         push	ax
28834                                           ! Debug: func () void = outb+0 (used reg = )
28835 7E13           E8         8729            call	_outb
28836 7E16           83C4                   04  add	sp,*4
28837                                           !BCC_EOS
28838                                           ! 4864       outb(0x0005, *(((Bit8u *)&base_count)+1));
28839                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
28840 7E19           8A46         F7            mov	al,-9[bp]
28841 7E1C           30E4                       xor	ah,ah
28842 7E1E           50                         push	ax
28843                                           ! Debug: list int = const 5 (used reg = )
28844 7E1F           B8                   0005  mov	ax,*5
28845 7E22           50                         push	ax
28846                                           ! Debug: func () void = outb+0 (used reg = )
28847 7E23           E8         8719            call	_outb
28848 7E26           83C4                   04  add	sp,*4
28849                                           !BCC_EOS
28850                                           ! 4865       mode_register = 0x4a;
28851                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
28852 7E29           B0                     4A  mov	al,*$4A
28853 7E2B           8846         F2            mov	-$E[bp],al
28854                                           !BCC_EOS
28855                                           ! 4866       outb(0x000b, mode_register);
28856                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
28857 7E2E           8A46         F2            mov	al,-$E[bp]
28858 7E31           30E4                       xor	ah,ah
28859 7E33           50                         push	ax
28860                                           ! Debug: list int = const $B (used reg = )
28861 7E34           B8                   000B  mov	ax,*$B
28862 7E37           50                         push	ax
28863                                           ! Debug: func () void = outb+0 (used reg = )
28864 7E38           E8         8704            call	_outb
28865 7E3B           83C4                   04  add	sp,*4
28866                                           !BCC_EOS
28867                                           ! 4867       outb(0x0081, page);
28868                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
28869 7E3E           8A46         F3            mov	al,-$D[bp]
28870 7E41           30E4                       xor	ah,ah
28871 7E43           50                         push	ax
28872                                           ! Debug: list int = const $81 (used reg = )
28873 7E44           B8                   0081  mov	ax,#$81
28874 7E47           50                         push	ax
28875                                           ! Debug: func () void = outb+0 (used reg = )
28876 7E48           E8         86F4            call	_outb
28877 7E4B           83C4                   04  add	sp,*4
28878                                           !BCC_EOS
28879                                           ! 4868       outb(0x000a, 0x02);
28880                                           ! Debug: list int = const 2 (used reg = )
28881 7E4E           B8                   0002  mov	ax,*2
28882 7E51           50                         push	ax
28883                                           ! Debug: list int = const $A (used reg = )
28884 7E52           B8                   000A  mov	ax,*$A
28885 7E55           50                         push	ax
28886                                           ! Debug: func () void = outb+0 (used reg = )
28887 7E56           E8         86E6            call	_outb
28888 7E59           83C4                   04  add	sp,*4
28889                                           !BCC_EOS
28890                                           ! 4869       floppy_prepare_controller(drive);
28891                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28892 7E5C           8A46         FF            mov	al,-1[bp]
28893 7E5F           30E4                       xor	ah,ah
28894 7E61           50                         push	ax
28895                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
28896 7E62           E8         F64A            call	_floppy_prepare_controller
28897 7E65           44                         inc	sp
28898 7E66           44                         inc	sp
28899                                           !BCC_EOS
28900                                           ! 4870       outb(0x03f5, 0x4d);
28901                                           ! Debug: list int = const $4D (used reg = )
28902 7E67           B8                   004D  mov	ax,*$4D
28903 7E6A           50                         push	ax
28904                                           ! Debug: list int = const $3F5 (used reg = )
28905 7E6B           B8                   03F5  mov	ax,#$3F5
28906 7E6E           50                         push	ax
28907                                           ! Debug: func () void = outb+0 (used reg = )
28908 7E6F           E8         86CD            call	_outb
28909 7E72           83C4                   04  add	sp,*4
28910                                           !BCC_EOS
28911                                           ! 4871       outb(0x03f5, (head << 2) | drive);
28912                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
28913 7E75           8A46         FB            mov	al,-5[bp]
28914 7E78           30E4                       xor	ah,ah
28915 7E7A           D1E0                       shl	ax,*1
28916 7E7C           D1E0                       shl	ax,*1
28917                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
28918 7E7E           0A46         FF            or	al,-1[bp]
28919                                           ! Debug: list unsigned int = ax+0 (used reg = )
28920 7E81           50                         push	ax
28921                                           ! Debug: list int = const $3F5 (used reg = )
28922 7E82           B8                   03F5  mov	ax,#$3F5
28923 7E85           50                         push	ax
28924                                           ! Debug: func () void = outb+0 (used reg = )
28925 7E86           E8         86B6            call	_outb
28926 7E89           83C4                   04  add	sp,*4
28927                                           !BCC_EOS
28928                                           ! 4872       outb(0x03f5, 2);
28929                                           ! Debug: list int = const 2 (used reg = )
28930 7E8C           B8                   0002  mov	ax,*2
28931 7E8F           50                         push	ax
28932                                           ! Debug: list int = const $3F5 (used reg = )
28933 7E90           B8                   03F5  mov	ax,#$3F5
28934 7E93           50                         push	ax
28935                                           ! Debug: func () void = outb+0 (used reg = )
28936 7E94           E8         86A8            call	_outb
28937 7E97           83C4                   04  add	sp,*4
28938                                           !BCC_EOS
28939                                           ! 4873       outb(0x03f5, num_sectors);
28940                                           ! Debug: list unsigned char num_sectors = [S+$24-4] (used reg = )
28941 7E9A           8A46         FE            mov	al,-2[bp]
28942 7E9D           30E4                       xor	ah,ah
28943 7E9F           50                         push	ax
28944                                           ! Debug: list int = const $3F5 (used reg = )
28945 7EA0           B8                   03F5  mov	ax,#$3F5
28946 7EA3           50                         push	ax
28947                                           ! Debug: func () void = outb+0 (used reg = )
28948 7EA4           E8         8698            call	_outb
28949 7EA7           83C4                   04  add	sp,*4
28950                                           !BCC_EOS
28951                                           ! 4874       outb(0x03f5, 0);
28952                                           ! Debug: list int = const 0 (used reg = )
28953 7EAA           31C0                       xor	ax,ax
28954 7EAC           50                         push	ax
28955                                           ! Debug: list int = const $3F5 (used reg = )
28956 7EAD           B8                   03F5  mov	ax,#$3F5
28957 7EB0           50                         push	ax
28958                                           ! Debug: func () void = outb+0 (used reg = )
28959 7EB1           E8         868B            call	_outb
28960 7EB4           83C4                   04  add	sp,*4
28961                                           !BCC_EOS
28962                                           ! 4875       outb(0x03f5, 0xf6);
28963                                           ! Debug: list int = const $F6 (used reg = )
28964 7EB7           B8                   00F6  mov	ax,#$F6
28965 7EBA           50                         push	ax
28966                                           ! Debug: list int = const $3F5 (used reg = )
28967 7EBB           B8                   03F5  mov	ax,#$3F5
28968 7EBE           50                         push	ax
28969                                           ! Debug: func () void = outb+0 (used reg = )
28970 7EBF           E8         867D            call	_outb
28971 7EC2           83C4                   04  add	sp,*4
28972                                           !BCC_EOS
28973                                           ! 4876 #asm
28974                                           !BCC_EOS
28975                                           !BCC_ASM
28976                       0000002E            _int13_diskette_function.BP	set	$2E
28977                       0000000C            .int13_diskette_function.BP	set	$C
28978                       0000003C            _int13_diskette_function.CS	set	$3C
28979                       0000001A            .int13_diskette_function.CS	set	$1A
28980                       00000036            _int13_diskette_function.CX	set	$36
28981                       00000014            .int13_diskette_function.CX	set	$14
28982                       0000001A            _int13_diskette_function.base_address	set	$1A
28983                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28984                       0000002A            _int13_diskette_function.DI	set	$2A
28985                       00000008            .int13_diskette_function.DI	set	8
28986                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28987                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28988                       00000018            _int13_diskette_function.base_count	set	$18
28989                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28990                       0000001E            _int13_diskette_function.sector	set	$1E
28991                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28992                       00000026            _int13_diskette_function.DS	set	$26
28993                       00000004            .int13_diskette_function.DS	set	4
28994                       0000001D            _int13_diskette_function.head	set	$1D
28995                       FFFFFFFB            .int13_diskette_function.head	set	-5
28996                       00000030            _int13_diskette_function.ELDX	set	$30
28997                       0000000E            .int13_diskette_function.ELDX	set	$E
28998                       00000012            _int13_diskette_function.dor	set	$12
28999                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29000                       00000034            _int13_diskette_function.DX	set	$34
29001                       00000012            .int13_diskette_function.DX	set	$12
29002                       0000000B            _int13_diskette_function.return_status	set	$B
29003                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29004                       00000004            _int13_diskette_function.es	set	4
29005                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29006                       00000014            _int13_diskette_function.mode_register	set	$14
29007                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29008                       00000028            _int13_diskette_function.ES	set	$28
29009                       00000006            .int13_diskette_function.ES	set	6
29010                       00000016            _int13_diskette_function.base_es	set	$16
29011                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29012                       0000001F            _int13_diskette_function.track	set	$1F
29013                       FFFFFFFD            .int13_diskette_function.track	set	-3
29014                       0000002C            _int13_diskette_function.SI	set	$2C
29015                       0000000A            .int13_diskette_function.SI	set	$A
29016                       0000000A            _int13_diskette_function.drive_type	set	$A
29017                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29018                       00000020            _int13_diskette_function.num_sectors	set	$20
29019                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29020                       0000003A            _int13_diskette_function.IP	set	$3A
29021                       00000018            .int13_diskette_function.IP	set	$18
29022                       00000007            _int13_diskette_function.spt	set	7
29023                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29024                       0000001C            _int13_diskette_function.status	set	$1C
29025                       FFFFFFFA            .int13_diskette_function.status	set	-6
29026                       00000000            _int13_diskette_function.maxCyl	set	0
29027                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29028                       00000038            _int13_diskette_function.AX	set	$38
29029                       00000016            .int13_diskette_function.AX	set	$16
29030                       00000013            _int13_diskette_function.val8	set	$13
29031                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29032                       00000002            _int13_diskette_function.last_addr	set	2
29033                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29034                       00000015            _int13_diskette_function.page	set	$15
29035                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29036                       00000008            _int13_diskette_function.ah	set	8
29037                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29038                       00000021            _int13_diskette_function.drive	set	$21
29039                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29040                       00000009            _int13_diskette_function.num_floppies	set	9
29041                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29042                       00000032            _int13_diskette_function.BX	set	$32
29043                       00000010            .int13_diskette_function.BX	set	$10
29044 7EC5           FB                               sti
29045                                           ! 4878 endasm
29046                                           !BCC_ENDASM
29047                                           !BCC_EOS
29048                                           ! 4879       do {
29049                       00007EC6            .6E2:
29050                                           ! 4880         val8 = *((Bit8u *)(0x0040));
29051                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
29052 7EC6           A0         0040            mov	al,[$40]
29053 7EC9           8846         F1            mov	-$F[bp],al
29054                                           !BCC_EOS
29055                                           ! 4881         if (val8 == 0) {
29056                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29057 7ECC           8A46         F1            mov	al,-$F[bp]
29058 7ECF           84C0                       test	al,al
29059 7ED1           75           1D            jne 	.6E3
29060                       00007ED3            .6E4:
29061                                           ! 4882           floppy_reset_controller();
29062                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
29063 7ED3           E8         F58B            call	_floppy_reset_controller
29064                                           !BCC_EOS
29065                                           ! 4883           *(((Bit8u *)&AX)+1) = (0x80);
29066                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
29067 7ED6           B0                     80  mov	al,#$80
29068 7ED8           8846         17            mov	$17[bp],al
29069                                           !BCC_EOS
29070                                           ! 4884           set_diskette_ret_status(0x80);
29071                                           ! Debug: list int = const $80 (used reg = )
29072 7EDB           B8                   0080  mov	ax,#$80
29073 7EDE           50                         push	ax
29074                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29075 7EDF           E8         074A            call	_set_diskette_ret_status
29076 7EE2           44                         inc	sp
29077 7EE3           44                         inc	sp
29078                                           !BCC_EOS
29079                                           ! 4885           FLAGS |= 0x0001;
29080                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29081 7EE4           8B46         1C            mov	ax,$1C[bp]
29082 7EE7           0C                     01  or	al,*1
29083 7EE9           8946         1C            mov	$1C[bp],ax
29084                                           !BCC_EOS
29085                                           ! 4886           return;
29086 7EEC           89EC                       mov	sp,bp
29087 7EEE           5D                         pop	bp
29088 7EEF           C3                         ret
29089                                           !BCC_EOS
29090                                           ! 4887         }
29091                                           ! 4888         val8 = (*((Bit8u *)(0x003e)) & 0x80);
29092                       00007EF0            .6E3:
29093                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
29094 7EF0           A0         003E            mov	al,[$3E]
29095 7EF3           24                     80  and	al,#$80
29096                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29097 7EF5           8846         F1            mov	-$F[bp],al
29098                                           !BCC_EOS
29099                                           ! 4889       } while ( val8 == 0 );
29100                       00007EF8            .6E1:
29101                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29102 7EF8           8A46         F1            mov	al,-$F[bp]
29103 7EFB           84C0                       test	al,al
29104 7EFD           74           C7            je 	.6E2
29105                       00007EFF            .6E5:
29106                                           !BCC_EOS
29107                                           ! 4890       val8 = 0;
29108                       00007EFF            .6E0:
29109                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29110 7EFF           30C0                       xor	al,al
29111 7F01           8846         F1            mov	-$F[bp],al
29112                                           !BCC_EOS
29113                                           ! 4891 #asm
29114                                           !BCC_EOS
29115                                           !BCC_ASM
29116                       0000002E            _int13_diskette_function.BP	set	$2E
29117                       0000000C            .int13_diskette_function.BP	set	$C
29118                       0000003C            _int13_diskette_function.CS	set	$3C
29119                       0000001A            .int13_diskette_function.CS	set	$1A
29120                       00000036            _int13_diskette_function.CX	set	$36
29121                       00000014            .int13_diskette_function.CX	set	$14
29122                       0000001A            _int13_diskette_function.base_address	set	$1A
29123                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29124                       0000002A            _int13_diskette_function.DI	set	$2A
29125                       00000008            .int13_diskette_function.DI	set	8
29126                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29127                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29128                       00000018            _int13_diskette_function.base_count	set	$18
29129                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29130                       0000001E            _int13_diskette_function.sector	set	$1E
29131                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29132                       00000026            _int13_diskette_function.DS	set	$26
29133                       00000004            .int13_diskette_function.DS	set	4
29134                       0000001D            _int13_diskette_function.head	set	$1D
29135                       FFFFFFFB            .int13_diskette_function.head	set	-5
29136                       00000030            _int13_diskette_function.ELDX	set	$30
29137                       0000000E            .int13_diskette_function.ELDX	set	$E
29138                       00000012            _int13_diskette_function.dor	set	$12
29139                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29140                       00000034            _int13_diskette_function.DX	set	$34
29141                       00000012            .int13_diskette_function.DX	set	$12
29142                       0000000B            _int13_diskette_function.return_status	set	$B
29143                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29144                       00000004            _int13_diskette_function.es	set	4
29145                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29146                       00000014            _int13_diskette_function.mode_register	set	$14
29147                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29148                       00000028            _int13_diskette_function.ES	set	$28
29149                       00000006            .int13_diskette_function.ES	set	6
29150                       00000016            _int13_diskette_function.base_es	set	$16
29151                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29152                       0000001F            _int13_diskette_function.track	set	$1F
29153                       FFFFFFFD            .int13_diskette_function.track	set	-3
29154                       0000002C            _int13_diskette_function.SI	set	$2C
29155                       0000000A            .int13_diskette_function.SI	set	$A
29156                       0000000A            _int13_diskette_function.drive_type	set	$A
29157                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29158                       00000020            _int13_diskette_function.num_sectors	set	$20
29159                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29160                       0000003A            _int13_diskette_function.IP	set	$3A
29161                       00000018            .int13_diskette_function.IP	set	$18
29162                       00000007            _int13_diskette_function.spt	set	7
29163                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29164                       0000001C            _int13_diskette_function.status	set	$1C
29165                       FFFFFFFA            .int13_diskette_function.status	set	-6
29166                       00000000            _int13_diskette_function.maxCyl	set	0
29167                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29168                       00000038            _int13_diskette_function.AX	set	$38
29169                       00000016            .int13_diskette_function.AX	set	$16
29170                       00000013            _int13_diskette_function.val8	set	$13
29171                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29172                       00000002            _int13_diskette_function.last_addr	set	2
29173                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29174                       00000015            _int13_diskette_function.page	set	$15
29175                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29176                       00000008            _int13_diskette_function.ah	set	8
29177                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29178                       00000021            _int13_diskette_function.drive	set	$21
29179                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29180                       00000009            _int13_diskette_function.num_floppies	set	9
29181                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29182                       00000032            _int13_diskette_function.BX	set	$32
29183                       00000010            .int13_diskette_function.BX	set	$10
29184 7F04           FA                               cli
29185                                           ! 4893 endasm
29186                                           !BCC_ENDASM
29187                                           !BCC_EOS
29188                                           ! 4894       val8 = *((Bit8u *)(0x003e));
29189                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
29190 7F05           A0         003E            mov	al,[$3E]
29191 7F08           8846         F1            mov	-$F[bp],al
29192                                           !BCC_EOS
29193                                           ! 4895       val8 &= 0x7f;
29194                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
29195 7F0B           8A46         F1            mov	al,-$F[bp]
29196 7F0E           24                     7F  and	al,*$7F
29197 7F10           8846         F1            mov	-$F[bp],al
29198                                           !BCC_EOS
29199                                           ! 4896       *((Bit8u *)(0x003e)) = (val8);
29200                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
29201 7F13           8A46         F1            mov	al,-$F[bp]
29202 7F16           A2         003E            mov	[$3E],al
29203                                           !BCC_EOS
29204                                           ! 4897       val8 = inb(0x03f4);
29205                                           ! Debug: list int = const $3F4 (used reg = )
29206 7F19           B8                   03F4  mov	ax,#$3F4
29207 7F1C           50                         push	ax
29208                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29209 7F1D           E8         8609            call	_inb
29210 7F20           44                         inc	sp
29211 7F21           44                         inc	sp
29212                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29213 7F22           8846         F1            mov	-$F[bp],al
29214                                           !BCC_EOS
29215                                           ! 4898       if ( (val8 & 0xc0) != 0xc0 )
29216                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
29217 7F25           8A46         F1            mov	al,-$F[bp]
29218 7F28           24                     C0  and	al,#$C0
29219                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
29220 7F2A           3C                     C0  cmp	al,#$C0
29221 7F2C           74           0E            je  	.6E6
29222                       00007F2E            .6E7:
29223                                           ! 4899         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
29224                                           ! Debug: list * char = .6E8+0 (used reg = )
29225 7F2E           BB                   CDB8  mov	bx,#.6E8
29226 7F31           53                         push	bx
29227                                           ! Debug: list int = const 7 (used reg = )
29228 7F32           B8                   0007  mov	ax,*7
29229 7F35           50                         push	ax
29230                                           ! Debug: func () void = bios_printf+0 (used reg = )
29231 7F36           E8         8A00            call	_bios_printf
29232 7F39           83C4                   04  add	sp,*4
29233                                           !BCC_EOS
29234                                           ! 4900       return_status[0] = inb(0x03f5);
29235                       00007F3C            .6E6:
29236                                           ! Debug: list int = const $3F5 (used reg = )
29237 7F3C           B8                   03F5  mov	ax,#$3F5
29238 7F3F           50                         push	ax
29239                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29240 7F40           E8         85E6            call	_inb
29241 7F43           44                         inc	sp
29242 7F44           44                         inc	sp
29243                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
29244 7F45           8846         E9            mov	-$17[bp],al
29245                                           !BCC_EOS
29246                                           ! 4901       return_status[1] = inb(0x03f5);
29247                                           ! Debug: list int = const $3F5 (used reg = )
29248 7F48           B8                   03F5  mov	ax,#$3F5
29249 7F4B           50                         push	ax
29250                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29251 7F4C           E8         85DA            call	_inb
29252 7F4F           44                         inc	sp
29253 7F50           44                         inc	sp
29254                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
29255 7F51           8846         EA            mov	-$16[bp],al
29256                                           !BCC_EOS
29257                                           ! 4902       return_status[2] = inb(0x03f5);
29258                                           ! Debug: list int = const $3F5 (used reg = )
29259 7F54           B8                   03F5  mov	ax,#$3F5
29260 7F57           50                         push	ax
29261                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29262 7F58           E8         85CE            call	_inb
29263 7F5B           44                         inc	sp
29264 7F5C           44                         inc	sp
29265                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
29266 7F5D           8846         EB            mov	-$15[bp],al
29267                                           !BCC_EOS
29268                                           ! 4903       return_status[3] = inb(0x03f5);
29269                                           ! Debug: list int = const $3F5 (used reg = )
29270 7F60           B8                   03F5  mov	ax,#$3F5
29271 7F63           50                         push	ax
29272                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29273 7F64           E8         85C2            call	_inb
29274 7F67           44                         inc	sp
29275 7F68           44                         inc	sp
29276                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
29277 7F69           8846         EC            mov	-$14[bp],al
29278                                           !BCC_EOS
29279                                           ! 4904       return_status[4] = inb(0x03f5);
29280                                           ! Debug: list int = const $3F5 (used reg = )
29281 7F6C           B8                   03F5  mov	ax,#$3F5
29282 7F6F           50                         push	ax
29283                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29284 7F70           E8         85B6            call	_inb
29285 7F73           44                         inc	sp
29286 7F74           44                         inc	sp
29287                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
29288 7F75           8846         ED            mov	-$13[bp],al
29289                                           !BCC_EOS
29290                                           ! 4905       return_status[5] = inb(0x03f5);
29291                                           ! Debug: list int = const $3F5 (used reg = )
29292 7F78           B8                   03F5  mov	ax,#$3F5
29293 7F7B           50                         push	ax
29294                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29295 7F7C           E8         85AA            call	_inb
29296 7F7F           44                         inc	sp
29297 7F80           44                         inc	sp
29298                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
29299 7F81           8846         EE            mov	-$12[bp],al
29300                                           !BCC_EOS
29301                                           ! 4906       return_status[6] = inb(0x03f5);
29302                                           ! Debug: list int = const $3F5 (used reg = )
29303 7F84           B8                   03F5  mov	ax,#$3F5
29304 7F87           50                         push	ax
29305                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29306 7F88           E8         859E            call	_inb
29307 7F8B           44                         inc	sp
29308 7F8C           44                         inc	sp
29309                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
29310 7F8D           8846         EF            mov	-$11[bp],al
29311                                           !BCC_EOS
29312                                           ! 4907       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
29313                                           ! Debug: list int = const 7 (used reg = )
29314 7F90           B8                   0007  mov	ax,*7
29315 7F93           50                         push	ax
29316                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29317 7F94           E8         86C3            call	_get_SS
29318                                           ! Debug: list unsigned short = ax+0 (used reg = )
29319 7F97           50                         push	ax
29320                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
29321 7F98           8D5E         E9            lea	bx,-$17[bp]
29322 7F9B           53                         push	bx
29323                                           ! Debug: list int = const $40 (used reg = )
29324 7F9C           B8                   0040  mov	ax,*$40
29325 7F9F           50                         push	ax
29326                                           ! Debug: list int = const $42 (used reg = )
29327 7FA0           B8                   0042  mov	ax,*$42
29328 7FA3           50                         push	ax
29329                                           ! Debug: func () void = _memcpyb+0 (used reg = )
29330 7FA4           E8         8074            call	__memcpyb
29331 7FA7           83C4                   0A  add	sp,*$A
29332                                           !BCC_EOS
29333                                           ! 4908       if ( (return_status[0] & 0xc0) != 0 ) {
29334                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
29335 7FAA           8A46         E9            mov	al,-$17[bp]
29336 7FAD           24                     C0  and	al,#$C0
29337                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29338 7FAF           84C0                       test	al,al
29339 7FB1           74           2B            je  	.6E9
29340                       00007FB3            .6EA:
29341                                           ! 4909         if ( (return_status[1] & 0x02) != 0 ) {
29342                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
29343 7FB3           8A46         EA            mov	al,-$16[bp]
29344 7FB6           24                     02  and	al,*2
29345                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29346 7FB8           84C0                       test	al,al
29347 7FBA           74           14            je  	.6EB
29348                       00007FBC            .6EC:
29349                                           ! 4910           AX = 0x0300;
29350                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
29351 7FBC           B8                   0300  mov	ax,#$300
29352 7FBF           8946         16            mov	$16[bp],ax
29353                                           !BCC_EOS
29354                                           ! 4911           FLAGS |= 0x0001;
29355                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29356 7FC2           8B46         1C            mov	ax,$1C[bp]
29357 7FC5           0C                     01  or	al,*1
29358 7FC7           8946         1C            mov	$1C[bp],ax
29359                                           !BCC_EOS
29360                                           ! 4912           return;
29361 7FCA           89EC                       mov	sp,bp
29362 7FCC           5D                         pop	bp
29363 7FCD           C3                         ret
29364                                           !BCC_EOS
29365                                           ! 4913         } else {
29366 7FCE           EB           0E            jmp .6ED
29367                       00007FD0            .6EB:
29368                                           ! 4914           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
29369                                           ! Debug: list * char = .6EE+0 (used reg = )
29370 7FD0           BB                   CD92  mov	bx,#.6EE
29371 7FD3           53                         push	bx
29372                                           ! Debug: list int = const 7 (used reg = )
29373 7FD4           B8                   0007  mov	ax,*7
29374 7FD7           50                         push	ax
29375                                           ! Debug: func () void = bios_printf+0 (used reg = )
29376 7FD8           E8         895E            call	_bios_printf
29377 7FDB           83C4                   04  add	sp,*4
29378                                           !BCC_EOS
29379                                           ! 4915         }
29380                                           ! 4916       }
29381                       00007FDE            .6ED:
29382                                           ! 4917       *(((Bit8u *)&AX)+1) = (0);
29383                       00007FDE            .6E9:
29384                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29385 7FDE           30C0                       xor	al,al
29386 7FE0           8846         17            mov	$17[bp],al
29387                                           !BCC_EOS
29388                                           ! 4918       set_diskette_ret_status(0);
29389                                           ! Debug: list int = const 0 (used reg = )
29390 7FE3           31C0                       xor	ax,ax
29391 7FE5           50                         push	ax
29392                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29393 7FE6           E8         0643            call	_set_diskette_ret_status
29394 7FE9           44                         inc	sp
29395 7FEA           44                         inc	sp
29396                                           !BCC_EOS
29397                                           ! 4919       set_diskette_current_cyl(drive, 0);
29398                                           ! Debug: list int = const 0 (used reg = )
29399 7FEB           31C0                       xor	ax,ax
29400 7FED           50                         push	ax
29401                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
29402 7FEE           8A46         FF            mov	al,-1[bp]
29403 7FF1           30E4                       xor	ah,ah
29404 7FF3           50                         push	ax
29405                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
29406 7FF4           E8         064D            call	_set_diskette_current_cyl
29407 7FF7           83C4                   04  add	sp,*4
29408                                           !BCC_EOS
29409                                           ! 4920       FLAGS &= 0xfffe;
29410                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29411 7FFA           8B46         1C            mov	ax,$1C[bp]
29412 7FFD           24                     FE  and	al,#$FE
29413 7FFF           8946         1C            mov	$1C[bp],ax
29414                                           !BCC_EOS
29415                                           ! 4921       return;
29416 8002           89EC                       mov	sp,bp
29417 8004           5D                         pop	bp
29418 8005           C3                         ret
29419                                           !BCC_EOS
29420                                           ! 4922     case 0x08:
29421                                           ! 4923 ;
29422                       00008006            .6EF:
29423                                           !BCC_EOS
29424                                           ! 4924       drive = ( ELDX & 0x00ff );
29425                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29426 8006           8A46         0E            mov	al,$E[bp]
29427                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29428 8009           8846         FF            mov	-1[bp],al
29429                                           !BCC_EOS
29430                                           ! 4925       if (drive > 1) {
29431                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29432 800C           8A46         FF            mov	al,-1[bp]
29433 800F           3C                     01  cmp	al,*1
29434 8011           76           30            jbe 	.6F0
29435                       00008013            .6F1:
29436                                           ! 4926         AX = 0;
29437                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$24+$14] (used reg = )
29438 8013           31C0                       xor	ax,ax
29439 8015           8946         16            mov	$16[bp],ax
29440                                           !BCC_EOS
29441                                           ! 4927         B
29442                                           ! 4927 X = 0;
29443                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$24+$E] (used reg = )
29444 8018           31C0                       xor	ax,ax
29445 801A           8946         10            mov	$10[bp],ax
29446                                           !BCC_EOS
29447                                           ! 4928         CX = 0;
29448                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29449 801D           31C0                       xor	ax,ax
29450 801F           8946         14            mov	$14[bp],ax
29451                                           !BCC_EOS
29452                                           ! 4929         DX = 0;
29453                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$24+$10] (used reg = )
29454 8022           31C0                       xor	ax,ax
29455 8024           8946         12            mov	$12[bp],ax
29456                                           !BCC_EOS
29457                                           ! 4930         ES = 0;
29458                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$24+4] (used reg = )
29459 8027           31C0                       xor	ax,ax
29460 8029           8946         06            mov	6[bp],ax
29461                                           !BCC_EOS
29462                                           ! 4931         DI = 0;
29463                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$24+6] (used reg = )
29464 802C           31C0                       xor	ax,ax
29465 802E           8946         08            mov	8[bp],ax
29466                                           !BCC_EOS
29467                                           ! 4932         *((Bit8u *)&DX) = (num_floppies);
29468                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29469 8031           8A46         E7            mov	al,-$19[bp]
29470 8034           8846         12            mov	$12[bp],al
29471                                           !BCC_EOS
29472                                           ! 4933         FLAGS |= 0x0001;
29473                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29474 8037           8B46         1C            mov	ax,$1C[bp]
29475 803A           0C                     01  or	al,*1
29476 803C           8946         1C            mov	$1C[bp],ax
29477                                           !BCC_EOS
29478                                           ! 4934         return;
29479 803F           89EC                       mov	sp,bp
29480 8041           5D                         pop	bp
29481 8042           C3                         ret
29482                                           !BCC_EOS
29483                                           ! 4935       }
29484                                           ! 4936       drive_type = inb_cmos(0x10);
29485                       00008043            .6F0:
29486                                           ! Debug: list int = const $10 (used reg = )
29487 8043           B8                   0010  mov	ax,*$10
29488 8046           50                         push	ax
29489                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29490 8047           E8         8524            call	_inb_cmos
29491 804A           44                         inc	sp
29492 804B           44                         inc	sp
29493                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29494 804C           8846         E8            mov	-$18[bp],al
29495                                           !BCC_EOS
29496                                           ! 4937       num_floppies = 0;
29497                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$24-$1B] (used reg = )
29498 804F           30C0                       xor	al,al
29499 8051           8846         E7            mov	-$19[bp],al
29500                                           !BCC_EOS
29501                                           ! 4938       if (drive_type & 0xf0)
29502                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29503 8054           8A46         E8            mov	al,-$18[bp]
29504 8057           24                     F0  and	al,#$F0
29505 8059           84C0                       test	al,al
29506 805B           74           07            je  	.6F2
29507                       0000805D            .6F3:
29508                                           ! 4939         num_floppies++;
29509                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29510 805D           8A46         E7            mov	al,-$19[bp]
29511 8060           40                         inc	ax
29512 8061           8846         E7            mov	-$19[bp],al
29513                                           !BCC_EOS
29514                                           ! 4940       if (drive_type & 0x0f)
29515                       00008064            .6F2:
29516                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29517 8064           8A46         E8            mov	al,-$18[bp]
29518 8067           24                     0F  and	al,*$F
29519 8069           84C0                       test	al,al
29520 806B           74           07            je  	.6F4
29521                       0000806D            .6F5:
29522                                           ! 4941         num_floppies++;
29523                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29524 806D           8A46         E7            mov	al,-$19[bp]
29525 8070           40                         inc	ax
29526 8071           8846         E7            mov	-$19[bp],al
29527                                           !BCC_EOS
29528                                           ! 4942       if (drive == 0)
29529                       00008074            .6F4:
29530                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29531 8074           8A46         FF            mov	al,-1[bp]
29532 8077           84C0                       test	al,al
29533 8079           75           0E            jne 	.6F6
29534                       0000807B            .6F7:
29535                                           ! 4943         drive_type >>= 4;
29536                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29537 807B           8A46         E8            mov	al,-$18[bp]
29538 807E           30E4                       xor	ah,ah
29539 8080           B1                     04  mov	cl,*4
29540 8082           D3E8                       shr	ax,cl
29541 8084           8846         E8            mov	-$18[bp],al
29542                                           !BCC_EOS
29543                                           ! 4944       else
29544                                           ! 4945         drive_type &= 0x0f;
29545 8087           EB           08            jmp .6F8
29546                       00008089            .6F6:
29547                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29548 8089           8A46         E8            mov	al,-$18[bp]
29549 808C           24                     0F  and	al,*$F
29550 808E           8846         E8            mov	-$18[bp],al
29551                                           !BCC_EOS
29552                                           ! 4946       *(((Bit8u *)&BX)+1) = (0);
29553                       00008091            .6F8:
29554                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$24+$F] (used reg = )
29555 8091           30C0                       xor	al,al
29556 8093           8846         11            mov	$11[bp],al
29557                                           !BCC_EOS
29558                                           ! 4947       *((Bit8u *)&BX) = (drive_type);
29559                                           ! Debug: eq unsigned char drive_type = [S+$24-$1A] to unsigned char BX = [S+$24+$E] (used reg = )
29560 8096           8A46         E8            mov	al,-$18[bp]
29561 8099           8846         10            mov	$10[bp],al
29562                                           !BCC_EOS
29563                                           ! 4948       *(((Bit8u *)&AX)+1) = (0);
29564                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29565 809C           30C0                       xor	al,al
29566 809E           8846         17            mov	$17[bp],al
29567                                           !BCC_EOS
29568                                           ! 4949       *((Bit8u *)&AX) = (0);
29569                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
29570 80A1           30C0                       xor	al,al
29571 80A3           8846         16            mov	$16[bp],al
29572                                           !BCC_EOS
29573                                           ! 4950       *((Bit8u *)&DX) = (num_floppies);
29574                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29575 80A6           8A46         E7            mov	al,-$19[bp]
29576 80A9           8846         12            mov	$12[bp],al
29577                                           !BCC_EOS
29578                                           ! 4951       switch (drive_type) {
29579 80AC           8A46         E8            mov	al,-$18[bp]
29580 80AF           E9         0087            br 	.6FB
29581                                           ! 4952         case 0:
29582                                           ! 4953           CX = 0;
29583                       000080B2            .6FC:
29584                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29585 80B2           31C0                       xor	ax,ax
29586 80B4           8946         14            mov	$14[bp],ax
29587                                           !BCC_EOS
29588                                           ! 4954           *(((Bit8u *)&DX)+1) = (0);
29589                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29590 80B7           30C0                       xor	al,al
29591 80B9           8846         13            mov	$13[bp],al
29592                                           !BCC_EOS
29593                                           ! 4955           break;
29594 80BC           E9         00A1            br 	.6F9
29595                                           !BCC_EOS
29596                                           ! 4956         case 1:
29597                                           ! 4957           CX = 0x2709;
29598                       000080BF            .6FD:
29599                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29600 80BF           B8                   2709  mov	ax,#$2709
29601 80C2           8946         14            mov	$14[bp],ax
29602                                           !BCC_EOS
29603                                           ! 4958           *(((Bit8u *)&DX)+1) = (1);
29604                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29605 80C5           B0                     01  mov	al,*1
29606 80C7           8846         13            mov	$13[bp],al
29607                                           !BCC_EOS
29608                                           ! 4959           break;
29609 80CA           E9         0093            br 	.6F9
29610                                           !BCC_EOS
29611                                           ! 4960         case 2:
29612                                           ! 4961           CX = 0x4f0f;
29613                       000080CD            .6FE:
29614                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$24+$12] (used reg = )
29615 80CD           B8                   4F0F  mov	ax,#$4F0F
29616 80D0           8946         14            mov	$14[bp],ax
29617                                           !BCC_EOS
29618                                           ! 4962           *(((Bit8u *)&DX)+1) = (1);
29619                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29620 80D3           B0                     01  mov	al,*1
29621 80D5           8846         13            mov	$13[bp],al
29622                                           !BCC_EOS
29623                                           ! 4963           break;
29624 80D8           E9         0085            br 	.6F9
29625                                           !BCC_EOS
29626                                           ! 4964         case 3:
29627                                           ! 4965           CX = 0x4f09;
29628                       000080DB            .6FF:
29629                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$24+$12] (used reg = )
29630 80DB           B8                   4F09  mov	ax,#$4F09
29631 80DE           8946         14            mov	$14[bp],ax
29632                                           !BCC_EOS
29633                                           ! 4966           *(((Bit8u *)&DX)+1) = (1);
29634                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29635 80E1           B0                     01  mov	al,*1
29636 80E3           8846         13            mov	$13[bp],al
29637                                           !BCC_EOS
29638                                           ! 4967           break;
29639 80E6           EB           78            jmp .6F9
29640                                           !BCC_EOS
29641                                           ! 4968         case 4:
29642                                           ! 4969           CX = 0x4f12;
29643                       000080E8            .700:
29644                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$24+$12] (used reg = )
29645 80E8           B8                   4F12  mov	ax,#$4F12
29646 80EB           8946         14            mov	$14[bp],ax
29647                                           !BCC_EOS
29648                                           ! 4970           *(((Bit8u *)&DX)+1) = (1);
29649                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29650 80EE           B0                     01  mov	al,*1
29651 80F0           8846         13            mov	$13[bp],al
29652                                           !BCC_EOS
29653                                           ! 4971           break;
29654 80F3           EB           6B            jmp .6F9
29655                                           !BCC_EOS
29656                                           ! 4972         case 5:
29657                                           ! 4973           CX = 0x4f24;
29658                       000080F5            .701:
29659                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$24+$12] (used reg = )
29660 80F5           B8                   4F24  mov	ax,#$4F24
29661 80F8           8946         14            mov	$14[bp],ax
29662                                           !BCC_EOS
29663                                           ! 4974           *(((Bit8u *)&DX)+1) = (1);
29664                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29665 80FB           B0                     01  mov	al,*1
29666 80FD           8846         13            mov	$13[bp],al
29667                                           !BCC_EOS
29668                                           ! 4975           break;
29669 8100           EB           5E            jmp .6F9
29670                                           !BCC_EOS
29671                                           ! 4976         case 6:
29672                                           ! 4977           CX = 0x2708;
29673                       00008102            .702:
29674                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29675 8102           B8                   2708  mov	ax,#$2708
29676 8105           8946         14            mov	$14[bp],ax
29677                                           !BCC_EOS
29678                                           ! 4978           *(((Bit8u *)&DX)+1) = (0);
29679                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29680 8108           30C0                       xor	al,al
29681 810A           8846         13            mov	$13[bp],al
29682                                           !BCC_EOS
29683                                           ! 4979           break;
29684 810D           EB           51            jmp .6F9
29685                                           !BCC_EOS
29686                                           ! 4980         case 7:
29687                                           ! 4981           CX = 0x2709;
29688                       0000810F            .703:
29689                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29690 810F           B8                   2709  mov	ax,#$2709
29691 8112           8946         14            mov	$14[bp],ax
29692                                           !BCC_EOS
29693                                           ! 4982           *(((Bit8u *)&DX)+1) = (0);
29694                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29695 8115           30C0                       xor	al,al
29696 8117           8846         13            mov	$13[bp],al
29697                                           !BCC_EOS
29698                                           ! 4983           break;
29699 811A           EB           44            jmp .6F9
29700                                           !BCC_EOS
29701                                           ! 4984         case 8:
29702                                           ! 4985           CX = 0x2708;
29703                       0000811C            .704:
29704                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29705 811C           B8                   2708  mov	ax,#$2708
29706 811F           8946         14            mov	$14[bp],ax
29707                                           !BCC_EOS
29708                                           ! 4986           *(((Bit8u *)&DX)+1) = (1);
29709                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29710 8122           B0                     01  mov	al,*1
29711 8124           8846         13            mov	$13[bp],al
29712                                           !BCC_EOS
29713                                           ! 4987           break;
29714 8127           EB           37            jmp .6F9
29715                                           !BCC_EOS
29716                                           ! 4988         default:
29717                                           ! 4989           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
29718                       00008129            .705:
29719                                           ! Debug: list * char = .706+0 (used reg = )
29720 8129           BB                   CD72  mov	bx,#.706
29721 812C           53                         push	bx
29722                                           ! Debug: list int = const 7 (used reg = )
29723 812D           B8                   0007  mov	ax,*7
29724 8130           50                         push	ax
29725                                           ! Debug: func () void = bios_printf+0 (used reg = )
29726 8131           E8         8805            call	_bios_printf
29727 8134           83C4                   04  add	sp,*4
29728                                           !BCC_EOS
29729                                           ! 4990         }
29730                                           ! 4991 #asm
29731 8137           EB           27            jmp .6F9
29732                       00008139            .6FB:
29733 8139           2C                     00  sub	al,*0
29734 813B           72           EC            jb 	.705
29735 813D           3C                     08  cmp	al,*8
29736 813F           77           1D            ja  	.707
29737 8141           30E4                       xor	ah,ah
29738 8143           D1E0                       shl	ax,*1
29739 8145           89C3                       mov	bx,ax
29740 8147           2E                         seg	cs
29741 8148           FFA7       814C            br	.708[bx]
29742                       0000814C            .708:
29743 814C                      80B2            .word	.6FC
29744 814E                      80BF            .word	.6FD
29745 8150                      80CD            .word	.6FE
29746 8152                      80DB            .word	.6FF
29747 8154                      80E8            .word	.700
29748 8156                      80F5            .word	.701
29749 8158                      8102            .word	.702
29750 815A                      810F            .word	.703
29751 815C                      811C            .word	.704
29752                       0000815E            .707:
29753 815E           EB           C9            jmp	.705
29754                       00008160            .6F9:
29755                                           !BCC_EOS
29756                                           !BCC_ASM
29757                       0000002E            _int13_diskette_function.BP	set	$2E
29758                       0000000C            .int13_diskette_function.BP	set	$C
29759                       0000003C            _int13_diskette_function.CS	set	$3C
29760                       0000001A            .int13_diskette_function.CS	set	$1A
29761                       00000036            _int13_diskette_function.CX	set	$36
29762                       00000014            .int13_diskette_function.CX	set	$14
29763                       0000001A            _int13_diskette_function.base_address	set	$1A
29764                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29765                       0000002A            _int13_diskette_function.DI	set	$2A
29766                       00000008            .int13_diskette_function.DI	set	8
29767                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29768                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29769                       00000018            _int13_diskette_function.base_count	set	$18
29770                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29771                       0000001E            _int13_diskette_function.sector	set	$1E
29772                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29773                       00000026            _int13_diskette_function.DS	set	$26
29774                       00000004            .int13_diskette_function.DS	set	4
29775                       0000001D            _int13_diskette_function.head	set	$1D
29776                       FFFFFFFB            .int13_diskette_function.head	set	-5
29777                       00000030            _int13_diskette_function.ELDX	set	$30
29778                       0000000E            .int13_diskette_function.ELDX	set	$E
29779                       00000012            _int13_diskette_function.dor	set	$12
29780                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29781                       00000034            _int13_diskette_function.DX	set	$34
29782                       00000012            .int13_diskette_function.DX	set	$12
29783                       0000000B            _int13_diskette_function.return_status	set	$B
29784                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29785                       00000004            _int13_diskette_function.es	set	4
29786                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29787                       00000014            _int13_diskette_function.mode_register	set	$14
29788                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29789                       00000028            _int13_diskette_function.ES	set	$28
29790                       00000006            .int13_diskette_function.ES	set	6
29791                       00000016            _int13_diskette_function.base_es	set	$16
29792                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29793                       0000001F            _int13_diskette_function.track	set	$1F
29794                       FFFFFFFD            .int13_diskette_function.track	set	-3
29795                       0000002C            _int13_diskette_function.SI	set	$2C
29796                       0000000A            .int13_diskette_function.SI	set	$A
29797                       0000000A            _int13_diskette_function.drive_type	set	$A
29798                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29799                       00000020            _int13_diskette_function.num_sectors	set	$20
29800                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29801                       0000003A            _int13_diskette_function.IP	set	$3A
29802                       00000018            .int13_diskette_function.IP	set	$18
29803                       00000007            _int13_diskette_function.spt	set	7
29804                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29805                       0000001C            _int13_diskette_function.status	set	$1C
29806                       FFFFFFFA            .int13_diskette_function.status	set	-6
29807                       00000000            _int13_diskette_function.maxCyl	set	0
29808                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29809                       00000038            _int13_diskette_function.AX	set	$38
29810                       00000016            .int13_diskette_function.AX	set	$16
29811                       00000013            _int13_diskette_function.val8	set	$13
29812                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29813                       00000002            _int13_diskette_function.last_addr	set	2
29814                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29815                       00000015            _int13_diskette_function.page	set	$15
29816                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29817                       00000008            _int13_diskette_function.ah	set	8
29818                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29819                       00000021            _int13_diskette_function.drive	set	$21
29820                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29821                       00000009            _int13_diskette_function.num_floppies	set	9
29822                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29823                       00000032            _int13_diskette_function.BX	set	$32
29824                       00000010            .int13_diskette_function.BX	set	$10
29825 8160           55                               push bp
29826 8161           89E5                             mov bp, sp
29827 8163           B8                   EFDE        mov ax, #diskette_param_table2
29828 8166           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
29829 8169           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
29830 816C           5D                               pop bp
29831                                           ! 4998 endasm
29832                                           !BCC_ENDASM
29833                                           !BCC_EOS
29834                                           ! 4999       FLAGS &= 0xfffe;
29835                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29836 816D           8B46         1C            mov	ax,$1C[bp]
29837 8170           24                     FE  and	al,#$FE
29838 8172           8946         1C            mov	$1C[bp],ax
29839                                           !BCC_EOS
29840                                           ! 5000       return;
29841 8175           89EC                       mov	sp,bp
29842 8177           5D                         pop	bp
29843 8178           C3                         ret
29844                                           !BCC_EOS
29845                                           ! 5001     case 0x15:
29846                                           ! 5002 ;
29847                       00008179            .709:
29848                                           !BCC_EOS
29849                                           ! 5003       drive = ( ELDX & 0x00ff );
29850                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29851 8179           8A46         0E            mov	al,$E[bp]
29852                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29853 817C           8846         FF            mov	-1[bp],al
29854                                           !BCC_EOS
29855                                           ! 5004       if (drive > 1) {
29856                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29857 817F           8A46         FF            mov	al,-1[bp]
29858 8182           3C                     01  cmp	al,*1
29859 8184           76           11            jbe 	.70A
29860                       00008186            .70B:
29861                                           ! 5005         *(((Bit8u *)&AX)+1) = (0);
29862                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29863 8186           30C0                       xor	al,al
29864 8188           8846         17            mov	$17[bp],al
29865                                           !BCC_EOS
29866                                           ! 5006         FLAGS |= 0x0001;
29867                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29868 818B           8B46         1C            mov	ax,$1C[bp]
29869 818E           0C                     01  or	al,*1
29870 8190           8946         1C            mov	$1C[bp],ax
29871                                           !BCC_EOS
29872                                           ! 5007         return;
29873 8193           89EC                       mov	sp,bp
29874 8195           5D                         pop	bp
29875 8196           C3                         ret
29876                                           !BCC_EOS
29877                                           ! 5008       }
29878                                           ! 5009       drive_type = inb_cmos(0x10);
29879                       00008197            .70A:
29880                                           ! Debug: list int = const $10 (used reg = )
29881 8197           B8                   0010  mov	ax,*$10
29882 819A           50                         push	ax
29883                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29884 819B           E8         83D0            call	_inb_cmos
29885 819E           44                         inc	sp
29886 819F           44                         inc	sp
29887                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29888 81A0           8846         E8            mov	-$18[bp],al
29889                                           !BCC_EOS
29890                                           ! 5010       if (drive == 0)
29891                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29892 81A3           8A46         FF            mov	al,-1[bp]
29893 81A6           84C0                       test	al,al
29894 81A8           75           0E            jne 	.70C
29895                       000081AA            .70D:
29896                                           ! 5011         drive_type >>= 4;
29897                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29898 81AA           8A46         E8            mov	al,-$18[bp]
29899 81AD           30E4                       xor	ah,ah
29900 81AF           B1                     04  mov	cl,*4
29901 81B1           D3E8                       shr	ax,cl
29902 81B3           8846         E8            mov	-$18[bp],al
29903                                           !BCC_EOS
29904                                           ! 5012       else
29905                                           ! 5013         drive_type &= 0x
29906 81B6           EB           08            jmp .70E
29907                       000081B8            .70C:
29908                                           ! 5013 0f;
29909                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29910 81B8           8A46         E8            mov	al,-$18[bp]
29911 81BB           24                     0F  and	al,*$F
29912 81BD           8846         E8            mov	-$18[bp],al
29913                                           !BCC_EOS
29914                                           ! 5014       FLAGS &= 0xfffe;
29915                       000081C0            .70E:
29916                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29917 81C0           8B46         1C            mov	ax,$1C[bp]
29918 81C3           24                     FE  and	al,#$FE
29919 81C5           8946         1C            mov	$1C[bp],ax
29920                                           !BCC_EOS
29921                                           ! 5015       if (drive_type==0) {
29922                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29923 81C8           8A46         E8            mov	al,-$18[bp]
29924 81CB           84C0                       test	al,al
29925 81CD           75           07            jne 	.70F
29926                       000081CF            .710:
29927                                           ! 5016         *(((Bit8u *)&AX)+1) = (0);
29928                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29929 81CF           30C0                       xor	al,al
29930 81D1           8846         17            mov	$17[bp],al
29931                                           !BCC_EOS
29932                                           ! 5017       }
29933                                           ! 5018       else {
29934 81D4           EB           05            jmp .711
29935                       000081D6            .70F:
29936                                           ! 5019         *(((Bit8u *)&AX)+1) = (1);
29937                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
29938 81D6           B0                     01  mov	al,*1
29939 81D8           8846         17            mov	$17[bp],al
29940                                           !BCC_EOS
29941                                           ! 5020       }
29942                                           ! 5021       return;
29943                       000081DB            .711:
29944 81DB           89EC                       mov	sp,bp
29945 81DD           5D                         pop	bp
29946 81DE           C3                         ret
29947                                           !BCC_EOS
29948                                           ! 5022     case 0x16:
29949                                           ! 5023 ;
29950                       000081DF            .712:
29951                                           !BCC_EOS
29952                                           ! 5024       drive = ( ELDX & 0x00ff );
29953                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29954 81DF           8A46         0E            mov	al,$E[bp]
29955                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29956 81E2           8846         FF            mov	-1[bp],al
29957                                           !BCC_EOS
29958                                           ! 5025       if (drive > 1) {
29959                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29960 81E5           8A46         FF            mov	al,-1[bp]
29961 81E8           3C                     01  cmp	al,*1
29962 81EA           76           1A            jbe 	.713
29963                       000081EC            .714:
29964                                           ! 5026         *(((Bit8u *)&AX)+1) = (0x01);
29965                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
29966 81EC           B0                     01  mov	al,*1
29967 81EE           8846         17            mov	$17[bp],al
29968                                           !BCC_EOS
29969                                           ! 5027         set_diskette_ret_status(0x01);
29970                                           ! Debug: list int = const 1 (used reg = )
29971 81F1           B8                   0001  mov	ax,*1
29972 81F4           50                         push	ax
29973                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29974 81F5           E8         0434            call	_set_diskette_ret_status
29975 81F8           44                         inc	sp
29976 81F9           44                         inc	sp
29977                                           !BCC_EOS
29978                                           ! 5028         FLAGS |= 0x0001;
29979                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29980 81FA           8B46         1C            mov	ax,$1C[bp]
29981 81FD           0C                     01  or	al,*1
29982 81FF           8946         1C            mov	$1C[bp],ax
29983                                           !BCC_EOS
29984                                           ! 5029         return;
29985 8202           89EC                       mov	sp,bp
29986 8204           5D                         pop	bp
29987 8205           C3                         ret
29988                                           !BCC_EOS
29989                                           ! 5030       }
29990                                           ! 5031       *(((Bit8u *)&AX)+1) = (0x06);
29991                       00008206            .713:
29992                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$24+$15] (used reg = )
29993 8206           B0                     06  mov	al,*6
29994 8208           8846         17            mov	$17[bp],al
29995                                           !BCC_EOS
29996                                           ! 5032       set_diskette_ret_status(0x06);
29997                                           ! Debug: list int = const 6 (used reg = )
29998 820B           B8                   0006  mov	ax,*6
29999 820E           50                         push	ax
30000                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30001 820F           E8         041A            call	_set_diskette_ret_status
30002 8212           44                         inc	sp
30003 8213           44                         inc	sp
30004                                           !BCC_EOS
30005                                           ! 5033       FLAGS |= 0x0001;
30006                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30007 8214           8B46         1C            mov	ax,$1C[bp]
30008 8217           0C                     01  or	al,*1
30009 8219           8946         1C            mov	$1C[bp],ax
30010                                           !BCC_EOS
30011                                           ! 5034       return;
30012 821C           89EC                       mov	sp,bp
30013 821E           5D                         pop	bp
30014 821F           C3                         ret
30015                                           !BCC_EOS
30016                                           ! 5035     case 0x17:
30017                                           ! 5036 ;
30018                       00008220            .715:
30019                                           !BCC_EOS
30020                                           ! 5037       drive = ( ELDX & 0x00ff );
30021                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30022 8220           8A46         0E            mov	al,$E[bp]
30023                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30024 8223           8846         FF            mov	-1[bp],al
30025                                           !BCC_EOS
30026                                           ! 5038       drive_type = ( AX & 0x00ff );
30027                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
30028 8226           8A46         16            mov	al,$16[bp]
30029                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30030 8229           8846         E8            mov	-$18[bp],al
30031                                           !BCC_EOS
30032                                           ! 5039       if (drive > 1) {
30033                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30034 822C           8A46         FF            mov	al,-1[bp]
30035 822F           3C                     01  cmp	al,*1
30036 8231           76           1A            jbe 	.716
30037                       00008233            .717:
30038                                           ! 5040         *(((Bit8u *)&AX)+1) = (0x01);
30039                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30040 8233           B0                     01  mov	al,*1
30041 8235           8846         17            mov	$17[bp],al
30042                                           !BCC_EOS
30043                                           ! 5041         set_diskette_ret_status(1);
30044                                           ! Debug: list int = const 1 (used reg = )
30045 8238           B8                   0001  mov	ax,*1
30046 823B           50                         push	ax
30047                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30048 823C           E8         03ED            call	_set_diskette_ret_status
30049 823F           44                         inc	sp
30050 8240           44                         inc	sp
30051                                           !BCC_EOS
30052                                           ! 5042         FLAGS |= 0x0001;
30053                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30054 8241           8B46         1C            mov	ax,$1C[bp]
30055 8244           0C                     01  or	al,*1
30056 8246           8946         1C            mov	$1C[bp],ax
30057                                           !BCC_EOS
30058                                           ! 5043         return;
30059 8249           89EC                       mov	sp,bp
30060 824B           5D                         pop	bp
30061 824C           C3                         ret
30062                                           !BCC_EOS
30063                                           ! 5044       }
30064                                           ! 5045       if (floppy_drive_exists(drive) == 0) {
30065                       0000824D            .716:
30066                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30067 824D           8A46         FF            mov	al,-1[bp]
30068 8250           30E4                       xor	ah,ah
30069 8252           50                         push	ax
30070                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30071 8253           E8         F4DF            call	_floppy_drive_exists
30072 8256           44                         inc	sp
30073 8257           44                         inc	sp
30074                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30075 8258           85C0                       test	ax,ax
30076 825A           75           1A            jne 	.718
30077                       0000825C            .719:
30078                                           ! 5046         *(((Bit8u *)&AX)+1) = (0x80);
30079                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30080 825C           B0                     80  mov	al,#$80
30081 825E           8846         17            mov	$17[bp],al
30082                                           !BCC_EOS
30083                                           ! 5047         set_diskette_ret_status(0x80);
30084                                           ! Debug: list int = const $80 (used reg = )
30085 8261           B8                   0080  mov	ax,#$80
30086 8264           50                         push	ax
30087                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30088 8265           E8         03C4            call	_set_diskette_ret_status
30089 8268           44                         inc	sp
30090 8269           44                         inc	sp
30091                                           !BCC_EOS
30092                                           ! 5048         FLAGS |= 0x0001;
30093                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30094 826A           8B46         1C            mov	ax,$1C[bp]
30095 826D           0C                     01  or	al,*1
30096 826F           8946         1C            mov	$1C[bp],ax
30097                                           !BCC_EOS
30098                                           ! 5049         return;
30099 8272           89EC                       mov	sp,bp
30100 8274           5D                         pop	bp
30101 8275           C3                         ret
30102                                           !BCC_EOS
30103                                           ! 5050       }
30104                                           ! 5051       base_address = (drive) ? 0x0091 : 0x0090;
30105                       00008276            .718:
30106 8276           8A46         FF            mov	al,-1[bp]
30107 8279           84C0                       test	al,al
30108 827B           74           04            je  	.71A
30109                       0000827D            .71B:
30110 827D           B0                     91  mov	al,#$91
30111 827F           EB           02            jmp .71C
30112                       00008281            .71A:
30113 8281           B0                     90  mov	al,#$90
30114                       00008283            .71C:
30115                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30116 8283           30E4                       xor	ah,ah
30117 8285           8946         F8            mov	-8[bp],ax
30118                                           !BCC_EOS
30119                                           ! 5052       status = *((Bit8u *)(base_address));
30120 8288           8B5E         F8            mov	bx,-8[bp]
30121                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30122 828B           8A07                       mov	al,[bx]
30123 828D           8846         FA            mov	-6[bp],al
30124                                           !BCC_EOS
30125                                           ! 5053       val8 = status & 0x0f;
30126                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30127 8290           8A46         FA            mov	al,-6[bp]
30128 8293           24                     0F  and	al,*$F
30129                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30130 8295           8846         F1            mov	-$F[bp],al
30131                                           !BCC_EOS
30132                                           ! 5054       switch(drive_type) {
30133 8298           8A46         E8            mov	al,-$18[bp]
30134 829B           EB           6A            jmp .71F
30135                                           ! 5055         case 1:
30136                                           ! 5056           val8 |= 0x90;
30137                       0000829D            .720:
30138                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30139 829D           8A46         F1            mov	al,-$F[bp]
30140 82A0           0C                     90  or	al,#$90
30141 82A2           8846         F1            mov	-$F[bp],al
30142                                           !BCC_EOS
30143                                           ! 5057           break;
30144 82A5           EB           72            jmp .71D
30145                                           !BCC_EOS
30146                                           ! 5058         case 2:
30147                                           ! 5059           val8 |= 0x70;
30148                       000082A7            .721:
30149                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30150 82A7           8A46         F1            mov	al,-$F[bp]
30151 82AA           0C                     70  or	al,*$70
30152 82AC           8846         F1            mov	-$F[bp],al
30153                                           !BCC_EOS
30154                                           ! 5060           break;
30155 82AF           EB           68            jmp .71D
30156                                           !BCC_EOS
30157                                           ! 5061         case 3:
30158                                           ! 5062           val8 |= 0x10;
30159                       000082B1            .722:
30160                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30161 82B1           8A46         F1            mov	al,-$F[bp]
30162 82B4           0C                     10  or	al,*$10
30163 82B6           8846         F1            mov	-$F[bp],al
30164                                           !BCC_EOS
30165                                           ! 5063           break;
30166 82B9           EB           5E            jmp .71D
30167                                           !BCC_EOS
30168                                           ! 5064         case 4:
30169                                           ! 5065           if (((status >> 4) & 0x01) && ((status >> 1) & 0x01))
30170                       000082BB            .723:
30171                                           ! Debug: sr int = const 4 to unsigned char status = [S+$24-8] (used reg = )
30172 82BB           8A46         FA            mov	al,-6[bp]
30173 82BE           30E4                       xor	ah,ah
30174 82C0           B1                     04  mov	cl,*4
30175 82C2           D3E8                       shr	ax,cl
30176                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30177 82C4           24                     01  and	al,*1
30178 82C6           84C0                       test	al,al
30179 82C8           74           17            je  	.724
30180                       000082CA            .726:
30181                                           ! Debug: sr int = const 1 to unsigned char status = [S+$24-8] (used reg = )
30182 82CA           8A46         FA            mov	al,-6[bp]
30183 82CD           30E4                       xor	ah,ah
30184 82CF           D1E8                       shr	ax,*1
30185                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30186 82D1           24                     01  and	al,*1
30187 82D3           84C0                       test	al,al
30188 82D5           74           0A            je  	.724
30189                       000082D7            .725:
30190                                           ! 5066           {
30191                                           ! 5067             val8 |= 0x50;
30192                                           ! Debug: orab int = const $50 to unsigned char val8 = [S+$24-$11] (used reg = )
30193 82D7           8A46         F1            mov	al,-$F[bp]
30194 82DA           0C                     50  or	al,*$50
30195 82DC           8846         F1            mov	-$F[bp],al
30196                                           !BCC_EOS
30197                                           ! 5068           }
30198                                           ! 5069           else
30199                                           ! 5070           {
30200 82DF           EB           08            jmp .727
30201                       000082E1            .724:
30202                                           ! 5071             val8 |= 0x90;
30203                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30204 82E1           8A46         F1            mov	al,-$F[bp]
30205 82E4           0C                     90  or	al,#$90
30206 82E6           8846         F1            mov	-$F[bp],al
30207                                           !BCC_EOS
30208                                           ! 5072           }
30209                                           ! 5073           break;
30210                       000082E9            .727:
30211 82E9           EB           2E            jmp .71D
30212                                           !BCC_EOS
30213                                           ! 5074         default:
30214                                           ! 5075           *(((Bit8u *)&AX)+1) = (0x01);
30215                       000082EB            .728:
30216                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30217 82EB           B0                     01  mov	al,*1
30218 82ED           8846         17            mov	$17[bp],al
30219                                           !BCC_EOS
30220                                           ! 5076           set_diskette_ret_status(1);
30221                                           ! Debug: list int = const 1 (used reg = )
30222 82F0           B8                   0001  mov	ax,*1
30223 82F3           50                         push	ax
30224                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30225 82F4           E8         0335            call	_set_diskette_ret_status
30226 82F7           44                         inc	sp
30227 82F8           44                         inc	sp
30228                                           !BCC_EOS
30229                                           ! 5077           FLAGS |= 0x0001;
30230                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30231 82F9           8B46         1C            mov	ax,$1C[bp]
30232 82FC           0C                     01  or	al,*1
30233 82FE           8946         1C            mov	$1C[bp],ax
30234                                           !BCC_EOS
30235                                           ! 5078           return;
30236 8301           89EC                       mov	sp,bp
30237 8303           5D                         pop	bp
30238 8304           C3                         ret
30239                                           !BCC_EOS
30240                                           ! 5079       }
30241                                           ! 5080 ;
30242 8305           EB           12            jmp .71D
30243                       00008307            .71F:
30244 8307           2C                     01  sub	al,*1
30245 8309           74           92            je 	.720
30246 830B           2C                     01  sub	al,*1
30247 830D           74           98            je 	.721
30248 830F           2C                     01  sub	al,*1
30249 8311           74           9E            je 	.722
30250 8313           2C                     01  sub	al,*1
30251 8315           74           A4            je 	.723
30252 8317           EB           D2            jmp	.728
30253                       00008319            .71D:
30254                                           !BCC_EOS
30255                                           ! 5081       *((Bit8u *)(base_address)) = (val8);
30256 8319           8B5E         F8            mov	bx,-8[bp]
30257                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30258 831C           8A46         F1            mov	al,-$F[bp]
30259 831F           8807                       mov	[bx],al
30260                                           !BCC_EOS
30261                                           ! 5082       *(((Bit8u *)&AX)+1) = (0);
30262                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30263 8321           30C0                       xor	al,al
30264 8323           8846         17            mov	$17[bp],al
30265                                           !BCC_EOS
30266                                           ! 5083       set_diskette_ret_status(0);
30267                                           ! Debug: list int = const 0 (used reg = )
30268 8326           31C0                       xor	ax,ax
30269 8328           50                         push	ax
30270                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30271 8329           E8         0300            call	_set_diskette_ret_status
30272 832C           44                         inc	sp
30273 832D           44                         inc	sp
30274                                           !BCC_EOS
30275                                           ! 5084       FLAGS &= 0xfffe;
30276                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30277 832E           8B46         1C            mov	ax,$1C[bp]
30278 8331           24                     FE  and	al,#$FE
30279 8333           8946         1C            mov	$1C[bp],ax
30280                                           !BCC_EOS
30281                                           ! 5085       return;
30282 8336           89EC                       mov	sp,bp
30283 8338           5D                         pop	bp
30284 8339           C3                         ret
30285                                           !BCC_EOS
30286                                           ! 5086     case 0x18:
30287                                           ! 5087 ;
30288                       0000833A            .729:
30289                                           !BCC_EOS
30290                                           ! 5088       drive = ( ELDX & 0x00ff );
30291                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30292 833A           8A46         0E            mov	al,$E[bp]
30293                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30294 833D           8846         FF            mov	-1[bp],al
30295                                           !BCC_EOS
30296                                           ! 5089       val8 = ( CX & 0x00ff );
30297                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
30298 8340           8A46         14            mov	al,$14[bp]
30299                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30300 8343           8846         F1            mov	-$F[bp],al
30301                                           !BCC_EOS
30302                                           ! 5090       spt = val8 & 0x3f;
30303                                           ! Debug: and int = const $3F to unsigned char val8 = [S+$24-$11] (used reg = )
30304 8346           8A46         F1            mov	al,-$F[bp]
30305 8349           24                     3F  and	al,*$3F
30306                                           ! Debug: eq unsigned char = al+0 to unsigned char spt = [S+$24-$1D] (used reg = )
30307 834B           8846         E5            mov	-$1B[bp],al
30308                                           !BCC_EOS
30309                                           ! 5091       maxCyl = ((val8 >> 6) << 8) + *(((Bit8u *)&CX)+1);
30310                                           ! Debug: sr int = const 6 to unsigned char val8 = [S+$24-$11] (used reg = )
30311 834E           8A46         F1            mov	al,-$F[bp]
30312 8351           30E4                       xor	ah,ah
30313 8353           B1                     06  mov	cl,*6
30314 8355           D3E8                       shr	ax,cl
30315                                           ! Debug: sl int = const 8 to unsigned int = ax+0 (used reg = )
30316 8357           88C4                       mov	ah,al
30317 8359           30C0                       xor	al,al
30318                                           ! Debug: add unsigned char CX = [S+$24+$13] to unsigned int = ax+0 (used reg = )
30319 835B           0246         15            add	al,$15[bp]
30320 835E           80D4                   00  adc	ah,*0
30321                                           ! Debug: eq unsigned int = ax+0 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30322 8361           8946         DE            mov	-$22[bp],ax
30323                                           !BCC_EOS
30324                                           ! 5092 ;
30325                                           !BCC_EOS
30326                                           ! 5093       if (drive > 1) {
30327                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30328 8364           8A46         FF            mov	al,-1[bp]
30329 8367           3C                     01  cmp	al,*1
30330 8369           76           1A            jbe 	.72A
30331                       0000836B            .72B:
30332                                           ! 5094         *(((Bit8u *)&AX)+1) = (0x01);
30333                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30334 836B           B0                     01  mov	al,*1
30335 836D           8846         17            mov	$17[bp],al
30336                                           !BCC_EOS
30337                                           ! 5095         set_diskette_ret_status(1);
30338                                           ! Debug: list int = const 1 (used reg = )
30339 8370           B8                   0001  mov	ax,*1
30340 8373           50                         push	ax
30341                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30342 8374           E8         02B5            call	_set_diskette_ret_status
30343 8377           44                         inc	sp
30344 8378           44                         inc	sp
30345                                           !BCC_EOS
30346                                           ! 5096         FLAGS |= 0x0001;
30347                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30348 8379           8B46         1C            mov	ax,$1C[bp]
30349 837C           0C                     01  or	al,*1
30350 837E           8946         1C            mov	$1C[bp],ax
30351                                           !BCC_EOS
30352                                           ! 5097         return;
30353 8381           89EC                       mov	sp,bp
30354 8383           5D                         pop	bp
30355 8384           C3                         ret
30356                                           !BCC_EOS
30357                                           ! 5098       }
30358                                           ! 5099       if (floppy_drive_exists(dri
30359                       00008385            .72A:
30360                                           ! 5099 ve) == 0) {
30361                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30362 8385           8A46         FF            mov	al,-1[bp]
30363 8388           30E4                       xor	ah,ah
30364 838A           50                         push	ax
30365                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30366 838B           E8         F3A7            call	_floppy_drive_exists
30367 838E           44                         inc	sp
30368 838F           44                         inc	sp
30369                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30370 8390           85C0                       test	ax,ax
30371 8392           75           1A            jne 	.72C
30372                       00008394            .72D:
30373                                           ! 5100         *(((Bit8u *)&AX)+1) = (0x80);
30374                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30375 8394           B0                     80  mov	al,#$80
30376 8396           8846         17            mov	$17[bp],al
30377                                           !BCC_EOS
30378                                           ! 5101         set_diskette_ret_status(0x80);
30379                                           ! Debug: list int = const $80 (used reg = )
30380 8399           B8                   0080  mov	ax,#$80
30381 839C           50                         push	ax
30382                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30383 839D           E8         028C            call	_set_diskette_ret_status
30384 83A0           44                         inc	sp
30385 83A1           44                         inc	sp
30386                                           !BCC_EOS
30387                                           ! 5102         FLAGS |= 0x0001;
30388                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30389 83A2           8B46         1C            mov	ax,$1C[bp]
30390 83A5           0C                     01  or	al,*1
30391 83A7           8946         1C            mov	$1C[bp],ax
30392                                           !BCC_EOS
30393                                           ! 5103         return;
30394 83AA           89EC                       mov	sp,bp
30395 83AC           5D                         pop	bp
30396 83AD           C3                         ret
30397                                           !BCC_EOS
30398                                           ! 5104       }
30399                                           ! 5105       if (floppy_media_known(drive) == 0) {
30400                       000083AE            .72C:
30401                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30402 83AE           8A46         FF            mov	al,-1[bp]
30403 83B1           30E4                       xor	ah,ah
30404 83B3           50                         push	ax
30405                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
30406 83B4           E8         F198            call	_floppy_media_known
30407 83B7           44                         inc	sp
30408 83B8           44                         inc	sp
30409                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30410 83B9           85C0                       test	ax,ax
30411 83BB           75           29            jne 	.72E
30412                       000083BD            .72F:
30413                                           ! 5106         if (floppy_media_sense(drive) == 0) {
30414                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30415 83BD           8A46         FF            mov	al,-1[bp]
30416 83C0           30E4                       xor	ah,ah
30417 83C2           50                         push	ax
30418                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
30419 83C3           E8         F1F9            call	_floppy_media_sense
30420 83C6           44                         inc	sp
30421 83C7           44                         inc	sp
30422                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30423 83C8           85C0                       test	ax,ax
30424 83CA           75           1A            jne 	.730
30425                       000083CC            .731:
30426                                           ! 5107           *(((Bit8u *)&AX)+1) = (0x0C);
30427                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30428 83CC           B0                     0C  mov	al,*$C
30429 83CE           8846         17            mov	$17[bp],al
30430                                           !BCC_EOS
30431                                           ! 5108           set_diskette_ret_status(0x0C);
30432                                           ! Debug: list int = const $C (used reg = )
30433 83D1           B8                   000C  mov	ax,*$C
30434 83D4           50                         push	ax
30435                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30436 83D5           E8         0254            call	_set_diskette_ret_status
30437 83D8           44                         inc	sp
30438 83D9           44                         inc	sp
30439                                           !BCC_EOS
30440                                           ! 5109           FLAGS |= 0x0001;
30441                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30442 83DA           8B46         1C            mov	ax,$1C[bp]
30443 83DD           0C                     01  or	al,*1
30444 83DF           8946         1C            mov	$1C[bp],ax
30445                                           !BCC_EOS
30446                                           ! 5110           return;
30447 83E2           89EC                       mov	sp,bp
30448 83E4           5D                         pop	bp
30449 83E5           C3                         ret
30450                                           !BCC_EOS
30451                                           ! 5111         }
30452                                           ! 5112       }
30453                       000083E6            .730:
30454                                           ! 5113       drive_type = inb_cmos(0x10);
30455                       000083E6            .72E:
30456                                           ! Debug: list int = const $10 (used reg = )
30457 83E6           B8                   0010  mov	ax,*$10
30458 83E9           50                         push	ax
30459                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30460 83EA           E8         8181            call	_inb_cmos
30461 83ED           44                         inc	sp
30462 83EE           44                         inc	sp
30463                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30464 83EF           8846         E8            mov	-$18[bp],al
30465                                           !BCC_EOS
30466                                           ! 5114       if (drive == 0)
30467                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
30468 83F2           8A46         FF            mov	al,-1[bp]
30469 83F5           84C0                       test	al,al
30470 83F7           75           0E            jne 	.732
30471                       000083F9            .733:
30472                                           ! 5115         drive_type >>= 4;
30473                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30474 83F9           8A46         E8            mov	al,-$18[bp]
30475 83FC           30E4                       xor	ah,ah
30476 83FE           B1                     04  mov	cl,*4
30477 8400           D3E8                       shr	ax,cl
30478 8402           8846         E8            mov	-$18[bp],al
30479                                           !BCC_EOS
30480                                           ! 5116       else
30481                                           ! 5117         drive_type &= 0x0f;
30482 8405           EB           08            jmp .734
30483                       00008407            .732:
30484                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
30485 8407           8A46         E8            mov	al,-$18[bp]
30486 840A           24                     0F  and	al,*$F
30487 840C           8846         E8            mov	-$18[bp],al
30488                                           !BCC_EOS
30489                                           ! 5118       base_address = (drive) ? 0x0091 : 0x0090;
30490                       0000840F            .734:
30491 840F           8A46         FF            mov	al,-1[bp]
30492 8412           84C0                       test	al,al
30493 8414           74           04            je  	.735
30494                       00008416            .736:
30495 8416           B0                     91  mov	al,#$91
30496 8418           EB           02            jmp .737
30497                       0000841A            .735:
30498 841A           B0                     90  mov	al,#$90
30499                       0000841C            .737:
30500                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30501 841C           30E4                       xor	ah,ah
30502 841E           8946         F8            mov	-8[bp],ax
30503                                           !BCC_EOS
30504                                           ! 5119       status = *((Bit8u *)(base_address));
30505 8421           8B5E         F8            mov	bx,-8[bp]
30506                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30507 8424           8A07                       mov	al,[bx]
30508 8426           8846         FA            mov	-6[bp],al
30509                                           !BCC_EOS
30510                                           ! 5120       val8 = status & 0x0f;
30511                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30512 8429           8A46         FA            mov	al,-6[bp]
30513 842C           24                     0F  and	al,*$F
30514                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30515 842E           8846         F1            mov	-$F[bp],al
30516                                           !BCC_EOS
30517                                           ! 5121       *(((Bit8u *)&AX)+1) = (0x0C);
30518                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30519 8431           B0                     0C  mov	al,*$C
30520 8433           8846         17            mov	$17[bp],al
30521                                           !BCC_EOS
30522                                           ! 5122       switch (drive_type) {
30523 8436           8A46         E8            mov	al,-$18[bp]
30524 8439           E9         010F            br 	.73A
30525                                           ! 5123         case 0:
30526                                           ! 5124           break;
30527                       0000843C            .73B:
30528 843C           E9         0133            br 	.738
30529                                           !BCC_EOS
30530                                           ! 5125         case 1:
30531                                           ! 5126         case 6:
30532                       0000843F            .73C:
30533                                           ! 5127         case 7:
30534                       0000843F            .73D:
30535                                           ! 5128         case 8:
30536                       0000843F            .73E:
30537                                           ! 5129           if (maxCyl == 39 && (spt == 8 || spt == 9))
30538                       0000843F            .73F:
30539                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30540 843F           8B46         DE            mov	ax,-$22[bp]
30541 8442           3D                   0027  cmp	ax,*$27
30542 8445           75           1B            jne 	.740
30543                       00008447            .742:
30544                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30545 8447           8A46         E5            mov	al,-$1B[bp]
30546 844A           3C                     08  cmp	al,*8
30547 844C           74           07            je  	.741
30548                       0000844E            .743:
30549                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30550 844E           8A46         E5            mov	al,-$1B[bp]
30551 8451           3C                     09  cmp	al,*9
30552 8453           75           0D            jne 	.740
30553                       00008455            .741:
30554                                           ! 5130           {
30555                                           ! 5131             val8 |= 0x90;
30556                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30557 8455           8A46         F1            mov	al,-$F[bp]
30558 8458           0C                     90  or	al,#$90
30559 845A           8846         F1            mov	-$F[bp],al
30560                                           !BCC_EOS
30561                                           ! 5132             *(((Bit8u *)&AX)+1) = (0);
30562                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30563 845D           30C0                       xor	al,al
30564 845F           8846         17            mov	$17[bp],al
30565                                           !BCC_EOS
30566                                           ! 5133           }
30567                                           ! 5134           break;
30568                       00008462            .740:
30569 8462           E9         010D            br 	.738
30570                                           !BCC_EOS
30571                                           ! 5135         case 2:
30572                                           ! 5136           if (maxCyl == 39 && (spt == 8 || spt == 9))
30573                       00008465            .744:
30574                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30575 8465           8B46         DE            mov	ax,-$22[bp]
30576 8468           3D                   0027  cmp	ax,*$27
30577 846B           75           1D            jne 	.745
30578                       0000846D            .747:
30579                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30580 846D           8A46         E5            mov	al,-$1B[bp]
30581 8470           3C                     08  cmp	al,*8
30582 8472           74           07            je  	.746
30583                       00008474            .748:
30584                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30585 8474           8A46         E5            mov	al,-$1B[bp]
30586 8477           3C                     09  cmp	al,*9
30587 8479           75           0F            jne 	.745
30588                       0000847B            .746:
30589                                           ! 5137           {
30590                                           ! 5138             val8 |= 0x70;
30591                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30592 847B           8A46         F1            mov	al,-$F[bp]
30593 847E           0C                     70  or	al,*$70
30594 8480           8846         F1            mov	-$F[bp],al
30595                                           !BCC_EOS
30596                                           ! 5139             *(((Bit8u *)&AX)+1) = (0);
30597                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30598 8483           30C0                       xor	al,al
30599 8485           8846         17            mov	$17[bp],al
30600                                           !BCC_EOS
30601                                           ! 5140           }
30602                                           ! 5141           else if (maxCyl == 79 && spt == 15)
30603 8488           EB           1C            jmp .749
30604                       0000848A            .745:
30605                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30606 848A           8B46         DE            mov	ax,-$22[bp]
30607 848D           3D                   004F  cmp	ax,*$4F
30608 8490           75           14            jne 	.74A
30609                       00008492            .74C:
30610                                           ! Debug: logeq int = const $F to unsigned char spt = [S+$24-$1D] (used reg = )
30611 8492           8A46         E5            mov	al,-$1B[bp]
30612 8495           3C                     0F  cmp	al,*$F
30613 8497           75           0D            jne 	.74A
30614                       00008499            .74B:
30615                                           ! 5142           {
30616                                           ! 5143             val8 |= 0x10;
30617                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30618 8499           8A46         F1            mov	al,-$F[bp]
30619 849C           0C                     10  or	al,*$10
30620 849E           8846         F1            mov	-$F[bp],al
30621                                           !BCC_EOS
30622                                           ! 5144             *(((Bit8u *)&AX)+1) = (0);
30623                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30624 84A1           30C0                       xor	al,al
30625 84A3           8846         17            mov	$17[bp],al
30626                                           !BCC_EOS
30627                                           ! 5145           }
30628                                           ! 5146           break;
30629                       000084A6            .74A:
30630                       000084A6            .749:
30631 84A6           E9         00C9            br 	.738
30632                                           !BCC_EOS
30633                                           ! 5147         case 3:
30634                                           ! 5148           if (maxCyl == 79 && spt == 9)
30635                       000084A9            .74D:
30636                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30637 84A9           8B46         DE            mov	ax,-$22[bp]
30638 84AC           3D                   004F  cmp	ax,*$4F
30639 84AF           75           14            jne 	.74E
30640                       000084B1            .750:
30641                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30642 84B1           8A46         E5            mov	al,-$1B[bp]
30643 84B4           3C                     09  cmp	al,*9
30644 84B6           75           0D            jne 	.74E
30645                       000084B8            .74F:
30646                                           ! 5149           {
30647                                           ! 5150             val8 |= 0x90;
30648                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30649 84B8           8A46         F1            mov	al,-$F[bp]
30650 84BB           0C                     90  or	al,#$90
30651 84BD           8846         F1            mov	-$F[bp],al
30652                                           !BCC_EOS
30653                                           ! 5151             *(((Bit8u *)&AX)+1) = (0);
30654                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30655 84C0           30C0                       xor	al,al
30656 84C2           8846         17            mov	$17[bp],al
30657                                           !BCC_EOS
30658                                           ! 5152           }
30659                                           ! 5153           break;
30660                       000084C5            .74E:
30661 84C5           E9         00AA            br 	.738
30662                                           !BCC_EOS
30663                                           ! 5154         case 4:
30664                                           ! 5155           if (maxCyl == 79)
30665                       000084C8            .751:
30666                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30667 84C8           8B46         DE            mov	ax,-$22[bp]
30668 84CB           3D                   004F  cmp	ax,*$4F
30669 84CE           75           2A            jne 	.752
30670                       000084D0            .753:
30671                                           ! 5156           {
30672                                           ! 5157             if (spt == 9)
30673                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30674 84D0           8A46         E5            mov	al,-$1B[bp]
30675 84D3           3C                     09  cmp	al,*9
30676 84D5           75           0F            jne 	.754
30677                       000084D7            .755:
30678                                           ! 5158             {
30679                                           ! 5159               val8 |= 0x90;
30680                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30681 84D7           8A46         F1            mov	al,-$F[bp]
30682 84DA           0C                     90  or	al,#$90
30683 84DC           8846         F1            mov	-$F[bp],al
30684                                           !BCC_EOS
30685                                           ! 5160               *(((Bit8u *)&AX)+1) = (0);
30686                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30687 84DF           30C0                       xor	al,al
30688 84E1           8846         17            mov	$17[bp],al
30689                                           !BCC_EOS
30690                                           ! 5161             }
30691                                           ! 5162             else if (spt == 18)
30692 84E4           EB           14            jmp .756
30693                       000084E6            .754:
30694                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30695 84E6           8A46         E5            mov	al,-$1B[bp]
30696 84E9           3C                     12  cmp	al,*$12
30697 84EB           75           0D            jne 	.757
30698                       000084ED            .758:
30699                                           ! 5163             {
30700                                           ! 5164               val8 |= 0x10;
30701                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30702 84ED           8A46         F1            mov	al,-$F[bp]
30703 84F0           0C                     10  or	al,*$10
30704 84F2           8846         F1            mov	-$F[bp],al
30705                                           !BCC_EOS
30706                                           ! 5165               *(((Bit8u *)&AX)+1) = (0);
30707                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30708 84F5           30C0                       xor	al,al
30709 84F7           8846         17            mov	$17[bp],al
30710                                           !BCC_EOS
30711                                           ! 5166             }
30712                                           ! 5167           }
30713                       000084FA            .757:
30714                       000084FA            .756:
30715                                           ! 5168           break;
30716                       000084FA            .752:
30717 84FA           E9         0075            br 	.738
30718                                           !BCC_EOS
30719                                           ! 5169         case 5:
30720                                           ! 5170           if (maxCyl == 79)
30721                       000084FD            .759:
30722                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30723 84FD           8B46         DE            mov	ax,-$22[bp]
30724 8500           3D                   004F  cmp	ax,*$4F
30725 8503           75           40            jne 	.75A
30726                       00008505            .75B:
30727                                           ! 5171           {
30728                                           ! 5172             if (spt == 9)
30729                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30730 8505           8A46         E5            mov	al,-$1B[bp]
30731 8508           3C                     09  cmp	al,*9
30732 850A           75           0F            jne 	.75C
30733                       0000850C            .75D:
30734                                           ! 5173             {
30735                                           ! 5174               val8 |= 0x90;
30736                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30737 850C           8A46         F1            mov	al,-$F[bp]
30738 850F           0C                     90  or	al,#$90
30739 8511           8846         F1            mov	-$F[bp],al
30740                                           !BCC_EOS
30741                                           ! 5175               *(((Bit8u *)&AX)+1) = (0);
30742                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30743 8514           30C0                       xor	al,al
30744 8516           8846         17            mov	$17[bp],al
30745                                           !BCC_EOS
30746                                           ! 5176             }
30747                                           ! 5177             else if (spt == 18)
30748 8519           EB           2A            jmp .75E
30749                       0000851B            .75C:
30750                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30751 851B           8A46         E5            mov	al,-$1B[bp]
30752 851E           3C                     12  cmp	al,*$12
30753 8520           75           0F            jne 	.75F
30754                       00008522            .760:
30755                                           ! 5178             {
30756                                           ! 5179               val8 |= 0x10;
30757                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30758 8522           8A46         F1            mov	al,-$F[bp]
30759 8525           0C                     10  or	al,*$10
30760 8527           8846         F1            mov	-$F[bp],al
30761                                           !BCC_EOS
30762                                           ! 5180               *(((Bit8u *)&AX)+1) = (0);
30763                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30764 852A           30C0                       xor	al,al
30765 852C           8846         17            mov	$17[bp],al
30766                                           !BCC_EOS
30767                                           ! 5181           
30768                                           ! 5181   }
30769                                           ! 5182             else if (spt == 36)
30770 852F           EB           14            jmp .761
30771                       00008531            .75F:
30772                                           ! Debug: logeq int = const $24 to unsigned char spt = [S+$24-$1D] (used reg = )
30773 8531           8A46         E5            mov	al,-$1B[bp]
30774 8534           3C                     24  cmp	al,*$24
30775 8536           75           0D            jne 	.762
30776                       00008538            .763:
30777                                           ! 5183             {
30778                                           ! 5184               val8 |= 0xD0;
30779                                           ! Debug: orab int = const $D0 to unsigned char val8 = [S+$24-$11] (used reg = )
30780 8538           8A46         F1            mov	al,-$F[bp]
30781 853B           0C                     D0  or	al,#$D0
30782 853D           8846         F1            mov	-$F[bp],al
30783                                           !BCC_EOS
30784                                           ! 5185               *(((Bit8u *)&AX)+1) = (0);
30785                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30786 8540           30C0                       xor	al,al
30787 8542           8846         17            mov	$17[bp],al
30788                                           !BCC_EOS
30789                                           ! 5186             }
30790                                           ! 5187           }
30791                       00008545            .762:
30792                       00008545            .761:
30793                       00008545            .75E:
30794                                           ! 5188           break;
30795                       00008545            .75A:
30796 8545           EB           2B            jmp .738
30797                                           !BCC_EOS
30798                                           ! 5189         default:
30799                                           ! 5190           break;
30800                       00008547            .764:
30801 8547           EB           29            jmp .738
30802                                           !BCC_EOS
30803                                           ! 5191       }
30804                                           ! 5192       if (0 != *(((Bit8u *)&AX)+1))
30805 8549           EB           27            jmp .738
30806                       0000854B            .73A:
30807 854B           2C                     00  sub	al,*0
30808 854D           72           F8            jb 	.764
30809 854F           3C                     08  cmp	al,*8
30810 8551           77           1D            ja  	.765
30811 8553           30E4                       xor	ah,ah
30812 8555           D1E0                       shl	ax,*1
30813 8557           89C3                       mov	bx,ax
30814 8559           2E                         seg	cs
30815 855A           FFA7       855E            br	.766[bx]
30816                       0000855E            .766:
30817 855E                      843C            .word	.73B
30818 8560                      843F            .word	.73C
30819 8562                      8465            .word	.744
30820 8564                      84A9            .word	.74D
30821 8566                      84C8            .word	.751
30822 8568                      84FD            .word	.759
30823 856A                      843F            .word	.73D
30824 856C                      843F            .word	.73E
30825 856E                      843F            .word	.73F
30826                       00008570            .765:
30827 8570           EB           D5            jmp	.764
30828                       00008572            .738:
30829                                           ! Debug: ne unsigned char AX = [S+$24+$15] to int = const 0 (used reg = )
30830                                           ! Debug: expression subtree swapping
30831 8572           8A46         17            mov	al,$17[bp]
30832 8575           84C0                       test	al,al
30833 8577           74           17            je  	.767
30834                       00008579            .768:
30835                                           ! 5193       {
30836                                           ! 5194         set_diskette_ret_status(*(((Bit8u *)&AX)+1));
30837                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30838 8579           8A46         17            mov	al,$17[bp]
30839 857C           30E4                       xor	ah,ah
30840 857E           50                         push	ax
30841                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30842 857F           E8         00AA            call	_set_diskette_ret_status
30843 8582           44                         inc	sp
30844 8583           44                         inc	sp
30845                                           !BCC_EOS
30846                                           ! 5195         FLAGS |= 0x0001;
30847                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30848 8584           8B46         1C            mov	ax,$1C[bp]
30849 8587           0C                     01  or	al,*1
30850 8589           8946         1C            mov	$1C[bp],ax
30851                                           !BCC_EOS
30852                                           ! 5196         return;
30853 858C           89EC                       mov	sp,bp
30854 858E           5D                         pop	bp
30855 858F           C3                         ret
30856                                           !BCC_EOS
30857                                           ! 5197       }
30858                                           ! 5198 ;
30859                       00008590            .767:
30860                                           !BCC_EOS
30861                                           ! 5199       *((Bit8u *)(base_address)) = (val8);
30862 8590           8B5E         F8            mov	bx,-8[bp]
30863                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30864 8593           8A46         F1            mov	al,-$F[bp]
30865 8596           8807                       mov	[bx],al
30866                                           !BCC_EOS
30867                                           ! 5200 #asm
30868                                           !BCC_EOS
30869                                           !BCC_ASM
30870                       0000002E            _int13_diskette_function.BP	set	$2E
30871                       0000000C            .int13_diskette_function.BP	set	$C
30872                       0000003C            _int13_diskette_function.CS	set	$3C
30873                       0000001A            .int13_diskette_function.CS	set	$1A
30874                       00000036            _int13_diskette_function.CX	set	$36
30875                       00000014            .int13_diskette_function.CX	set	$14
30876                       0000001A            _int13_diskette_function.base_address	set	$1A
30877                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30878                       0000002A            _int13_diskette_function.DI	set	$2A
30879                       00000008            .int13_diskette_function.DI	set	8
30880                       0000003E            _int13_diskette_function.FLAGS	set	$3E
30881                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30882                       00000018            _int13_diskette_function.base_count	set	$18
30883                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30884                       0000001E            _int13_diskette_function.sector	set	$1E
30885                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30886                       00000026            _int13_diskette_function.DS	set	$26
30887                       00000004            .int13_diskette_function.DS	set	4
30888                       0000001D            _int13_diskette_function.head	set	$1D
30889                       FFFFFFFB            .int13_diskette_function.head	set	-5
30890                       00000030            _int13_diskette_function.ELDX	set	$30
30891                       0000000E            .int13_diskette_function.ELDX	set	$E
30892                       00000012            _int13_diskette_function.dor	set	$12
30893                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30894                       00000034            _int13_diskette_function.DX	set	$34
30895                       00000012            .int13_diskette_function.DX	set	$12
30896                       0000000B            _int13_diskette_function.return_status	set	$B
30897                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30898                       00000004            _int13_diskette_function.es	set	4
30899                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
30900                       00000014            _int13_diskette_function.mode_register	set	$14
30901                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30902                       00000028            _int13_diskette_function.ES	set	$28
30903                       00000006            .int13_diskette_function.ES	set	6
30904                       00000016            _int13_diskette_function.base_es	set	$16
30905                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30906                       0000001F            _int13_diskette_function.track	set	$1F
30907                       FFFFFFFD            .int13_diskette_function.track	set	-3
30908                       0000002C            _int13_diskette_function.SI	set	$2C
30909                       0000000A            .int13_diskette_function.SI	set	$A
30910                       0000000A            _int13_diskette_function.drive_type	set	$A
30911                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30912                       00000020            _int13_diskette_function.num_sectors	set	$20
30913                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30914                       0000003A            _int13_diskette_function.IP	set	$3A
30915                       00000018            .int13_diskette_function.IP	set	$18
30916                       00000007            _int13_diskette_function.spt	set	7
30917                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
30918                       0000001C            _int13_diskette_function.status	set	$1C
30919                       FFFFFFFA            .int13_diskette_function.status	set	-6
30920                       00000000            _int13_diskette_function.maxCyl	set	0
30921                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
30922                       00000038            _int13_diskette_function.AX	set	$38
30923                       00000016            .int13_diskette_function.AX	set	$16
30924                       00000013            _int13_diskette_function.val8	set	$13
30925                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30926                       00000002            _int13_diskette_function.last_addr	set	2
30927                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
30928                       00000015            _int13_diskette_function.page	set	$15
30929                       FFFFFFF3            .int13_diskette_function.page	set	-$D
30930                       00000008            _int13_diskette_function.ah	set	8
30931                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
30932                       00000021            _int13_diskette_function.drive	set	$21
30933                       FFFFFFFF            .int13_diskette_function.drive	set	-1
30934                       00000009            _int13_diskette_function.num_floppies	set	9
30935                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
30936                       00000032            _int13_diskette_function.BX	set	$32
30937                       00000010            .int13_diskette_function.BX	set	$10
30938 8598           55                               push bp
30939 8599           89E5                             mov bp, sp
30940 859B           B8                   EFDE        mov ax, #diskette_param_table2
30941 859E           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
30942 85A1           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
30943 85A4           5D                               pop bp
30944                                           ! 5207 endasm
30945                                           !BCC_ENDASM
30946                                           !BCC_EOS
30947                                           ! 5208       set_diskette_ret_status(0);
30948                                           ! Debug: list int = const 0 (used reg = )
30949 85A5           31C0                       xor	ax,ax
30950 85A7           50                         push	ax
30951                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30952 85A8           E8         0081            call	_set_diskette_ret_status
30953 85AB           44                         inc	sp
30954 85AC           44                         inc	sp
30955                                           !BCC_EOS
30956                                           ! 5209       FLAGS &= 0xfffe;
30957                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30958 85AD           8B46         1C            mov	ax,$1C[bp]
30959 85B0           24                     FE  and	al,#$FE
30960 85B2           8946         1C            mov	$1C[bp],ax
30961                                           !BCC_EOS
30962                                           ! 5210       return;
30963 85B5           89EC                       mov	sp,bp
30964 85B7           5D                         pop	bp
30965 85B8           C3                         ret
30966                                           !BCC_EOS
30967                                           ! 5211     default:
30968                                           ! 5212         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
30969                       000085B9            .769:
30970                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30971 85B9           8A46         17            mov	al,$17[bp]
30972 85BC           30E4                       xor	ah,ah
30973 85BE           50                         push	ax
30974                                           ! Debug: list * char = .76A+0 (used reg = )
30975 85BF           BB                   CD4D  mov	bx,#.76A
30976 85C2           53                         push	bx
30977                                           ! Debug: list int = const 4 (used reg = )
30978 85C3           B8                   0004  mov	ax,*4
30979 85C6           50                         push	ax
30980                                           ! Debug: func () void = bios_printf+0 (used reg = )
30981 85C7           E8         836F            call	_bios_printf
30982 85CA           83C4                   06  add	sp,*6
30983                                           !BCC_EOS
30984                                           ! 5213         *(((Bit8u *)&AX)+1) = (0x01);
30985                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30986 85CD           B0                     01  mov	al,*1
30987 85CF           8846         17            mov	$17[bp],al
30988                                           !BCC_EOS
30989                                           ! 5214         set_diskette_ret_status(1);
30990                                           ! Debug: list int = const 1 (used reg = )
30991 85D2           B8                   0001  mov	ax,*1
30992 85D5           50                         push	ax
30993                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30994 85D6           E8         0053            call	_set_diskette_ret_status
30995 85D9           44                         inc	sp
30996 85DA           44                         inc	sp
30997                                           !BCC_EOS
30998                                           ! 5215         FLAGS |= 0x0001;
30999                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31000 85DB           8B46         1C            mov	ax,$1C[bp]
31001 85DE           0C                     01  or	al,*1
31002 85E0           8946         1C            mov	$1C[bp],ax
31003                                           !BCC_EOS
31004                                           ! 5216         return;
31005 85E3           89EC                       mov	sp,bp
31006 85E5           5D                         pop	bp
31007 85E6           C3                         ret
31008                                           !BCC_EOS
31009                                           ! 5217     }
31010                                           ! 5218 }
31011 85E7           EB           3F            jmp .696
31012                       000085E9            .698:
31013 85E9           2C                     00  sub	al,*0
31014 85EB           72           CC            jb 	.769
31015 85ED           3C                     08  cmp	al,*8
31016 85EF           77           1D            ja  	.76B
31017 85F1           30E4                       xor	ah,ah
31018 85F3           D1E0                       shl	ax,*1
31019 85F5           89C3                       mov	bx,ax
31020 85F7           2E                         seg	cs
31021 85F8           FFA7       85FC            br	.76C[bx]
31022                       000085FC            .76C:
31023 85FC                      778F            .word	.699
31024 85FE                      7828            .word	.6A1
31025 8600                      784F            .word	.6A4
31026 8602                      784F            .word	.6A5
31027 8604                      784F            .word	.6A6
31028 8606                      7CA3            .word	.6CF
31029 8608                      85B9            .word	.769
31030 860A                      85B9            .word	.769
31031 860C                      8006            .word	.6EF
31032                       0000860E            .76B:
31033 860E           2C                     15  sub	al,*$15
31034 8610         0F84         FB65            beq 	.709
31035 8614           2C                     01  sub	al,*1
31036 8616         0F84         FBC5            beq 	.712
31037 861A           2C                     01  sub	al,*1
31038 861C         0F84         FC00            beq 	.715
31039 8620           2C                     01  sub	al,*1
31040 8622         0F84         FD14            beq 	.729
31041 8626           EB           91            jmp	.769
31042                       00008628            .696:
31043                       FFFFFFDC            ..FFDB	=	-$24
31044                       FFFFFFDC            ..FFDA	=	-$24
31045 8628           89EC                       mov	sp,bp
31046 862A           5D                         pop	bp
31047 862B           C3                         ret
31048                                           ! 5219  void
31049                                           ! Register BX used in function int13_diskette_function
31050                                           ! 5220 set_diskette_ret_status(value)
31051                                           ! 5221   Bit8u value;
31052                                           export	_set_diskette_ret_status
31053                       0000862C            _set_diskette_ret_status:
31054                                           !BCC_EOS
31055                                           ! 5222 {
31056                                           ! 5223   _write_byte(value, 0x0041, 0x0040);
31057 862C           55                         push	bp
31058 862D           89E5                       mov	bp,sp
31059                                           ! Debug: list int = const $40 (used reg = )
31060 862F           B8                   0040  mov	ax,*$40
31061 8632           50                         push	ax
31062                                           ! Debug: list int = const $41 (used reg = )
31063 8633           B8                   0041  mov	ax,*$41
31064 8636           50                         push	ax
31065                                           ! Debug: list unsigned char value = [S+6+2] (used reg = )
31066 8637           8A46         04            mov	al,4[bp]
31067 863A           30E4                       xor	ah,ah
31068 863C           50                         push	ax
31069                                           ! Debug: func () void = _write_byte+0 (used reg = )
31070 863D           E8         7FBB            call	__write_byte
31071 8640           89EC                       mov	sp,bp
31072                                           !BCC_EOS
31073                                           ! 5224 }
31074 8642           5D                         pop	bp
31075 8643           C3                         ret
31076                                           ! 5225   void
31077                                           ! 5226 set_diskette_current_cyl(drive, cyl)
31078                                           ! 5227   Bit8u drive;
31079                                           export	_set_diskette_current_cyl
31080                       00008644            _set_diskette_current_cyl:
31081                                           !BCC_EOS
31082                                           ! 5228   Bit8u cyl;
31083                                           !BCC_EOS
31084                                           ! 5229 {
31085                                           ! 5230   if (drive > 1)
31086 8644           55                         push	bp
31087 8645           89E5                       mov	bp,sp
31088                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
31089 8647           8A46         04            mov	al,4[bp]
31090 864A           3C                     01  cmp	al,*1
31091 864C           76           0D            jbe 	.76D
31092                       0000864E            .76E:
31093                                           ! 5231     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
31094                                           ! Debug: list * char = .76F+0 (used reg = )
31095 864E           BB                   CD26  mov	bx,#.76F
31096 8651           53                         push	bx
31097                                           ! Debug: list int = const 7 (used reg = )
31098 8652           B8                   0007  mov	ax,*7
31099 8655           50                         push	ax
31100                                           ! Debug: func () void = bios_printf+0 (used reg = )
31101 8656           E8         82E0            call	_bios_printf
31102 8659           89EC                       mov	sp,bp
31103                                           !BCC_EOS
31104                                           ! 5232   _write_byte(cyl, 0x0094+drive, 0x0040);
31105                       0000865B            .76D:
31106                                           ! Debug: list int = const $40 (used reg = )
31107 865B           B8                   0040  mov	ax,*$40
31108 865E           50                         push	ax
31109                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
31110                                           ! Debug: expression subtree swapping
31111 865F           8A46         04            mov	al,4[bp]
31112 8662           30E4                       xor	ah,ah
31113                                           ! Debug: list unsigned int = ax+$94 (used reg = )
31114 8664           05                   0094  add	ax,#$94
31115 8667           50                         push	ax
31116                                           ! Debug: list unsigned char cyl = [S+6+4] (used reg = )
31117 8668           8A46         06            mov	al,6[bp]
31118 866B           30E4                       xor	ah,ah
31119 866D           50                         push	ax
31120                                           ! Debug: func () void = _write_byte+0 (used reg = )
31121 866E           E8         7F8A            call	__write_byte
31122 8671           89EC                       mov	sp,bp
31123                                           !BCC_EOS
31124                                           ! 5233 }
31125 8673           5D                         pop	bp
31126 8674           C3                         ret
31127                                           ! 5234   void
31128                                           ! Register BX used in function set_diskette_current_cyl
31129                                           ! 5235 determine_floppy_media(drive)
31130                                           ! 5236   Bit16u drive;
31131                                           export	_determine_floppy_media
31132                       00008675            _determine_floppy_media:
31133                                           !BCC_EOS
31134                                           ! 5237 {
31135                                           ! 5238 }
31136 8675           C3                         ret
31137                                           ! 5239   void
31138                                           ! 5240 int17_function(regs, ds, iret_addr)
31139                                           ! 5241   pusha_regs_t regs;
31140                                           export	_int17_function
31141                       00008676            _int17_function:
31142                                           !BCC_EOS
31143                                           ! 5242   Bit16u ds;
31144                                           !BCC_EOS
31145                                           ! 5243   iret_addr_t iret_addr;
31146                                           !BCC_EOS
31147                                           ! 5244 {
31148                                           ! 5245   Bit16u addr,timeout;
31149                                           !BCC_EOS
31150                                           ! 5246   Bit8u val8;
31151                                           !BCC_EOS
31152                                           ! 5247 #asm
31153 8676           55                         push	bp
31154 8677           89E5                       mov	bp,sp
31155 8679           83C4                   FA  add	sp,*-6
31156                                           !BCC_EOS
31157                                           !BCC_ASM
31158                       0000001A            _int17_function.ds	set	$1A
31159                       00000014            .int17_function.ds	set	$14
31160                       00000002            _int17_function.timeout	set	2
31161                       FFFFFFFC            .int17_function.timeout	set	-4
31162                       00000001            _int17_function.val8	set	1
31163                       FFFFFFFB            .int17_function.val8	set	-5
31164                       0000001C            _int17_function.iret_addr	set	$1C
31165                       00000016            .int17_function.iret_addr	set	$16
31166                       00000004            _int17_function.addr	set	4
31167                       FFFFFFFE            .int17_function.addr	set	-2
31168                       0000000A            _int17_function.regs	set	$A
31169                       00000004            .int17_function.regs	set	4
31170 867C           FB                           sti
31171                                           ! 5249 endasm
31172                                           !BCC_ENDASM
31173                                           !BCC_EOS
31174                                           ! 5250   addr = *((Bit16u *)(0x0400 + (regs.u.r16.dx << 1) + 8));
31175                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
31176 867D           8B46         0E            mov	ax,$E[bp]
31177 8680           D1E0                       shl	ax,*1
31178                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
31179                                           ! Debug: expression subtree swapping
31180                                           ! Debug: add int = const 8 to unsigned int = ax+$400 (used reg = )
31181                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$408 (used reg = )
31182 8682           89C3                       mov	bx,ax
31183                                           ! Debug: eq unsigned short = [bx+$408] to unsigned short addr = [S+8-4] (used reg = )
31184 8684           8B9F       0408            mov	bx,$408[bx]
31185 8688           895E         FE            mov	-2[bp],bx
31186                                           !BCC_EOS
31187                                           ! 5251   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
31188                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
31189 868B           8A46         13            mov	al,$13[bp]
31190 868E           3C                     03  cmp	al,*3
31191 8690         0F83         00FF            bhis	.770
31192                       00008694            .773:
31193                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
31194 8694           8B46         0E            mov	ax,$E[bp]
31195 8697           3D                   0003  cmp	ax,*3
31196 869A         0F83         00F5            bhis	.770
31197                       0000869E            .772:
31198                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
31199 869E           8B46         FE            mov	ax,-2[bp]
31200 86A1           85C0                       test	ax,ax
31201 86A3         0F84         00EC            beq 	.770
31202                       000086A7            .771:
31203                                           ! 5252     *(((Bit8u *)&timeout)+1) = *((Bit8u *)(0x0478 + regs.u.r16.dx));
31204                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $478 (used reg = )
31205                                           ! Debug: expression subtree swapping
31206 86A7           8B46         0E            mov	ax,$E[bp]
31207                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$478 (used reg = )
31208 86AA           89C3                       mov	bx,ax
31209                                           ! Debug: eq unsigned char = [bx+$478] to unsigned char timeout = [S+8-5] (used reg = )
31210 86AC           8A87       0478            mov	al,$478[bx]
31211 86B0           8846         FD            mov	-3[bp],al
31212                                           !BCC_EOS
31213                                           ! 5253     *((Bit8u *)&timeout) = 0;
31214                                           ! Debug: eq int = const 0 to unsigned char timeout = [S+8-6] (used reg = )
31215 86B3           30C0                       xor	al,al
31216 86B5           8846         FC            mov	-4[bp],al
31217                                           !BCC_EOS
31218                                           ! 5254     if (regs.u.r8.ah == 0) {
31219                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
31220 86B8           8A46         13            mov	al,$13[bp]
31221 86BB           84C0                       test	al,al
31222 86BD         0F85         0066            bne 	.774
31223                       000086C1            .775:
31224                                           ! 5255       outb(addr, regs.u.r8.al);
31225                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
31226 86C1           8A46         12            mov	al,$12[bp]
31227 86C4           30E4                       xor	ah,ah
31228 86C6           50                         push	ax
31229                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
31230 86C7           FF76         FE            push	-2[bp]
31231                                           ! Debug: func () void = outb+0 (used reg = )
31232 86CA           E8         7E72            call	_outb
31233 86CD           83C4                   04  add	sp,*4
31234                                           !BCC_EOS
31235                                           ! 5256       val8 = inb(addr+2);
31236                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31237 86D0           8B46         FE            mov	ax,-2[bp]
31238                                           ! Debug: list unsigned int = ax+2 (used reg = )
31239 86D3           40                         inc	ax
31240 86D4           40                         inc	ax
31241 86D5           50                         push	ax
31242                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31243 86D6           E8         7E50            call	_inb
31244 86D9           44                         inc	sp
31245 86DA           44                         inc	sp
31246                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31247 86DB           8846         FB            mov	-5[bp],al
31248                                           !BCC_EOS
31249                                           ! 5257       outb(addr+2, val8 | 0x01);
31250                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
31251 86DE           8A46         FB            mov	al,-5[bp]
31252 86E1           0C                     01  or	al,*1
31253                                           ! Debug: list unsigned char = al+0 (used reg = )
31254 86E3           30E4                       xor	ah,ah
31255 86E5           50                         push	ax
31256                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31257 86E6           8B46         FE            mov	ax,-2[bp]
31258                                           ! Debug: list unsigned int = ax+2 (used reg = )
31259 86E9           40                         inc	ax
31260 86EA           40                         inc	ax
31261 86EB           50                         push	ax
31262                                           ! Debug: func () void = outb+0 (used reg = )
31263 86EC           E8         7E50            call	_outb
31264 86EF           83C4                   04  add	sp,*4
31265                                           !BCC_EOS
31266                                           ! 5258 #asm
31267                                           !BCC_EOS
31268                                           !BCC_ASM
31269                       0000001A            _int17_function.ds	set	$1A
31270                       00000014            .int17_function.ds	set	$14
31271                       00000002            _int17_function.timeout	set	2
31272                       FFFFFFFC            .int17_function.timeout	set	-4
31273                       00000001            _int17_function.val8	set	1
31274                       FFFFFFFB            .int17_function.val8	set	-5
31275                       0000001C            _int17_function.iret_addr	set	$1C
31276                       00000016            .int17_function.iret_addr	set	$16
31277                       00000004            _int17_function.addr	set	4
31278                       FFFFFFFE            .int17_function.addr	set	-2
31279                       0000000A            _int17_function.regs	set	$A
31280                       00000004            .int17_function.regs	set	4
31281 86F2           90                               nop
31282                                           ! 5260 endasm
31283                                           !BCC_ENDASM
31284                                           !BCC_EOS
31285                                           ! 5261       outb(addr+2, val8 & ~0x01);
31286                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
31287 86F3           8A46         FB            mov	al,-5[bp]
31288 86F6           24                     FE  and	al,#$FE
31289                                           ! Debug: list unsigned char = al+0 (used reg = )
31290 86F8           30E4                       xor	ah,ah
31291 86FA           50                         push	ax
31292                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31293 86FB           8B46         FE            mov	ax,-2[bp]
31294                                           ! Debug: list unsigned int = ax+2 (used reg = )
31295 86FE           40                         inc	ax
31296 86FF           40                         inc	ax
31297 8700           50                         push	ax
31298                                           ! Debug: func () void = outb+0 (used reg = )
31299 8701           E8         7E3B            call	_outb
31300 8704           83C4                   04  add	sp,*4
31301                                           !BCC_EOS
31302                                           ! 5262       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
31303 8707           EB           07            jmp .777
31304                       00008709            .778:
31305                                           ! 5263         timeout--;
31306                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
31307 8709           8B46         FC            mov	ax,-4[bp]
31308 870C           48                         dec	ax
31309 870D           8946         FC            mov	-4[bp],ax
31310                                           !BCC_EOS
31311                                           ! 5264       }
31312                                           ! 5265     }
31313                       00008710            .777:
31314                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31315 8710           8B46         FE            mov	ax,-2[bp]
31316                                           ! Debug: list unsigned int = ax+1 (used reg = )
31317 8713           40                         inc	ax
31318 8714           50                         push	ax
31319                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31320 8715           E8         7E11            call	_inb
31321 8718           44                         inc	sp
31322 8719           44                         inc	sp
31323                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
31324 871A           24                     40  and	al,*$40
31325                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
31326 871C           3C                     40  cmp	al,*$40
31327 871E           75           07            jne 	.779
31328                       00008720            .77A:
31329 8720           8B46         FC            mov	ax,-4[bp]
31330 8723           85C0                       test	ax,ax
31331 8725           75           E2            jne	.778
31332                       00008727            .779:
31333                       00008727            .776:
31334                                           ! 5266     if (regs.u.r8.ah == 1) {
31335                       00008727            .774:
31336                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31337 8727           8A46         13            mov	al,$13[bp]
31338 872A           3C                     01  cmp	al,*1
31339 872C           75           37            jne 	.77B
31340                       0000872E            .77C:
31341                                           ! 5267       val8 = inb(addr+2);
31342                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31343 872E           8B46         FE            mov	ax,-2[bp]
31344                                           ! Debug: list unsigned int = ax+2 (used reg = )
31345 8731           40                         inc	ax
31346 8732           40                         inc	ax
31347 8733           50                         push	ax
31348                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31349 8734           E8         7DF2            call	_inb
31350 8737           44                         inc	sp
31351 8738           44                         inc	sp
31352                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31353 8739           8846         FB            mov	-5[bp],al
31354                                           !BCC_EOS
31355                                           ! 5268       outb(addr+2, val8 & ~0x04);
31356                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
31357 873C           8A46         FB            mov	al,-5[bp]
31358 873F           24                     FB  and	al,#$FB
31359                                           ! Debug: list unsigned char = al+0 (used reg = )
31360 8741           30E4                       xor	ah,ah
31361 8743           50                         push	ax
31362                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31363 8744           8B46         FE            mov	ax,-2[bp]
31364                                           ! Debug: list unsigned int = ax+2 (used reg = )
31365 8747           40                         inc	ax
31366 8748           40                         inc	ax
31367 8749           50                         push	ax
31368                                           ! Debug: func () void = outb+0 (used reg = )
31369 874A           E8         7DF2            call	_outb
31370 874D           83C4                   04  add	sp,*4
31371                                           !BCC_EOS
31372                                           ! 5269 #asm
31373                                           !BCC_EOS
31374                                           !BCC_ASM
31375                       0000001A            _int17_function.ds	set	$1A
31376                       00000014            .int17_function.ds	set	$14
31377                       00000002            _int17_function.timeout	set	2
31378                       FFFFFFFC            .int17_function.timeout	set	-4
31379                       00000001            _int17_function.val8	set	1
31380                       FFFFFFFB            .int17_function.val8	set	-5
31381                       0000001C            _int17_function.iret_addr	set	$1C
31382                       00000016            .int17_function.iret_addr	set	$16
31383                       00000004            _int17_function.addr	set	4
31384                       FFFFFFFE            .int17_function.addr	set	-2
31385                       0000000A            _int17_function.regs	set	$A
31386                       00000004            .int17_function.regs	set	4
31387 8750           90                               nop
31388                                           ! 5271 endasm
31389                                           !BCC_ENDASM
31390                                           !BCC_EOS
31391                                           ! 5272       outb(addr+2, val8 | 0x04);
31392                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
31393 8751           8A46         FB            mov	al,-5[bp]
31394 8754           0C                     04  or	al,*4
31395                                           ! Debug: list unsigned char = al+0 (used reg = )
31396 8756           30E4                       xor	ah,ah
31397 8758           50                         push	ax
31398                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31399 8759           8B46         FE            mov	ax,-2[bp]
31400                                           ! Debug: list unsigned int = ax+2 (used reg = )
31401 875C           40                         inc	ax
31402 875D           40                         inc	ax
31403 875E           50                         push	ax
31404                                           ! Debug: func () void = outb+0 (used reg = )
31405 875F           E8         7DDD            call	_outb
31406 8762           83C4                   04  add	sp,*4
31407                                           !BCC_EOS
31408                                           ! 5273     }
31409                                           ! 5274     va
31410                                           ! 5274 l8 = inb(addr+1);
31411                       00008765            .77B:
31412                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31413 8765           8B46         FE            mov	ax,-2[bp]
31414                                           ! Debug: list unsigned int = ax+1 (used reg = )
31415 8768           40                         inc	ax
31416 8769           50                         push	ax
31417                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31418 876A           E8         7DBC            call	_inb
31419 876D           44                         inc	sp
31420 876E           44                         inc	sp
31421                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31422 876F           8846         FB            mov	-5[bp],al
31423                                           !BCC_EOS
31424                                           ! 5275     regs.u.r8.ah = (val8 ^ 0x48);
31425                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
31426 8772           8A46         FB            mov	al,-5[bp]
31427 8775           34                     48  xor	al,*$48
31428                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
31429 8777           8846         13            mov	$13[bp],al
31430                                           !BCC_EOS
31431                                           ! 5276     if (!timeout) regs.u.r8.ah |= 0x01;
31432 877A           8B46         FC            mov	ax,-4[bp]
31433 877D           85C0                       test	ax,ax
31434 877F           75           08            jne 	.77D
31435                       00008781            .77E:
31436                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31437 8781           8A46         13            mov	al,$13[bp]
31438 8784           0C                     01  or	al,*1
31439 8786           8846         13            mov	$13[bp],al
31440                                           !BCC_EOS
31441                                           ! 5277     iret_addr.flags.u.r8.flagsl &= 0xfe;
31442                       00008789            .77D:
31443                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
31444 8789           8A46         1A            mov	al,$1A[bp]
31445 878C           24                     FE  and	al,#$FE
31446 878E           8846         1A            mov	$1A[bp],al
31447                                           !BCC_EOS
31448                                           ! 5278   } else {
31449 8791           EB           08            jmp .77F
31450                       00008793            .770:
31451                                           ! 5279     iret_addr.flags.u.r8.flagsl |= 0x01;
31452                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
31453 8793           8A46         1A            mov	al,$1A[bp]
31454 8796           0C                     01  or	al,*1
31455 8798           8846         1A            mov	$1A[bp],al
31456                                           !BCC_EOS
31457                                           ! 5280   }
31458                                           ! 5281 }
31459                       0000879B            .77F:
31460 879B           89EC                       mov	sp,bp
31461 879D           5D                         pop	bp
31462 879E           C3                         ret
31463                                           ! 5282 void
31464                                           ! Register BX used in function int17_function
31465                                           ! 5283 int19_function(seq_nr)
31466                                           ! 5284 Bit16u seq_nr;
31467                                           export	_int19_function
31468                       0000879F            _int19_function:
31469                                           !BCC_EOS
31470                                           ! 5285 {
31471                                           ! 5286   Bit16u ebda_seg=*((Bit16u *)(0x040E));
31472 879F           55                         push	bp
31473 87A0           89E5                       mov	bp,sp
31474 87A2           4C                         dec	sp
31475 87A3           4C                         dec	sp
31476                                           ! Debug: eq unsigned short = [+$40E] to unsigned short ebda_seg = [S+4-4] (used reg = )
31477 87A4           A1         040E            mov	ax,[$40E]
31478 87A7           8946         FE            mov	-2[bp],ax
31479                                           !BCC_EOS
31480                                           ! 5287   Bit16u bootdev;
31481                                           !BCC_EOS
31482                                           ! 5288   Bit8u bootdrv;
31483                                           !BCC_EOS
31484                                           ! 5289   Bit8u bootchk;
31485                                           !BCC_EOS
31486                                           ! 5290   Bit16u bootseg;
31487                                           !BCC_EOS
31488                                           ! 5291   Bit16u bootip;
31489                                           !BCC_EOS
31490                                           ! 5292   Bit16u status;
31491                                           !BCC_EOS
31492                                           ! 5293   Bit16u bootfirst;
31493                                           !BCC_EOS
31494                                           ! 5294   ipl_entry_t e;
31495                                           !BCC_EOS
31496                                           ! 5295   bootdev = inb_cmos(0x3d);
31497 87AA           83C4                   E4  add	sp,*-$1C
31498                                           ! Debug: list int = const $3D (used reg = )
31499 87AD           B8                   003D  mov	ax,*$3D
31500 87B0           50                         push	ax
31501                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31502 87B1           E8         7DBA            call	_inb_cmos
31503 87B4           44                         inc	sp
31504 87B5           44                         inc	sp
31505                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31506 87B6           30E4                       xor	ah,ah
31507 87B8           8946         FC            mov	-4[bp],ax
31508                                           !BCC_EOS
31509                                           ! 5296   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
31510                                           ! Debug: list int = const $38 (used reg = )
31511 87BB           B8                   0038  mov	ax,*$38
31512 87BE           50                         push	ax
31513                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31514 87BF           E8         7DAC            call	_inb_cmos
31515 87C2           44                         inc	sp
31516 87C3           44                         inc	sp
31517                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
31518 87C4           24                     F0  and	al,#$F0
31519                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
31520 87C6           30E4                       xor	ah,ah
31521 87C8           B1                     04  mov	cl,*4
31522 87CA           D3E0                       shl	ax,cl
31523                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31524 87CC           0B46         FC            or	ax,-4[bp]
31525 87CF           8946         FC            mov	-4[bp],ax
31526                                           !BCC_EOS
31527                                           ! 5297   bootdev >>= 4 * seq_nr;
31528                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
31529                                           ! Debug: expression subtree swapping
31530 87D2           8B46         04            mov	ax,4[bp]
31531 87D5           D1E0                       shl	ax,*1
31532 87D7           D1E0                       shl	ax,*1
31533                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31534 87D9           89C3                       mov	bx,ax
31535 87DB           8B46         FC            mov	ax,-4[bp]
31536 87DE           89D9                       mov	cx,bx
31537 87E0           D3E8                       shr	ax,cl
31538 87E2           8946         FC            mov	-4[bp],ax
31539                                           !BCC_EOS
31540                                           ! 5298   bootdev &= 0xf;
31541                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
31542 87E5           8A46         FC            mov	al,-4[bp]
31543 87E8           24                     0F  and	al,*$F
31544 87EA           30E4                       xor	ah,ah
31545 87EC           8946         FC            mov	-4[bp],ax
31546                                           !BCC_EOS
31547                                           ! 5299   bootfirst = _read_word(0x0084, 0x9ff0);
31548                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31549 87EF           B8                   9FF0  mov	ax,#$9FF0
31550 87F2           50                         push	ax
31551                                           ! Debug: list int = const $84 (used reg = )
31552 87F3           B8                   0084  mov	ax,#$84
31553 87F6           50                         push	ax
31554                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31555 87F7           E8         7DF3            call	__read_word
31556 87FA           83C4                   04  add	sp,*4
31557                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
31558 87FD           8946         F2            mov	-$E[bp],ax
31559                                           !BCC_EOS
31560                                           ! 5300   if (bootfirst != 0xFFFF) {
31561                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
31562 8800           8B46         F2            mov	ax,-$E[bp]
31563 8803           3D                   FFFF  cmp	ax,#$FFFF
31564 8806           74           2C            je  	.780
31565                       00008808            .781:
31566                                           ! 5301     bootdev = bootfirst;
31567                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
31568 8808           8B46         F2            mov	ax,-$E[bp]
31569 880B           8946         FC            mov	-4[bp],ax
31570                                           !BCC_EOS
31571                                           ! 5302     _write_word(0xFFFF, 0x0084, 0x9ff0);
31572                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31573 880E           B8                   9FF0  mov	ax,#$9FF0
31574 8811           50                         push	ax
31575                                           ! Debug: list int = const $84 (used reg = )
31576 8812           B8                   0084  mov	ax,#$84
31577 8815           50                         push	ax
31578                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31579 8816           B8                   FFFF  mov	ax,#$FFFF
31580 8819           50                         push	ax
31581                                           ! Debug: func () void = _write_word+0 (used reg = )
31582 881A           E8         7DF1            call	__write_word
31583 881D           83C4                   06  add	sp,*6
31584                                           !BCC_EOS
31585                                           ! 5303     _write_word(0xFFFF, 0x0082, 0x9ff0);
31586                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31587 8820           B8                   9FF0  mov	ax,#$9FF0
31588 8823           50                         push	ax
31589                                           ! Debug: list int = const $82 (used reg = )
31590 8824           B8                   0082  mov	ax,#$82
31591 8827           50                         push	ax
31592                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31593 8828           B8                   FFFF  mov	ax,#$FFFF
31594 882B           50                         push	ax
31595                                           ! Debug: func () void = _write_word+0 (used reg = )
31596 882C           E8         7DDF            call	__write_word
31597 882F           83C4                   06  add	sp,*6
31598                                           !BCC_EOS
31599                                           ! 5304   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
31600 8832           EB           15            jmp .782
31601                       00008834            .780:
31602                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
31603 8834           8B46         FC            mov	ax,-4[bp]
31604 8837           85C0                       test	ax,ax
31605 8839           75           0E            jne 	.783
31606                       0000883B            .784:
31607                                           ! Debug: list * char = .785+0 (used reg = )
31608 883B           BB                   CD11  mov	bx,#.785
31609 883E           53                         push	bx
31610                                           ! Debug: list int = const 7 (used reg = )
31611 883F           B8                   0007  mov	ax,*7
31612 8842           50                         push	ax
31613                                           ! Debug: func () void = bios_printf+0 (used reg = )
31614 8843           E8         80F3            call	_bios_printf
31615 8846           83C4                   04  add	sp,*4
31616                                           !BCC_EOS
31617                                           ! 5305   bootdev -= 1;
31618                       00008849            .783:
31619                       00008849            .782:
31620                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
31621 8849           8B46         FC            mov	ax,-4[bp]
31622 884C           48                         dec	ax
31623 884D           8946         FC            mov	-4[bp],ax
31624                                           !BCC_EOS
31625                                           ! 5306   if (get_boot_vector(bootdev, &e) == 0) {
31626                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31627 8850           8D5E         E2            lea	bx,-$1E[bp]
31628 8853           53                         push	bx
31629                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
31630 8854           FF76         FC            push	-4[bp]
31631                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
31632 8857           E8         8B0F            call	_get_boot_vector
31633 885A           83C4                   04  add	sp,*4
31634                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
31635 885D           84C0                       test	al,al
31636 885F           75           15            jne 	.786
31637                       00008861            .787:
31638                                           ! 5307     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
31639                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
31640 8861           FF76         FC            push	-4[bp]
31641                                           ! Debug: list * char = .788+0 (used reg = )
31642 8864           BB                   CCF5  mov	bx,#.788
31643 8867           53                         push	bx
31644                                           ! Debug: list int = const 4 (used reg = )
31645 8868           B8                   0004  mov	ax,*4
31646 886B           50                         push	ax
31647                                           ! Debug: func () void = bios_printf+0 (used reg = )
31648 886C           E8         80CA            call	_bios_printf
31649 886F           83C4                   06  add	sp,*6
31650                                           !BCC_EOS
31651                                           ! 5308     return;
31652 8872           89EC                       mov	sp,bp
31653 8874           5D                         pop	bp
31654 8875           C3                         ret
31655                                           !BCC_EOS
31656                                           ! 5309   }
31657                                           ! 5310   print_boot_device(&e);
31658                       00008876            .786:
31659                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31660 8876           8D5E         E2            lea	bx,-$1E[bp]
31661 8879           53                         push	bx
31662                                           ! Debug: func () void = print_boot_device+0 (used reg = )
31663 887A           E8         8D35            call	_print_boot_device
31664 887D           44                         inc	sp
31665 887E           44                         inc	sp
31666                                           !BCC_EOS
31667                                           ! 5311   switch(e.type) {
31668 887F           8B46         E2            mov	ax,-$1E[bp]
31669 8882           E9         0106            br 	.78B
31670                                           ! 5312   case 0x01:
31671                                           ! 5313   case 0x02:
31672                       00008885            .78C:
31673                                           ! 5314     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
31674                       00008885            .78D:
31675                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
31676 8885           8B46         E2            mov	ax,-$1E[bp]
31677 8888           3D                   0002  cmp	ax,*2
31678 888B           75           04            jne 	.78E
31679                       0000888D            .78F:
31680 888D           B0                     80  mov	al,#$80
31681 888F           EB           02            jmp .790
31682                       00008891            .78E:
31683 8891           30C0                       xor	al,al
31684                       00008893            .790:
31685                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
31686 8893           8846         FB            mov	-5[bp],al
31687                                           !BCC_EOS
31688                                           ! 5315     bootseg = 0x07c0;
31689                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31690 8896           B8                   07C0  mov	ax,#$7C0
31691 8899           8946         F8            mov	-8[bp],ax
31692                                           !BCC_EOS
31693                                           ! 5316     status = 0;
31694                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31695 889C           31C0                       xor	ax,ax
31696 889E           8946         F4            mov	-$C[bp],ax
31697                                           !BCC_EOS
31698                                           ! 5317 #asm
31699                                           !BCC_EOS
31700                                           !BCC_ASM
31701                       00000014            _int19_function.bootip	set	$14
31702                       FFFFFFF6            .int19_function.bootip	set	-$A
31703                       00000022            _int19_function.seq_nr	set	$22
31704                       00000004            .int19_function.seq_nr	set	4
31705                       00000018            _int19_function.bootchk	set	$18
31706                       FFFFFFFA            .int19_function.bootchk	set	-6
31707                       00000016            _int19_function.bootseg	set	$16
31708                       FFFFFFF8            .int19_function.bootseg	set	-8
31709                       0000001C            _int19_function.ebda_seg	set	$1C
31710                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31711                       00000012            _int19_function.status	set	$12
31712                       FFFFFFF4            .int19_function.status	set	-$C
31713                       00000010            _int19_function.bootfirst	set	$10
31714                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31715                       00000019            _int19_function.bootdrv	set	$19
31716                       FFFFFFFB            .int19_function.bootdrv	set	-5
31717                       0000001A            _int19_function.bootdev	set	$1A
31718                       FFFFFFFC            .int19_function.bootdev	set	-4
31719                       00000000            _int19_function.e	set	0
31720                       FFFFFFE2            .int19_function.e	set	-$1E
31721 88A1           55                             push bp
31722 88A2           89E5                           mov bp, sp
31723 88A4           50                             push ax
31724 88A5           53                             push bx
31725 88A6           51                             push cx
31726 88A7           52                             push dx
31727 88A8           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
31728 88AB           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
31729 88AE           8EC0                           mov es, ax ;; segment
31730 88B0           31DB                           xor bx, bx ;; offset
31731 88B2           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
31732 88B4           B0                     01      mov al, #0x01 ;; read 1 sector
31733 88B6           B5                     00      mov ch, #0x00 ;; track 0
31734 88B8           B1                     01      mov cl, #0x01 ;; sector 1
31735 88BA           B6                     00      mov dh, #0x00 ;; head 0
31736 88BC           CD                     13      int #0x13 ;; read sector
31737 88BE           73           06                jnc int19_load_done
31738 88C0           B8                   0001      mov ax, #0x0001
31739 88C3           8946         14                mov _int19_function.status + 2[bp], ax
31740                       000088C6            int19_load_done:
31741 88C6           5A                             pop dx
31742 88C7           59                             pop cx
31743 88C8           5B                             pop bx
31744 88C9           58                             pop ax
31745 88CA           5D                             pop bp
31746                                           ! 5343 endasm
31747                                           !BCC_ENDASM
31748                                           !BCC_EOS
31749                                           ! 5344     if (status != 0) {
31750                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31751 88CB           8B46         F4            mov	ax,-$C[bp]
31752 88CE           85C0                       test	ax,ax
31753 88D0           74           11            je  	.791
31754                       000088D2            .792:
31755                                           ! 5345       print_boot_failure(e.type, 1);
31756                                           ! Debug: list int = const 1 (used reg = )
31757 88D2           B8                   0001  mov	ax,*1
31758 88D5           50                         push	ax
31759                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31760 88D6           FF76         E2            push	-$1E[bp]
31761                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31762 88D9           E8         8DA0            call	_print_boot_failure
31763 88DC           83C4                   04  add	sp,*4
31764                                           !BCC_EOS
31765                                           ! 5346       return;
31766 88DF           89EC                       mov	sp,bp
31767 88E1           5D                         pop	bp
31768 88E2           C3                         ret
31769                                           !BCC_EOS
31770                                           ! 5347     }
31771                                           ! 5348     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
31772                       000088E3            .791:
31773                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
31774 88E3           8B46         E2            mov	ax,-$1E[bp]
31775 88E6           3D                   0001  cmp	ax,*1
31776 88E9           75           0F            jne 	.794
31777                       000088EB            .795:
31778                                           ! Debug: list int = const $38 (used reg = )
31779 88EB           B8                   0038  mov	ax,*$38
31780 88EE           50                         push	ax
31781                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31782 88EF           E8         7C7C            call	_inb_cmos
31783 88F2           44                         inc	sp
31784 88F3           44                         inc	sp
31785                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
31786 88F4           24                     01  and	al,*1
31787 88F6           84C0                       test	al,al
31788 88F8           75           22            jne 	.793
31789                       000088FA            .794:
31790                                           ! 5349       if (_read_word(0x1fe, bootseg) != 0xaa55) {
31791                                           ! Debug: list unsigned short bootseg = [S+$20-$A] (used reg = )
31792 88FA           FF76         F8            push	-8[bp]
31793                                           ! Debug: list int = const $1FE (used reg = )
31794 88FD           B8                   01FE  mov	ax,#$1FE
31795 8900           50                         push	ax
31796                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31797 8901           E8         7CE9            call	__read_word
31798 8904           83C4                   04  add	sp,*4
31799                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
31800 8907           3D                   AA55  cmp	ax,#$AA55
31801 890A           74           10            je  	.796
31802                       0000890C            .797:
31803                                           ! 5350         print_boot_failure(e.type, 0);
31804                                           ! Debug: list int = const 0 (used reg = )
31805 890C           31C0                       xor	ax,ax
31806 890E           50                         push	ax
31807                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31808 890F           FF76         E2            push	-$1E[bp]
31809                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31810 8912           E8         8D67            call	_print_boot_failure
31811 8915           83C4                   04  add	sp,*4
31812                                           !BCC_EOS
31813                                           ! 5351         return;
31814 8918           89EC                       mov	sp,bp
31815 891A           5D                         pop	bp
31816 891B           C3                         ret
31817                                           !BCC_EOS
31818                                           ! 5352       }
31819                                           ! 5353     }
31820                       0000891C            .796:
31821                                           ! 5354     bootip = (bootseg & 0x0fff) << 4;
31822                       0000891C            .793:
31823                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
31824 891C           8B46         F8            mov	ax,-8[bp]
31825 891F           25                   0FFF  and	ax,#$FFF
31826                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
31827 8922           B1                     04  mov	cl,*4
31828 8924           D3E0                       shl	ax,cl
31829                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
31830 8926           8946         F6            mov	-$A[bp],ax
31831                                           !BCC_EOS
31832                                           ! 5355     bootseg &= 0xf000;
31833                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
31834 8929           8B46         F8            mov	ax,-8[bp]
31835 892C           25                   F000  and	ax,#$F000
31836 892F           8946         F8            mov	-8[bp],ax
31837                                           !BCC_EOS
31838                                           ! 5356   break;
31839 8932           EB           71            jmp .789
31840                                           !BCC_EOS
31841                                           ! 5357   case 0x03:
31842                                           ! 5358     status = cdrom_boot();
31843                       00008934            .798:
31844                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
31845 8934           E8         AC7D            call	_cdrom_boot
31846                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
31847 8937           8946         F4            mov	-$C[bp],ax
31848                                           !BCC_EOS
31849                                           ! 5359     if ( 
31850                                           ! 5359 (status & 0x00ff) !=0 ) {
31851                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
31852 893A           8A46         F4            mov	al,-$C[bp]
31853                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31854 893D           84C0                       test	al,al
31855 893F           74           19            je  	.799
31856                       00008941            .79A:
31857                                           ! 5360       print_cdromboot_failure(status);
31858                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
31859 8941           FF76         F4            push	-$C[bp]
31860                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
31861 8944           E8         8D9B            call	_print_cdromboot_failure
31862 8947           44                         inc	sp
31863 8948           44                         inc	sp
31864                                           !BCC_EOS
31865                                           ! 5361       print_boot_failure(e.type, 1);
31866                                           ! Debug: list int = const 1 (used reg = )
31867 8949           B8                   0001  mov	ax,*1
31868 894C           50                         push	ax
31869                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31870 894D           FF76         E2            push	-$1E[bp]
31871                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31872 8950           E8         8D29            call	_print_boot_failure
31873 8953           83C4                   04  add	sp,*4
31874                                           !BCC_EOS
31875                                           ! 5362       return;
31876 8956           89EC                       mov	sp,bp
31877 8958           5D                         pop	bp
31878 8959           C3                         ret
31879                                           !BCC_EOS
31880                                           ! 5363     }
31881                                           ! 5364     bootdrv = *(((Bit8u *)&status)+1);
31882                       0000895A            .799:
31883                                           ! Debug: eq unsigned char status = [S+$20-$D] to unsigned char bootdrv = [S+$20-7] (used reg = )
31884 895A           8A46         F5            mov	al,-$B[bp]
31885 895D           8846         FB            mov	-5[bp],al
31886                                           !BCC_EOS
31887                                           ! 5365     bootseg = _read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg);
31888                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
31889 8960           FF76         FE            push	-2[bp]
31890                                           ! Debug: list * unsigned short = const $266 (used reg = )
31891 8963           B8                   0266  mov	ax,#$266
31892 8966           50                         push	ax
31893                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31894 8967           E8         7C83            call	__read_word
31895 896A           83C4                   04  add	sp,*4
31896                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31897 896D           8946         F8            mov	-8[bp],ax
31898                                           !BCC_EOS
31899                                           ! 5366     bootip = 0;
31900                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
31901 8970           31C0                       xor	ax,ax
31902 8972           8946         F6            mov	-$A[bp],ax
31903                                           !BCC_EOS
31904                                           ! 5367     break;
31905 8975           EB           2E            jmp .789
31906                                           !BCC_EOS
31907                                           ! 5368   case 0x80:
31908                                           ! 5369     bootseg = *(((Bit16u *)&e.vector)+1);
31909                       00008977            .79B:
31910                                           ! Debug: eq unsigned short e = [S+$20-$1A] to unsigned short bootseg = [S+$20-$A] (used reg = )
31911 8977           8B46         E8            mov	ax,-$18[bp]
31912 897A           8946         F8            mov	-8[bp],ax
31913                                           !BCC_EOS
31914                                           ! 5370     bootip = *((Bit16u *)&e.vector);
31915                                           ! Debug: eq unsigned short e = [S+$20-$1C] to unsigned short bootip = [S+$20-$C] (used reg = )
31916 897D           8B46         E6            mov	ax,-$1A[bp]
31917 8980           8946         F6            mov	-$A[bp],ax
31918                                           !BCC_EOS
31919                                           ! 5371     break;
31920 8983           EB           20            jmp .789
31921                                           !BCC_EOS
31922                                           ! 5372   default: return;
31923                       00008985            .79C:
31924 8985           89EC                       mov	sp,bp
31925 8987           5D                         pop	bp
31926 8988           C3                         ret
31927                                           !BCC_EOS
31928                                           ! 5373   }
31929                                           ! 5374   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
31930 8989           EB           1A            jmp .789
31931                       0000898B            .78B:
31932 898B           2D                   0001  sub	ax,*1
31933 898E         0F84         FEF3            beq 	.78C
31934 8992           2D                   0001  sub	ax,*1
31935 8995         0F84         FEEC            beq 	.78D
31936 8999           2D                   0001  sub	ax,*1
31937 899C           74           96            je 	.798
31938 899E           2D                   007D  sub	ax,*$7D
31939 89A1           74           D4            je 	.79B
31940 89A3           EB           E0            jmp	.79C
31941                       000089A5            .789:
31942                       FFFFFFE0            ..FFD9	=	-$20
31943                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
31944 89A5           FF76         F6            push	-$A[bp]
31945                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
31946 89A8           FF76         F8            push	-8[bp]
31947                                           ! Debug: list * char = .79D+0 (used reg = )
31948 89AB           BB                   CCE1  mov	bx,#.79D
31949 89AE           53                         push	bx
31950                                           ! Debug: list int = const 4 (used reg = )
31951 89AF           B8                   0004  mov	ax,*4
31952 89B2           50                         push	ax
31953                                           ! Debug: func () void = bios_printf+0 (used reg = )
31954 89B3           E8         7F83            call	_bios_printf
31955 89B6           83C4                   08  add	sp,*8
31956                                           !BCC_EOS
31957                                           ! 5375 #asm
31958                                           !BCC_EOS
31959                                           !BCC_ASM
31960                       00000014            _int19_function.bootip	set	$14
31961                       FFFFFFF6            .int19_function.bootip	set	-$A
31962                       00000022            _int19_function.seq_nr	set	$22
31963                       00000004            .int19_function.seq_nr	set	4
31964                       00000018            _int19_function.bootchk	set	$18
31965                       FFFFFFFA            .int19_function.bootchk	set	-6
31966                       00000016            _int19_function.bootseg	set	$16
31967                       FFFFFFF8            .int19_function.bootseg	set	-8
31968                       0000001C            _int19_function.ebda_seg	set	$1C
31969                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31970                       00000012            _int19_function.status	set	$12
31971                       FFFFFFF4            .int19_function.status	set	-$C
31972                       00000010            _int19_function.bootfirst	set	$10
31973                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31974                       00000019            _int19_function.bootdrv	set	$19
31975                       FFFFFFFB            .int19_function.bootdrv	set	-5
31976                       0000001A            _int19_function.bootdev	set	$1A
31977                       FFFFFFFC            .int19_function.bootdev	set	-4
31978                       00000000            _int19_function.e	set	0
31979                       FFFFFFE2            .int19_function.e	set	-$1E
31980 89B9           89E5                           mov bp, sp
31981 89BB           0E                             push cs
31982 89BC           68                   8F41      push #int18_handler
31983                                               ;; Build an iret stack frame that will take us to the boot vector.
31984                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
31985 89BF           9C                             pushf
31986 89C0           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
31987 89C3           50                             push ax
31988 89C4           8B46         14                mov ax, _int19_function.bootip + 0[bp]
31989 89C7           50                             push ax
31990                                               ;; Set the magic number in ax and the boot drive in dl.
31991 89C8           B8                   AA55      mov ax, #0xaa55
31992 89CB           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
31993                                               ;; Zero some of the other registers.
31994 89CE           31DB                           xor bx, bx
31995 89D0           8EDB                           mov ds, bx
31996 89D2           8EC3                           mov es, bx
31997 89D4           89DD                           mov bp, bx
31998                                               ;; Go!
31999 89D6           CF                             iret
32000                                           ! 5396 endasm
32001                                           !BCC_ENDASM
32002                                           !BCC_EOS
32003                                           ! 5397 }
32004 89D7           89EC                       mov	sp,bp
32005 89D9           5D                         pop	bp
32006 89DA           C3                         ret
32007                                           ! 5398   void
32008                                           ! Register BX used in function int19_function
32009                                           ! 5399 int1a_function(regs, ds, iret_addr)
32010                                           ! 5400   pusha_regs_t regs;
32011                                           export	_int1a_function
32012                       000089DB            _int1a_function:
32013                                           !BCC_EOS
32014                                           ! 5401   Bit16u ds;
32015                                           !BCC_EOS
32016                                           ! 5402   iret_addr_t iret_addr;
32017                                           !BCC_EOS
32018                                           ! 5403 {
32019                                           ! 5404   Bit8u val8;
32020                                           !BCC_EOS
32021                                           ! 5405   ;
32022 89DB           55                         push	bp
32023 89DC           89E5                       mov	bp,sp
32024 89DE           4C                         dec	sp
32025 89DF           4C                         dec	sp
32026                                           !BCC_EOS
32027                                           ! 5406 #asm
32028                                           !BCC_EOS
32029                                           !BCC_ASM
32030                       00000016            _int1a_function.ds	set	$16
32031                       00000014            .int1a_function.ds	set	$14
32032                       00000001            _int1a_function.val8	set	1
32033                       FFFFFFFF            .int1a_function.val8	set	-1
32034                       00000018            _int1a_function.iret_addr	set	$18
32035                       00000016            .int1a_function.iret_addr	set	$16
32036                       00000006            _int1a_function.regs	set	6
32037                       00000004            .int1a_function.regs	set	4
32038 89E0           FB                           sti
32039                                           ! 5408 endasm
32040                                           !BCC_ENDASM
32041                                           !BCC_EOS
32042                                           ! 5409   switch (regs.u.r8.ah) {
32043 89E1           8A46         13            mov	al,$13[bp]
32044 89E4           E9         036E            br 	.7A0
32045                                           ! 5410     case 0:
32046                                           ! 5411 #asm
32047                       000089E7            .7A1:
32048                                           !BCC_EOS
32049                                           !BCC_ASM
32050                       00000016            _int1a_function.ds	set	$16
32051                       00000014            .int1a_function.ds	set	$14
32052                       00000001            _int1a_function.val8	set	1
32053                       FFFFFFFF            .int1a_function.val8	set	-1
32054                       00000018            _int1a_function.iret_addr	set	$18
32055                       00000016            .int1a_function.iret_addr	set	$16
32056                       00000006            _int1a_function.regs	set	6
32057                       00000004            .int1a_function.regs	set	4
32058 89E7           FA                               cli
32059                                           ! 5413 endasm
32060                                           !BCC_ENDASM
32061                                           !BCC_EOS
32062                                           ! 5414       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
32063                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
32064 89E8           A1         046E            mov	ax,[$46E]
32065 89EB           8946         10            mov	$10[bp],ax
32066                                           !BCC_EOS
32067                                           ! 5415       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
32068                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
32069 89EE           A1         046C            mov	ax,[$46C]
32070 89F1           8946         0E            mov	$E[bp],ax
32071                                           !BCC_EOS
32072                                           ! 5416       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
32073                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
32074 89F4           A0         0470            mov	al,[$470]
32075 89F7           8846         12            mov	$12[bp],al
32076                                           !BCC_EOS
32077                                           ! 5417       ((bios_data_t *) 0)->midnight_flag = 0;
32078                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32079 89FA           30C0                       xor	al,al
32080 89FC           A2         0470            mov	[$470],al
32081                                           !BCC_EOS
32082                                           ! 5418 #asm
32083                                           !BCC_EOS
32084                                           !BCC_ASM
32085                       00000016            _int1a_function.ds	set	$16
32086                       00000014            .int1a_function.ds	set	$14
32087                       00000001            _int1a_function.val8	set	1
32088                       FFFFFFFF            .int1a_function.val8	set	-1
32089                       00000018            _int1a_function.iret_addr	set	$18
32090                       00000016            .int1a_function.iret_addr	set	$16
32091                       00000006            _int1a_function.regs	set	6
32092                       00000004            .int1a_function.regs	set	4
32093 89FF           FB                               sti
32094                                           ! 5420 endasm
32095                                           !BCC_ENDASM
32096                                           !BCC_EOS
32097                                           ! 5421       iret_addr.flags.u.r8.flagsl &= 0xfe;
32098                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32099 8A00           8A46         1A            mov	al,$1A[bp]
32100 8A03           24                     FE  and	al,#$FE
32101 8A05           8846         1A            mov	$1A[bp],al
32102                                           !BCC_EOS
32103                                           ! 5422       break;
32104 8A08           E9         0375            br 	.79E
32105                                           !BCC_EOS
32106                                           ! 5423     case 1:
32107                                           ! 5424 #asm
32108                       00008A0B            .7A2:
32109                                           !BCC_EOS
32110                                           !BCC_ASM
32111                       00000016            _int1a_function.ds	set	$16
32112                       00000014            .int1a_function.ds	set	$14
32113                       00000001            _int1a_function.val8	set	1
32114                       FFFFFFFF            .int1a_function.val8	set	-1
32115                       00000018            _int1a_function.iret_addr	set	$18
32116                       00000016            .int1a_function.iret_addr	set	$16
32117                       00000006            _int1a_function.regs	set	6
32118                       00000004            .int1a_function.regs	set	4
32119 8A0B           FA                               cli
32120                                           ! 5426 endasm
32121                                           !BCC_ENDASM
32122                                           !BCC_EOS
32123                                           ! 5427       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
32124                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
32125 8A0C           8B46         10            mov	ax,$10[bp]
32126 8A0F           A3         046E            mov	[$46E],ax
32127                                           !BCC_EOS
32128                                           ! 5428       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
32129                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
32130 8A12           8B46         0E            mov	ax,$E[bp]
32131 8A15           A3         046C            mov	[$46C],ax
32132                                           !BCC_EOS
32133                                           ! 5429       ((bios_data_t *) 0)->midnight_flag = 0;
32134                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32135 8A18           30C0                       xor	al,al
32136 8A1A           A2         0470            mov	[$470],al
32137                                           !BCC_EOS
32138                                           ! 5430 #asm
32139                                           !BCC_EOS
32140                                           !BCC_ASM
32141                       00000016            _int1a_function.ds	set	$16
32142                       00000014            .int1a_function.ds	set	$14
32143                       00000001            _int1a_function.val8	set	1
32144                       FFFFFFFF            .int1a_function.val8	set	-1
32145                       00000018            _int1a_function.iret_addr	set	$18
32146                       00000016            .int1a_function.iret_addr	set	$16
32147                       00000006            _int1a_function.regs	set	6
32148                       00000004            .int1a_function.regs	set	4
32149 8A1D           FB                               sti
32150                                           ! 5432 endasm
32151                                           !BCC_ENDASM
32152                                           !BCC_EOS
32153                                           ! 5433       regs.u.r8.ah = 0;
32154                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32155 8A1E           30C0                       xor	al,al
32156 8A20           8846         13            mov	$13[bp],al
32157                                           !BCC_EOS
32158                                           ! 5434       iret_addr.flags.u.r8.flagsl &= 0xfe;
32159                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32160 8A23           8A46         1A            mov	al,$1A[bp]
32161 8A26           24                     FE  and	al,#$FE
32162 8A28           8846         1A            mov	$1A[bp],al
32163                                           !BCC_EOS
32164                                           ! 5435       break;
32165 8A2B           E9         0352            br 	.79E
32166                                           !BCC_EOS
32167                                           ! 5436     case 2:
32168                                           ! 5437       if (rtc_updating()) {
32169                       00008A2E            .7A3:
32170                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32171 8A2E           E8         7B7A            call	_rtc_updating
32172 8A31           85C0                       test	ax,ax
32173 8A33           74           0B            je  	.7A4
32174                       00008A35            .7A5:
32175                                           ! 5438         iret_addr.flags.u.r8.flagsl |= 0x01;
32176                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32177 8A35           8A46         1A            mov	al,$1A[bp]
32178 8A38           0C                     01  or	al,*1
32179 8A3A           8846         1A            mov	$1A[bp],al
32180                                           !BCC_EOS
32181                                           ! 5439         break;
32182 8A3D           E9         0340            br 	.79E
32183                                           !BCC_EOS
32184                                           ! 5440       }
32185                                           ! 5441       regs.u.r8.dh = inb_cmos(0x00);
32186                       00008A40            .7A4:
32187                                           ! Debug: list int = const 0 (used reg = )
32188 8A40           31C0                       xor	ax,ax
32189 8A42           50                         push	ax
32190                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32191 8A43           E8         7B28            call	_inb_cmos
32192 8A46           44                         inc	sp
32193 8A47           44                         inc	sp
32194                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32195 8A48           8846         0F            mov	$F[bp],al
32196                                           !BCC_EOS
32197                                           ! 5442       regs.u.r8.cl = inb_cmos(0x02);
32198                                           ! Debug: list int = const 2 (used reg = )
32199 8A4B           B8                   0002  mov	ax,*2
32200 8A4E           50                         push	ax
32201                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32202 8A4F           E8         7B1C            call	_inb_cmos
32203 8A52           44                         inc	sp
32204 8A53           44                         inc	sp
32205                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32206 8A54           8846         10            mov	$10[bp],al
32207                                           !BCC_EOS
32208                                           ! 5443       regs.u.r8.ch = inb_cmos(0x04);
32209                                           ! Debug: list int = const 4 (used reg = )
32210 8A57           B8                   0004  mov	ax,*4
32211 8A5A           50                         push	ax
32212                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32213 8A5B           E8         7B10            call	_inb_cmos
32214 8A5E           44                         inc	sp
32215 8A5F           44                         inc	sp
32216                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32217 8A60           8846         11            mov	$11[bp],al
32218                                           !BCC_EOS
32219                                           ! 5444       regs.
32220                                           ! 5444 u.r8.dl = inb_cmos(0x0b) & 0x01;
32221                                           ! Debug: list int = const $B (used reg = )
32222 8A63           B8                   000B  mov	ax,*$B
32223 8A66           50                         push	ax
32224                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32225 8A67           E8         7B04            call	_inb_cmos
32226 8A6A           44                         inc	sp
32227 8A6B           44                         inc	sp
32228                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
32229 8A6C           24                     01  and	al,*1
32230                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32231 8A6E           8846         0E            mov	$E[bp],al
32232                                           !BCC_EOS
32233                                           ! 5445       regs.u.r8.ah = 0;
32234                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32235 8A71           30C0                       xor	al,al
32236 8A73           8846         13            mov	$13[bp],al
32237                                           !BCC_EOS
32238                                           ! 5446       regs.u.r8.al = regs.u.r8.ch;
32239                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32240 8A76           8A46         11            mov	al,$11[bp]
32241 8A79           8846         12            mov	$12[bp],al
32242                                           !BCC_EOS
32243                                           ! 5447       iret_addr.flags.u.r8.flagsl &= 0xfe;
32244                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32245 8A7C           8A46         1A            mov	al,$1A[bp]
32246 8A7F           24                     FE  and	al,#$FE
32247 8A81           8846         1A            mov	$1A[bp],al
32248                                           !BCC_EOS
32249                                           ! 5448       break;
32250 8A84           E9         02F9            br 	.79E
32251                                           !BCC_EOS
32252                                           ! 5449     case 3:
32253                                           ! 5450       if (rtc_updating()) {
32254                       00008A87            .7A6:
32255                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32256 8A87           E8         7B21            call	_rtc_updating
32257 8A8A           85C0                       test	ax,ax
32258 8A8C           74           03            je  	.7A7
32259                       00008A8E            .7A8:
32260                                           ! 5451         init_rtc();
32261                                           ! Debug: func () void = init_rtc+0 (used reg = )
32262 8A8E           E8         7AE9            call	_init_rtc
32263                                           !BCC_EOS
32264                                           ! 5452       }
32265                                           ! 5453       outb_cmos(0x00, regs.u.r8.dh);
32266                       00008A91            .7A7:
32267                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32268 8A91           8A46         0F            mov	al,$F[bp]
32269 8A94           30E4                       xor	ah,ah
32270 8A96           50                         push	ax
32271                                           ! Debug: list int = const 0 (used reg = )
32272 8A97           31C0                       xor	ax,ax
32273 8A99           50                         push	ax
32274                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32275 8A9A           E8         7AC2            call	_outb_cmos
32276 8A9D           83C4                   04  add	sp,*4
32277                                           !BCC_EOS
32278                                           ! 5454       outb_cmos(0x02, regs.u.r8.cl);
32279                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32280 8AA0           8A46         10            mov	al,$10[bp]
32281 8AA3           30E4                       xor	ah,ah
32282 8AA5           50                         push	ax
32283                                           ! Debug: list int = const 2 (used reg = )
32284 8AA6           B8                   0002  mov	ax,*2
32285 8AA9           50                         push	ax
32286                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32287 8AAA           E8         7AB2            call	_outb_cmos
32288 8AAD           83C4                   04  add	sp,*4
32289                                           !BCC_EOS
32290                                           ! 5455       outb_cmos(0x04, regs.u.r8.ch);
32291                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32292 8AB0           8A46         11            mov	al,$11[bp]
32293 8AB3           30E4                       xor	ah,ah
32294 8AB5           50                         push	ax
32295                                           ! Debug: list int = const 4 (used reg = )
32296 8AB6           B8                   0004  mov	ax,*4
32297 8AB9           50                         push	ax
32298                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32299 8ABA           E8         7AA2            call	_outb_cmos
32300 8ABD           83C4                   04  add	sp,*4
32301                                           !BCC_EOS
32302                                           ! 5456       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
32303                                           ! Debug: expression subtree swapping
32304                                           ! Debug: list int = const $B (used reg = )
32305 8AC0           B8                   000B  mov	ax,*$B
32306 8AC3           50                         push	ax
32307                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32308 8AC4           E8         7AA7            call	_inb_cmos
32309 8AC7           44                         inc	sp
32310 8AC8           44                         inc	sp
32311                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
32312 8AC9           24                     60  and	al,*$60
32313                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
32314 8ACB           0C                     02  or	al,*2
32315 8ACD           50                         push	ax
32316                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
32317 8ACE           8A46         0E            mov	al,$E[bp]
32318 8AD1           24                     01  and	al,*1
32319                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
32320 8AD3           0A46         FC            or	al,0+..FFD8[bp]
32321 8AD6           44                         inc	sp
32322 8AD7           44                         inc	sp
32323                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32324 8AD8           8846         FF            mov	-1[bp],al
32325                                           !BCC_EOS
32326                                           ! 5457       outb_cmos(0x0b, val8);
32327                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32328 8ADB           8A46         FF            mov	al,-1[bp]
32329 8ADE           30E4                       xor	ah,ah
32330 8AE0           50                         push	ax
32331                                           ! Debug: list int = const $B (used reg = )
32332 8AE1           B8                   000B  mov	ax,*$B
32333 8AE4           50                         push	ax
32334                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32335 8AE5           E8         7A77            call	_outb_cmos
32336 8AE8           83C4                   04  add	sp,*4
32337                                           !BCC_EOS
32338                                           ! 5458       regs.u.r8.ah = 0;
32339                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32340 8AEB           30C0                       xor	al,al
32341 8AED           8846         13            mov	$13[bp],al
32342                                           !BCC_EOS
32343                                           ! 5459       regs.u.r8.al = val8;
32344                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32345 8AF0           8A46         FF            mov	al,-1[bp]
32346 8AF3           8846         12            mov	$12[bp],al
32347                                           !BCC_EOS
32348                                           ! 5460       iret_addr.flags.u.r8.flagsl &= 0xfe;
32349                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32350 8AF6           8A46         1A            mov	al,$1A[bp]
32351 8AF9           24                     FE  and	al,#$FE
32352 8AFB           8846         1A            mov	$1A[bp],al
32353                                           !BCC_EOS
32354                                           ! 5461       break;
32355 8AFE           E9         027F            br 	.79E
32356                                           !BCC_EOS
32357                                           ! 5462     case 4:
32358                                           ! 5463       regs.u.r8.ah = 0;
32359                       00008B01            .7A9:
32360                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32361 8B01           30C0                       xor	al,al
32362 8B03           8846         13            mov	$13[bp],al
32363                                           !BCC_EOS
32364                                           ! 5464       if (rtc_updating()) {
32365                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32366 8B06           E8         7AA2            call	_rtc_updating
32367 8B09           85C0                       test	ax,ax
32368 8B0B           74           0B            je  	.7AA
32369                       00008B0D            .7AB:
32370                                           ! 5465         iret_addr.flags.u.r8.flagsl |= 0x01;
32371                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32372 8B0D           8A46         1A            mov	al,$1A[bp]
32373 8B10           0C                     01  or	al,*1
32374 8B12           8846         1A            mov	$1A[bp],al
32375                                           !BCC_EOS
32376                                           ! 5466         break;
32377 8B15           E9         0268            br 	.79E
32378                                           !BCC_EOS
32379                                           ! 5467       }
32380                                           ! 5468       regs.u.r8.cl = inb_cmos(0x09);
32381                       00008B18            .7AA:
32382                                           ! Debug: list int = const 9 (used reg = )
32383 8B18           B8                   0009  mov	ax,*9
32384 8B1B           50                         push	ax
32385                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32386 8B1C           E8         7A4F            call	_inb_cmos
32387 8B1F           44                         inc	sp
32388 8B20           44                         inc	sp
32389                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32390 8B21           8846         10            mov	$10[bp],al
32391                                           !BCC_EOS
32392                                           ! 5469       regs.u.r8.dh = inb_cmos(0x08);
32393                                           ! Debug: list int = const 8 (used reg = )
32394 8B24           B8                   0008  mov	ax,*8
32395 8B27           50                         push	ax
32396                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32397 8B28           E8         7A43            call	_inb_cmos
32398 8B2B           44                         inc	sp
32399 8B2C           44                         inc	sp
32400                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32401 8B2D           8846         0F            mov	$F[bp],al
32402                                           !BCC_EOS
32403                                           ! 5470       regs.u.r8.dl = inb_cmos(0x07);
32404                                           ! Debug: list int = const 7 (used reg = )
32405 8B30           B8                   0007  mov	ax,*7
32406 8B33           50                         push	ax
32407                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32408 8B34           E8         7A37            call	_inb_cmos
32409 8B37           44                         inc	sp
32410 8B38           44                         inc	sp
32411                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32412 8B39           8846         0E            mov	$E[bp],al
32413                                           !BCC_EOS
32414                                           ! 5471       regs.u.r8.ch = inb_cmos(0x32);
32415                                           ! Debug: list int = const $32 (used reg = )
32416 8B3C           B8                   0032  mov	ax,*$32
32417 8B3F           50                         push	ax
32418                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32419 8B40           E8         7A2B            call	_inb_cmos
32420 8B43           44                         inc	sp
32421 8B44           44                         inc	sp
32422                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32423 8B45           8846         11            mov	$11[bp],al
32424                                           !BCC_EOS
32425                                           ! 5472       regs.u.r8.al = regs.u.r8.ch;
32426                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32427 8B48           8A46         11            mov	al,$11[bp]
32428 8B4B           8846         12            mov	$12[bp],al
32429                                           !BCC_EOS
32430                                           ! 5473       iret_addr.flags.u.r8.flagsl &= 0xfe;
32431                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32432 8B4E           8A46         1A            mov	al,$1A[bp]
32433 8B51           24                     FE  and	al,#$FE
32434 8B53           8846         1A            mov	$1A[bp],al
32435                                           !BCC_EOS
32436                                           ! 5474       break;
32437 8B56           E9         0227            br 	.79E
32438                                           !BCC_EOS
32439                                           ! 5475     case 5:
32440                                           ! 5476       if (rtc_updating()) {
32441                       00008B59            .7AC:
32442                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32443 8B59           E8         7A4F            call	_rtc_updating
32444 8B5C           85C0                       test	ax,ax
32445 8B5E           74           0E            je  	.7AD
32446                       00008B60            .7AE:
32447                                           ! 5477         init_rtc();
32448                                           ! Debug: func () void = init_rtc+0 (used reg = )
32449 8B60           E8         7A17            call	_init_rtc
32450                                           !BCC_EOS
32451                                           ! 5478         iret_addr.flags.u.r8.flagsl |= 0x01;
32452                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32453 8B63           8A46         1A            mov	al,$1A[bp]
32454 8B66           0C                     01  or	al,*1
32455 8B68           8846         1A            mov	$1A[bp],al
32456                                           !BCC_EOS
32457                                           ! 5479         break;
32458 8B6B           E9         0212            br 	.79E
32459                                           !BCC_EOS
32460                                           ! 5480         }
32461                                           ! 5481       outb_cmos(0x09, regs.u.r8.cl);
32462                       00008B6E            .7AD:
32463                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32464 8B6E           8A46         10            mov	al,$10[bp]
32465 8B71           30E4                       xor	ah,ah
32466 8B73           50                         push	ax
32467                                           ! Debug: list int = const 9 (used reg = )
32468 8B74           B8                   0009  mov	ax,*9
32469 8B77           50                         push	ax
32470                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32471 8B78           E8         79E4            call	_outb_cmos
32472 8B7B           83C4                   04  add	sp,*4
32473                                           !BCC_EOS
32474                                           ! 5482       outb_cmos(0x08, regs.u.r8.dh);
32475                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32476 8B7E           8A46         0F            mov	al,$F[bp]
32477 8B81           30E4                       xor	ah,ah
32478 8B83           50                         push	ax
32479                                           ! Debug: list int = const 8 (used reg = )
32480 8B84           B8                   0008  mov	ax,*8
32481 8B87           50                         push	ax
32482                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32483 8B88           E8         79D4            call	_outb_cmos
32484 8B8B           83C4                   04  add	sp,*4
32485                                           !BCC_EOS
32486                                           ! 5483       outb_cmos(0x07, regs.u.r8.dl);
32487                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
32488 8B8E           8A46         0E            mov	al,$E[bp]
32489 8B91           30E4                       xor	ah,ah
32490 8B93           50                         push	ax
32491                                           ! Debug: list int = const 7 (used reg = )
32492 8B94           B8                   0007  mov	ax,*7
32493 8B97           50                         push	ax
32494                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32495 8B98           E8         79C4            call	_outb_cmos
32496 8B9B           83C4                   04  add	sp,*4
32497                                           !BCC_EOS
32498                                           ! 5484       outb_cmos(0x32, regs.u.r8.ch);
32499                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32500 8B9E           8A46         11            mov	al,$11[bp]
32501 8BA1           30E4                       xor	ah,ah
32502 8BA3           50                         push	ax
32503                                           ! Debug: list int = const $32 (used reg = )
32504 8BA4           B8                   0032  mov	ax,*$32
32505 8BA7           50                         push	ax
32506                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32507 8BA8           E8         79B4            call	_outb_cmos
32508 8BAB           83C4                   04  add	sp,*4
32509                                           !BCC_EOS
32510                                           ! 5485       val8 = inb_cmos(0x0b) & 0x7f;
32511                                           ! Debug: list int = const $B (used reg = )
32512 8BAE           B8                   000B  mov	ax,*$B
32513 8BB1           50                         push	ax
32514                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32515 8BB2           E8         79B9            call	_inb_cmos
32516 8BB5           44                         inc	sp
32517 8BB6           44                         inc	sp
32518                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
32519 8BB7           24                     7F  and	al,*$7F
32520                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32521 8BB9           8846         FF            mov	-1[bp],al
32522                                           !BCC_EOS
32523                                           ! 5486       outb_cmos(0x0b, val8);
32524                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32525 8BBC           8A46         FF            mov	al,-1[bp]
32526 8BBF           30E4                       xor	ah,ah
32527 8BC1           50                         push	ax
32528                                           ! Debug: list int = const $B (used reg = )
32529 8BC2           B8                   000B  mov	ax,*$B
32530 8BC5           50                         push	ax
32531                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32532 8BC6           E8         7996            call	_outb_cmos
32533 8BC9           83C4                   04  add	sp,*4
32534                                           !BCC_EOS
32535                                           ! 5487       regs.u.r8.ah = 0;
32536                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32537 8BCC           30C0                       xor	al,al
32538 8BCE           8846         13            mov	$13[bp],al
32539                                           !BCC_EOS
32540                                           ! 5488       regs.u.r8.al = val8;
32541                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32542 8BD1           8A46         FF            mov	al,-1[bp]
32543 8BD4           8846         12            mov	$12[bp],al
32544                                           !BCC_EOS
32545                                           ! 5489       iret_addr.flags.u.r8.flagsl &= 0xfe;
32546                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32547 8BD7           8A46         1A            mov	al,$1A[bp]
32548 8BDA           24                     FE  and	al,#$FE
32549 8BDC           8846         1A            mov	$1A[bp],al
32550                                           !BCC_EOS
32551                                           ! 5490       break;
32552 8BDF           E9         019E            br 	.79E
32553                                           !BCC_EOS
32554                                           ! 5491     case 6:
32555                                           ! 5492       val8 = inb_cmos(0x0b);
32556                       00008BE2            .7AF:
32557                                           ! Debug: list int = const $B (used reg = )
32558 8BE2           B8                   000B  mov	ax,*$B
32559 8BE5           50                         push	ax
32560                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32561 8BE6           E8         7985            call	_inb_cmos
32562 8BE9           44                         inc	sp
32563 8BEA           44                         inc	sp
32564                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32565 8BEB           8846         FF            mov	-1[bp],al
32566                                           !BCC_EOS
32567                                           ! 5493       regs.u.r16.ax = 0;
32568                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
32569 8BEE           31C0                       xor	ax,ax
32570 8BF0           8946         12            mov	$12[bp],ax
32571                                           !BCC_EOS
32572                                           ! 5494       if (val8 & 0x20) {
32573                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
32574 8BF3           8A46         FF            mov	al,-1[bp]
32575 8BF6           24                     20  and	al,*$20
32576 8BF8           84C0                       test	al,al
32577 8BFA           74           0B            je  	.7B0
32578                       00008BFC            .7B1:
32579                                           ! 5495         iret_addr.flags.u.r8.flagsl |= 0x01;
32580                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32581 8BFC           8A46         1A            mov	al,$1A[bp]
32582 8BFF           0C                     01  or	al,*1
32583 8C01           8846         1A            mov	$1A[bp],al
32584                                           !BCC_EOS
32585                                           ! 5496         break;
32586 8C04           E9         0179            br 	.79E
32587                                           !BCC_EOS
32588                                           ! 5497       }
32589                                           ! 5498       if (rtc_updating()) {
32590                       00008C07            .7B0:
32591                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32592 8C07           E8         79A1            call	_rtc_updating
32593 8C0A           85C0                       test	ax,ax
32594 8C0C           74           03            je  	.7B2
32595                       00008C0E            .7B3:
32596                                           ! 5499         init_rtc();
32597                                           ! Debug: func () void = init_rtc+0 (used reg = )
32598 8C0E           E8         7969            call	_init_rtc
32599                                           !BCC_EOS
32600                                           ! 5500       }
32601                                           ! 5501       outb_cmos(0x01, regs.u.r8.dh);
32602                       00008C11            .7B2:
32603                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32604 8C11           8A46         0F            mov	al,$F[bp]
32605 8C14           30E4                       xor	ah,ah
32606 8C16           50                         push	ax
32607                                           ! Debug: list int = const 1 (used reg = )
32608 8C17           B8                   0001  mov	ax,*1
32609 8C1A           50                         push	ax
32610                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32611 8C1B           E8         7941            call	_outb_cmos
32612 8C1E           83C4                   04  add	sp,*4
32613                                           !BCC_EOS
32614                                           ! 5502       outb_cmos(0x03, regs.u.r8.cl);
32615                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32616 8C21           8A46         10            mov	al,$10[bp]
32617 8C24           30E4                       xor	ah,ah
32618 8C26           50                         push	ax
32619                                           ! Debug: list int = const 3 (used reg = )
32620 8C27           B8                   0003  mov	ax,*3
32621 8C2A           50                         push	ax
32622                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32623 8C2B           E8         7931            call	_outb_cmos
32624 8C2E           83C4                   04  add	sp,*4
32625                                           !BCC_EOS
32626                                           ! 5503       outb_cmos(0x05, regs.u.r8.ch);
32627                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32628 8C31           8A46         11            mov	al,$11[bp]
32629 8C34           30E4                       xor	ah,ah
32630 8C36           50                         push	ax
32631                                           ! Debug: list int = const 5 (used reg = )
32632 8C37           B8                   0005  mov	ax,*5
32633 8C3A           50                         push	ax
32634                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32635 8C3B           E8         7921            call	_outb_cmos
32636 8C3E           83C4                   04  add	sp,*4
32637                                           !BCC_EOS
32638                                           ! 5504       outb(0x00a1, inb(0x00a1) & 0xfe);
32639                                           ! Debug: list int = const $A1 (used reg = )
32640 8C41           B8                   00A1  mov	ax,#$A1
32641 8C44           50                         push	ax
32642                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32643 8C45           E8         78E1            call	_inb
32644 8C48           44                         inc	sp
32645 8C49           44                         inc	sp
32646                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
32647 8C4A           24                     FE  and	al,#$FE
32648                                           ! Debug: list unsigned char = al+0 (used reg = )
32649 8C4C           30E4                       xor	ah,ah
32650 8C4E           50                         push	ax
32651                                           ! Debug: list int = const $A1 (used reg = )
32652 8C4F           B8                   00A1  mov	ax,#$A1
32653 8C52           50                         push	ax
32654                                           ! Debug: func () void = outb+0 (used reg = )
32655 8C53           E8         78E9            call	_outb
32656 8C56           83C4                   04  add	sp,*4
32657                                           !BCC_EOS
32658                                           ! 5505       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
32659                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
32660 8C59           8A46         FF            mov	al,-1[bp]
32661 8C5C           24                     7F  and	al,*$7F
32662                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
32663 8C5E           0C                     20  or	al,*$20
32664                                           ! Debug: list unsigned char = al+0 (used reg = )
32665 8C60           30E4                       xor	ah,ah
32666 8C62           50                         push	ax
32667                                           ! Debug: list int = const $B (used reg = )
32668 8C63           B8                   000B  mov	ax,*$B
32669 8C66           50                         push	ax
32670                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32671 8C67           E8         78F5            call	_outb_cmos
32672 8C6A           83C4                   04  add	sp,*4
32673                                           !BCC_EOS
32674                                           ! 5506       iret_addr.flags.u.r8.flagsl &= 0xfe;
32675                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32676 8C6D           8A46         1A            mov	al,$1A[bp]
32677 8C70           24                     FE  and	al,#$FE
32678 8C72           8846         1A            mov	$1A[bp],al
32679                                           !BCC_EOS
32680                                           ! 5507       break;
32681 8C75           E9         0108            br 	.79E
32682                                           !BCC_EOS
32683                                           ! 5508     case 7:
32684                                           ! 5509       val8 = inb_cmos(0x0b);
32685                       00008C78            .7B4:
32686                                           ! Debug: list int = const $B (used reg = )
32687 8C78           B8                   000B  mov	ax,*$B
32688 8C7B           50                         push	ax
32689                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32690 8C7C           E8         78EF            call	_inb_cmos
32691 8C7F           44                         inc	sp
32692 8C80           44                         inc	sp
32693                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32694 8C81           8846         FF            mov	-1[bp],al
32695                                           !BCC_EOS
32696                                           ! 5510       outb_cmos(0x0b, val8 & 0x57);
32697                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
32698 8C84           8A46         FF            mov	al,-1[bp]
32699 8C87           24                     57  and	al,*$57
32700                                           ! Debug: list unsigned char = al+0 (used reg = )
32701 8C89           30E4                       xor	ah,ah
32702 8C8B           50                         push	ax
32703                                           ! Debug: list int = const $B (used reg = )
32704 8C8C           B8                   000B  mov	ax,*$B
32705 8C8F           50                         push	ax
32706                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32707 8C90           E8         78CC            call	_outb_cmos
32708 8C93           83C4                   04  add	sp,*4
32709                                           !BCC_EOS
32710                                           ! 5511       regs.u.r8.ah = 0;
32711                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32712 8C96           30C0                       xor	al,al
32713 8C98           8846         13            mov	$13[bp],al
32714                                           !BCC_EOS
32715                                           ! 5512       regs.u.r8.al = val8;
32716                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32717 8C9B           8A46         FF            mov	al,-1[bp]
32718 8C9E           8846         12            mov	$12[bp],al
32719                                           !BCC_EOS
32720                                           ! 5513       iret_addr.flags.u.r8.flagsl &= 0xfe;
32721                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32722 8CA1           8A46         1A            mov	al,$1A[bp]
32723 8CA4           24                     FE  and	al,#$FE
32724 8CA6           8846         1A            mov	$1A[bp],al
32725                                           !BCC_EOS
32726                                           ! 5514       break;
32727 8CA9           E9         00D4            br 	.79E
32728                                           !BCC_EOS
32729                                           ! 5515     case 0xb1:
32730                                           ! 5516       if (regs.u.r8.bl == 0xf
32731                       00008CAC            .7B5:
32732                                           ! 5516 f) {
32733                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
32734 8CAC           8A46         0C            mov	al,$C[bp]
32735 8CAF           3C                     FF  cmp	al,#$FF
32736 8CB1           75           10            jne 	.7B6
32737                       00008CB3            .7B7:
32738                                           ! 5517         bios_printf(4, "PCI BIOS: PCI not present\n");
32739                                           ! Debug: list * char = .7B8+0 (used reg = )
32740 8CB3           BB                   CCC6  mov	bx,#.7B8
32741 8CB6           53                         push	bx
32742                                           ! Debug: list int = const 4 (used reg = )
32743 8CB7           B8                   0004  mov	ax,*4
32744 8CBA           50                         push	ax
32745                                           ! Debug: func () void = bios_printf+0 (used reg = )
32746 8CBB           E8         7C7B            call	_bios_printf
32747 8CBE           83C4                   04  add	sp,*4
32748                                           !BCC_EOS
32749                                           ! 5518       } else if (regs.u.r8.bl == 0x81) {
32750 8CC1           EB           78            jmp .7B9
32751                       00008CC3            .7B6:
32752                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
32753 8CC3           8A46         0C            mov	al,$C[bp]
32754 8CC6           3C                     81  cmp	al,#$81
32755 8CC8           75           16            jne 	.7BA
32756                       00008CCA            .7BB:
32757                                           ! 5519         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
32758                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
32759 8CCA           8A46         12            mov	al,$12[bp]
32760 8CCD           30E4                       xor	ah,ah
32761 8CCF           50                         push	ax
32762                                           ! Debug: list * char = .7BC+0 (used reg = )
32763 8CD0           BB                   CCA0  mov	bx,#.7BC
32764 8CD3           53                         push	bx
32765                                           ! Debug: list int = const 4 (used reg = )
32766 8CD4           B8                   0004  mov	ax,*4
32767 8CD7           50                         push	ax
32768                                           ! Debug: func () void = bios_printf+0 (used reg = )
32769 8CD8           E8         7C5E            call	_bios_printf
32770 8CDB           83C4                   06  add	sp,*6
32771                                           !BCC_EOS
32772                                           ! 5520       } else if (regs.u.r8.bl == 0x83) {
32773 8CDE           EB           5B            jmp .7BD
32774                       00008CE0            .7BA:
32775                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
32776 8CE0           8A46         0C            mov	al,$C[bp]
32777 8CE3           3C                     83  cmp	al,#$83
32778 8CE5           75           13            jne 	.7BE
32779                       00008CE7            .7BF:
32780                                           ! 5521         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
32781                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
32782 8CE7           FF76         0E            push	$E[bp]
32783                                           ! Debug: list * char = .7C0+0 (used reg = )
32784 8CEA           BB                   CC88  mov	bx,#.7C0
32785 8CED           53                         push	bx
32786                                           ! Debug: list int = const 4 (used reg = )
32787 8CEE           B8                   0004  mov	ax,*4
32788 8CF1           50                         push	ax
32789                                           ! Debug: func () void = bios_printf+0 (used reg = )
32790 8CF2           E8         7C44            call	_bios_printf
32791 8CF5           83C4                   06  add	sp,*6
32792                                           !BCC_EOS
32793                                           ! 5522       } else if (regs.u.r8.bl == 0x86) {
32794 8CF8           EB           41            jmp .7C1
32795                       00008CFA            .7BE:
32796                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
32797 8CFA           8A46         0C            mov	al,$C[bp]
32798 8CFD           3C                     86  cmp	al,#$86
32799 8CFF           75           3A            jne 	.7C2
32800                       00008D01            .7C3:
32801                                           ! 5523         if (regs.u.r8.al == 0x02) {
32802                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
32803 8D01           8A46         12            mov	al,$12[bp]
32804 8D04           3C                     02  cmp	al,*2
32805 8D06           75           19            jne 	.7C4
32806                       00008D08            .7C5:
32807                                           ! 5524           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
32808                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
32809 8D08           FF76         06            push	6[bp]
32810                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
32811 8D0B           FF76         10            push	$10[bp]
32812                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
32813 8D0E           FF76         0E            push	$E[bp]
32814                                           ! Debug: list * char = .7C6+0 (used reg = )
32815 8D11           BB                   CC5C  mov	bx,#.7C6
32816 8D14           53                         push	bx
32817                                           ! Debug: list int = const 4 (used reg = )
32818 8D15           B8                   0004  mov	ax,*4
32819 8D18           50                         push	ax
32820                                           ! Debug: func () void = bios_printf+0 (used reg = )
32821 8D19           E8         7C1D            call	_bios_printf
32822 8D1C           83C4                   0A  add	sp,*$A
32823                                           !BCC_EOS
32824                                           ! 5525         } else {
32825 8D1F           EB           1A            jmp .7C7
32826                       00008D21            .7C4:
32827                                           ! 5526           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
32828                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
32829 8D21           FF76         06            push	6[bp]
32830                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
32831 8D24           FF76         0E            push	$E[bp]
32832                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
32833 8D27           8A46         10            mov	al,$10[bp]
32834 8D2A           30E4                       xor	ah,ah
32835 8D2C           50                         push	ax
32836                                           ! Debug: list * char = .7C8+0 (used reg = )
32837 8D2D           BB                   CC20  mov	bx,#.7C8
32838 8D30           53                         push	bx
32839                                           ! Debug: list int = const 4 (used reg = )
32840 8D31           B8                   0004  mov	ax,*4
32841 8D34           50                         push	ax
32842                                           ! Debug: func () void = bios_printf+0 (used reg = )
32843 8D35           E8         7C01            call	_bios_printf
32844 8D38           83C4                   0A  add	sp,*$A
32845                                           !BCC_EOS
32846                                           ! 5527         }
32847                                           ! 5528       }
32848                       00008D3B            .7C7:
32849                                           ! 5529       regs.u.r8.ah = regs.u.r8.bl;
32850                       00008D3B            .7C2:
32851                       00008D3B            .7C1:
32852                       00008D3B            .7BD:
32853                       00008D3B            .7B9:
32854                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
32855 8D3B           8A46         0C            mov	al,$C[bp]
32856 8D3E           8846         13            mov	$13[bp],al
32857                                           !BCC_EOS
32858                                           ! 5530       iret_addr.flags.u.r8.flagsl |= 0x01;
32859                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32860 8D41           8A46         1A            mov	al,$1A[bp]
32861 8D44           0C                     01  or	al,*1
32862 8D46           8846         1A            mov	$1A[bp],al
32863                                           !BCC_EOS
32864                                           ! 5531       break;
32865 8D49           EB           35            jmp .79E
32866                                           !BCC_EOS
32867                                           ! 5532     default:
32868                                           ! 5533       iret_addr.flags.u.r8.flagsl |= 0x01;
32869                       00008D4B            .7C9:
32870                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32871 8D4B           8A46         1A            mov	al,$1A[bp]
32872 8D4E           0C                     01  or	al,*1
32873 8D50           8846         1A            mov	$1A[bp],al
32874                                           !BCC_EOS
32875                                           ! 5534   }
32876                                           ! 5535 }
32877 8D53           EB           2B            jmp .79E
32878                       00008D55            .7A0:
32879 8D55           2C                     00  sub	al,*0
32880 8D57           72           F2            jb 	.7C9
32881 8D59           3C                     07  cmp	al,*7
32882 8D5B           77           1B            ja  	.7CA
32883 8D5D           30E4                       xor	ah,ah
32884 8D5F           D1E0                       shl	ax,*1
32885 8D61           89C3                       mov	bx,ax
32886 8D63           2E                         seg	cs
32887 8D64           FFA7       8D68            br	.7CB[bx]
32888                       00008D68            .7CB:
32889 8D68                      89E7            .word	.7A1
32890 8D6A                      8A0B            .word	.7A2
32891 8D6C                      8A2E            .word	.7A3
32892 8D6E                      8A87            .word	.7A6
32893 8D70                      8B01            .word	.7A9
32894 8D72                      8B59            .word	.7AC
32895 8D74                      8BE2            .word	.7AF
32896 8D76                      8C78            .word	.7B4
32897                       00008D78            .7CA:
32898 8D78           2C                     B1  sub	al,#$B1
32899 8D7A         0F84         FF2E            beq 	.7B5
32900 8D7E           EB           CB            jmp	.7C9
32901                       00008D80            .79E:
32902                       FFFFFFFC            ..FFD8	=	-4
32903 8D80           89EC                       mov	sp,bp
32904 8D82           5D                         pop	bp
32905 8D83           C3                         ret
32906                                           ! 5536   void
32907                                           ! Register BX used in function int1a_function
32908                                           ! 5537 int70_function(regs, ds, iret_addr)
32909                                           ! 5538   pusha_regs_t regs;
32910                                           export	_int70_function
32911                       00008D84            _int70_function:
32912                                           !BCC_EOS
32913                                           ! 5539   Bit16u ds;
32914                                           !BCC_EOS
32915                                           ! 5540   iret_addr_t iret_addr;
32916                                           !BCC_EOS
32917                                           ! 5541 {
32918                                           ! 5542   Bit8u registerB = 0, registerC = 0;
32919 8D84           55                         push	bp
32920 8D85           89E5                       mov	bp,sp
32921 8D87           4C                         dec	sp
32922                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
32923 8D88           30C0                       xor	al,al
32924 8D8A           8846         FF            mov	-1[bp],al
32925 8D8D           4C                         dec	sp
32926                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
32927 8D8E           30C0                       xor	al,al
32928 8D90           8846         FE            mov	-2[bp],al
32929                                           !BCC_EOS
32930                                           ! 5543   registerB = inb_cmos( 0xB );
32931                                           ! Debug: list int = const $B (used reg = )
32932 8D93           B8                   000B  mov	ax,*$B
32933 8D96           50                         push	ax
32934                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32935 8D97           E8         77D4            call	_inb_cmos
32936 8D9A           44                         inc	sp
32937 8D9B           44                         inc	sp
32938                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
32939 8D9C           8846         FF            mov	-1[bp],al
32940                                           !BCC_EOS
32941                                           ! 5544   registerC = inb_cmos( 0xC );
32942                                           ! Debug: list int = const $C (used reg = )
32943 8D9F           B8                   000C  mov	ax,*$C
32944 8DA2           50                         push	ax
32945                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32946 8DA3           E8         77C8            call	_inb_cmos
32947 8DA6           44                         inc	sp
32948 8DA7           44                         inc	sp
32949                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
32950 8DA8           8846         FE            mov	-2[bp],al
32951                                           !BCC_EOS
32952                                           ! 5545   if( ( registerB & 0x60 ) != 0 ) {
32953                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
32954 8DAB           8A46         FF            mov	al,-1[bp]
32955 8DAE           24                     60  and	al,*$60
32956                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32957 8DB0           84C0                       test	al,al
32958 8DB2         0F84         00B2            beq 	.7CC
32959                       00008DB6            .7CD:
32960                                           ! 5546     if( ( registerC & 0x20 ) != 0 ) {
32961                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
32962 8DB6           8A46         FE            mov	al,-2[bp]
32963 8DB9           24                     20  and	al,*$20
32964                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32965 8DBB           84C0                       test	al,al
32966 8DBD           74           04            je  	.7CE
32967                       00008DBF            .7CF:
32968                                           ! 5547 #asm
32969                                           !BCC_EOS
32970                                           !BCC_ASM
32971                       00000000            _int70_function.registerC	set	0
32972                       FFFFFFFE            .int70_function.registerC	set	-2
32973                       00000016            _int70_function.ds	set	$16
32974                       00000014            .int70_function.ds	set	$14
32975                       00000001            _int70_function.registerB	set	1
32976                       FFFFFFFF            .int70_function.registerB	set	-1
32977                       00000018            _int70_function.iret_addr	set	$18
32978                       00000016            .int70_function.iret_addr	set	$16
32979                       00000006            _int70_function.regs	set	6
32980                       00000004            .int70_function.regs	set	4
32981 8DBF           FB                               sti
32982 8DC0           CD                     4A        int #0x4a
32983 8DC2           FA                               cli
32984                                           ! 5551 endasm
32985                                           !BCC_ENDASM
32986                                           !BCC_EOS
32987                                           ! 5552     }
32988                                           ! 5553     if( ( registerC & 0x40 ) != 0 ) {
32989                       00008DC3            .7CE:
32990                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
32991 8DC3           8A46         FE            mov	al,-2[bp]
32992 8DC6           24                     40  and	al,*$40
32993                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32994 8DC8           84C0                       test	al,al
32995 8DCA         0F84         009A            beq 	.7D0
32996                       00008DCE            .7D1:
32997                                           ! 5554       if( *((Bit8u *)(0x4A0)) != 0 ) {
32998                                           ! Debug: ne int = const 0 to unsigned char = [+$4A0] (used reg = )
32999 8DCE           A0         04A0            mov	al,[$4A0]
33000 8DD1           84C0                       test	al,al
33001 8DD3         0F84         0091            beq 	.7D2
33002                       00008DD7            .7D3:
33003                                           ! 5555         Bit32u time, toggle;
33004                                           !BCC_EOS
33005                                           ! 5556         time = *((Bit32u *)(0x49C));
33006 8DD7           83C4                   F8  add	sp,*-8
33007                                           ! Debug: eq unsigned long = [+$49C] to unsigned long time = [S+$C-8] (used reg = )
33008 8DDA           A1         049C            mov	ax,[$49C]
33009 8DDD           8B1E       049E            mov	bx,[$49E]
33010 8DE1           8946         FA            mov	-6[bp],ax
33011 8DE4           895E         FC            mov	-4[bp],bx
33012                                           !BCC_EOS
33013                                           ! 5557         if( time < 0x3D1 ) {
33014                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33015 8DE7           B8                   03D1  mov	ax,#$3D1
33016 8DEA           31DB                       xor	bx,bx
33017 8DEC           8D7E         FA            lea	di,-6[bp]
33018 8DEF           E8         72AA            call	lcmpul
33019 8DF2           76           48            jbe 	.7D4
33020                       00008DF4            .7D5:
33021                                           ! 5558           Bit16u segment, offset;
33022                                           !BCC_EOS
33023                                           ! 5559           segment = *((Bit16u *)(0x498));
33024 8DF4           83C4                   FC  add	sp,*-4
33025                                           ! Debug: eq unsigned short = [+$498] to unsigned short segment = [S+$10-$E] (used reg = )
33026 8DF7           A1         0498            mov	ax,[$498]
33027 8DFA           8946         F4            mov	-$C[bp],ax
33028                                           !BCC_EOS
33029                                           ! 5560           offset = *((Bit16u *)(0x49A));
33030                                           ! Debug: eq unsigned short = [+$49A] to unsigned short offset = [S+$10-$10] (used reg = )
33031 8DFD           A1         049A            mov	ax,[$49A]
33032 8E00           8946         F2            mov	-$E[bp],ax
33033                                           !BCC_EOS
33034                                           ! 5561           *((Bit8u *)(0x4A0)) = (0);
33035                                           ! Debug: eq int = const 0 to unsigned char = [+$4A0] (used reg = )
33036 8E03           30C0                       xor	al,al
33037 8E05           A2         04A0            mov	[$4A0],al
33038                                           !BCC_EOS
33039                                           ! 5562           outb_cmos( 0xB, registerB & 0x37 );
33040                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
33041 8E08           8A46         FF            mov	al,-1[bp]
33042 8E0B           24                     37  and	al,*$37
33043                                           ! Debug: list unsigned char = al+0 (used reg = )
33044 8E0D           30E4                       xor	ah,ah
33045 8E0F           50                         push	ax
33046                                           ! Debug: list int = const $B (used reg = )
33047 8E10           B8                   000B  mov	ax,*$B
33048 8E13           50                         push	ax
33049                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33050 8E14           E8         7748            call	_outb_cmos
33051 8E17           83C4                   04  add	sp,*4
33052                                           !BCC_EOS
33053                                           ! 5563           _write_byte(_read_byte(offset, segment) | 0x80, offset, segment);
33054                                           ! Debug: list unsigned short segment = [S+$10-$E] (used reg = )
33055 8E1A           FF76         F4            push	-$C[bp]
33056                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
33057 8E1D           FF76         F2            push	-$E[bp]
33058                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
33059 8E20           FF76         F4            push	-$C[bp]
33060                                           ! Debug: list unsigned short offset = [S+$16-$10] (used reg = )
33061 8E23           FF76         F2            push	-$E[bp]
33062                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
33063 8E26           E8         77B6            call	__read_byte
33064 8E29           83C4                   04  add	sp,*4
33065                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
33066 8E2C           0C                     80  or	al,#$80
33067                                           ! Debug: list unsigned char = al+0 (used reg = )
33068 8E2E           30E4                       xor	ah,ah
33069 8E30           50                         push	ax
33070                                           ! Debug: func () void = _write_byte+0 (used reg = )
33071 8E31           E8         77C7            call	__write_byte
33072 8E34           83C4                   06  add	sp,*6
33073                                           !BCC_EOS
33074                                           ! 5564         } else {
33075 8E37           83C4                   04  add	sp,*4
33076 8E3A           EB           29            jmp .7D6
33077                       00008E3C            .7D4:
33078                                           ! 5565           time -= 0x3D1;
33079                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33080 8E3C           B8                   03D1  mov	ax,#$3D1
33081 8E3F           31DB                       xor	bx,bx
33082 8E41           53                         push	bx
33083 8E42           50                         push	ax
33084 8E43           8B46         FA            mov	ax,-6[bp]
33085 8E46           8B5E         FC            mov	bx,-4[bp]
33086 8E49           8D7E         F2            lea	di,-$E[bp]
33087 8E4C           E8         7263            call	lsubul
33088 8E4F           8946         FA            mov	-6[bp],ax
33089 8E52           895E         FC            mov	-4[bp],bx
33090 8E55           83C4                   04  add	sp,*4
33091                                           !BCC_EOS
33092                                           ! 5566           *((Bit32u *)(0x49C)) = (time);
33093                                           ! Debug: eq unsigned long time = [S+$C-8] to unsigned long = [+$49C] (used reg = )
33094 8E58           8B46         FA            mov	ax,-6[bp]
33095 8E5B           8B5E         FC            mov	bx,-4[bp]
33096 8E5E           A3         049C            mov	[$49C],ax
33097 8E61           891E       049E            mov	[$49E],bx
33098                                           !BCC_EOS
33099                                           ! 5567         }
33100                                           ! 5568       }
33101                       00008E65            .7D6:
33102 8E65           83C4                   08  add	sp,*8
33103                                           ! 5569     }
33104                       00008E68            .7D2:
33105                                           ! 5570   }
33106                       00008E68            .7D0:
33107                                           ! 5571 #asm
33108                       00008E68            .7CC:
33109                                           !BCC_EOS
33110                                           !BCC_ASM
33111                       00000000            _int70_function.registerC	set	0
33112                       FFFFFFFE            .int70_function.registerC	set	-2
33113                       00000016            _int70_function.ds	set	$16
33114                       00000014            .int70_function.ds	set	$14
33115                       00000001            _int70_function.registerB	set	1
33116                       FFFFFFFF            .int70_function.registerB	set	-1
33117                       00000018            _int70_function.iret_addr	set	$18
33118                       00000016            .int70_function.iret_addr	set	$16
33119                       00000006            _int70_function.regs	set	6
33120                       00000004            .int70_function.regs	set	4
33121 8E68           E8         042A              call eoi_both_pics
33122                                           ! 5573 endasm
33123                                           !BCC_ENDASM
33124                                           !BCC_EOS
33125                                           ! 5574 }
33126 8E6B           89EC                       mov	sp,bp
33127 8E6D           5D                         pop	bp
33128 8E6E           C3                         ret
33129                                           ! 5575 #asm
33130                                           !BCC_ASM
33131                       00000012            _int70_function.ds	set	$12
33132                       00000014            _int70_function.iret_addr	set	$14
33133                       00000002            _int70_function.regs	set	2
33134                                           ;------------------------------------------
33135                                           ;- INT74h : PS/2 mouse hardware interrupt -
33136                                           ;------------------------------------------
33137                       00008E6F            int74_handler:
33138 8E6F           FB                           sti
33139 8E70           60                           pusha
33140 8E71           1E                           push ds ;; save DS
33141 8E72           6A                     00    push #0x00
33142 8E74           1F                           pop ds
33143 8E75           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
33144 8E79           1F                           pop ds
33145 8E7A           6A                     00    push #0x00 ;; placeholder for status
33146 8E7C           6A                     00    push #0x00 ;; placeholder for X
33147 8E7E           6A                     00    push #0x00 ;; placeholder for Y
33148 8E80           6A                     00    push #0x00 ;; placeholder for Z
33149 8E82           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
33150 8E84           E8         CB6F              call _int74_function
33151 8E87           59                           pop cx ;; remove make_far_call from stack
33152 8E88           E3           04              jcxz int74_done
33153                                             ;; make far call to EBDA:0022
33154 8E8A           FF1E       0022              call far ptr[0x22]
33155                       00008E8E            int74_done:
33156 8E8E           FA                           cli
33157 8E8F           E8         0403              call eoi_both_pics
33158 8E92           83C4                   08    add sp, #8 ;; pop status, x, y, z
33159 8E95           1F                           pop ds ;; restore DS
33160 8E96           61                           popa
33161 8E97           CF                           iret
33162                                           ;; This will perform an IRET, but will retain value of current CF
33163                                           ;; by altering flags on stack. Better than RETF #02.
33164                       00008E98            iret_modify_cf:
33165 8E98           72           09              jc carry_set
33166 8E9A           55                           push bp
33167 8E9B           89E5                         mov bp, sp
33168 8E9D           8066         06        FE    and BYTE [bp + 0x06], #0xfe
33169 8EA1           5D                           pop bp
33170 8EA2           CF                           iret
33171                       00008EA3            carry_set:
33172 8EA3           55                           push bp
33173 8EA4           89E5                         mov bp, sp
33174 8EA6           804E         06        01    or BYTE [bp + 0x06], #0x01
33175 8EAA           5D                           pop bp
33176 8EAB           CF                           iret
33177                                           ;----------------------
33178                                           ;- INT13h (relocated) -
33179                                           ;----------------------
33180                                           ;
33181                                           ; int13_relocated is a little bit messed up since I played with it
33182                                           ; I have to rewrite it:
33183                                           ; - call a function that detect which function to call
33184                                           ; - make all called C function get the same parameters list
33185                                           ;
33186                       00008EAC            int13_relocated:
33187                                             ;; check for an eltorito function
33188 8EAC           80FC                   4A    cmp ah,#0x4a
33189 8EAF           72           0E              jb int13_not_eltorito
33190 8EB1           80FC                   4D    cmp ah,#0x4d
33191 8EB4           77           09              ja int13_not_eltorito
33192 8EB6           60                           pusha
33193 8EB7           06                           push es
33194 8EB8           1E                           push ds
33195 8EB9           68                   8F3D    push #int13_out
33196 8EBC           E9         DF2E              jmp _int13_eltorito ;; ELDX not used
33197                       00008EBF            int13_not_eltorito:
33198 8EBF           50                           push ax
33199 8EC0           53                           push bx
33200 8EC1           51                           push cx
33201 8EC2           52                           push dx
33202                                             ;; check if emulation active
33203 8EC3           E8         A698              call _cdemu_isactive
33204 8EC6           3C                     00    cmp al,#0x00
33205 8EC8           74           31              je int13_cdemu_inactive
33206                                             ;; check if access to the emulated drive
33207 8ECA           E8         A6AD              call _cdemu_emulated_drive
33208 8ECD           5A                           pop dx
33209 8ECE           52                           push dx
33210 8ECF           38D0                         cmp al,dl ;; int13 on emulated drive
33211 8ED1           75           15              jne int13_nocdemu
33212 8ED3           5A                           pop dx
33213 8ED4           59                           pop cx
33214 8ED5           5B                           pop bx
33215 8ED6           58                           pop ax
33216 8ED7           60                           pusha
33217 8ED8           06                           push es
33218 8ED9           1E                           push ds
33219 8EDA           6A                     40    push #0x40
33220 8EDC           1F                           pop ds
33221 8EDD           FF36       000E              push 0x000E
33222 8EE1           1F                           pop ds ;; Set DS to EBDA segment
33223 8EE2           68                   8F3D    push #int13_out
33224 8EE5           E9         E108              jmp _int13_cdemu ;; ELDX not used
33225                       00008EE8            int13_nocdemu:
33226 8EE8           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
33227 8EEB           38D0                         cmp al,dl ;; al is 0x00 or 0x80
33228 8EED           75           0C              jne int13_cdemu_inactive ;; inactive for device class
33229 8EEF           5A                           pop dx
33230 8EF0           59                           pop cx
33231 8EF1           5B                           pop bx
33232 8EF2           58                           pop ax
33233 8EF3           50                           push ax
33234 8EF4           51                           push cx
33235 8EF5           52                           push dx
33236 8EF6           53                           push bx
33237 8EF7           FECA                         dec dl ;; real drive is dl - 1
33238 8EF9           EB           08              jmp int13_legacy
33239                       00008EFB            int13_cdemu_inactive:
33240 8EFB           5A                           pop dx
33241 8EFC           59                           pop cx
33242 8EFD           5B                           pop bx
33243 8EFE           58                           pop ax
33244                       00008EFF            int13_noeltorito:
33245 8EFF           50                           push ax
33246 8F00           51                           push cx
33247 8F01           52                           push dx
33248 8F02           53                           push bx
33249                       00008F03            int13_legacy:
33250 8F03           52                           push dx ;; push eltorito value of dx instead of sp
33251 8F04           55                           push bp
33252 8F05           56                           push si
33253 8F06           57                           push di
33254 8F07           06                           push es
33255 8F08           1E                           push ds
33256 8F09           6A                     40    push #0x40
33257 8F0B           1F                           pop ds ;; Set DS to 0x40
33258                                             ;; now the 16-bit registers can be restored with:
33259                                             ;; pop ds; pop es; popa; iret
33260                                             ;; arguments passed to functions should be
33261                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
33262 8F0C           F6C2                   80    test dl, #0x80
33263 8F0F           75           06              jnz int13_notfloppy
33264 8F11           68                   8F3D    push #int13_out
33265 8F14           E9         E866              jmp _int13_diskette_function
33266                       00008F17            int13_notfloppy:
33267 8F17           FF36       000E              push 0x000E
33268 8F1B           1F                           pop ds ;; Set DS to EBDA segment
33269 8F1C           80FA                   E0    cmp dl, #0xE0
33270 8F1F           72           0F              jb int13_notcdrom
33271 8F21     66    C1EB                   10    shr ebx, #16
33272 8F25           53                           push bx
33273 8F26           E8         D9CF              call _int13_cdrom
33274 8F29           5B                           pop bx
33275 8F2A     66    C1E3                   10    shl ebx, #16
33276 8F2E           EB           0D              jmp int13_out
33277                       00008F30            int13_notcdrom:
33278                       00008F30            int13_disk:
33279                                             ;; int13_harddisk modifies high word of EAX
33280 8F30     66    C1E8                   10    shr eax, #16
33281 8F34           50                           push ax
33282 8F35           E8         D20D              call _int13_harddisk
33283 8F38           58                           pop ax
33284 8F39     66    C1E0                   10    shl eax, #16
33285                       00008F3D            int13_out:
33286 8F3D           1F                           pop ds
33287 8F3E           07                           pop es
33288 8F3F           61                           popa
33289 8F40           CF                           iret
33290                                           ;----------
33291                                           ;- INT18h -
33292                                           ;----------
33293                       00008F41            int18_handler: ;; Boot Failure recovery: try the next device.
33294                                             ;; Reset SP and SS
33295 8F41           B8                   FFFE    mov ax, #0xfffe
33296 8F44           89C4                         mov sp, ax
33297 8F46           31C0                         xor ax, ax
33298 8F48           8ED0                         mov ss, ax
33299                                             ;; Get the boot sequence number out of the IPL memory
33300 8F4A           BB                   9FF0    mov bx, #0x9ff0
33301 8F4D           8EDB                         mov ds, bx ;; Set segment
33302 8F4F           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
33303 8F53           43                           inc bx ;; ++
33304 8F54           891E       0082              mov 0x0082, bx ;; Write it back
33305 8F58           8ED8                         mov ds, ax ;; and reset the segment to zero.
33306                                             ;; Carry on in the INT 19h handler, using the new sequence number
33307 8F5A           53                           push bx
33308 8F5B           EB           17              jmp int19_next_boot
33309                                           ;----------
33310                                           ;- INT19h -
33311                                           ;----------
33312                       00008F5D            int19_relocated: ;; Boot function, relocated
33313                                             ;; int19 was beginning to be really complex, so now it
33314                                             ;; just calls a C function that does the work
33315 8F5D           55                           push bp
33316 8F5E           89E5                         mov bp, sp
33317                                             ;; Reset SS and SP
33318 8F60           B8                   FFFE    mov ax, #0xfffe
33319 8F63           89C4                         mov sp, ax
33320 8F65           31C0                         xor ax, ax
33321 8F67           8ED0                         mov ss, ax
33322                                             ;; Start from the first boot device (0, in AX)
33323 8F69           BB                   9FF0    mov bx, #0x9ff0
33324 8F6C           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
33325 8F6E           A3         0082              mov 0x0082, ax ;; Save the sequence number
33326 8F71           8ED8                         mov ds, ax ;; and reset the segment.
33327 8F73           50                           push ax
33328                       00008F74            int19_next_boot:
33329                                             ;; Call the C code for the next boot device
33330 8F74           E8         F828              call _int19_function
33331                                             ;; Boot failed: invoke the boot recovery function
33332 8F77           CD                     18    int #0x18
33333                                           ;----------------------
33334                                           ;- POST: Floppy Drive -
33335                                           ;----------------------
33336                       00008F79            floppy_drive_post:
33337 8F79           31C0                         xor ax, ax
33338 8F7B           8ED8                         mov ds, ax
33339 8F7D           B0                     00    mov al, #0x00
33340 8F7F           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
33341 8F82           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
33342 8F85           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
33343 8F88           A2         0441              mov 0x0441, al ;; diskette controller status return code
33344 8F8B           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
33345 8F8E           A2         0443              mov 0x0443, al ;; diskette controller status register 1
33346 8F91           A2         0444              mov 0x0444, al ;; diskette controller status register 2
33347 8F94           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
33348 8F97           A2         0446              mov 0x0446, al ;; diskette controller head number
33349 8F9A           A2         0447              mov 0x0447, al ;; diskette controller sector number
33350 8F9D           A2         0448              mov 0x0448, al ;; diskette controller bytes written
33351 8FA0           A2         048B              mov 0x048b, al ;; diskette configuration data
33352                                             ;; -----------------------------------------------------------------
33353                                             ;; (048F) diskette controller information
33354                                             ;;
33355 8FA3           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
33356 8FA5           E6                     70    out 0x0070, AL
33357 8FA7           E4                     71    in AL, 0x0071
33358 8FA9           88C4                         mov ah, al ;; save byte to AH
33359                       00008FAB            look_drive0:
33360 8FAB           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
33361 8FAE           74           04              jz f0_missing ;; jump if no drive0
33362 8FB0           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
33363 8FB2           EB           02              jmp look_drive1
33364                       00008FB4            f0_missing:
33365 8FB4           B3                     00    mov bl, #0x00 ;; no drive0
33366                       00008FB6            look_drive1:
33367 8FB6           88E0                         mov al, ah ;; restore from AH
33368 8FB8           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
33369 8FBA           74           03              jz f1_missing ;; jump if no drive1
33370 8FBC           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
33371                       00008FBF            f1_missing:
33372                                                              ;; leave high bits in BL zerod
33373 8FBF           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
33374                                             ;; -----------------------------------------------------------------
33375 8FC3           B0                     00    mov al, #0x00
33376 8FC5           A2         0490              mov 0x0490, al ;; diskette 0 media state
33377 8FC8           A2         0491              mov 0x0491, al ;; diskette 1 media state
33378                                                              ;; diskette 0,1 operational starting state
33379                                                              ;; drive type has not been determined,
33380                                                              ;; has no changed detection line
33381 8FCB           A2         0492              mov 0x0492, al
33382 8FCE           A2         0493              mov 0x0493, al
33383 8FD1           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
33384 8FD4           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
33385 8FD7           B0                     02    mov al, #0x02
33386 8FD9           E6                     0A    out 0x000a, al ;; clear DMA-1 channel 2 mask bit
33387                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   8FDB           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   8FDE           A3         0078              mov 0x1E*4, ax
 +a   8FE1           B8                   F000    mov ax,  #0xF000
 +a   8FE4           A3         007A              mov 0x1E*4+2, ax
33388                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   8FE7           B8                   EC59    mov ax,  #int13_diskette
 +a   8FEA           A3         0100              mov 0x40*4, ax
 +a   8FED           B8                   F000    mov ax,  #0xF000
 +a   8FF0           A3         0102              mov 0x40*4+2, ax
33389                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   8FF3           B8                   EF57    mov ax,  #int0e_handler
 +a   8FF6           A3         0038              mov 0x0E*4, ax
 +a   8FF9           B8                   F000    mov ax,  #0xF000
 +a   8FFC           A3         003A              mov 0x0E*4+2, ax
33390 8FFF           C3                           ret
33391                                           ;--------------------
33392                                           ;- POST: HARD DRIVE -
33393                                           ;--------------------
33394                                           ; relocated here because the primary POST area isnt big enough.
33395                       00009000            hard_drive_post:
33396 9000           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
33397 9002           BA                   03F6    mov dx, #0x03f6
33398 9005           EE                           out dx, al
33399 9006           31C0                         xor ax, ax
33400 9008           8ED8                         mov ds, ax
33401 900A           A2         0474              mov 0x0474, al
33402 900D           A2         0477              mov 0x0477, al
33403 9010           A2         048C              mov 0x048c, al
33404 9013           A2         048D              mov 0x048d, al
33405 9016           A2         048E              mov 0x048e, al
33406 9019           B0                     01    mov al, #0x01
33407 901B           A2         0475              mov 0x0475, al
33408 901E           B0                     C0    mov al, #0xc0
33409 9020           A2         0476              mov 0x0476, al
33410                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   9023           B8                   E3FE    mov ax,  #int13_handler
 +a   9026           A3         004C              mov 0x13*4, ax
 +a   9029           B8                   F000    mov ax,  #0xF000
 +a   902C           A3         004E              mov 0x13*4+2, ax
33411                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   902F           B8                   9303    mov ax,  #int76_handler
 +a   9032           A3         01D8              mov 0x76*4, ax
 +a   9035           B8                   F000    mov ax,  #0xF000
 +a   9038           A3         01DA              mov 0x76*4+2, ax
33412                                             ;; INT 41h: hard disk 0 configuration pointer
33413                                             ;; INT 46h: hard disk 1 configuration pointer
33414                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   903B           B8                   003D    mov ax,  #0x003D
 +a   903E           A3         0104              mov 0x41*4, ax
 +a   9041           B8                   9FC0    mov ax,  #0x9FC0
 +a   9044           A3         0106              mov 0x41*4+2, ax
33415                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   9047           B8                   004D    mov ax,  #0x004D
 +a   904A           A3         0118              mov 0x46*4, ax
 +a   904D           B8                   9FC0    mov ax,  #0x9FC0
 +a   9050           A3         011A              mov 0x46*4+2, ax
33416                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
33417 9053           B0                     12    mov al, #0x12
33418 9055           E6                     70    out 0x0070, al
33419 9057           E4                     71    in al, 0x0071
33420 9059           24                     F0    and al, #0xf0
33421 905B           3C                     F0    cmp al, #0xf0
33422 905D           74           03              je post_d0_extended
33423 905F           E9         00D4              jmp check_for_hd1
33424                       00009062            post_d0_extended:
33425 9062           B0                     19    mov al, #0x19
33426 9064           E6                     70    out 0x0070, al
33427 9066           E4                     71    in al, 0x0071
33428 9068           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
33429 906A           74           07              je post_d0_type47
33430                                             HALT(9099)
 +a   906C           BA                   0400    mov dx,#0x400
 +a   906F           B8                   238B    mov ax,#9099
 +a   9072           EF                           out dx,ax
33431                       00009073            post_d0_type47:
33432                                             ;; CMOS purpose param table offset
33433                                             ;; 1b cylinders low 0
33434                                             ;; 1c cylinders high 1
33435                                             ;; 1d heads 2
33436                                             ;; 1e write pre-comp low 5
33437                                             ;; 1f write pre-comp high 6
33438                                             ;; 20 retries/bad map/heads>8 8
33439                                             ;; 21 landing zone low C
33440                                             ;; 22 landing zone high D
33441                                             ;; 23 sectors/track E
33442 9073           B8                   9FC0    mov ax, #0x9FC0
33443 9076           8ED8                         mov ds, ax
33444                                             ;;; Filling EBDA table for hard disk 0.
33445 9078           B0                     1F    mov al, #0x1f
33446 907A           E6                     70    out 0x0070, al
33447 907C           E4                     71    in al, 0x0071
33448 907E           88C4                         mov ah, al
33449 9080           B0                     1E    mov al, #0x1e
33450 9082           E6                     70    out 0x0070, al
33451 9084           E4                     71    in al, 0x0071
33452 9086           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
33453 9089           B0                     20    mov al, #0x20
33454 908B           E6                     70    out 0x0070, al
33455 908D           E4                     71    in al, 0x0071
33456 908F           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
33457 9092           B0                     22    mov al, #0x22
33458 9094           E6                     70    out 0x0070, al
33459 9096           E4                     71    in al, 0x0071
33460 9098           88C4                         mov ah, al
33461 909A           B0                     21    mov al, #0x21
33462 909C           E6                     70    out 0x0070, al
33463 909E           E4                     71    in al, 0x0071
33464 90A0           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
33465 90A3           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
33466 90A5           E6                     70    out 0x0070, al
33467 90A7           E4                     71    in al, 0x0071 ;; high byte
33468 90A9           88C4                         mov ah, al
33469 90AB           B0                     1B    mov al, #0x1b
33470 90AD           E6                     70    out 0x0070, al
33471 90AF           E4                     71    in al, 0x0071 ;; low byte
33472 90B1           89C3                         mov bx, ax ;; BX = cylinders
33473 90B3           B0                     1D    mov al, #0x1d
33474 90B5           E6                     70    out 0x0070, al
33475 90B7           E4                     71    in al, 0x0071
33476 90B9           88C1                         mov cl, al ;; CL = heads
33477 90BB           B0                     23    mov al, #0x23
33478 90BD           E6                     70    out 0x0070, al
33479 90BF           E4                     71    in al, 0x0071
33480 90C1           88C2                         mov dl, al ;; DL = sectors
33481 90C3           81FB                 0400    cmp bx, #1024
33482 90C7           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
33483                       000090C9            hd0_post_physical_chs:
33484                                             ;; no logical CHS mapping used, just physical CHS
33485                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
33486 90C9           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
33487 90CD           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
33488 90D1           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
33489 90D5           EB           5F              jmp check_for_hd1
33490                       000090D7            hd0_post_logical_chs:
33491                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
33492 90D7           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
33493 90DB           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
33494 90DF           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
33495 90E3           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
33496 90E7           B0                     A0    mov al, #0xa0
33497 90E9           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
33498 90EC           81FB                 0800    cmp bx, #2048
33499 90F0           77           06              jnbe hd0_post_above_2048
33500                                             ;; 1024 < c <= 2048 cylinders
33501 90F2           D1EB                         shr bx, #0x01
33502 90F4           D0E1                         shl cl, #0x01
33503 90F6           EB           22              jmp hd0_post_store_logical
33504                       000090F8            hd0_post_above_2048:
33505 90F8           81FB                 1000    cmp bx, #4096
33506 90FC           77           08              jnbe hd0_post_above_4096
33507                                             ;; 2048 < c <= 4096 cylinders
33508 90FE           C1EB                   02    shr bx, #0x02
33509 9101           C0E1                   02    shl cl, #0x02
33510 9104           EB           14              jmp hd0_post_store_logical
33511                       00009106            hd0_post_above_4096:
33512 9106           81FB                 2000    cmp bx, #8192
33513 910A           77           08              jnbe hd0_post_above_8192
33514                                             ;; 4096 < c <= 8192 cylinders
33515 910C           C1EB                   03    shr bx, #0x03
33516 910F           C0E1                   03    shl cl, #0x03
33517 9112           EB           06              jmp hd0_post_store_logical
33518                       00009114            hd0_post_above_8192:
33519                                             ;; 8192 < c <= 16384 cylinders
33520 9114           C1EB                   04    shr bx, #0x04
33521 9117           C0E1                   04    shl cl, #0x04
33522                       0000911A            hd0_post_store_logical:
33523 911A           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
33524 911E           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
33525                                             ;; checksum
33526 9122           B1                     0F    mov cl, #0x0f ;; repeat count
33527 9124           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
33528 9127           B0                     00    mov al, #0x00 ;; sum
33529                       00009129            hd0_post_checksum_loop:
33530 9129           0204                         add al, [si]
33531 912B           46                           inc si
33532 912C           FEC9                         dec cl
33533 912E           75           F9              jnz hd0_post_checksum_loop
33534 9130           F6D0                         not al ;; now take 2s complement
33535 9132           FEC0                         inc al
33536 9134           8804                         mov [si], al
33537                                           ;;; Done filling EBDA table for hard disk 0.
33538                       00009136            check_for_hd1:
33539                                             ;; is there really a second hard disk? if not, return now
33540 9136           B0                     12    mov al, #0x12
33541 9138           E6                     70    out 0x0070, al
33542 913A           E4                     71    in al, 0x0071
33543 913C           24                     0F    and al, #0x0f
33544 913E           75           01              jnz post_d1_exists
33545 9140           C3                           ret
33546                       00009141            post_d1_exists:
33547                                             ;; check that the hd type is really 0x0f.
33548 9141           3C                     0F    cmp al, #0x0f
33549 9143           74           07              jz post_d1_extended
33550                                             HALT(9236)
 +a   9145           BA                   0400    mov dx,#0x400
 +a   9148           B8                   2414    mov ax,#9236
 +a   914B           EF                           out dx,ax
33551                       0000914C            post_d1_extended:
33552                                             ;; check that the extended type is 47 - user definable
33553 914C           B0                     1A    mov al, #0x1a
33554 914E           E6                     70    out 0x0070, al
33555 9150           E4                     71    in al, 0x0071
33556 9152           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
33557 9154           74           07              je post_d1_type47
33558                                             HALT(9244)
 +a   9156           BA                   0400    mov dx,#0x400
 +a   9159           B8                   241C    mov ax,#9244
 +a   915C           EF                           out dx,ax
33559                       0000915D            post_d1_type47:
33560                                             ;; Table for disk1.
33561                                             ;; CMOS purpose param table offset
33562                                             ;; 0x24 cylinders low 0
33563                                             ;; 0x25 cylinders high 1
33564                                             ;; 0x26 heads 2
33565                                             ;; 0x27 write pre-comp low 5
33566                                             ;; 0x28 write pre-comp high 6
33567                                             ;; 0x29 heads>8 8
33568                                             ;; 0x2a landing zone low C
33569                                             ;; 0x2b landing zone high D
33570                                             ;; 0x2c sectors/track E
33571                                           ;;; Fill EBDA table for hard disk 1.
33572 915D           B8                   9FC0    mov ax, #0x9FC0
33573 9160           8ED8                         mov ds, ax
33574 9162           B0                     28    mov al, #0x28
33575 9164           E6                     70    out 0x0070, al
33576 9166           E4                     71    in al, 0x0071
33577 9168           88C4                         mov ah, al
33578 916A           B0                     27    mov al, #0x27
33579 916C           E6                     70    out 0x0070, al
33580 916E           E4                     71    in al, 0x0071
33581 9170           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
33582 9173           B0                     29    mov al, #0x29
33583 9175           E6                     70    out 0x0070, al
33584 9177           E4                     71    in al, 0x0071
33585 9179           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
33586 917C           B0                     2B    mov al, #0x2b
33587 917E           E6                     70    out 0x0070, al
33588 9180           E4                     71    in al, 0x0071
33589 9182           88C4                         mov ah, al
33590 9184           B0                     2A    mov al, #0x2a
33591 9186           E6                     70    out 0x0070, al
33592 9188           E4                     71    in al, 0x0071
33593 918A           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
33594 918D           B0                     25    mov al, #0x25 ;; get cylinders word in AX
33595 918F           E6                     70    out 0x0070, al
33596 9191           E4                     71    in al, 0x0071 ;; high byte
33597 9193           88C4                         mov ah, al
33598 9195           B0                     24    mov al, #0x24
33599 9197           E6                     70    out 0x0070, al
33600 9199           E4                     71    in al, 0x0071 ;; low byte
33601 919B           89C3                         mov bx, ax ;; BX = cylinders
33602 919D           B0                     26    mov al, #0x26
33603 919F           E6                     70    out 0x0070, al
33604 91A1           E4                     71    in al, 0x0071
33605 91A3           88C1                         mov cl, al ;; CL = heads
33606 91A5           B0                     2C    mov al, #0x2c
33607 91A7           E6                     70    out 0x0070, al
33608 91A9           E4                     71    in al, 0x0071
33609 91AB           88C2                         mov dl, al ;; DL = sectors
33610 91AD           81FB                 0400    cmp bx, #1024
33611 91B1           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
33612                       000091B3            hd1_post_physical_chs:
33613                                             ;; no logical CHS mapping used, just physical CHS
33614                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
33615 91B3           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
33616 91B7           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
33617 91BB           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
33618 91BF           C3                           ret
33619                       000091C0            hd1_post_logical_chs:
33620                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
33621 91C0           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
33622 91C4           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
33623 91C8           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
33624 91CC           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
33625 91D0           B0                     A0    mov al, #0xa0
33626 91D2           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
33627 91D5           81FB                 0800    cmp bx, #2048
33628 91D9           77           06              jnbe hd1_post_above_2048
33629                                             ;; 1024 < c <= 2048 cylinders
33630 91DB           D1EB                         shr bx, #0x01
33631 91DD           D0E1                         shl cl, #0x01
33632 91DF           EB           22              jmp hd1_post_store_logical
33633                       000091E1            hd1_post_above_2048:
33634 91E1           81FB                 1000    cmp bx, #4096
33635 91E5           77           08              jnbe hd1_post_above_4096
33636                                             ;; 2048 < c <= 4096 cylinders
33637 91E7           C1EB                   02    shr bx, #0x02
33638 91EA           C0E1                   02    shl cl, #0x02
33639 91ED           EB           14              jmp hd1_post_store_logical
33640                       000091EF            hd1_post_above_4096:
33641 91EF           81FB                 2000    cmp bx, #8192
33642 91F3           77           08              jnbe hd1_post_above_8192
33643                                             ;; 4096 < c <= 8192 cylinders
33644 91F5           C1EB                   03    shr bx, #0x03
33645 91F8           C0E1                   03    shl cl, #0x03
33646 91FB           EB           06              jmp hd1_post_store_logical
33647                       000091FD            hd1_post_above_8192:
33648                                             ;; 8192 < c <= 16384 cylinders
33649 91FD           C1EB                   04    shr bx, #0x04
33650 9200           C0E1                   04    shl cl, #0x04
33651                       00009203            hd1_post_store_logical:
33652 9203           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
33653 9207           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
33654                                             ;; checksum
33655 920B           B1                     0F    mov cl, #0x0f ;; repeat count
33656 920D           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
33657 9210           B0                     00    mov al, #0x00 ;; sum
33658                       00009212            hd1_post_checksum_loop:
33659 9212           0204                         add al, [si]
33660 9214           46                           inc si
33661 9215           FEC9                         dec cl
33662 9217           75           F9              jnz hd1_post_checksum_loop
33663 9219           F6D0                         not al ;; now take 2s complement
33664 921B           FEC0                         inc al
33665 921D           8804                         mov [si], al
33666                                           ;;; Done filling EBDA table for hard disk 1.
33667 921F           C3                           ret
33668                                           ;--------------------
33669                                           ;- POST: EBDA segment
33670                                           ;--------------------
33671                                           ; relocated here because the primary POST area isnt big enough.
33672                       00009220            ebda_post:
33673 9220           B8                   9FC0    mov ax, #0x9FC0
33674 9223           8ED8                         mov ds, ax
33675 9225           C606       0000        01    mov byte ptr [0x0], #1
33676 922A           31C0                         xor ax, ax ; mov EBDA seg into 0x40E
33677 922C           8ED8                         mov ds, ax
33678 922E           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
33679 9234           C3                           ret;;
33680                                           ;--------------------
33681                                           ;- POST: EOI + jmp via [0x40:67)
33682                                           ;--------------------
33683                                           ; relocated here because the primary POST area isnt big enough.
33684                       00009235            eoi_jmp_post:
33685 9235           B0                     11    mov al, #0x11 ; send initialisation commands
33686 9237           E6                     20    out 0x0020, al
33687 9239           E6                     A0    out 0x00a0, al
33688 923B           B0                     08    mov al, #0x08
33689 923D           E6                     21    out 0x0021, al
33690 923F           B0                     70    mov al, #0x70
33691 9241           E6                     A1    out 0x00a1, al
33692 9243           B0                     04    mov al, #0x04
33693 9245           E6                     21    out 0x0021, al
33694 9247           B0                     02    mov al, #0x02
33695 9249           E6                     A1    out 0x00a1, al
33696 924B           B0                     01    mov al, #0x01
33697 924D           E6                     21    out 0x0021, al
33698 924F           E6                     A1    out 0x00a1, al
33699 9251           B0                     B8    mov al, #0xb8
33700 9253           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
33701 9255           B0                     8F    mov al, #0x8f
33702 9257           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
33703 9259           B0                     20    mov al, #0x20
33704 925B           E6                     A0    out 0x00a0, al ;; slave PIC EOI
33705 925D           B0                     20    mov al, #0x20
33706 925F           E6                     20    out 0x0020, al ;; master PIC EOI
33707                       00009261            jmp_post_0x467:
33708 9261           31C0                         xor ax, ax
33709 9263           8ED8                         mov ds, ax
33710 9265           FF2E       0467              jmp far ptr [0x467]
33711                       00009269            iret_post_0x467:
33712 9269           31C0                         xor ax, ax
33713 926B           8ED8                         mov ds, ax
33714 926D           8B26       0467              mov sp, [0x467]
33715 9271           8E16       0469              mov ss, [0x469]
33716 9275           CF                           iret
33717                       00009276            retf_post_0x467:
33718 9276           31C0                         xor ax, ax
33719 9278           8ED8                         mov ds, ax
33720 927A           8B26       0467              mov sp, [0x467]
33721 927E           8E16       0469              mov ss, [0x469]
33722 9282           CB                           retf
33723                       00009283            s3_post:
33724 9283           BC                   0FFE    mov sp, #0xffe
33725 9286           E8         851E              call _s3_resume
33726 9289           B3                     00    mov bl, #0x00
33727 928B           21C0                         and ax, ax
33728 928D   7503    E9         4E11              jz normal_post
33729 9292           E8         7F3A              call _s3_resume_panic
33730                                           ;--------------------
33731                       00009295            eoi_both_pics:
33732 9295           B0                     20    mov al, #0x20
33733 9297           E6                     A0    out 0x00a0, al ;; slave PIC EOI
33734                       00009299            eoi_master_pic:
33735 9299           B0                     20    mov al, #0x20
33736 929B           E6                     20    out 0x0020, al ;; master PIC EOI
33737 929D           C3                           ret
33738                                           ;--------------------
33739                       0000929E            BcdToBin:
33740                                             ;; in: AL in BCD format
33741                                             ;; out: AL in binary format, AH will always be 0
33742                                             ;; trashes BX
33743 929E           88C3                         mov bl, al
33744 92A0           80E3                   0F    and bl, #0x0f ;; bl has low digit
33745 92A3           C0E8                   04    shr al, #4 ;; al has high digit
33746 92A6           B7                     0A    mov bh, #10
33747 92A8           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
33748 92AA           00D8                         add al, bl ;; then add low digit
33749 92AC           C3                           ret
33750                                           ;--------------------
33751                       000092AD            timer_tick_post:
33752                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
33753                                             ;; Timer Ticks Roller Flag (0x470:byte)
33754                                             ;; The Timer Ticks Count needs to be set according to
33755                                             ;; the current CMOS time, as if ticks have been occurring
33756                                             ;; at 18.2hz since midnight up to this point. Calculating
33757                                             ;; this is a little complicated. Here are the factors I gather
33758                                             ;; regarding this. 14,318,180 hz was the original clock speed,
33759                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
33760                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
33761                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
33762                                             ;; the timer. With a maximum 16bit timer count, this is again
33763                                             ;; divided down by 65536 to 18.2hz.
33764                                             ;;
33765                                             ;; 14,318,180 Hz clock
33766                                             ;; /3 = 4,772,726 Hz fed to original 5Mhz CPU
33767                                             ;; /4 = 1,193,181 Hz fed to timer
33768                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
33769                                             ;; 1 second = 18.20650736 ticks
33770                                             ;; 1 minute = 1092.390442 ticks
33771                                             ;; 1 hour = 65543.42651 ticks
33772                                             ;;
33773                                             ;; Given the values in the CMOS clock, one could calculate
33774                                             ;; the number of ticks by the following:
33775                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
33776                                             ;; (BcdToBin(minutes) * 1092.3904)
33777                                             ;; (BcdToBin(hours) * 65543.427)
33778                                             ;; To get a little more accuracy, since Im using integer
33779                                             ;; arithmetic, I use:
33780                                             ;; ticks = (((BcdToBin(hours) * 60 + BcdToBin(minutes)) * 60 + BcdToBin(seconds)) * (18 * 4294967296 + 886942379)) / 4294967296
33781                                             ;; assuming DS=0000
33782                                             ;; get CMOS hours
33783 92AD     66    31C0                         xor eax, eax ;; clear EAX
33784 92B0           B0                     04    mov al, #0x04
33785 92B2           E6                     70    out 0x0070, al
33786 92B4           E4                     71    in al, 0x0071 ;; AL has CMOS hours in BCD
33787 92B6           E8         FFE5              call BcdToBin ;; EAX now has hours in binary
33788 92B9     66    6BC0                   3C    imul eax, #60
33789 92BD     66    89C2                         mov edx, eax
33790                                             ;; get CMOS minutes
33791 92C0     66    31C0                         xor eax, eax ;; clear EAX
33792 92C3           B0                     02    mov al, #0x02
33793 92C5           E6                     70    out 0x0070, al
33794 92C7           E4                     71    in al, 0x0071 ;; AL has CMOS minutes in BCD
33795 92C9           E8         FFD2              call BcdToBin ;; EAX now has minutes in binary
33796 92CC     66    01D0                         add eax, edx
33797 92CF     66    6BC0                   3C    imul eax, #60
33798 92D3     66    89C2                         mov edx, eax
33799                                             ;; get CMOS seconds
33800 92D6     66    31C0                         xor eax, eax ;; clear EAX
33801 92D9           B0                     00    mov al, #0x00
33802 92DB           E6                     70    out 0x0070, al
33803 92DD           E4                     71    in al, 0x0071 ;; AL has CMOS seconds in BCD
33804 92DF           E8         FFBC              call BcdToBin ;; EAX now has seconds in binary
33805 92E2     66    01D0                         add eax, edx
33806                                             ;; multiplying 18.2065073649
33807 92E5     66    89C1                         mov ecx, eax
33808 92E8     66    6BC9                   12    imul ecx, #18
33809 92EC     66    BA               34DDAAAB    mov edx, #886942379
33810 92F2     66    F7E2                         mul edx
33811 92F5     66    01D1                         add ecx, edx
33812 92F8     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
33813 92FD           30C0                         xor al, al
33814 92FF           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
33815 9302           C3                           ret
33816                                           ;--------------------
33817                       00009303            int76_handler:
33818                                             ;; record completion in BIOS task complete flag
33819 9303           50                           push ax
33820 9304           1E                           push ds
33821 9305           B8                   0040    mov ax, #0x0040
33822 9308           8ED8                         mov ds, ax
33823 930A           C606       008E        FF    mov BYTE 0x008E, #0xff
33824 930F           E8         FF83              call eoi_both_pics
33825                                             ;; Notify fixed disk interrupt complete w/ int 15h, function AX=9100
33826 9312           B8                   9100    mov ax, #0x9100
33827 9315           CD                     15    int 0x15
33828 9317           1F                           pop ds
33829 9318           58                           pop ax
33830 9319           CF                           iret
33831                                           ;--------------------
33832                                           use32 386
33833                       0000931A            apm32_out_str:
33834 931A           50                           push eax
33835 931B           53                           push ebx
33836 931C           89C3                         mov ebx, eax
33837                       0000931E            apm32_out_str1:
33838 931E           2E                           SEG CS
33839 931F   67      8A07                         mov al, byte ptr [bx]
33840 9322           3C                     00    cmp al, #0
33841 9324           74           04              je apm32_out_str2
33842 9326           EE                           outb dx, al
33843 9327           43                           inc ebx
33844 9328           EB           F4              jmp apm32_out_str1
33845                       0000932A            apm32_out_str2:
33846 932A           5B                           pop ebx
33847 932B           58                           pop eax
33848 932C           C3                           ret
33849                       0000932D            apm32_07_poweroff_str:
33850 932D                        53              .ascii "Shutdown"
33851 9335                        00              db 0
33852                       00009336            apm32_07_suspend_str:
33853 9336                        53              .ascii "Suspend"
33854 933D                        00              db 0
33855                       0000933E            apm32_07_standby_str:
33856 933E                        53              .ascii "Standby"
33857 9345                        00              db 0
33858                       00009346            _apm32_entry:
33859 9346     66    9C                           pushf
33860                                           ;-----------------
33861                                           ; APM interface disconnect
33862                       00009348            apm32_04:
33863 9348           3C                     04    cmp al, #0x04
33864 934A           75           05              jne apm32_05
33865 934C           E9     000000A1              jmp apm32_ok
33866                                           ;-----------------
33867                                           ; APM cpu idle
33868                       00009351            apm32_05:
33869 9351           3C                     05    cmp al, #0x05
33870 9353           75           07              jne apm32_07
33871 9355           FB                           sti
33872 9356           F4                           hlt
33873 9357           E9     00000096              jmp apm32_ok
33874                                           ;-----------------
33875                                           ; APM Set Power State
33876                       0000935C            apm32_07:
33877 935C           3C                     07    cmp al, #0x07
33878 935E           75           52              jne apm32_08
33879 9360     66    83FB                   01    cmp bx, #1
33880 9364   7405    E9     00000087              jne apm32_ok
33881 936B     66    83F9                   03    cmp cx, #3
33882 936F           74           0E              je apm32_07_poweroff
33883 9371     66    83F9                   02    cmp cx, #2
33884 9375           74           19              je apm32_07_suspend
33885 9377     66    83F9                   01    cmp cx, #1
33886 937B           74           24              je apm32_07_standby
33887 937D           75           73              jne apm32_ok
33888                       0000937F            apm32_07_poweroff:
33889 937F           FA                           cli
33890 9380     66    BA                   8900    mov dx, #0x8900
33891 9384     66    B8                   932D    mov ax, #apm32_07_poweroff_str
33892 9388           E8     FFFFFF8D              call apm32_out_str
33893                       0000938D            apm32_07_1:
33894 938D           F4                           hlt
33895 938E           EB           FD              jmp apm32_07_1
33896                       00009390            apm32_07_suspend:
33897 9390           52                           push edx
33898 9391     66    BA                   8900    mov dx, #0x8900
33899 9395     66    B8                   9336    mov ax, #apm32_07_suspend_str
33900 9399           E8     FFFFFF7C              call apm32_out_str
33901 939E           5A                           pop edx
33902 939F           EB           51              jmp apm32_ok
33903                       000093A1            apm32_07_standby:
33904 93A1           52                           push edx
33905 93A2     66    BA                   8900    mov dx, #0x8900
33906 93A6     66    B8                   933E    mov ax, #apm32_07_standby_str
33907 93AA           E8     FFFFFF6B              call apm32_out_str
33908 93AF           5A                           pop edx
33909 93B0           EB           40              jmp apm32_ok
33910                                           ;-----------------
33911                                           ; APM Enable / Disable
33912                       000093B2            apm32_08:
33913 93B2           3C                     08    cmp al, #0x08
33914 93B4           75           02              jne apm32_0a
33915 93B6           EB           3A              jmp apm32_ok
33916                                           ;-----------------
33917                                           ; Get Power Status
33918                       000093B8            apm32_0a:
33919 93B8           3C                     0A    cmp al, #0x0a
33920 93BA           75           12              jne apm32_0b
33921 93BC           B7                     01    mov bh, #0x01
33922 93BE           B3                     FF    mov bl, #0xff
33923 93C0           B5                     80    mov ch, #0x80
33924 93C2           B1                     FF    mov cl, #0xff
33925 93C4     66    BA                   FFFF    mov dx, #0xffff
33926 93C8     66    BE                   0000    mov si, #0
33927 93CC           EB           24              jmp apm32_ok
33928                                           ;-----------------
33929                                           ; Get PM Event
33930                       000093CE            apm32_0b:
33931 93CE           3C                     0B    cmp al, #0x0b
33932 93D0           75           04              jne apm32_0e
33933 93D2           B4                     80    mov ah, #0x80
33934 93D4           EB           20              jmp apm32_error
33935                                           ;-----------------
33936                                           ; APM Driver Version
33937                       000093D6            apm32_0e:
33938 93D6           3C                     0E    cmp al, #0x0e
33939 93D8           75           06              jne apm32_0f
33940 93DA           B4                     01    mov ah, #1
33941 93DC           B0                     02    mov al, #2
33942 93DE           EB           12              jmp apm32_ok
33943                                           ;-----------------
33944                                           ; APM Engage / Disengage
33945                       000093E0            apm32_0f:
33946 93E0           3C                     0F    cmp al, #0x0f
33947 93E2           75           02              jne apm32_10
33948 93E4           EB           0C              jmp apm32_ok
33949                                           ;-----------------
33950                                           ; APM Get Capabilities
33951                       000093E6            apm32_10:
33952 93E6           3C                     10    cmp al, #0x10
33953 93E8           75           0C              jne apm32_unimplemented
33954 93EA           B3                     00    mov bl, #0
33955 93EC     66    B9                   0000    mov cx, #0
33956 93F0           EB           00              jmp apm32_ok
33957                                           ;-----------------
33958                       000093F2            apm32_ok:
33959 93F2     66    9D                           popf
33960 93F4           F8                           clc
33961 93F5           CB                           retf
33962                       000093F6            apm32_unimplemented:
33963                       000093F6            apm32_error:
33964 93F6     66    9D                           popf
33965 93F8           F9                           stc
33966 93F9           CB                           retf
33967                                           use16 386
33968                       000093FA            apm16_out_str:
33969 93FA     66    50                           push eax
33970 93FC     66    53                           push ebx
33971 93FE     66    89C3                         mov ebx, eax
33972                       00009401            apm16_out_str1:
33973 9401           2E                           SEG CS
33974 9402           8A07                         mov al, byte ptr [bx]
33975 9404           3C                     00    cmp al, #0
33976 9406           74           05              je apm16_out_str2
33977 9408           EE                           outb dx, al
33978 9409     66    43                           inc ebx
33979 940B           EB           F4              jmp apm16_out_str1
33980                       0000940D            apm16_out_str2:
33981 940D     66    5B                           pop ebx
33982 940F     66    58                           pop eax
33983 9411           C3                           ret
33984                       00009412            apm16_07_poweroff_str:
33985 9412                        53              .ascii "Shutdown"
33986 941A                        00              db 0
33987                       0000941B            apm16_07_suspend_str:
33988 941B                        53              .ascii "Suspend"
33989 9422                        00              db 0
33990                       00009423            apm16_07_standby_str:
33991 9423                        53              .ascii "Standby"
33992 942A                        00              db 0
33993                       0000942B            _apm16_entry:
33994 942B           9C                           pushf
33995                                           ;-----------------
33996                                           ; APM interface disconnect
33997                       0000942C            apm16_04:
33998 942C           3C                     04    cmp al, #0x04
33999 942E           75           03              jne apm16_05
34000 9430           E9         008B              jmp apm16_ok
34001                                           ;-----------------
34002                                           ; APM cpu idle
34003                       00009433            apm16_05:
34004 9433           3C                     05    cmp al, #0x05
34005 9435           75           05              jne apm16_07
34006 9437           FB                           sti
34007 9438           F4                           hlt
34008 9439           E9         0082              jmp apm16_ok
34009                                           ;-----------------
34010                                           ; APM Set Power State
34011                       0000943C            apm16_07:
34012 943C           3C                     07    cmp al, #0x07
34013 943E           75           41              jne apm16_08
34014 9440           83FB                   01    cmp bx, #1
34015 9443           75           79              jne apm16_ok
34016 9445           83F9                   03    cmp cx, #3
34017 9448           74           0C              je apm16_07_poweroff
34018 944A           83F9                   02    cmp cx, #2
34019 944D           74           14              je apm16_07_suspend
34020 944F           83F9                   01    cmp cx, #1
34021 9452           74           1E              je apm16_07_standby
34022 9454           75           68              jne apm16_ok
34023                       00009456            apm16_07_poweroff:
34024 9456           FA                           cli
34025 9457           BA                   8900    mov dx, #0x8900
34026 945A           B8                   9412    mov ax, #apm16_07_poweroff_str
34027 945D           E8         FF9A              call apm16_out_str
34028                       00009460            apm16_07_1:
34029 9460           F4                           hlt
34030 9461           EB           FD              jmp apm16_07_1
34031                       00009463            apm16_07_suspend:
34032 9463     66    52                           push edx
34033 9465           BA                   8900    mov dx, #0x8900
34034 9468           B8                   941B    mov ax, #apm16_07_suspend_str
34035 946B           E8         FF8C              call apm16_out_str
34036 946E     66    5A                           pop edx
34037 9470           EB           4C              jmp apm16_ok
34038                       00009472            apm16_07_standby:
34039 9472     66    52                           push edx
34040 9474           BA                   8900    mov dx, #0x8900
34041 9477           B8                   9423    mov ax, #apm16_07_standby_str
34042 947A           E8         FF7D              call apm16_out_str
34043 947D     66    5A                           pop edx
34044 947F           EB           3D              jmp apm16_ok
34045                                           ;-----------------
34046                                           ; APM Enable / Disable
34047                       00009481            apm16_08:
34048 9481           3C                     08    cmp al, #0x08
34049 9483           75           02              jne apm16_0a
34050 9485           EB           37              jmp apm16_ok
34051                                           ;-----------------
34052                                           ; Get Power Status
34053                       00009487            apm16_0a:
34054 9487           3C                     0A    cmp al, #0x0a
34055 9489           75           10              jne apm16_0b
34056 948B           B7                     01    mov bh, #0x01
34057 948D           B3                     FF    mov bl, #0xff
34058 948F           B5                     80    mov ch, #0x80
34059 9491           B1                     FF    mov cl, #0xff
34060 9493           BA                   FFFF    mov dx, #0xffff
34061 9496           BE                   0000    mov si, #0
34062 9499           EB           23              jmp apm16_ok
34063                                           ;-----------------
34064                                           ; Get PM Event
34065                       0000949B            apm16_0b:
34066 949B           3C                     0B    cmp al, #0x0b
34067 949D           75           04              jne apm16_0e
34068 949F           B4                     80    mov ah, #0x80
34069 94A1           EB           1E              jmp apm16_error
34070                                           ;-----------------
34071                                           ; APM Driver Version
34072                       000094A3            apm16_0e:
34073 94A3           3C                     0E    cmp al, #0x0e
34074 94A5           75           06              jne apm16_0f
34075 94A7           B4                     01    mov ah, #1
34076 94A9           B0                     02    mov al, #2
34077 94AB           EB           11              jmp apm16_ok
34078                                           ;-----------------
34079                                           ; APM Engage / Disengage
34080                       000094AD            apm16_0f:
34081 94AD           3C                     0F    cmp al, #0x0f
34082 94AF           75           02              jne apm16_10
34083 94B1           EB           0B              jmp apm16_ok
34084                                           ;-----------------
34085                                           ; APM Get Capabilities
34086                       000094B3            apm16_10:
34087 94B3           3C                     10    cmp al, #0x10
34088 94B5           75           0A              jne apm16_unimplemented
34089 94B7           B3                     00    mov bl, #0
34090 94B9           B9                   0000    mov cx, #0
34091 94BC           EB           00              jmp apm16_ok
34092                                           ;-----------------
34093                       000094BE            apm16_ok:
34094 94BE           9D                           popf
34095 94BF           F8                           clc
34096 94C0           CB                           retf
34097                       000094C1            apm16_unimplemented:
34098                       000094C1            apm16_error:
34099 94C1           9D                           popf
34100 94C2           F9                           stc
34101 94C3           CB                           retf
34102                       000094C4            apmreal_out_str:
34103 94C4     66    50                           push eax
34104 94C6     66    53                           push ebx
34105 94C8     66    89C3                         mov ebx, eax
34106                       000094CB            apmreal_out_str1:
34107 94CB           2E                           SEG CS
34108 94CC           8A07                         mov al, byte ptr [bx]
34109 94CE           3C                     00    cmp al, #0
34110 94D0           74           05              je apmreal_out_str2
34111 94D2           EE                           outb dx, al
34112 94D3     66    43                           inc ebx
34113 94D5           EB           F4              jmp apmreal_out_str1
34114                       000094D7            apmreal_out_str2:
34115 94D7     66    5B                           pop ebx
34116 94D9     66    58                           pop eax
34117 94DB           C3                           ret
34118                       000094DC            apmreal_07_poweroff_str:
34119 94DC                        53              .ascii "Shutdown"
34120 94E4                        00              db 0
34121                       000094E5            apmreal_07_suspend_str:
34122 94E5                        53              .ascii "Suspend"
34123 94EC                        00              db 0
34124                       000094ED            apmreal_07_standby_str:
34125 94ED                        53              .ascii "Standby"
34126 94F4                        00              db 0
34127 94F5           9C                           pushf
34128                       000094F6            _apmreal_entry:
34129                                           ;-----------------
34130                                           ; APM installation check
34131                       000094F6            apmreal_00:
34132 94F6           3C                     00    cmp al, #0x00
34133 94F8           75           0E              jne apmreal_01
34134 94FA           B4                     01    mov ah, #1
34135 94FC           B0                     02    mov al, #2
34136 94FE           B7                     50    mov bh, #0x50
34137 9500           B3                     4D    mov bl, #0x4d
34138 9502           B9                   0003    mov cx, #0x3
34139 9505           E9         00CE              jmp apmreal_ok
34140                                           ;-----------------
34141                                           ; APM real mode interface connect
34142                       00009508            apmreal_01:
34143 9508           3C                     01    cmp al, #0x01
34144 950A           75           03              jne apmreal_02
34145 950C           E9         00C7              jmp apmreal_ok
34146                                           ;-----------------
34147                                           ; APM 16 bit protected mode interface connect
34148                       0000950F            apmreal_02:
34149 950F           3C                     02    cmp al, #0x02
34150 9511           75           12              jne apmreal_03
34151 9513           BB                   942B    mov bx, #_apm16_entry
34152 9516           B8                   F000    mov ax, #0xf000
34153 9519           BE                   FFF0    mov si, #0xfff0
34154 951C           B9                   F000    mov cx, #0xf000
34155 951F           BF                   FFF0    mov di, #0xfff0
34156 9522           E9         00B1              jmp apmreal_ok
34157                                           ;-----------------
34158                                           ; APM 32 bit protected mode interface connect
34159                       00009525            apmreal_03:
34160 9525           3C                     03    cmp al, #0x03
34161 9527           75           1B              jne apmreal_04
34162 9529           B8                   F000    mov ax, #0xf000
34163 952C     66    BB               00009346    mov ebx, #_apm32_entry
34164 9532           B9                   F000    mov cx, #0xf000
34165 9535     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
34166 953B           BA                   F000    mov dx, #0xf000
34167 953E           BF                   FFF0    mov di, #0xfff0
34168 9541           E9         0092              jmp apmreal_ok
34169                                           ;-----------------
34170                                           ; APM interface disconnect
34171                       00009544            apmreal_04:
34172 9544           3C                     04    cmp al, #0x04
34173 9546           75           03              jne apmreal_05
34174 9548           E9         008B              jmp apmreal_ok
34175                                           ;-----------------
34176                                           ; APM cpu idle
34177                       0000954B            apmreal_05:
34178 954B           3C                     05    cmp al, #0x05
34179 954D           75           05              jne apmreal_07
34180 954F           FB                           sti
34181 9550           F4                           hlt
34182 9551           E9         0082              jmp apmreal_ok
34183                                           ;-----------------
34184                                           ; APM Set Power State
34185                       00009554            apmreal_07:
34186 9554           3C                     07    cmp al, #0x07
34187 9556           75           41              jne apmreal_08
34188 9558           83FB                   01    cmp bx, #1
34189 955B           75           79              jne apmreal_ok
34190 955D           83F9                   03    cmp cx, #3
34191 9560           74           0C              je apmreal_07_poweroff
34192 9562           83F9                   02    cmp cx, #2
34193 9565           74           14              je apmreal_07_suspend
34194 9567           83F9                   01    cmp cx, #1
34195 956A           74           1E              je apmreal_07_standby
34196 956C           75           68              jne apmreal_ok
34197                       0000956E            apmreal_07_poweroff:
34198 956E           FA                           cli
34199 956F           BA                   8900    mov dx, #0x8900
34200 9572           B8                   94DC    mov ax, #apmreal_07_poweroff_str
34201 9575           E8         FF4C              call apmreal_out_str
34202                       00009578            apmreal_07_1:
34203 9578           F4                           hlt
34204 9579           EB           FD              jmp apmreal_07_1
34205                       0000957B            apmreal_07_suspend:
34206 957B     66    52                           push edx
34207 957D           BA                   8900    mov dx, #0x8900
34208 9580           B8                   94E5    mov ax, #apmreal_07_suspend_str
34209 9583           E8         FF3E              call apmreal_out_str
34210 9586     66    5A                           pop edx
34211 9588           EB           4C              jmp apmreal_ok
34212                       0000958A            apmreal_07_standby:
34213 958A     66    52                           push edx
34214 958C           BA                   8900    mov dx, #0x8900
34215 958F           B8                   94ED    mov ax, #apmreal_07_standby_str
34216 9592           E8         FF2F              call apmreal_out_str
34217 9595     66    5A                           pop edx
34218 9597           EB           3D              jmp apmreal_ok
34219                                           ;-----------------
34220                                           ; APM Enable / Disable
34221                       00009599            apmreal_08:
34222 9599           3C                     08    cmp al, #0x08
34223 959B           75           02              jne apmreal_0a
34224 959D           EB           37              jmp apmreal_ok
34225                                           ;-----------------
34226                                           ; Get Power Status
34227                       0000959F            apmreal_0a:
34228 959F           3C                     0A    cmp al, #0x0a
34229 95A1           75           10              jne apmreal_0b
34230 95A3           B7                     01    mov bh, #0x01
34231 95A5           B3                     FF    mov bl, #0xff
34232 95A7           B5                     80    mov ch, #0x80
34233 95A9           B1                     FF    mov cl, #0xff
34234 95AB           BA                   FFFF    mov dx, #0xffff
34235 95AE           BE                   0000    mov si, #0
34236 95B1           EB           23              jmp apmreal_ok
34237                                           ;-----------------
34238                                           ; Get PM Event
34239                       000095B3            apmreal_0b:
34240 95B3           3C                     0B    cmp al, #0x0b
34241 95B5           75           04              jne apmreal_0e
34242 95B7           B4                     80    mov ah, #0x80
34243 95B9           EB           20              jmp apmreal_error
34244                                           ;-----------------
34245                                           ; APM Driver Version
34246                       000095BB            apmreal_0e:
34247 95BB           3C                     0E    cmp al, #0x0e
34248 95BD           75           06              jne apmreal_0f
34249 95BF           B4                     01    mov ah, #1
34250 95C1           B0                     02    mov al, #2
34251 95C3           EB           11              jmp apmreal_ok
34252                                           ;-----------------
34253                                           ; APM Engage / Disengage
34254                       000095C5            apmreal_0f:
34255 95C5           3C                     0F    cmp al, #0x0f
34256 95C7           75           02              jne apmreal_10
34257 95C9           EB           0B              jmp apmreal_ok
34258                                           ;-----------------
34259                                           ; APM Get Capabilities
34260                       000095CB            apmreal_10:
34261 95CB           3C                     10    cmp al, #0x10
34262 95CD           75           0C              jne apmreal_unimplemented
34263 95CF           B3                     00    mov bl, #0
34264 95D1           B9                   0000    mov cx, #0
34265 95D4           EB           00              jmp apmreal_ok
34266                                           ;-----------------
34267                       000095D6            apmreal_ok:
34268 95D6           9D                           popf
34269 95D7           F8                           clc
34270 95D8           E9         F8BD              jmp iret_modify_cf
34271                       000095DB            apmreal_unimplemented:
34272                       000095DB            apmreal_error:
34273 95DB           9D                           popf
34274 95DC           F9                           stc
34275 95DD           E9         F8B8              jmp iret_modify_cf
34276                                           ;--------------------
34277                                           use32 386
34278 95E0                  00000010            .align 16
34279                       000095E0            bios32_structure:
34280 95E0                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
34281 95E4                      95F0              dw bios32_entry_point, 0xf ;; 32 bit physical address
34282 95E8                        00              db 0 ;; revision level
34283                                             ;; length in paragraphs and checksum stored in a word to prevent errors
34284 95E9                      4801              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
34285 95EB                        00              db 0,0,0,0,0 ;; reserved
34286 95F0                  00000010            .align 16
34287                       000095F0            bios32_entry_point:
34288 95F0           9C                           pushfd
34289 95F1           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
34290 95F6           75           3E              jne unknown_service
34291 95F8           B8               80000000    mov eax, #0x80000000
34292 95FD     66    BA                   0CF8    mov dx, #0x0cf8
34293 9601           EF                           out dx, eax
34294 9602     66    BA                   0CFC    mov dx, #0x0cfc
34295 9606           ED                           in eax, dx
34296 9607           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
34297 960C           74           15              je pci_found
34298 960E           3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
34299 9613           74           0E              je pci_found
34300 9615           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34301 961A           74           07              je pci_found
34302                                             ;; say ok if a device is present
34303 961C           3D               FFFFFFFF    cmp eax, #0xffffffff
34304 9621           74           13              je unknown_service
34305                       00009623            pci_found:
34306 9623           BB               000F0000    mov ebx, #0x000f0000
34307 9628           B9               00010000    mov ecx, #0x10000
34308 962D           BA               00009640    mov edx, #pcibios_protected
34309 9632           30C0                         xor al, al
34310 9634           EB           02              jmp bios32_end
34311                       00009636            unknown_service:
34312 9636           B0                     80    mov al, #0x80
34313                       00009638            bios32_end:
34314 9638           9D                           popfd
34315 9639           CB                           retf
34316 963A                  00000010            .align 16
34317                       00009640            pcibios_protected:
34318 9640           9C                           pushfd
34319 9641           FA                           cli
34320 9642           56                           push esi
34321 9643           57                           push edi
34322 9644           3C                     01    cmp al, #0x01 ;; installation check
34323 9646           75           15              jne pci_pro_f02
34324 9648     66    BB                   0210    mov bx, #0x0210
34325 964C           E8     0000012E              call pci_pro_get_max_bus ;; sets CX
34326 9651           BA               20494350    mov edx, #0x20494350 ;; "PCI "
34327 9656           B0                     01    mov al, #0x01
34328 9658           E9     0000011B              jmp pci_pro_ok
34329                       0000965D            pci_pro_f02: ;; find pci device
34330 965D           3C                     02    cmp al, #0x02
34331 965F           75           38              jne pci_pro_f03
34332 9661           C1E1                   10    shl ecx, #16
34333 9664     66    89D1                         mov cx, dx
34334 9667     66    31DB                         xor bx, bx
34335 966A     66    BF                   0000    mov di, #0x00
34336                       0000966E            pci_pro_devloop:
34337 966E           E8     0000012D              call pci_pro_select_reg
34338 9673     66    BA                   0CFC    mov dx, #0x0cfc
34339 9677           ED                           in eax, dx
34340 9678           39C8                         cmp eax, ecx
34341 967A           75           0D              jne pci_pro_nextdev
34342 967C     66    83FE                   00    cmp si, #0
34343 9680   7505    E9     000000F1              je pci_pro_ok
34344 9687     66    4E                           dec si
34345                       00009689            pci_pro_nextdev:
34346 9689     66    43                           inc bx
34347 968B     66    81FB                 0200    cmp bx, #0x0200
34348 9690           75           DC              jne pci_pro_devloop
34349 9692           B4                     86    mov ah, #0x86
34350 9694           E9     000000DA              jmp pci_pro_fail
34351                       00009699            pci_pro_f03: ;; find class code
34352 9699           3C                     03    cmp al, #0x03
34353 969B           75           35              jne pci_pro_f08
34354 969D     66    31DB                         xor bx, bx
34355 96A0     66    BF                   0008    mov di, #0x08
34356                       000096A4            pci_pro_devloop2:
34357 96A4           E8     000000F7              call pci_pro_select_reg
34358 96A9     66    BA                   0CFC    mov dx, #0x0cfc
34359 96AD           ED                           in eax, dx
34360 96AE           C1E8                   08    shr eax, #8
34361 96B1           39C8                         cmp eax, ecx
34362 96B3           75           0D              jne pci_pro_nextdev2
34363 96B5     66    83FE                   00    cmp si, #0
34364 96B9   7505    E9     000000B8              je pci_pro_ok
34365 96C0     66    4E                           dec si
34366                       000096C2            pci_pro_nextdev2:
34367 96C2     66    43                           inc bx
34368 96C4     66    81FB                 0200    cmp bx, #0x0200
34369 96C9           75           D9              jne pci_pro_devloop2
34370 96CB           B4                     86    mov ah, #0x86
34371 96CD           E9     000000A1              jmp pci_pro_fail
34372                       000096D2            pci_pro_f08: ;; read configuration byte
34373 96D2           3C                     08    cmp al, #0x08
34374 96D4           75           1B              jne pci_pro_f09
34375 96D6           E8     000000C5              call pci_pro_select_reg
34376 96DB           52                           push edx
34377 96DC     66    89FA                         mov dx, di
34378 96DF     66    83E2                   03    and dx, #0x03
34379 96E3     66    81C2                 0CFC    add dx, #0x0cfc
34380 96E8           EC                           in al, dx
34381 96E9           5A                           pop edx
34382 96EA           88C1                         mov cl, al
34383 96EC           E9     00000087              jmp pci_pro_ok
34384                       000096F1            pci_pro_f09: ;; read configuration word
34385 96F1           3C                     09    cmp al, #0x09
34386 96F3           75           1A              jne pci_pro_f0a
34387 96F5           E8     000000A6              call pci_pro_select_reg
34388 96FA           52                           push edx
34389 96FB     66    89FA                         mov dx, di
34390 96FE     66    83E2                   02    and dx, #0x02
34391 9702     66    81C2                 0CFC    add dx, #0x0cfc
34392 9707     66    ED                           in ax, dx
34393 9709           5A                           pop edx
34394 970A     66    89C1                         mov cx, ax
34395 970D           EB           69              jmp pci_pro_ok
34396                       0000970F            pci_pro_f0a: ;; read configuration dword
34397 970F           3C                     0A    cmp al, #0x0a
34398 9711           75           10              jne pci_pro_f0b
34399 9713           E8     00000088              call pci_pro_select_reg
34400 9718           52                           push edx
34401 9719     66    BA                   0CFC    mov dx, #0x0cfc
34402 971D           ED                           in eax, dx
34403 971E           5A                           pop edx
34404 971F           89C1                         mov ecx, eax
34405 9721           EB           55              jmp pci_pro_ok
34406                       00009723            pci_pro_f0b: ;; write configuration byte
34407 9723           3C                     0B    cmp al, #0x0b
34408 9725           75           18              jne pci_pro_f0c
34409 9727           E8     00000074              call pci_pro_select_reg
34410 972C           52                           push edx
34411 972D     66    89FA                         mov dx, di
34412 9730     66    83E2                   03    and dx, #0x03
34413 9734     66    81C2                 0CFC    add dx, #0x0cfc
34414 9739           88C8                         mov al, cl
34415 973B           EE                           out dx, al
34416 973C           5A                           pop edx
34417 973D           EB           39              jmp pci_pro_ok
34418                       0000973F            pci_pro_f0c: ;; write configuration word
34419 973F           3C                     0C    cmp al, #0x0c
34420 9741           75           1A              jne pci_pro_f0d
34421 9743           E8     00000058              call pci_pro_select_reg
34422 9748           52                           push edx
34423 9749     66    89FA                         mov dx, di
34424 974C     66    83E2                   02    and dx, #0x02
34425 9750     66    81C2                 0CFC    add dx, #0x0cfc
34426 9755     66    89C8                         mov ax, cx
34427 9758     66    EF                           out dx, ax
34428 975A           5A                           pop edx
34429 975B           EB           1B              jmp pci_pro_ok
34430                       0000975D            pci_pro_f0d: ;; write configuration dword
34431 975D           3C                     0D    cmp al, #0x0d
34432 975F           75           10              jne pci_pro_unknown
34433 9761           E8     0000003A              call pci_pro_select_reg
34434 9766           52                           push edx
34435 9767     66    BA                   0CFC    mov dx, #0x0cfc
34436 976B           89C8                         mov eax, ecx
34437 976D           EF                           out dx, eax
34438 976E           5A                           pop edx
34439 976F           EB           07              jmp pci_pro_ok
34440                       00009771            pci_pro_unknown:
34441 9771           B4                     81    mov ah, #0x81
34442                       00009773            pci_pro_fail:
34443 9773           5F                           pop edi
34444 9774           5E                           pop esi
34445 9775           9D                           popfd
34446 9776           F9                           stc
34447 9777           CB                           retf
34448                       00009778            pci_pro_ok:
34449 9778           30E4                         xor ah, ah
34450 977A           5F                           pop edi
34451 977B           5E                           pop esi
34452 977C           9D                           popfd
34453 977D           F8                           clc
34454 977E           CB                           retf
34455                       0000977F            pci_pro_get_max_bus:
34456 977F           50                           push eax
34457 9780           B8               80000000    mov eax, #0x80000000
34458 9785     66    BA                   0CF8    mov dx, #0x0cf8
34459 9789           EF                           out dx, eax
34460 978A     66    BA                   0CFC    mov dx, #0x0cfc
34461 978E           ED                           in eax, dx
34462 978F     66    B9                   0000    mov cx, #0
34463 9793           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34464 9798           75           04              jne pci_pro_no_i440bx
34465 979A     66    B9                   0001    mov cx, #0x0001
34466                       0000979E            pci_pro_no_i440bx:
34467 979E           58                           pop eax
34468 979F           C3                           ret
34469                       000097A0            pci_pro_select_reg:
34470 97A0           52                           push edx
34471 97A1           B8               00800000    mov eax, #0x800000
34472 97A6     66    89D8                         mov ax, bx
34473 97A9           C1E0                   08    shl eax, #8
34474 97AC     66    81E7                 00FF    and di, #0xff
34475 97B1     66    09F8                         or ax, di
34476 97B4           24                     FC    and al, #0xfc
34477 97B6     66    BA                   0CF8    mov dx, #0x0cf8
34478 97BA           EF                           out dx, eax
34479 97BB           5A                           pop edx
34480 97BC           C3                           ret
34481                                           use16 386
34482                       000097BD            pcibios_real:
34483 97BD     66    50                           push eax
34484 97BF           52                           push dx
34485 97C0     66    B8               80000000    mov eax, #0x80000000
34486 97C6           BA                   0CF8    mov dx, #0x0cf8
34487 97C9     66    EF                           out dx, eax
34488 97CB           BA                   0CFC    mov dx, #0x0cfc
34489 97CE     66    ED                           in eax, dx
34490 97D0     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
34491 97D6           74           1F              je pci_present
34492 97D8     66    3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
34493 97DE           74           17              je pci_present
34494 97E0     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34495 97E6           74           0F              je pci_present
34496                                             ;; say ok if a device is present
34497 97E8     66    3D               FFFFFFFF    cmp eax, #0xffffffff
34498 97EE           75           07              jne pci_present
34499 97F0           5A                           pop dx
34500 97F1     66    58                           pop eax
34501 97F3           B4                     FF    mov ah, #0xff
34502 97F5           F9                           stc
34503 97F6           C3                           ret
34504                       000097F7            pci_present:
34505 97F7           5A                           pop dx
34506 97F8     66    58                           pop eax
34507 97FA           3C                     01    cmp al, #0x01 ;; installation check
34508 97FC           75           1A              jne pci_real_f02
34509 97FE           B8                   0001    mov ax, #0x0001
34510 9801           BB                   0210    mov bx, #0x0210
34511 9804           E8         0145              call pci_real_get_max_bus ;; sets CX
34512 9807     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
34513 980D     66    BF               000F0000    mov edi, #0xf0000
34514 9813           BF                   9640    mov di, #pcibios_protected
34515 9816           F8                           clc
34516 9817           C3                           ret
34517                       00009818            pci_real_f02: ;; find pci device
34518 9818     66    56                           push esi
34519 981A     66    57                           push edi
34520 981C           3C                     02    cmp al, #0x02
34521 981E           75           34              jne pci_real_f03
34522 9820     66    C1E1                   10    shl ecx, #16
34523 9824           89D1                         mov cx, dx
34524 9826           31DB                         xor bx, bx
34525 9828           BF                   0000    mov di, #0x00
34526                       0000982B            pci_real_devloop:
34527 982B           E8         0141              call pci_real_select_reg
34528 982E           BA                   0CFC    mov dx, #0x0cfc
34529 9831     66    ED                           in eax, dx
34530 9833     66    39C8                         cmp eax, ecx
34531 9836           75           09              jne pci_real_nextdev
34532 9838           83FE                   00    cmp si, #0
34533 983B   7503    E9         0104              je pci_real_ok
34534 9840           4E                           dec si
34535                       00009841            pci_real_nextdev:
34536 9841           43                           inc bx
34537 9842           81FB                 0200    cmp bx, #0x0200
34538 9846           75           E3              jne pci_real_devloop
34539 9848           89CA                         mov dx, cx
34540 984A     66    C1E9                   10    shr ecx, #16
34541 984E           B8                   8602    mov ax, #0x8602
34542 9851           E9         00EA              jmp pci_real_fail
34543                       00009854            pci_real_f03: ;; find class code
34544 9854           3C                     03    cmp al, #0x03
34545 9856           75           32              jne pci_real_f08
34546 9858           31DB                         xor bx, bx
34547 985A           BF                   0008    mov di, #0x08
34548                       0000985D            pci_real_devloop2:
34549 985D           E8         010F              call pci_real_select_reg
34550 9860           BA                   0CFC    mov dx, #0x0cfc
34551 9863     66    ED                           in eax, dx
34552 9865     66    C1E8                   08    shr eax, #8
34553 9869     66    39C8                         cmp eax, ecx
34554 986C           75           09              jne pci_real_nextdev2
34555 986E           83FE                   00    cmp si, #0
34556 9871   7503    E9         00CE              je pci_real_ok
34557 9876           4E                           dec si
34558                       00009877            pci_real_nextdev2:
34559 9877           43                           inc bx
34560 9878           81FB                 0200    cmp bx, #0x0200
34561 987C           75           DF              jne pci_real_devloop2
34562 987E           89CA                         mov dx, cx
34563 9880     66    C1E9                   10    shr ecx, #16
34564 9884           B8                   8603    mov ax, #0x8603
34565 9887           E9         00B4              jmp pci_real_fail
34566                       0000988A            pci_real_f08: ;; read configuration byte
34567 988A           3C                     08    cmp al, #0x08
34568 988C           75           14              jne pci_real_f09
34569 988E           E8         00DE              call pci_real_select_reg
34570 9891           52                           push dx
34571 9892           89FA                         mov dx, di
34572 9894           83E2                   03    and dx, #0x03
34573 9897           81C2                 0CFC    add dx, #0x0cfc
34574 989B           EC                           in al, dx
34575 989C           5A                           pop dx
34576 989D           88C1                         mov cl, al
34577 989F           E9         00A2              jmp pci_real_ok
34578                       000098A2            pci_real_f09: ;; read configuration word
34579 98A2           3C                     09    cmp al, #0x09
34580 98A4           75           14              jne pci_real_f0a
34581 98A6           E8         00C6              call pci_real_select_reg
34582 98A9           52                           push dx
34583 98AA           89FA                         mov dx, di
34584 98AC           83E2                   02    and dx, #0x02
34585 98AF           81C2                 0CFC    add dx, #0x0cfc
34586 98B3           ED                           in ax, dx
34587 98B4           5A                           pop dx
34588 98B5           89C1                         mov cx, ax
34589 98B7           E9         008A              jmp pci_real_ok
34590                       000098BA            pci_real_f0a: ;; read configuration dword
34591 98BA           3C                     0A    cmp al, #0x0a
34592 98BC           75           0F              jne pci_real_f0b
34593 98BE           E8         00AE              call pci_real_select_reg
34594 98C1           52                           push dx
34595 98C2           BA                   0CFC    mov dx, #0x0cfc
34596 98C5     66    ED                           in eax, dx
34597 98C7           5A                           pop dx
34598 98C8     66    89C1                         mov ecx, eax
34599 98CB           EB           77              jmp pci_real_ok
34600                       000098CD            pci_real_f0b: ;; write configuration byte
34601 98CD           3C                     0B    cmp al, #0x0b
34602 98CF           75           13              jne pci_real_f0c
34603 98D1           E8         009B              call pci_real_select_reg
34604 98D4           52                           push dx
34605 98D5           89FA                         mov dx, di
34606 98D7           83E2                   03    and dx, #0x03
34607 98DA           81C2                 0CFC    add dx, #0x0cfc
34608 98DE           88C8                         mov al, cl
34609 98E0           EE                           out dx, al
34610 98E1           5A                           pop dx
34611 98E2           EB           60              jmp pci_real_ok
34612                       000098E4            pci_real_f0c: ;; write configuration word
34613 98E4           3C                     0C    cmp al, #0x0c
34614 98E6           75           13              jne pci_real_f0d
34615 98E8           E8         0084              call pci_real_select_reg
34616 98EB           52                           push dx
34617 98EC           89FA                         mov dx, di
34618 98EE           83E2                   02    and dx, #0x02
34619 98F1           81C2                 0CFC    add dx, #0x0cfc
34620 98F5           89C8                         mov ax, cx
34621 98F7           EF                           out dx, ax
34622 98F8           5A                           pop dx
34623 98F9           EB           49              jmp pci_real_ok
34624                       000098FB            pci_real_f0d: ;; write configuration dword
34625 98FB           3C                     0D    cmp al, #0x0d
34626 98FD           75           0F              jne pci_real_f0e
34627 98FF           E8         006D              call pci_real_select_reg
34628 9902           52                           push dx
34629 9903           BA                   0CFC    mov dx, #0x0cfc
34630 9906     66    89C8                         mov eax, ecx
34631 9909     66    EF                           out dx, eax
34632 990B           5A                           pop dx
34633 990C           EB           36              jmp pci_real_ok
34634                       0000990E            pci_real_f0e: ;; get irq routing options
34635 990E           3C                     0E    cmp al, #0x0e
34636 9910           75           2A              jne pci_real_unknown
34637 9912           50                           push ax
34638 9913           B8                   0060    mov ax, #pci_routing_table_structure_end - pci_routing_table_structure_start
34639 9916           26                           SEG ES
34640 9917           3905                         cmp word ptr [di], ax
34641 9919           72           1B              jb pci_real_too_small
34642 991B           AB                           stosw
34643 991C           9C                           pushf
34644 991D           06                           push es
34645 991E           51                           push cx
34646 991F           FC                           cld
34647 9920           BE                   99B0    mov si, #pci_routing_table_structure_start
34648 9923           0E                           push cs
34649 9924           1F                           pop ds
34650 9925           26                           SEG ES
34651 9926           C47D         02              les di, [di+2]
34652 9929           89C1                         mov cx, ax
34653 992B           F3                           rep
34654 992C           A4                               movsb
34655 992D           59                           pop cx
34656 992E           07                           pop es
34657 992F           9D                           popf
34658 9930           58                           pop ax
34659 9931           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
34660 9934           EB           0E              jmp pci_real_ok
34661                       00009936            pci_real_too_small:
34662 9936           AB                           stosw
34663 9937           58                           pop ax
34664 9938           B4                     89    mov ah, #0x89
34665 993A           EB           02              jmp pci_real_fail
34666                       0000993C            pci_real_unknown:
34667 993C           B4                     81    mov ah, #0x81
34668                       0000993E            pci_real_fail:
34669 993E     66    5F                           pop edi
34670 9940     66    5E                           pop esi
34671 9942           F9                           stc
34672 9943           C3                           ret
34673                       00009944            pci_real_ok:
34674 9944           30E4                         xor ah, ah
34675 9946     66    5F                           pop edi
34676 9948     66    5E                           pop esi
34677 994A           F8                           clc
34678 994B           C3                           ret
34679                       0000994C            pci_real_get_max_bus:
34680 994C     66    50                           push eax
34681 994E     66    B8               80000000    mov eax, #0x80000000
34682 9954           BA                   0CF8    mov dx, #0x0cf8
34683 9957     66    EF                           out dx, eax
34684 9959           BA                   0CFC    mov dx, #0x0cfc
34685 995C     66    ED                           in eax, dx
34686 995E           B9                   0000    mov cx, #0
34687 9961     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34688 9967           75           03              jne pci_real_no_i440bx
34689 9969           B9                   0001    mov cx, #0x0001
34690                       0000996C            pci_real_no_i440bx:
34691 996C     66    58                           pop eax
34692 996E           C3                           ret
34693                       0000996F            pci_real_select_reg:
34694 996F           52                           push dx
34695 9970     66    B8               00800000    mov eax, #0x800000
34696 9976           89D8                         mov ax, bx
34697 9978     66    C1E0                   08    shl eax, #8
34698 997C           81E7                 00FF    and di, #0xff
34699 9980           09F8                         or ax, di
34700 9982           24                     FC    and al, #0xfc
34701 9984           BA                   0CF8    mov dx, #0x0cf8
34702 9987     66    EF                           out dx, eax
34703 9989           5A                           pop dx
34704 998A           C3                           ret
34705 998B                  00000010            .align 16
34706                       00009990            pci_routing_table_structure:
34707 9990                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
34708 9994                        00              db 0, 1 ;; version
34709 9996                      0080              dw 32 + (6 * 16) ;; table size
34710 9998                        00              db 0 ;; PCI interrupt router bus
34711 9999                        08              db 0x08 ;; PCI interrupt router DevFunc
34712 999A                      0000              dw 0x0000 ;; PCI exclusive IRQs
34713 999C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
34714 999E                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
34715 99A0                      0000              dw 0,0 ;; Miniport data
34716 99A4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
34717 99AF                        37              db 0x37 ;; checksum
34718                       000099B0            pci_routing_table_structure_start:
34719                                             ;; first slot entry PCI-to-ISA (embedded)
34720 99B0                        00              db 0 ;; pci bus number
34721 99B1                        08              db 0x08 ;; pci device number (bit 7-3)
34722 99B2                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
34723 99B3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34724 99B5                        61              db 0x61 ;; link value INTB#
34725 99B6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34726 99B8                        62              db 0x62 ;; link value INTC#
34727 99B9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34728 99BB                        63              db 0x63 ;; link value INTD#
34729 99BC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34730 99BE                        00              db 0 ;; physical slot (0 = embedded)
34731 99BF                        00              db 0 ;; reserved
34732                                             ;; second slot entry: 1st PCI slot
34733 99C0                        00              db 0 ;; pci bus number
34734 99C1                        10              db 0x10 ;; pci device number (bit 7-3)
34735 99C2                        61              db 0x61 ;; link value INTA#
34736 99C3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34737 99C5                        62              db 0x62 ;; link value INTB#
34738 99C6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34739 99C8                        63              db 0x63 ;; link value INTC#
34740 99C9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34741 99CB                        60              db 0x60 ;; link value INTD#
34742 99CC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34743 99CE                        01              db 1 ;; physical slot (0 = embedded)
34744 99CF                        00              db 0 ;; reserved
34745                                             ;; third slot entry: 2nd PCI slot
34746 99D0                        00              db 0 ;; pci bus number
34747 99D1                        18              db 0x18 ;; pci device number (bit 7-3)
34748 99D2                        62              db 0x62 ;; link value INTA#
34749 99D3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34750 99D5                        63              db 0x63 ;; link value INTB#
34751 99D6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34752 99D8                        60              db 0x60 ;; link value INTC#
34753 99D9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34754 99DB                        61              db 0x61 ;; link value INTD#
34755 99DC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34756 99DE                        02              db 2 ;; physical slot (0 = embedded)
34757 99DF                        00              db 0 ;; reserved
34758                                             ;; 4th slot entry: 3rd PCI slot
34759 99E0                        00              db 0 ;; pci bus number
34760 99E1                        20              db 0x20 ;; pci device number (bit 7-3)
34761 99E2                        63              db 0x63 ;; link value INTA#
34762 99E3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34763 99E5                        60              db 0x60 ;; link value INTB#
34764 99E6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34765 99E8                        61              db 0x61 ;; link value INTC#
34766 99E9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34767 99EB                        62              db 0x62 ;; link value INTD#
34768 99EC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34769 99EE                        03              db 3 ;; physical slot (0 = embedded)
34770 99EF                        00              db 0 ;; reserved
34771                                             ;; 5th slot entry: 4th PCI slot
34772 99F0                        00              db 0 ;; pci bus number
34773 99F1                        28              db 0x28 ;; pci device number (bit 7-3)
34774 99F2                        60              db 0x60 ;; link value INTA#
34775 99F3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34776 99F5                        61              db 0x61 ;; link value INTB#
34777 99F6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34778 99F8                        62              db 0x62 ;; link value INTC#
34779 99F9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34780 99FB                        63              db 0x63 ;; link value INTD#
34781 99FC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34782 99FE                        04              db 4 ;; physical slot (0 = embedded)
34783 99FF                        00              db 0 ;; reserved
34784                                             ;; 6th slot entry: 5th PCI slot
34785 9A00                        00              db 0 ;; pci bus number
34786 9A01                        30              db 0x30 ;; pci device number (bit 7-3)
34787 9A02                        61              db 0x61 ;; link value INTA#
34788 9A03                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34789 9A05                        62              db 0x62 ;; link value INTB#
34790 9A06                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34791 9A08                        63              db 0x63 ;; link value INTC#
34792 9A09                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34793 9A0B                        60              db 0x60 ;; link value INTD#
34794 9A0C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34795 9A0E                        05              db 5 ;; physical slot (0 = embedded)
34796 9A0F                        00              db 0 ;; reserved
34797                       00009A10            pci_routing_table_structure_end:
34798                       00009A10            pci_irq_list:
34799 9A10                        0B              db 11, 10, 9, 5;
34800                       00009A14            pcibios_init_sel_reg:
34801 9A14     66    50                           push eax
34802 9A16     66    B8               00800000    mov eax, #0x800000
34803 9A1C           89D8                         mov ax, bx
34804 9A1E     66    C1E0                   08    shl eax, #8
34805 9A22           80E2                   FC    and dl, #0xfc
34806 9A25           08D0                         or al, dl
34807 9A27           BA                   0CF8    mov dx, #0x0cf8
34808 9A2A     66    EF                           out dx, eax
34809 9A2C     66    58                           pop eax
34810 9A2E           C3                           ret
34811                       00009A2F            pcibios_init_iomem_bases:
34812 9A2F           55                           push bp
34813 9A30           89E5                         mov bp, sp
34814 9A32     66    B8               C0000000    mov eax, #0xc0000000 ;; base for memory init
34815 9A38     66    50                           push eax
34816 9A3A           B8                   C000    mov ax, #0xc000 ;; base for i/o init
34817 9A3D           50                           push ax
34818 9A3E           B8                   0010    mov ax, #0x0010 ;; start at base address #0
34819 9A41           50                           push ax
34820 9A42           BB                   0008    mov bx, #0x0008
34821                       00009A45            pci_init_io_loop1:
34822 9A45           B2                     00    mov dl, #0x00
34823 9A47           E8         FFCA              call pcibios_init_sel_reg
34824 9A4A           BA                   0CFC    mov dx, #0x0cfc
34825 9A4D           ED                           in ax, dx
34826 9A4E           3D                   FFFF    cmp ax, #0xffff
34827 9A51   7503    E9         0087              jz next_pci_dev
34828 9A56           B2                     04    mov dl, #0x04 ;; disable i/o and memory space access
34829 9A58           E8         FFB9              call pcibios_init_sel_reg
34830 9A5B           BA                   0CFC    mov dx, #0x0cfc
34831 9A5E           EC                           in al, dx
34832 9A5F           24                     FC    and al, #0xfc
34833 9A61           EE                           out dx, al
34834                       00009A62            pci_init_io_loop2:
34835 9A62           8A56         F8              mov dl, [bp-8]
34836 9A65           E8         FFAC              call pcibios_init_sel_reg
34837 9A68           BA                   0CFC    mov dx, #0x0cfc
34838 9A6B     66    ED                           in eax, dx
34839 9A6D           A8                     01    test al, #0x01
34840 9A6F           75           33              jnz init_io_base
34841 9A71     66    89C1                         mov ecx, eax
34842 9A74     66    B8               FFFFFFFF    mov eax, #0xffffffff
34843 9A7A     66    EF                           out dx, eax
34844 9A7C     66    ED                           in eax, dx
34845 9A7E     66    39C8                         cmp eax, ecx
34846 9A81           74           40              je next_pci_base
34847 9A83     66    F7D0                         not eax
34848 9A86     66    89C1                         mov ecx, eax
34849 9A89     66    8B46         FC              mov eax, [bp-4]
34850 9A8D     66    EF                           out dx, eax
34851 9A8F     66    01C8                         add eax, ecx ;; calculate next free mem base
34852 9A92     66    05               01000000    add eax, #0x01000000
34853 9A98     66    25               FF000000    and eax, #0xff000000
34854 9A9E     66    8946         FC              mov [bp-4], eax
34855 9AA2           EB           1F              jmp next_pci_base
34856                       00009AA4            init_io_base:
34857 9AA4           89C1                         mov cx, ax
34858 9AA6           B8                   FFFF    mov ax, #0xffff
34859 9AA9           EF                           out dx, ax
34860 9AAA           ED                           in ax, dx
34861 9AAB           39C8                         cmp ax, cx
34862 9AAD           74           14              je next_pci_base
34863 9AAF           35                   FFFE    xor ax, #0xfffe
34864 9AB2           89C1                         mov cx, ax
34865 9AB4           8B46         FA              mov ax, [bp-6]
34866 9AB7           EF                           out dx, ax
34867 9AB8           01C8                         add ax, cx ;; calculate next free i/o base
34868 9ABA           05                   0100    add ax, #0x0100
34869 9ABD           25                   FF00    and ax, #0xff00
34870 9AC0           8946         FA              mov [bp-6], ax
34871                       00009AC3            next_pci_base:
34872 9AC3           8A46         F8              mov al, [bp-8]
34873 9AC6           04                     04    add al, #0x04
34874 9AC8           3C                     28    cmp al, #0x28
34875 9ACA           74           05              je enable_iomem_space
34876 9ACC           8846         F8              mov byte ptr[bp-8], al
34877 9ACF           EB           91              jmp pci_init_io_loop2
34878                       00009AD1            enable_iomem_space:
34879 9AD1           B2                     04    mov dl, #0x04 ;; enable i/o and memory space access if available
34880 9AD3           E8         FF3E              call pcibios_init_sel_reg
34881 9AD6           BA                   0CFC    mov dx, #0x0cfc
34882 9AD9           EC                           in al, dx
34883 9ADA           0C                     03    or al, #0x03
34884 9ADC           EE                           out dx, al
34885                       00009ADD            next_pci_dev:
34886 9ADD           C646         F8        10    mov byte ptr[bp-8], #0x10
34887 9AE1           43                           inc bx
34888 9AE2           81FB                 0100    cmp bx, #0x0100
34889 9AE6   7403    E9         FF5A              jne pci_init_io_loop1
34890 9AEB           C9                           leave
34891 9AEC           C3                           ret
34892                       00009AED            pcibios_init_set_elcr:
34893 9AED           50                           push ax
34894 9AEE           51                           push cx
34895 9AEF           BA                   04D0    mov dx, #0x04d0
34896 9AF2           A8                     08    test al, #0x08
34897 9AF4           74           03              jz is_master_pic
34898 9AF6           42                           inc dx
34899 9AF7           24                     07    and al, #0x07
34900                       00009AF9            is_master_pic:
34901 9AF9           88C1                         mov cl, al
34902 9AFB           B3                     01    mov bl, #0x01
34903 9AFD           D2E3                         shl bl, cl
34904 9AFF           EC                           in al, dx
34905 9B00           08D8                         or al, bl
34906 9B02           EE                           out dx, al
34907 9B03           59                           pop cx
34908 9B04           58                           pop ax
34909 9B05           C3                           ret
34910                       00009B06            pcibios_init_irqs:
34911 9B06           1E                           push ds
34912 9B07           55                           push bp
34913 9B08           0E                           push cs
34914 9B09           1F                           pop ds
34915 9B0A           BA                   04D0    mov dx, #0x04d0 ;; reset ELCR1 + ELCR2
34916 9B0D           B0                     00    mov al, #0x00
34917 9B0F           EE                           out dx, al
34918 9B10           42                           inc dx
34919 9B11           EE                           out dx, al
34920 9B12           BE                   9990    mov si, #pci_routing_table_structure
34921 9B15           8A7C         08              mov bh, [si+8]
34922 9B18           8A5C         09              mov bl, [si+9]
34923 9B1B           B2                     00    mov dl, #0x00
34924 9B1D           E8         FEF4              call pcibios_init_sel_reg
34925 9B20           BA                   0CFC    mov dx, #0x0cfc
34926 9B23           ED                           in ax, dx
34927 9B24           3B44         0C              cmp ax, [si+12] ;; check irq router
34928 9B27   7403    E9         00A4              jne pci_init_end
34929 9B2C           8A54         22              mov dl, [si+34]
34930 9B2F           E8         FEE2              call pcibios_init_sel_reg
34931 9B32           53                           push bx ;; save irq router bus + devfunc
34932 9B33           BA                   0CFC    mov dx, #0x0cfc
34933 9B36           B8                   8080    mov ax, #0x8080
34934 9B39           EF                           out dx, ax ;; reset PIRQ route control
34935 9B3A           83C2                   02    add dx, #2
34936 9B3D           EF                           out dx, ax
34937 9B3E           8B44         06              mov ax, [si+6]
34938 9B41           2D                   0020    sub ax, #0x20
34939 9B44           C1E8                   04    shr ax, #4
34940 9B47           89C1                         mov cx, ax
34941 9B49           83C6                   20    add si, #0x20 ;; set pointer to 1st entry
34942 9B4C           89E5                         mov bp, sp
34943 9B4E           68                   9A10    push #pci_irq_list
34944 9B51           6A                     00    push #0x00
34945                       00009B53            pci_init_irq_loop1:
34946 9B53           8A3C                         mov bh, [si]
34947 9B55           8A5C         01              mov bl, [si+1]
34948                       00009B58            pci_init_irq_loop2:
34949 9B58           B2                     00    mov dl, #0x00
34950 9B5A           E8         FEB7              call pcibios_init_sel_reg
34951 9B5D           BA                   0CFC    mov dx, #0x0cfc
34952 9B60           ED                           in ax, dx
34953 9B61           3D                   FFFF    cmp ax, #0xffff
34954 9B64           75           07              jnz pci_test_int_pin
34955 9B66           F6C3                   07    test bl, #0x07
34956 9B69           74           59              jz next_pir_entry
34957 9B6B           EB           4D              jmp next_pci_func
34958                       00009B6D            pci_test_int_pin:
34959 9B6D           B2                     3C    mov dl, #0x3c
34960 9B6F           E8         FEA2              call pcibios_init_sel_reg
34961 9B72           BA                   0CFD    mov dx, #0x0cfd
34962 9B75           EC                           in al, dx
34963 9B76           24                     07    and al, #0x07
34964 9B78           74           40              jz next_pci_func
34965 9B7A           FEC8                         dec al ;; determine pirq reg
34966 9B7C           B2                     03    mov dl, #0x03
34967 9B7E           F6E2                         mul al, dl
34968 9B80           04                     02    add al, #0x02
34969 9B82           30E4                         xor ah, ah
34970 9B84           89C3                         mov bx, ax
34971 9B86           8A           00              mov al, [si+bx]
34972 9B88           88C2                         mov dl, al
34973 9B8A           8B5E         00              mov bx, [bp]
34974 9B8D           E8         FE84              call pcibios_init_sel_reg
34975 9B90           BA                   0CFC    mov dx, #0x0cfc
34976 9B93           24                     03    and al, #0x03
34977 9B95           00C2                         add dl, al
34978 9B97           EC                           in al, dx
34979 9B98           3C                     80    cmp al, #0x80
34980 9B9A           72           0D              jb pirq_found
34981 9B9C           8B5E         FE              mov bx, [bp-2] ;; pci irq list pointer
34982 9B9F           8A07                         mov al, [bx]
34983 9BA1           EE                           out dx, al
34984 9BA2           43                           inc bx
34985 9BA3           895E         FE              mov [bp-2], bx
34986 9BA6           E8         FF44              call pcibios_init_set_elcr
34987                       00009BA9            pirq_found:
34988 9BA9           8A3C                         mov bh, [si]
34989 9BAB           8A5C         01              mov bl, [si+1]
34990 9BAE           025E         FD              add bl, [bp-3] ;; pci function number
34991 9BB1           B2                     3C    mov dl, #0x3c
34992 9BB3           E8         FE5E              call pcibios_init_sel_reg
34993 9BB6           BA                   0CFC    mov dx, #0x0cfc
34994 9BB9           EE                           out dx, al
34995                       00009BBA            next_pci_func:
34996 9BBA           FE46         FD              inc byte ptr[bp-3]
34997 9BBD           FEC3                         inc bl
34998 9BBF           F6C3                   07    test bl, #0x07
34999 9BC2           75           94              jnz pci_init_irq_loop2
35000                       00009BC4            next_pir_entry:
35001 9BC4           83C6                   10    add si, #0x10
35002 9BC7           C646         FD        00    mov byte ptr[bp-3], #0x00
35003 9BCB           E2           86              loop pci_init_irq_loop1
35004 9BCD           89EC                         mov sp, bp
35005 9BCF           5B                           pop bx
35006                       00009BD0            pci_init_end:
35007 9BD0           5D                           pop bp
35008 9BD1           1F                           pop ds
35009 9BD2           C3                           ret
35010                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
35011                       00009BD3            detect_parport:
35012 9BD3           52                           push dx
35013 9BD4           83C2                   02    add dx, #2
35014 9BD7           EC                           in al, dx
35015 9BD8           24                     DF    and al, #0xdf ; clear input mode
35016 9BDA           EE                           out dx, al
35017 9BDB           5A                           pop dx
35018 9BDC           B0                     AA    mov al, #0xaa
35019 9BDE           EE                           out dx, al
35020 9BDF           EC                           in al, dx
35021 9BE0           3C                     AA    cmp al, #0xaa
35022 9BE2           75           0D              jne no_parport
35023 9BE4           53                           push bx
35024 9BE5           D1E3                         shl bx, #1
35025 9BE7           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
35026 9BEB           5B                           pop bx
35027 9BEC           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
35028 9BF0           43                           inc bx
35029                       00009BF1            no_parport:
35030 9BF1           C3                           ret
35031                                           ; serial port detection: base address in DX, index in BX, timeout in CL
35032                       00009BF2            detect_serial:
35033 9BF2           52                           push dx
35034 9BF3           42                           inc dx
35035 9BF4           B0                     02    mov al, #0x02
35036 9BF6           EE                           out dx, al
35037 9BF7           EC                           in al, dx
35038 9BF8           3C                     02    cmp al, #0x02
35039 9BFA           75           19              jne no_serial
35040 9BFC           42                           inc dx
35041 9BFD           EC                           in al, dx
35042 9BFE           3C                     02    cmp al, #0x02
35043 9C00           75           13              jne no_serial
35044 9C02           4A                           dec dx
35045 9C03           30C0                         xor al, al
35046 9C05           EE                           out dx, al
35047 9C06           5A                           pop dx
35048 9C07           53                           push bx
35049 9C08           D1E3                         shl bx, #1
35050 9C0A           8997       0400              mov [bx+0x400], dx ; Serial I/O address
35051 9C0E           5B                           pop bx
35052 9C0F           888F       047C              mov [bx+0x47c], cl ; Serial timeout
35053 9C13           43                           inc bx
35054 9C14           C3                           ret
35055                       00009C15            no_serial:
35056 9C15           5A                           pop dx
35057 9C16           C3                           ret
35058                       00009C17            rom_checksum:
35059 9C17           60                           pusha
35060 9C18           1E                           push ds
35061 9C19           31C0                         xor ax, ax
35062 9C1B           31DB                         xor bx, bx
35063 9C1D           31C9                         xor cx, cx
35064 9C1F           31D2                         xor dx, dx
35065 9C21           8A2E       0002              mov ch, [2]
35066 9C25           D1E1                         shl cx, #1
35067 9C27           73           05              jnc checksum_loop
35068 9C29           74           03              jz checksum_loop
35069 9C2B           87CA                         xchg dx, cx
35070 9C2D           49                           dec cx
35071                       00009C2E            checksum_loop:
35072 9C2E           0207                         add al, [bx]
35073 9C30           43                           inc bx
35074 9C31           E2           FB              loop checksum_loop
35075 9C33           85D2                         test dx, dx
35076 9C35           74           11              je checksum_out
35077 9C37           0207                         add al, [bx]
35078 9C39           89D1                         mov cx, dx
35079 9C3B           8CDA                         mov dx, ds
35080 9C3D           80C6                   10    add dh, #0x10
35081 9C40           8EDA                         mov ds, dx
35082 9C42           31D2                         xor dx, dx
35083 9C44           31DB                         xor bx, bx
35084 9C46           EB           E6              jmp checksum_loop
35085                       00009C48            checksum_out:
35086 9C48           24                     FF    and al, #0xff
35087 9C4A           1F                           pop ds
35088 9C4B           61                           popa
35089 9C4C           C3                           ret
35090 9C4D                  00000010            .align 16
35091                       00009C50            pnpbios_structure:
35092 9C50                        24              .ascii "$PnP"
35093 9C54                        10              db 0x10 ;; version
35094 9C55                        21              db 0x21 ;; length
35095 9C56                      0000              dw 0x0 ;; control field
35096 9C58                        D1              db 0xd1 ;; checksum
35097 9C59                  000F0000              dd 0xf0000 ;; event notification flag address
35098 9C5D                      9C78              dw pnpbios_real ;; real mode 16 bit offset
35099 9C5F                      F000              dw 0xf000 ;; real mode 16 bit segment
35100 9C61                      9C71              dw pnpbios_prot ;; 16 bit protected mode offset
35101 9C63                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35102 9C67                  00000000              dd 0x0 ;; OEM device identifier
35103 9C6B                      F000              dw 0xf000 ;; real mode 16 bit data segment
35104 9C6D                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35105                       00009C71            pnpbios_prot:
35106 9C71     66    55                           push ebp
35107 9C73     66    89E5                         mov ebp, esp
35108 9C76           EB           06              jmp pnpbios_code
35109                       00009C78            pnpbios_real:
35110 9C78     66    55                           push ebp
35111 9C7A     66  0FB7EC                         movzx ebp, sp
35112                       00009C7E            pnpbios_code:
35113 9C7E   67      8B45         08              mov ax, 8[ebp]
35114 9C82           3D                   0060    cmp ax, #0x60 ;; Get Version and Installation Check
35115 9C85           75           10              jnz pnpbios_00
35116 9C87           06                           push es
35117 9C88           57                           push di
35118 9C89   67      C47D         0A              les di, 10[ebp]
35119 9C8D           B8                   0101    mov ax, #0x0101
35120 9C90           AB                           stosw
35121 9C91           5F                           pop di
35122 9C92           07                           pop es
35123 9C93           31C0                         xor ax, ax ;; SUCCESS
35124 9C95           EB           1F              jmp pnpbios_exit
35125                       00009C97            pnpbios_00:
35126 9C97           3D                   0000    cmp ax, #0x00 ;; Get Number of System Device Nodes
35127 9C9A           75           17              jnz pnpbios_fail
35128 9C9C           06                           push es
35129 9C9D           57                           push di
35130 9C9E   67      C47D         0A              les di, 10[ebp]
35131 9CA2           B0                     00    mov al, #0x00
35132 9CA4           AA                           stosb
35133 9CA5   67      C47D         0E              les di, 14[ebp]
35134 9CA9           B8                   0000    mov ax, #0x0000
35135 9CAC           AB                           stosw
35136 9CAD           5F                           pop di
35137 9CAE           07                           pop es
35138 9CAF           31C0                         xor ax, ax ;; SUCCESS
35139 9CB1           EB           03              jmp pnpbios_exit
35140                       00009CB3            pnpbios_fail:
35141 9CB3           B8                   0082    mov ax, #0x82 ;; FUNCTION_NOT_SUPPORTED
35142                       00009CB6            pnpbios_exit:
35143 9CB6     66    5D                           pop ebp
35144 9CB8           CB                           retf
35145                       00009CB9            rom_scan:
35146                                             ;; Scan for existence of valid expansion ROMS.
35147                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
35148                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
35149                                             ;; System ROM: only 0xE0000
35150                                             ;;
35151                                             ;; Header:
35152                                             ;; Offset Value
35153                                             ;; 0 0x55
35154                                             ;; 1 0xAA
35155                                             ;; 2 ROM length in 512-byte blocks
35156                                             ;; 3 ROM initialization entry point (FAR CALL)
35157                       00009CB9            rom_scan_loop:
35158 9CB9           50                           push ax ;; Save AX
35159 9CBA           8ED9                         mov ds, cx
35160 9CBC           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
35161 9CBF           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
35162 9CC5   7403    E9         009E              jne rom_scan_increment
35163 9CCA           E8         FF4A              call rom_checksum
35164 9CCD   7403    E9         0096              jnz rom_scan_increment
35165 9CD2           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
35166                                             ;; We want our increment in 512-byte quantities, rounded to
35167                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
35168 9CD5           A8                     03    test al, #0x03
35169 9CD7           74           04              jz block_count_rounded
35170 9CD9           24                     FC    and al, #0xfc ;; needs rounding up
35171 9CDB           04                     04    add al, #0x04
35172                       00009CDD            block_count_rounded:
35173 9CDD           31DB                         xor bx, bx ;; Restore DS back to 0000:
35174 9CDF           8EDB                         mov ds, bx
35175 9CE1           50                           push ax ;; Save AX
35176 9CE2           57                           push di ;; Save DI
35177                                             ;; Push addr of ROM entry point
35178 9CE3           51                           push cx ;; Push seg
35179 9CE4           6A                     03    push #0x0003 ;; Push offset
35180                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35181                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
35182 9CE6           B8                   F000    mov ax, #0xf000
35183 9CE9           8EC0                         mov es, ax
35184 9CEB           8D3E       9C50              lea di, pnpbios_structure
35185 9CEF           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
35186 9CF1                        FF              db 0xff ;; call_far ss:[bp+0]
35187 9CF2                        5E              db 0x5e
35188 9CF3                        00              db 0
35189 9CF4           FA                           cli ;; In case expansion ROM BIOS turns IF on
35190 9CF5           83C4                   02    add sp, #2 ;; Pop offset value
35191 9CF8           59                           pop cx ;; Pop seg value (restore CX)
35192                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
35193                                             ;; to init all the ROMs and then go back and build an IPL table of
35194                                             ;; all the bootable devices, but we can get away with one pass.
35195 9CF9           8ED9                         mov ds, cx ;; ROM base
35196 9CFB           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
35197 9CFF           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
35198 9D01           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
35199 9D04           75           60              jne no_bev
35200 9D06           8B47         02              mov ax, 2[bx]
35201 9D09           3D                   506E    cmp ax, #0x506e
35202 9D0C           75           58              jne no_bev
35203 9D0E           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
35204 9D11           3D                   0000    cmp ax, #0x0000
35205 9D14           74           17              je no_bcv
35206                                             ;; Option ROM has BCV. Run it now.
35207 9D16           51                           push cx ;; Push seg
35208 9D17           50                           push ax ;; Push offset
35209                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35210 9D18           BB                   F000    mov bx, #0xf000
35211 9D1B           8EC3                         mov es, bx
35212 9D1D           8D3E       9C50              lea di, pnpbios_structure
35213 9D21           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
35214 9D23                        FF              db 0xff ;; call_far ss:[bp+0]
35215 9D24                        5E              db 0x5e
35216 9D25                        00              db 0
35217 9D26           FA                           cli ;; In case expansion ROM BIOS turns IF on
35218 9D27           83C4                   02    add sp, #2 ;; Pop offset value
35219 9D2A           59                           pop cx ;; Pop seg value (restore CX)
35220 9D2B           EB           39              jmp no_bev
35221                       00009D2D            no_bcv:
35222 9D2D           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
35223 9D30           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
35224 9D33           74           31              je no_bev
35225                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
35226 9D35           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
35227 9D38           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
35228 9D3B           8EDB                         mov ds, bx
35229 9D3D           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
35230 9D41           83FB                   08    cmp bx, #8
35231 9D44           74           20              je no_bev ;; Get out if the table is full
35232 9D46           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
35233 9D49           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
35234 9D4D           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
35235 9D50           8947         04              mov 4[bx], ax ;; and the offset
35236 9D53           83FF                   00    cmp di, #0x0000
35237 9D56           74           06              je no_prod_str
35238 9D58           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
35239 9D5B           897F         08              mov 8[bx], di ;; and the offset
35240                       00009D5E            no_prod_str:
35241 9D5E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
35242 9D61           43                           inc bx ;; We have one more entry now
35243 9D62           891E       0080              mov 0x0080, bx ;; Remember that.
35244                       00009D66            no_bev:
35245 9D66           5F                           pop di ;; Restore DI
35246 9D67           58                           pop ax ;; Restore AX
35247                       00009D68            rom_scan_increment:
35248 9D68           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
35249                                                           ;; because the segment selector is shifted left 4 bits.
35250 9D6B           01C1                         add cx, ax
35251 9D6D           58                           pop ax ;; Restore AX
35252 9D6E           39C1                         cmp cx, ax
35253 9D70   7703    E9         FF44              jbe rom_scan_loop
35254 9D75           31C0                         xor ax, ax ;; Restore DS back to 0000:
35255 9D77           8ED8                         mov ds, ax
35256 9D79           C3                           ret
35257                       00009D7A            post_init_pic:
35258 9D7A           B0                     11    mov al, #0x11 ; send initialisation commands
35259 9D7C           E6                     20    out 0x0020, al
35260 9D7E           E6                     A0    out 0x00a0, al
35261 9D80           B0                     08    mov al, #0x08
35262 9D82           E6                     21    out 0x0021, al
35263 9D84           B0                     70    mov al, #0x70
35264 9D86           E6                     A1    out 0x00a1, al
35265 9D88           B0                     04    mov al, #0x04
35266 9D8A           E6                     21    out 0x0021, al
35267 9D8C           B0                     02    mov al, #0x02
35268 9D8E           E6                     A1    out 0x00a1, al
35269 9D90           B0                     01    mov al, #0x01
35270 9D92           E6                     21    out 0x0021, al
35271 9D94           E6                     A1    out 0x00a1, al
35272 9D96           B0                     B8    mov al, #0xb8
35273 9D98           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
35274 9D9A           B0                     8F    mov al, #0x8f
35275 9D9C           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
35276 9D9E           C3                           ret
35277                       00009D9F            post_init_ivt:
35278                                             ;; set first 120 interrupts to default handler
35279 9D9F           31FF                         xor di, di ;; offset index
35280 9DA1           B9                   0078    mov cx, #0x0078 ;; counter (120 interrupts)
35281 9DA4           B8                   F000    mov ax, #0xF000
35282 9DA7     66    C1E0                   10    shl eax, #16
35283 9DAB           B8                   FF53    mov ax, #dummy_iret_handler
35284 9DAE           FC                           cld
35285 9DAF           F3                           rep
35286 9DB0     66    AB                             stosd
35287                                             ;; Master PIC vector
35288 9DB2           BB                   0020    mov bx, #0x0020
35289 9DB5           B1                     08    mov cl, #0x08
35290 9DB7           B8                   E9E6    mov ax, #dummy_master_pic_irq_handler
35291                       00009DBA            post_default_master_pic_ints:
35292 9DBA           8907                         mov [bx], ax
35293 9DBC           83C3                   04    add bx, #4
35294 9DBF           E2           F9              loop post_default_master_pic_ints
35295                                             ;; Slave PIC vector
35296 9DC1           81C3                 0180    add bx, #0x0180
35297 9DC5           B1                     08    mov cl, #0x08
35298 9DC7           B8                   E9EC    mov ax, #dummy_slave_pic_irq_handler
35299                       00009DCA            post_default_slave_pic_ints:
35300 9DCA           8907                         mov [bx], ax
35301 9DCC           83C3                   04    add bx, #4
35302 9DCF           E2           F9              loop post_default_slave_pic_ints
35303                                             ;; Printer Services vector
35304                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   9DD1           B8                   EFD2    mov ax,  #int17_handler
 +a   9DD4           A3         005C              mov 0x17*4, ax
 +a   9DD7           B8                   F000    mov ax,  #0xF000
 +a   9DDA           A3         005E              mov 0x17*4+2, ax
35305                                             ;; Bootstrap failure vector
35306                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   9DDD           B8                   8F41    mov ax,  #int18_handler
 +a   9DE0           A3         0060              mov 0x18*4, ax
 +a   9DE3           B8                   F000    mov ax,  #0xF000
 +a   9DE6           A3         0062              mov 0x18*4+2, ax
35307                                             ;; Bootstrap Loader vector
35308                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   9DE9           B8                   E6F2    mov ax,  #int19_handler
 +a   9DEC           A3         0064              mov 0x19*4, ax
 +a   9DEF           B8                   F000    mov ax,  #0xF000
 +a   9DF2           A3         0066              mov 0x19*4+2, ax
35309                                             ;; Memory Size Check vector
35310                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   9DF5           B8                   F841    mov ax,  #int12_handler
 +a   9DF8           A3         0048              mov 0x12*4, ax
 +a   9DFB           B8                   F000    mov ax,  #0xF000
 +a   9DFE           A3         004A              mov 0x12*4+2, ax
35311                                             ;; Equipment Configuration Check vector
35312                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   9E01           B8                   F84D    mov ax,  #int11_handler
 +a   9E04           A3         0044              mov 0x11*4, ax
 +a   9E07           B8                   F000    mov ax,  #0xF000
 +a   9E0A           A3         0046              mov 0x11*4+2, ax
35313                                             ;; System Services
35314                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   9E0D           B8                   F859    mov ax,  #int15_handler
 +a   9E10           A3         0054              mov 0x15*4, ax
 +a   9E13           B8                   F000    mov ax,  #0xF000
 +a   9E16           A3         0056              mov 0x15*4+2, ax
35315                                             ;; MDA/CGA Video Parameter Table is not available
35316                                             SET_INT_VECTOR(0x1D, #0, #0)
 +a   9E19           B8                   0000    mov ax,  #0
 +a   9E1C           A3         0074              mov 0x1D*4, ax
 +a   9E1F           B8                   0000    mov ax,  #0
 +a   9E22           A3         0076              mov 0x1D*4+2, ax
35317                                             ;; Character Font for upper 128 characters is not available
35318                                             SET_INT_VECTOR(0x1F, #0, #0)
 +a   9E25           B8                   0000    mov ax,  #0
 +a   9E28           A3         007C              mov 0x1F*4, ax
 +a   9E2B           B8                   0000    mov ax,  #0
 +a   9E2E           A3         007E              mov 0x1F*4+2, ax
35319                                             ;; set vectors 0x60 - 0x67h to zero (0:180..0:19f)
35320 9E31           31C0                         xor ax, ax
35321 9E33           B9                   0010    mov cx, #0x0010 ;; 16 words
35322 9E36           BF                   0180    mov di, #0x0180
35323 9E39           FC                           cld
35324 9E3A           F3                           rep
35325 9E3B           AB                             stosw
35326                                             ;; set vector 0x78 and above to zero
35327 9E3C     66    31C0                         xor eax, eax
35328 9E3F           B1                     88    mov cl, #0x88 ;; 136 dwords
35329 9E41           BF                   01E0    mov di, #0x1e0
35330 9E44           F3                           rep
35331 9E45     66    AB                             stosd
35332 9E47           C3                           ret
35333                                           ;; the following area can be used to write dynamically generated tables
35334 9E48                  00000010              .align 16
35335                       00009E50            bios_table_area_start:
35336 9E50                  AAFB4442              dd 0xaafb4442
35337 9E54                  00002DA8              dd bios_table_area_end - bios_table_area_start - 8;
35338                                           ;--------
35339                                           ;- POST -
35340                                           ;--------
35341 E05B                                      .org 0xe05b ; POST Entry Point
35342                       0000E05B            post:
35343 E05B           31C0                         xor ax, ax
35344                                             ;; first reset the DMA controllers
35345 E05D           E6                     0D    out 0x000d,al
35346 E05F           E6                     DA    out 0x00da,al
35347                                             ;; then initialize the DMA controllers
35348 E061           B0                     C0    mov al, #0xC0
35349 E063           E6                     D6    out 0x00d6, al ; cascade mode of channel 4 enabled
35350 E065           B0                     00    mov al, #0x00
35351 E067           E6                     D4    out 0x00d4, al ; unmask channel 4
35352                                             ;; Examine CMOS shutdown status.
35353 E069           B0                     0F    mov AL, #0x0f
35354 E06B           E6                     70    out 0x0070, AL
35355 E06D           E4                     71    in AL, 0x0071
35356                                             ;; backup status
35357 E06F           88C3                         mov bl, al
35358                                             ;; Reset CMOS shutdown status.
35359 E071           B0                     0F    mov AL, #0x0f
35360 E073           E6                     70    out 0x0070, AL ; select CMOS register Fh
35361 E075           B0                     00    mov AL, #0x00
35362 E077           E6                     71    out 0x0071, AL ; set shutdown action to normal
35363                                             ;; Examine CMOS shutdown status.
35364 E079           88D8                         mov al, bl
35365                                             ;; 0x00, 0x0D+ = normal startup
35366 E07B           3C                     00    cmp AL, #0x00
35367 E07D           74           24              jz normal_post
35368 E07F           3C                     0D    cmp AL, #0x0d
35369 E081           73           20              jae normal_post
35370                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
35371 E083           3C                     05    cmp al, #0x05
35372 E085   7503    E9         B1AB              je eoi_jmp_post
35373                                             ;; 0x0A = jmp via [0x40:0x67] jump
35374 E08A           3C                     0A    cmp al, #0x0a
35375 E08C   7503    E9         B1D0              je jmp_post_0x467
35376                                             ;; 0x0B = iret via [0x40:0x67]
35377 E091           3C                     0B    cmp al, #0x0b
35378 E093   7503    E9         B1D1              je iret_post_0x467
35379                                             ;; 0x0C = retf via [0x40:0x67]
35380 E098           3C                     0C    cmp al, #0x0c
35381 E09A   7503    E9         B1D7              je retf_post_0x467
35382                                             ;; Examine CMOS shutdown status.
35383                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
35384 E09F           53                           push bx
35385 E0A0           E8         3114              call _shutdown_status_panic
35386                       0000E0A3            normal_post:
35387                                             ; case 0: normal startup
35388 E0A3           FA                           cli
35389 E0A4           B8                   FFFE    mov ax, #0xfffe
35390 E0A7           89C4                         mov sp, ax
35391 E0A9           31C0                         xor ax, ax
35392 E0AB           8ED8                         mov ds, ax
35393 E0AD           8ED0                         mov ss, ax
35394                                             ;; Save shutdown status
35395 E0AF           881E       04B0              mov 0x04b0, bl
35396 E0B3           80FB                   FE    cmp bl, #0xfe
35397 E0B6   7503    E9         B1C8              jz s3_post
35398                                             ;; zero out BIOS data area (40:00..40:ff)
35399 E0BB           8EC0                         mov es, ax
35400 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
35401 E0C0           BF                   0400    mov di, #0x0400
35402 E0C3           FC                           cld
35403 E0C4           F3                           rep
35404 E0C5           AB                             stosw
35405 E0C6           E8         3652              call _log_bios_start
35406 E0C9           E8         BCD3              call post_init_ivt
35407                                             ;; base memory in K 40:13 (word)
35408 E0CC           B8                   027F    mov ax, #(640 - 1)
35409 E0CF           A3         0413              mov 0x0413, ax
35410                                             ;; Manufacturing Test 40:12
35411                                             ;; zerod out above
35412                                             ;; Warm Boot Flag 0040:0072
35413                                             ;; value of 1234h = skip memory checks
35414                                             ;; zerod out above
35415                                             ;; EBDA setup
35416 E0D2           E8         B14B              call ebda_post
35417                                             ;; PIT setup
35418                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E0D5           B8                   FEA5    mov ax,  #int08_handler
 +a   E0D8           A3         0020              mov 0x08*4, ax
 +a   E0DB           B8                   F000    mov ax,  #0xF000
 +a   E0DE           A3         0022              mov 0x08*4+2, ax
35419                                             ;; int 1C already points at dummy_iret_handler (above)
35420 E0E1           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
35421 E0E3           E6                     43    out 0x0043, al
35422 E0E5           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
35423 E0E7           E6                     40    out 0x0040, al
35424 E0E9           E6                     40    out 0x0040, al
35425                                             ;; Keyboard
35426                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E0EB           B8                   E987    mov ax,  #int09_handler
 +a   E0EE           A3         0024              mov 0x09*4, ax
 +a   E0F1           B8                   F000    mov ax,  #0xF000
 +a   E0F4           A3         0026              mov 0x09*4+2, ax
35427                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E0F7           B8                   E82E    mov ax,  #int16_handler
 +a   E0FA           A3         0058              mov 0x16*4, ax
 +a   E0FD           B8                   F000    mov ax,  #0xF000
 +a   E100           A3         005A              mov 0x16*4+2, ax
35428 E103           31C0                         xor ax, ax
35429 E105           8ED8                         mov ds, ax
35430 E107           A2         0417              mov 0x0417, al
35431 E10A           A2         0418              mov 0x0418, al
35432 E10D           A2         0419              mov 0x0419, al
35433 E110           A2         0471              mov 0x0471, al
35434 E113           A2         0497              mov 0x0497, al
35435 E116           B0                     10    mov al, #0x10
35436 E118           A2         0496              mov 0x0496, al
35437 E11B           BB                   001E    mov bx, #0x001E
35438 E11E           891E       041A              mov 0x041A, bx
35439 E122           891E       041C              mov 0x041C, bx
35440 E126           BB                   001E    mov bx, #0x001E
35441 E129           891E       0480              mov 0x0480, bx
35442 E12D           BB                   003E    mov bx, #0x003E
35443 E130           891E       0482              mov 0x0482, bx
35444 E134           E8         2B27              call _keyboard_init
35445                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
35446 E137           A1         0410              mov ax, 0x0410
35447 E13A           B0                     14    mov al, #0x14
35448 E13C           E6                     70    out 0x0070, al
35449 E13E           E4                     71    in al, 0x0071
35450 E140           A3         0410              mov 0x0410, ax
35451                                             ;; Parallel setup
35452 E143           31C0                         xor ax, ax
35453 E145           8ED8                         mov ds, ax
35454 E147           31DB                         xor bx, bx
35455 E149           B1                     14    mov cl, #0x14 ; timeout value
35456 E14B           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
35457 E14E           E8         BA82              call detect_parport
35458 E151           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
35459 E154           E8         BA7C              call detect_parport
35460 E157           C1E3                   0E    shl bx, #0x0e
35461 E15A           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determine # parallel ports
35462 E15D           25                   3FFF    and ax, #0x3fff
35463 E160           09D8                         or ax, bx ; set number of parallel ports
35464 E162           A3         0410              mov 0x410, ax
35465                                             ;; Serial setup
35466                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E165           B8                   E739    mov ax,  #int14_handler
 +a   E168           A3         0050              mov 0x14*4, ax
 +a   E16B           B8                   F000    mov ax,  #0xF000
 +a   E16E           A3         0052              mov 0x14*4+2, ax
35467 E171           31DB                         xor bx, bx
35468 E173           B1                     0A    mov cl, #0x0a ; timeout value
35469 E175           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
35470 E178           E8         BA77              call detect_serial
35471 E17B           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
35472 E17E           E8         BA71              call detect_serial
35473 E181           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
35474 E184           E8         BA6B              call detect_serial
35475 E187           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
35476 E18A           E8         BA65              call detect_serial
35477 E18D           C1E3                   09    shl bx, #0x09
35478 E190           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determine # serial ports
35479 E193           25                   F1FF    and ax, #0xf1ff
35480 E196           09D8                         or ax, bx ; set number of serial port
35481 E198           A3         0410              mov 0x410, ax
35482                                             ;; CMOS RTC
35483                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E19B           B8                   FE6E    mov ax,  #int1a_handler
 +a   E19E           A3         0068              mov 0x1A*4, ax
 +a   E1A1           B8                   F000    mov ax,  #0xF000
 +a   E1A4           A3         006A              mov 0x1A*4+2, ax
35484                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E1A7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1AA           A3         0128              mov 0x4A*4, ax
 +a   E1AD           B8                   F000    mov ax,  #0xF000
 +a   E1B0           A3         012A              mov 0x4A*4+2, ax
35485                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E1B3           B8                   FE93    mov ax,  #int70_handler
 +a   E1B6           A3         01C0              mov 0x70*4, ax
 +a   E1B9           B8                   F000    mov ax,  #0xF000
 +a   E1BC           A3         01C2              mov 0x70*4+2, ax
35486                                             ;; BIOS DATA AREA 0x4CE ???
35487 E1BF           E8         B0EB              call timer_tick_post
35488                                             ;; IRQ9 (IRQ2 redirect) setup
35489                                             SET_INT_VECTOR(0x71, #0xF000, #int71_handler)
 +a   E1C2           B8                   E9DD    mov ax,  #int71_handler
 +a   E1C5           A3         01C4              mov 0x71*4, ax
 +a   E1C8           B8                   F000    mov ax,  #0xF000
 +a   E1CB           A3         01C6              mov 0x71*4+2, ax
35490                                             ;; PS/2 mouse setup
35491                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E1CE           B8                   8E6F    mov ax,  #int74_handler
 +a   E1D1           A3         01D0              mov 0x74*4, ax
 +a   E1D4           B8                   F000    mov ax,  #0xF000
 +a   E1D7           A3         01D2              mov 0x74*4+2, ax
35492                                             ;; IRQ13 (FPU exception) setup
35493                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E1DA           B8                   E2C7    mov ax,  #int75_handler
 +a   E1DD           A3         01D4              mov 0x75*4, ax
 +a   E1E0           B8                   F000    mov ax,  #0xF000
 +a   E1E3           A3         01D6              mov 0x75*4+2, ax
35494                                             ;; Video setup
35495                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E1E6           B8                   F065    mov ax,  #int10_handler
 +a   E1E9           A3         0040              mov 0x10*4, ax
 +a   E1EC           B8                   F000    mov ax,  #0xF000
 +a   E1EF           A3         0042              mov 0x10*4+2, ax
35496                                             ;; PIC
35497 E1F2           E8         BB85              call post_init_pic
35498 E1F5           E8         B837              call pcibios_init_iomem_bases
35499 E1F8           E8         B90B              call pcibios_init_irqs
35500 E1FB           B9                   C000    mov cx, #0xc000 ;; init vga bios
35501 E1FE           B8                   C780    mov ax, #0xc780
35502 E201           E8         BAB5              call rom_scan
35503                                             ;; Hack fix: SeaVGABIOS does not setup a video mode
35504 E204           BA                   03D4    mov dx, #0x03d4
35505 E207           B0                     00    mov al, #0x00
35506 E209           EE                           out dx, al
35507 E20A           42                           inc dx
35508 E20B           EC                           in al, dx
35509 E20C           84C0                         test al, al
35510 E20E           75           05              jnz vga_init_ok
35511 E210           B8                   0003    mov ax, #0x0003
35512 E213           CD                     10    int #0x10
35513                       0000E215            vga_init_ok:
35514 E215           E8         2FC9              call _print_bios_banner
35515                                             ;;
35516                                             ;; Floppy setup
35517                                             ;;
35518 E218           E8         AD5E              call floppy_drive_post
35519                                             ;;
35520                                             ;; Hard Drive setup
35521                                             ;;
35522 E21B           E8         ADE2              call hard_drive_post
35523                                             ;;
35524                                             ;; ATA/ATAPI driver setup
35525                                             ;;
35526 E21E           E8         3627              call _ata_init
35527 E221           E8         3966              call _ata_detect
35528                                             ;;
35529                                             ;;
35530                                             ;; eltorito floppy/harddisk emulation from cd
35531                                             ;;
35532 E224           E8         5318              call _cdemu_init
35533                                             ;;
35534 E227           E8         3010              call _init_boot_vectors
35535 E22A           B9                   C800    mov cx, #0xc800 ;; init option roms
35536 E22D           B8                   E000    mov ax, #0xe000
35537 E230           E8         BA86              call rom_scan
35538 E233           E8         3180              call _interactive_bootkey
35539 E236           FB                           sti ;; enable interrupts
35540 E237           CD                     19    int #0x19
35541 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
35542                       0000E2C3            nmi:
35543                                             ;; FIXME the NMI handler should not panic
35544                                             ;; but iret when called from int75 (fpu exception)
35545 E2C3           E8         3431              call _nmi_handler_msg
35546 E2C6           CF                           iret
35547                       0000E2C7            int75_handler:
35548 E2C7           E6                     F0    out 0xf0, al
35549 E2C9           E8         AFC9              call eoi_both_pics
35550 E2CC           CD                     02    int 2
35551 E2CE           CF                           iret
35552                                           ;-------------------------------------------
35553                                           ;- INT 13h Fixed Disk Services Entry Point -
35554                                           ;-------------------------------------------
35555 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
35556                       0000E3FE            int13_handler:
35557 E3FE           E9         AAAB              jmp int13_relocated
35558 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
35559                                           ;----------
35560                                           ;- INT19h -
35561                                           ;----------
35562 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
35563                       0000E6F2            int19_handler:
35564 E6F2           E9         A868              jmp int19_relocated
35565                                           ;-------------------------------------------
35566                                           ;- System BIOS Configuration Data Table
35567                                           ;-------------------------------------------
35568 E6F5                                      .org 0xe6f5
35569 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
35570 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
35571 E6F7                        FC            db 0xFC
35572 E6F8                        00            db 0x00
35573 E6F9                        01            db 1
35574                                           ; Feature byte 1
35575                                           ; b7: 1=DMA channel 3 used by hard disk
35576                                           ; b6: 1=2 interrupt controllers present
35577                                           ; b5: 1=RTC present
35578                                           ; b4: 1=BIOS calls int 15h/4Fh every key
35579                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
35580                                           ; b2: 1=extended BIOS data area used
35581                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
35582                                           ; b0: 1=Dual bus (MicroChannel + ISA)
35583 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
35584                                           ; Feature byte 2
35585                                           ; b7: 1=32-bit DMA supported
35586                                           ; b6: 1=int16h, function 9 supported
35587                                           ; b5: 1=int15h/C6h (get POS data) supported
35588                                           ; b4: 1=int15h/C7h (get mem map info) supported
35589                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
35590                                           ; b2: 1=non-8042 kb controller
35591                                           ; b1: 1=data streaming supported
35592                                           ; b0: reserved
35593 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
35594                                           ; Feature byte 3
35595                                           ; b7: not used
35596                                           ; b6: reserved
35597                                           ; b5: reserved
35598                                           ; b4: POST supports ROM-to-RAM enable/disable
35599                                           ; b3: SCSI on system board
35600                                           ; b2: info panel installed
35601                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
35602                                           ; b0: SCSI supported in IML
35603 E6FC                        00            db 0x00
35604                                           ; Feature byte 4
35605                                           ; b7: IBM private
35606                                           ; b6: EEPROM present
35607                                           ; b5-3: ABIOS presence (011 = not supported)
35608                                           ; b2: private
35609                                           ; b1: memory split above 16Mb supported
35610                                           ; b0: POSTEXT directly supported by POST
35611 E6FD                        00            db 0x00
35612                                           ; Feature byte 5 (IBM)
35613                                           ; b1: enhanced mouse
35614                                           ; b0: flash EPROM
35615 E6FE                        00            db 0x00
35616 E729                                      .org 0xe729 ; Baud Rate Generator Table
35617                                           ;----------
35618                                           ;- INT14h -
35619                                           ;----------
35620 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
35621                       0000E739            int14_handler:
35622 E739           1E                           push ds
35623 E73A           60                           pusha
35624 E73B           31C0                         xor ax, ax
35625 E73D           8ED8                         mov ds, ax
35626 E73F           E8         5351              call _int14_function
35627 E742           61                           popa
35628 E743           1F                           pop ds
35629 E744           CF                           iret
35630                                           ;----------------------------------------
35631                                           ;- INT 16h Keyboard Service Entry Point -
35632                                           ;----------------------------------------
35633 E82E                                      .org 0xe82e
35634                       0000E82E            int16_handler:
35635 E82E           FB                           sti
35636 E82F           1E                           push ds
35637 E830           9C                           pushf
35638 E831           60                           pusha
35639 E832           6A                     40    push #0x40
35640 E834           1F                           pop ds
35641 E835           80FC                   00    cmp ah, #0x00
35642 E838           74           1F              je int16_F00
35643 E83A           80FC                   10    cmp ah, #0x10
35644 E83D           74           1A              je int16_F00
35645 E83F           E8         653F              call _int16_function
35646 E842           61                           popa
35647 E843           9D                           popf
35648 E844           1F                           pop ds
35649 E845           74           09              jz int16_zero_set
35650                       0000E847            int16_zero_clear:
35651 E847           55                           push bp
35652 E848           89E5                         mov bp, sp
35653 E84A           8066         06        BF    and BYTE [bp + 0x06], #0xbf
35654 E84E           5D                           pop bp
35655 E84F           CF                           iret
35656                       0000E850            int16_zero_set:
35657 E850           55                           push bp
35658 E851           89E5                         mov bp, sp
35659 E853           804E         06        40    or BYTE [bp + 0x06], #0x40
35660 E857           5D                           pop bp
35661 E858           CF                           iret
35662                       0000E859            int16_F00:
35663 E859           FA                           cli
35664 E85A           A1         001A              mov ax, 0x001a
35665 E85D           3B06       001C              cmp ax, 0x001c
35666 E861           75           13              jne int16_key_found
35667 E863           FB                           sti
35668                                             ;; no key yet, call int 15h, function AX=9002
35669 E864           B8                   9002    mov ax, #0x9002
35670 E867           CD                     15    int #0x15
35671                       0000E869            int16_wait_for_key:
35672 E869           FA                           cli
35673 E86A           A1         001A              mov ax, 0x001a
35674 E86D           3B06       001C              cmp ax, 0x001c
35675 E871           75           03              jne int16_key_found
35676 E873           FB                           sti
35677 E874           EB           F3              jmp int16_wait_for_key
35678                       0000E876            int16_key_found:
35679 E876           E8         6508              call _int16_function
35680 E879           61                           popa
35681 E87A           9D                           popf
35682 E87B           1F                           pop ds
35683 E87C           CF                           iret
35684                                           ;-------------------------------------------------
35685                                           ;- INT09h : Keyboard Hardware Service Entry Point -
35686                                           ;-------------------------------------------------
35687 E987                                      .org 0xe987
35688                       0000E987            int09_handler:
35689 E987           FA                           cli
35690 E988           50                           push ax
35691 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
35692 E98B           E6                     64    out 0x0064, al
35693 E98D           B0                     0B    mov al, #0x0B
35694 E98F           E6                     20    out 0x0020, al
35695 E991           E4                     20    in al, 0x0020
35696 E993           24                     02    and al, #0x02
35697 E995           74           40              jz int09_finish
35698 E997           E4                     60    in al, 0x0060 ;;read key from keyboard controller
35699 E999           FB                           sti
35700 E99A           1E                           push ds
35701 E99B           60                           pusha
35702 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
35703 E99E           F9                           stc
35704 E99F           CD                     15    int #0x15
35705 E9A1           55                           push bp
35706 E9A2           89E5                         mov bp, sp
35707 E9A4           8846         10              mov [bp + 0x10], al
35708 E9A7           5D                           pop bp
35709 E9A8           73           22              jnc int09_done
35710                                             ;; check for extended key
35711 E9AA           6A                     40    push #0x40
35712 E9AC           1F                           pop ds
35713 E9AD           3C                     E0    cmp al, #0xe0
35714 E9AF           75           0A              jne int09_check_pause
35715 E9B1           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x02
35716 E9B4           0C                     02    or al, #0x02
35717 E9B6           A2         0096              mov BYTE [0x96], al
35718 E9B9           EB           11              jmp int09_done
35719                       0000E9BB            int09_check_pause: ;; check for pause key
35720 E9BB           3C                     E1    cmp al, #0xe1
35721 E9BD           75           0A              jne int09_process_key
35722 E9BF           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x01
35723 E9C2           0C                     01    or al, #0x01
35724 E9C4           A2         0096              mov BYTE [0x96], al
35725 E9C7           EB           03              jmp int09_done
35726                       0000E9C9            int09_process_key:
35727 E9C9           E8         6A34              call _int09_function
35728                       0000E9CC            int09_done:
35729 E9CC           61                           popa
35730 E9CD           1F                           pop ds
35731 E9CE           FA                           cli
35732 E9CF           E8         A8C7              call eoi_master_pic
35733                                             ;; Notify keyboard interrupt complete w/ int 15h, function AX=9102
35734 E9D2           B8                   9102    mov ax, #0x9102
35735 E9D5           CD                     15    int #0x15
35736                       0000E9D7            int09_finish:
35737 E9D7           B0                     AE    mov al, #0xAE ;;enable keyboard
35738 E9D9           E6                     64    out 0x0064, al
35739 E9DB           58                           pop ax
35740 E9DC           CF                           iret
35741                                           ; IRQ9 handler(Redirect to IRQ2)
35742                                           ;--------------------
35743                       0000E9DD            int71_handler:
35744 E9DD           50                           push ax
35745 E9DE           B0                     20    mov al, #0x20
35746 E9E0           E6                     A0    out 0x00a0, al ;; slave PIC EOI
35747 E9E2           58                           pop ax
35748 E9E3           CD                     0A    int #0x0A
35749 E9E5           CF                           iret
35750                                           ;--------------------
35751                       0000E9E6            dummy_master_pic_irq_handler:
35752 E9E6           50                           push ax
35753 E9E7           E8         A8AF              call eoi_master_pic
35754 E9EA           58                           pop ax
35755 E9EB           CF                           iret
35756                                           ;--------------------
35757                       0000E9EC            dummy_slave_pic_irq_handler:
35758 E9EC           50                           push ax
35759 E9ED           E8         A8A5              call eoi_both_pics
35760 E9F0           58                           pop ax
35761 E9F1           CF                           iret
35762                                           ;----------------------------------------
35763                                           ;- INT 13h Diskette Service Entry Point -
35764                                           ;----------------------------------------
35765 EC59                                      .org 0xec59
35766                       0000EC59            int13_diskette:
35767 EC59           E9         A2A3              jmp int13_noeltorito
35768                                           ;---------------------------------------------
35769                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
35770                                           ;---------------------------------------------
35771 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
35772                       0000EF57            int0e_handler:
35773 EF57           50                           push ax
35774 EF58           52                           push dx
35775 EF59           BA                   03F4    mov dx, #0x03f4
35776 EF5C           EC                           in al, dx
35777 EF5D           24                     C0    and al, #0xc0
35778 EF5F           3C                     C0    cmp al, #0xc0
35779 EF61           74           1E              je int0e_normal
35780 EF63           BA                   03F5    mov dx, #0x03f5
35781 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
35782 EF68           EE                           out dx, al
35783                       0000EF69            int0e_loop1:
35784 EF69           BA                   03F4    mov dx, #0x03f4
35785 EF6C           EC                           in al, dx
35786 EF6D           24                     C0    and al, #0xc0
35787 EF6F           3C                     C0    cmp al, #0xc0
35788 EF71           75           F6              jne int0e_loop1
35789                       0000EF73            int0e_loop2:
35790 EF73           BA                   03F5    mov dx, #0x03f5
35791 EF76           EC                           in al, dx
35792 EF77           BA                   03F4    mov dx, #0x03f4
35793 EF7A           EC                           in al, dx
35794 EF7B           24                     C0    and al, #0xc0
35795 EF7D           3C                     C0    cmp al, #0xc0
35796 EF7F           74           F2              je int0e_loop2
35797                       0000EF81            int0e_normal:
35798 EF81           1E                           push ds
35799 EF82           31C0                         xor ax, ax ;; segment 0000
35800 EF84           8ED8                         mov ds, ax
35801 EF86           E8         A310              call eoi_master_pic
35802 EF89           A0         043E              mov al, 0x043e
35803 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
35804 EF8E           A2         043E              mov 0x043e, al
35805 EF91           1F                           pop ds
35806                                             ;; Notify diskette interrupt complete w/ int 15h, function AX=9101
35807 EF92           B8                   9101    mov ax, #0x9101
35808 EF95           CD                     15    int #0x15
35809 EF97           5A                           pop dx
35810 EF98           58                           pop ax
35811 EF99           CF                           iret
35812 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
35813                       0000EFC7            diskette_param_table:
35814                                           ;; Since no provisions are made for multiple drive types, most
35815                                           ;; values in this table are ignored. I set parameters for 1.44M
35816                                           ;; floppy here
35817 EFC7                        AF            db 0xAF
35818 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
35819 EFC9                        25            db 0x25
35820 EFCA                        02            db 0x02
35821 EFCB                        12            db 18
35822 EFCC                        1B            db 0x1B
35823 EFCD                        FF            db 0xFF
35824 EFCE                        6C            db 0x6C
35825 EFCF                        F6            db 0xF6
35826 EFD0                        0F            db 0x0F
35827 EFD1                        08            db 0x08
35828                                           ;----------------------------------------
35829                                           ;- INT17h : Printer Service Entry Point -
35830                                           ;----------------------------------------
35831 EFD2                                      .org 0xefd2
35832                       0000EFD2            int17_handler:
35833 EFD2           1E                           push ds
35834 EFD3           60                           pusha
35835 EFD4           31C0                         xor ax, ax
35836 EFD6           8ED8                         mov ds, ax
35837 EFD8           E8         969B              call _int17_function
35838 EFDB           61                           popa
35839 EFDC           1F                           pop ds
35840 EFDD           CF                           iret
35841                       0000EFDE            diskette_param_table2:
35842                                           ;; New diskette parameter table adding 3 parameters from IBM
35843                                           ;; Since no provisions are made for multiple drive types, most
35844                                           ;; values in this table are ignored. I set parameters for 1.44M
35845                                           ;; floppy here
35846 EFDE                        AF            db 0xAF
35847 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
35848 EFE0                        25            db 0x25
35849 EFE1                        02            db 0x02
35850 EFE2                        12            db 18
35851 EFE3                        1B            db 0x1B
35852 EFE4                        FF            db 0xFF
35853 EFE5                        6C            db 0x6C
35854 EFE6                        F6            db 0xF6
35855 EFE7                        0F            db 0x0F
35856 EFE8                        08            db 0x08
35857 EFE9                        4F            db 79 ;; maximum track
35858 EFEA                        00            db 0 ;; data transfer rate
35859 EFEB                        04            db 4 ;; drive type in cmos
35860 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
35861                                             HALT(11527)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2D07    mov ax,#11527
 +a   F04B           EF                           out dx,ax
35862 F04C           CF                           iret
35863                                           ;----------
35864                                           ;- INT10h -
35865                                           ;----------
35866 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
35867                       0000F065            int10_handler:
35868                                             ;; dont do anything, since the VGA BIOS handles int10h requests
35869 F065           CF                           iret
35870 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
35871                                           ;----------
35872                                           ;- INT12h -
35873                                           ;----------
35874 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
35875                                           ; ??? different for Pentium (machine check)?
35876                       0000F841            int12_handler:
35877 F841           1E                           push ds
35878 F842           B8                   0040    mov ax, #0x0040
35879 F845           8ED8                         mov ds, ax
35880 F847           A1         0013              mov ax, 0x0013
35881 F84A           1F                           pop ds
35882 F84B           CF                           iret
35883                                           ;----------
35884                                           ;- INT11h -
35885                                           ;----------
35886 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
35887                       0000F84D            int11_handler:
35888 F84D           1E                           push ds
35889 F84E           B8                   0040    mov ax, #0x0040
35890 F851           8ED8                         mov ds, ax
35891 F853           A1         0010              mov ax, 0x0010
35892 F856           1F                           pop ds
35893 F857           CF                           iret
35894                                           ;----------
35895                                           ;- INT15h -
35896                                           ;----------
35897 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
35898                       0000F859            int15_handler:
35899 F859           80FC                   80    cmp ah, #0x80 ; Device open
35900 F85C           74           39              je int15_stub
35901 F85E           80FC                   81    cmp ah, #0x81 ; Device close
35902 F861           74           34              je int15_stub
35903 F863           80FC                   82    cmp ah, #0x82 ; Program termination
35904 F866           74           2F              je int15_stub
35905 F868           80FC                   90    cmp ah, #0x90 ; Device busy interrupt. Called by Int 16h when no key available
35906 F86B           74           2A              je int15_stub
35907 F86D           80FC                   91    cmp ah, #0x91 ; Interrupt complete. Called by IRQ handlers
35908 F870           74           25              je int15_stub
35909 F872           9C                           pushf
35910 F873           80FC                   53    cmp ah, #0x53
35911 F876           74           1C              je apm_call
35912 F878           1E                           push ds
35913 F879           06                           push es
35914 F87A           80FC                   86    cmp ah, #0x86
35915 F87D           74           23              je int15_handler32
35916 F87F           80FC                   E8    cmp ah, #0xE8
35917 F882           74           1E              je int15_handler32
35918 F884           60                           pusha
35919 F885           80FC                   C2    cmp ah, #0xC2
35920 F888           74           13              je int15_handler_mouse
35921 F88A           E8         4433              call _int15_function
35922                       0000F88D            int15_handler_mouse_ret:
35923 F88D           61                           popa
35924                       0000F88E            int15_handler32_ret:
35925 F88E           07                           pop es
35926 F88F           1F                           pop ds
35927 F890           9D                           popf
35928 F891           E9         9604              jmp iret_modify_cf
35929                       0000F894            apm_call:
35930 F894           E9         9C5F              jmp _apmreal_entry
35931                       0000F897            int15_stub:
35932 F897           30E4                         xor ah, ah ; "operation success"
35933 F899           F8                           clc
35934 F89A           E9         95FB              jmp iret_modify_cf
35935                       0000F89D            int15_handler_mouse:
35936 F89D           E8         4904              call _int15_function_mouse
35937 F8A0           EB           EB              jmp int15_handler_mouse_ret
35938                       0000F8A2            int15_handler32:
35939 F8A2     66    60                           pushad
35940 F8A4           E8         5025              call _int15_function32
35941 F8A7     66    61                           popad
35942 F8A9           EB           E3              jmp int15_handler32_ret
35943                                           ;; Protected mode IDT descriptor
35944                                           ;;
35945                                           ;; I just make the limit 0, so the machine will shutdown
35946                                           ;; if an exception occurs during protected mode memory
35947                                           ;; transfers.
35948                                           ;;
35949                                           ;; Set base to f0000 to correspond to beginning of BIOS,
35950                                           ;; in case I actually define an IDT later
35951                                           ;; Set limit to 0
35952                       0000F8AB            pmode_IDT_info:
35953 F8AB                      0000            dw 0x0000 ;; limit 15:00
35954 F8AD                      0000            dw 0x0000 ;; base 15:00
35955 F8AF                        0F            db 0x0f ;; base 23:16
35956 F8B0                        00            db 0x00 ;; base 31:24
35957                                           ;; Real mode IDT descriptor
35958                                           ;;
35959                                           ;; Set to typical real-mode values.
35960                                           ;; base = 000000
35961                                           ;; limit = 03ff
35962                       0000F8B1            rmode_IDT_info:
35963 F8B1                      03FF            dw 0x03ff ;; limit 15:00
35964 F8B3                      0000            dw 0x0000 ;; base 15:00
35965 F8B5                        00            db 0x00 ;; base 23:16
35966 F8B6                        00            db 0x00 ;; base 31:24
35967                                           ;----------
35968                                           ;- INT1Ah -
35969                                           ;----------
35970 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
35971                       0000FE6E            int1a_handler:
35972 FE6E           80FC                   B1    cmp ah, #0xb1
35973 FE71           75           14              jne int1a_normal
35974 FE73           E8         9947              call pcibios_real
35975 FE76           72           03              jc pcibios_error
35976 FE78           CA                   0002    retf 2
35977                       0000FE7B            pcibios_error:
35978 FE7B           88E3                         mov bl, ah
35979 FE7D           B4                     B1    mov ah, #0xb1
35980 FE7F           1E                           push ds
35981 FE80           60                           pusha
35982 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
35983 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
35984 FE85           EB           06              jmp int1a_callfunction
35985                       0000FE87            int1a_normal:
35986 FE87           1E                           push ds
35987 FE88           60                           pusha
35988 FE89           31C0                         xor ax, ax
35989 FE8B           8ED8                         mov ds, ax
35990                       0000FE8D            int1a_callfunction:
35991 FE8D           E8         8B4B              call _int1a_function
35992 FE90           61                           popa
35993 FE91           1F                           pop ds
35994 FE92           CF                           iret
35995                                           ;;
35996                                           ;; int70h: IRQ8 - CMOS RTC
35997                                           ;;
35998                       0000FE93            int70_handler:
35999 FE93           1E                           push ds
36000 FE94     66    60                           pushad
36001 FE96           31C0                         xor ax, ax
36002 FE98           8ED8                         mov ds, ax
36003 FE9A           E8         8EE7              call _int70_function
36004 FE9D     66    61                           popad
36005 FE9F           1F                           pop ds
36006 FEA0           CF                           iret
36007                                           ;---------
36008                                           ;- INT08 -
36009                                           ;---------
36010 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
36011                       0000FEA5            int08_handler:
36012 FEA5           FB                           sti
36013 FEA6     66    50                           push eax
36014 FEA8           1E                           push ds
36015 FEA9           31C0                         xor ax, ax
36016 FEAB           8ED8                         mov ds, ax
36017                                             ;; time to turn off drive(s)?
36018 FEAD           A0         0440              mov al,0x0440
36019 FEB0           08C0                         or al,al
36020 FEB2           74           10              jz int08_floppy_off
36021 FEB4           FEC8                         dec al
36022 FEB6           A2         0440              mov 0x0440,al
36023 FEB9           75           09              jnz int08_floppy_off
36024                                             ;; turn motor(s) off
36025 FEBB           52                           push dx
36026 FEBC           BA                   03F2    mov dx,#0x03f2
36027 FEBF           EC                           in al,dx
36028 FEC0           24                     CF    and al,#0xcf
36029 FEC2           EE                           out dx,al
36030 FEC3           5A                           pop dx
36031                       0000FEC4            int08_floppy_off:
36032 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
36033 FEC8     66    40                           inc eax
36034                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
36035 FECA     66    3D               001800B0    cmp eax, #0x001800B0
36036 FED0           72           07              jb int08_store_ticks
36037                                             ;; there has been a midnight rollover at this point
36038 FED2     66    31C0                         xor eax, eax ;; zero out counter
36039 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
36040                       0000FED9            int08_store_ticks:
36041 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
36042                                             ;; chain to user timer tick INT #0x1c
36043 FEDD           CD                     1C    int #0x1c
36044 FEDF           FA                           cli
36045 FEE0           E8         93B6              call eoi_master_pic
36046 FEE3           1F                           pop ds
36047 FEE4     66    58                           pop eax
36048 FEE6           CF                           iret
36049 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
36050                       0000FEF3            initial_int_vector_offset_08_1f:
36051 FEF3                      FEA5              dw int08_handler
36052 FEF5                      E987              dw int09_handler
36053 FEF7                      E9E6              dw dummy_master_pic_irq_handler
36054 FEF9                      E9E6              dw dummy_master_pic_irq_handler
36055 FEFB                      E9E6              dw dummy_master_pic_irq_handler
36056 FEFD                      E9E6              dw dummy_master_pic_irq_handler
36057 FEFF                      EF57              dw int0e_handler
36058 FF01                      E9E6              dw dummy_master_pic_irq_handler
36059 FF03                      F065              dw int10_handler
36060 FF05                      F84D              dw int11_handler
36061 FF07                      F841              dw int12_handler
36062 FF09                      E3FE              dw int13_handler
36063 FF0B                      E739              dw int14_handler
36064 FF0D                      F859              dw int15_handler
36065 FF0F                      E82E              dw int16_handler
36066 FF11                      EFD2              dw int17_handler
36067 FF13                      8F41              dw int18_handler
36068 FF15                      E6F2              dw int19_handler
36069 FF17                      FE6E              dw int1a_handler
36070 FF19                      FF53              dw dummy_iret_handler
36071 FF1B                      FF53              dw dummy_iret_handler
36072 FF1D                      0000              dw 0
36073 FF1F                      EFDE              dw diskette_param_table2
36074 FF21                      0000              dw 0
36075                                           ;------------------------------------------------
36076                                           ;- IRET Instruction for Dummy Interrupt Handler -
36077                                           ;------------------------------------------------
36078 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
36079                       0000FF53            dummy_iret_handler:
36080 FF53           CF                           iret
36081 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
36082                                             HALT(11782)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2E06    mov ax,#11782
 +a   FF5A           EF                           out dx,ax
36083 FF5B           CF                           iret
36084 FFF0                                      .org 0xfff0 ; Power-up Entry Point
36085 FFF0           EA         E05B      F000    jmp 0xf000:post
36086 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
36087 FFF5                        30            .ascii "08/01/21"
36088 FFFE                                      .org 0xfffe ; System Model ID
36089 FFFE                        FC            db 0xFC
36090 FFFF                        00            db 0x00 ; filler
36091 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
36092                                           ! 8534 endasm
36093                                           !BCC_ENDASM
36094                                           ! 8535 static Bit8u vgafont8[128*8]=
36095                                           ! Register BX used in function int70_function
36096                                           ! 8536 {
36097                                           
36098                       0000FA6E            _vgafont8:
36099                                           ! 8537  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
36100 FA6E                        00            .byte	0
36101 FA6F                        00            .byte	0
36102 FA70                        00            .byte	0
36103 FA71                        00            .byte	0
36104 FA72                        00            .byte	0
36105 FA73                        00            .byte	0
36106 FA74                        00            .byte	0
36107 FA75                        00            .byte	0
36108                                           ! 8538  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
36109 FA76                        7E            .byte	$7E
36110 FA77                        81            .byte	$81
36111 FA78                        A5            .byte	$A5
36112 FA79                        81            .byte	$81
36113 FA7A                        BD            .byte	$BD
36114 FA7B                        99            .byte	$99
36115 FA7C                        81            .byte	$81
36116 FA7D                        7E            .byte	$7E
36117                                           ! 8539  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
36118 FA7E                        7E            .byte	$7E
36119 FA7F                        FF            .byte	$FF
36120 FA80                        DB            .byte	$DB
36121 FA81                        FF            .byte	$FF
36122 FA82                        C3            .byte	$C3
36123 FA83                        E7            .byte	$E7
36124 FA84                        FF            .byte	$FF
36125 FA85                        7E            .byte	$7E
36126                                           ! 8540  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36127 FA86                        6C            .byte	$6C
36128 FA87                        FE            .byte	$FE
36129 FA88                        FE            .byte	$FE
36130 FA89                        FE            .byte	$FE
36131 FA8A                        7C            .byte	$7C
36132 FA8B                        38            .byte	$38
36133 FA8C                        10            .byte	$10
36134 FA8D                        00            .byte	0
36135                                           ! 8541  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36136 FA8E                        10            .byte	$10
36137 FA8F                        38            .byte	$38
36138 FA90                        7C            .byte	$7C
36139 FA91                        FE            .byte	$FE
36140 FA92                        7C            .byte	$7C
36141 FA93                        38            .byte	$38
36142 FA94                        10            .byte	$10
36143 FA95                        00            .byte	0
36144                                           ! 8542  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
36145 FA96                        38            .byte	$38
36146 FA97                        7C            .byte	$7C
36147 FA98                        38            .byte	$38
36148 FA99                        FE            .byte	$FE
36149 FA9A                        FE            .byte	$FE
36150 FA9B                        7C            .byte	$7C
36151 FA9C                        38            .byte	$38
36152 FA9D                        7C            .byte	$7C
36153                                           ! 8543  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
36154 FA9E                        10            .byte	$10
36155 FA9F                        10            .byte	$10
36156 FAA0                        38            .byte	$38
36157 FAA1                        7C            .byte	$7C
36158 FAA2                        FE            .byte	$FE
36159 FAA3                        7C            .byte	$7C
36160 FAA4                        38            .byte	$38
36161 FAA5                        7C            .byte	$7C
36162                                           ! 8544  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
36163 FAA6                        00            .byte	0
36164 FAA7                        00            .byte	0
36165 FAA8                        18            .byte	$18
36166 FAA9                        3C            .byte	$3C
36167 FAAA                        3C            .byte	$3C
36168 FAAB                        18            .byte	$18
36169 FAAC                        00            .byte	0
36170 FAAD                        00            .byte	0
36171                                           ! 8545  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 
36172 FAAE                        FF            .byte	$FF
36173 FAAF                        FF            .byte	$FF
36174 FAB0                        E7            .byte	$E7
36175 FAB1                        C3            .byte	$C3
36176 FAB2                        C3            .byte	$C3
36177 FAB3                        E7            .byte	$E7
36178 FAB4                        FF            .byte	$FF
36179                                           ! 8545 0xff,
36180 FAB5                        FF            .byte	$FF
36181                                           ! 8546  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
36182 FAB6                        00            .byte	0
36183 FAB7                        3C            .byte	$3C
36184 FAB8                        66            .byte	$66
36185 FAB9                        42            .byte	$42
36186 FABA                        42            .byte	$42
36187 FABB                        66            .byte	$66
36188 FABC                        3C            .byte	$3C
36189 FABD                        00            .byte	0
36190                                           ! 8547  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
36191 FABE                        FF            .byte	$FF
36192 FABF                        C3            .byte	$C3
36193 FAC0                        99            .byte	$99
36194 FAC1                        BD            .byte	$BD
36195 FAC2                        BD            .byte	$BD
36196 FAC3                        99            .byte	$99
36197 FAC4                        C3            .byte	$C3
36198 FAC5                        FF            .byte	$FF
36199                                           ! 8548  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
36200 FAC6                        0F            .byte	$F
36201 FAC7                        07            .byte	7
36202 FAC8                        0F            .byte	$F
36203 FAC9                        7D            .byte	$7D
36204 FACA                        CC            .byte	$CC
36205 FACB                        CC            .byte	$CC
36206 FACC                        CC            .byte	$CC
36207 FACD                        78            .byte	$78
36208                                           ! 8549  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
36209 FACE                        3C            .byte	$3C
36210 FACF                        66            .byte	$66
36211 FAD0                        66            .byte	$66
36212 FAD1                        66            .byte	$66
36213 FAD2                        3C            .byte	$3C
36214 FAD3                        18            .byte	$18
36215 FAD4                        7E            .byte	$7E
36216 FAD5                        18            .byte	$18
36217                                           ! 8550  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
36218 FAD6                        3F            .byte	$3F
36219 FAD7                        33            .byte	$33
36220 FAD8                        3F            .byte	$3F
36221 FAD9                        30            .byte	$30
36222 FADA                        30            .byte	$30
36223 FADB                        70            .byte	$70
36224 FADC                        F0            .byte	$F0
36225 FADD                        E0            .byte	$E0
36226                                           ! 8551  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
36227 FADE                        7F            .byte	$7F
36228 FADF                        63            .byte	$63
36229 FAE0                        7F            .byte	$7F
36230 FAE1                        63            .byte	$63
36231 FAE2                        63            .byte	$63
36232 FAE3                        67            .byte	$67
36233 FAE4                        E6            .byte	$E6
36234 FAE5                        C0            .byte	$C0
36235                                           ! 8552  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
36236 FAE6                        99            .byte	$99
36237 FAE7                        5A            .byte	$5A
36238 FAE8                        3C            .byte	$3C
36239 FAE9                        E7            .byte	$E7
36240 FAEA                        E7            .byte	$E7
36241 FAEB                        3C            .byte	$3C
36242 FAEC                        5A            .byte	$5A
36243 FAED                        99            .byte	$99
36244                                           ! 8553  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
36245 FAEE                        80            .byte	$80
36246 FAEF                        E0            .byte	$E0
36247 FAF0                        F8            .byte	$F8
36248 FAF1                        FE            .byte	$FE
36249 FAF2                        F8            .byte	$F8
36250 FAF3                        E0            .byte	$E0
36251 FAF4                        80            .byte	$80
36252 FAF5                        00            .byte	0
36253                                           ! 8554  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
36254 FAF6                        02            .byte	2
36255 FAF7                        0E            .byte	$E
36256 FAF8                        3E            .byte	$3E
36257 FAF9                        FE            .byte	$FE
36258 FAFA                        3E            .byte	$3E
36259 FAFB                        0E            .byte	$E
36260 FAFC                        02            .byte	2
36261 FAFD                        00            .byte	0
36262                                           ! 8555  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
36263 FAFE                        18            .byte	$18
36264 FAFF                        3C            .byte	$3C
36265 FB00                        7E            .byte	$7E
36266 FB01                        18            .byte	$18
36267 FB02                        18            .byte	$18
36268 FB03                        7E            .byte	$7E
36269 FB04                        3C            .byte	$3C
36270 FB05                        18            .byte	$18
36271                                           ! 8556  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
36272 FB06                        66            .byte	$66
36273 FB07                        66            .byte	$66
36274 FB08                        66            .byte	$66
36275 FB09                        66            .byte	$66
36276 FB0A                        66            .byte	$66
36277 FB0B                        00            .byte	0
36278 FB0C                        66            .byte	$66
36279 FB0D                        00            .byte	0
36280                                           ! 8557  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
36281 FB0E                        7F            .byte	$7F
36282 FB0F                        DB            .byte	$DB
36283 FB10                        DB            .byte	$DB
36284 FB11                        7B            .byte	$7B
36285 FB12                        1B            .byte	$1B
36286 FB13                        1B            .byte	$1B
36287 FB14                        1B            .byte	$1B
36288 FB15                        00            .byte	0
36289                                           ! 8558  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
36290 FB16                        3E            .byte	$3E
36291 FB17                        63            .byte	$63
36292 FB18                        38            .byte	$38
36293 FB19                        6C            .byte	$6C
36294 FB1A                        6C            .byte	$6C
36295 FB1B                        38            .byte	$38
36296 FB1C                        CC            .byte	$CC
36297 FB1D                        78            .byte	$78
36298                                           ! 8559  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
36299 FB1E                        00            .byte	0
36300 FB1F                        00            .byte	0
36301 FB20                        00            .byte	0
36302 FB21                        00            .byte	0
36303 FB22                        7E            .byte	$7E
36304 FB23                        7E            .byte	$7E
36305 FB24                        7E            .byte	$7E
36306 FB25                        00            .byte	0
36307                                           ! 8560  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
36308 FB26                        18            .byte	$18
36309 FB27                        3C            .byte	$3C
36310 FB28                        7E            .byte	$7E
36311 FB29                        18            .byte	$18
36312 FB2A                        7E            .byte	$7E
36313 FB2B                        3C            .byte	$3C
36314 FB2C                        18            .byte	$18
36315 FB2D                        FF            .byte	$FF
36316                                           ! 8561  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
36317 FB2E                        18            .byte	$18
36318 FB2F                        3C            .byte	$3C
36319 FB30                        7E            .byte	$7E
36320 FB31                        18            .byte	$18
36321 FB32                        18            .byte	$18
36322 FB33                        18            .byte	$18
36323 FB34                        18            .byte	$18
36324 FB35                        00            .byte	0
36325                                           ! 8562  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
36326 FB36                        18            .byte	$18
36327 FB37                        18            .byte	$18
36328 FB38                        18            .byte	$18
36329 FB39                        18            .byte	$18
36330 FB3A                        7E            .byte	$7E
36331 FB3B                        3C            .byte	$3C
36332 FB3C                        18            .byte	$18
36333 FB3D                        00            .byte	0
36334                                           ! 8563  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
36335 FB3E                        00            .byte	0
36336 FB3F                        18            .byte	$18
36337 FB40                        0C            .byte	$C
36338 FB41                        FE            .byte	$FE
36339 FB42                        0C            .byte	$C
36340 FB43                        18            .byte	$18
36341 FB44                        00            .byte	0
36342 FB45                        00            .byte	0
36343                                           ! 8564  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
36344 FB46                        00            .byte	0
36345 FB47                        30            .byte	$30
36346 FB48                        60            .byte	$60
36347 FB49                        FE            .byte	$FE
36348 FB4A                        60            .byte	$60
36349 FB4B                        30            .byte	$30
36350 FB4C                        00            .byte	0
36351 FB4D                        00            .byte	0
36352                                           ! 8565  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
36353 FB4E                        00            .byte	0
36354 FB4F                        00            .byte	0
36355 FB50                        C0            .byte	$C0
36356 FB51                        C0            .byte	$C0
36357 FB52                        C0            .byte	$C0
36358 FB53                        FE            .byte	$FE
36359 FB54                        00            .byte	0
36360 FB55                        00            .byte	0
36361                                           ! 8566  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
36362 FB56                        00            .byte	0
36363 FB57                        24            .byte	$24
36364 FB58                        66            .byte	$66
36365 FB59                        FF            .byte	$FF
36366 FB5A                        66            .byte	$66
36367 FB5B                        24            .byte	$24
36368 FB5C                        00            .byte	0
36369 FB5D                        00            .byte	0
36370                                           ! 8567  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
36371 FB5E                        00            .byte	0
36372 FB5F                        18            .byte	$18
36373 FB60                        3C            .byte	$3C
36374 FB61                        7E            .byte	$7E
36375 FB62                        FF            .byte	$FF
36376 FB63                        FF            .byte	$FF
36377 FB64                        00            .byte	0
36378 FB65                        00            .byte	0
36379                                           ! 8568  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
36380 FB66                        00            .byte	0
36381 FB67                        FF            .byte	$FF
36382 FB68                        FF            .byte	$FF
36383 FB69                        7E            .byte	$7E
36384 FB6A                        3C            .byte	$3C
36385 FB6B                        18            .byte	$18
36386 FB6C                        00            .byte	0
36387 FB6D                        00            .byte	0
36388                                           ! 8569  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
36389 FB6E                        00            .byte	0
36390 FB6F                        00            .byte	0
36391 FB70                        00            .byte	0
36392 FB71                        00            .byte	0
36393 FB72                        00            .byte	0
36394 FB73                        00            .byte	0
36395 FB74                        00            .byte	0
36396 FB75                        00            .byte	0
36397                                           ! 8570  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
36398 FB76                        30            .byte	$30
36399 FB77                        78            .byte	$78
36400 FB78                        78            .byte	$78
36401 FB79                        30            .byte	$30
36402 FB7A                        30            .byte	$30
36403 FB7B                        00            .byte	0
36404 FB7C                        30            .byte	$30
36405 FB7D                        00            .byte	0
36406                                           ! 8571  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
36407 FB7E                        6C            .byte	$6C
36408 FB7F                        6C            .byte	$6C
36409 FB80                        6C            .byte	$6C
36410 FB81                        00            .byte	0
36411 FB82                        00            .byte	0
36412 FB83                        00            .byte	0
36413 FB84                        00            .byte	0
36414 FB85                        00            .byte	0
36415                                           ! 8572  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
36416 FB86                        6C            .byte	$6C
36417 FB87                        6C            .byte	$6C
36418 FB88                        FE            .byte	$FE
36419 FB89                        6C            .byte	$6C
36420 FB8A                        FE            .byte	$FE
36421 FB8B                        6C            .byte	$6C
36422 FB8C                        6C            .byte	$6C
36423 FB8D                        00            .byte	0
36424                                           ! 8573  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
36425 FB8E                        30            .byte	$30
36426 FB8F                        7C            .byte	$7C
36427 FB90                        C0            .byte	$C0
36428 FB91                        78            .byte	$78
36429 FB92                        0C            .byte	$C
36430 FB93                        F8            .byte	$F8
36431 FB94                        30            .byte	$30
36432 FB95                        00            .byte	0
36433                                           ! 8574  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
36434 FB96                        00            .byte	0
36435 FB97                        C6            .byte	$C6
36436 FB98                        CC            .byte	$CC
36437 FB99                        18            .byte	$18
36438 FB9A                        30            .byte	$30
36439 FB9B                        66            .byte	$66
36440 FB9C                        C6            .byte	$C6
36441 FB9D                        00            .byte	0
36442                                           ! 8575  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
36443 FB9E                        38            .byte	$38
36444 FB9F                        6C            .byte	$6C
36445 FBA0                        38            .byte	$38
36446 FBA1                        76            .byte	$76
36447 FBA2                        DC            .byte	$DC
36448 FBA3                        CC            .byte	$CC
36449 FBA4                        76            .byte	$76
36450 FBA5                        00            .byte	0
36451                                           ! 8576  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
36452 FBA6                        60            .byte	$60
36453 FBA7                        60            .byte	$60
36454 FBA8                        C0            .byte	$C0
36455 FBA9                        00            .byte	0
36456 FBAA                        00            .byte	0
36457 FBAB                        00            .byte	0
36458 FBAC                        00            .byte	0
36459 FBAD                        00            .byte	0
36460                                           ! 8577  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
36461 FBAE                        18            .byte	$18
36462 FBAF                        30            .byte	$30
36463 FBB0                        60            .byte	$60
36464 FBB1                        60            .byte	$60
36465 FBB2                        60            .byte	$60
36466 FBB3                        30            .byte	$30
36467 FBB4                        18            .byte	$18
36468 FBB5                        00            .byte	0
36469                                           ! 8578  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
36470 FBB6                        60            .byte	$60
36471 FBB7                        30            .byte	$30
36472 FBB8                        18            .byte	$18
36473 FBB9                        18            .byte	$18
36474 FBBA                        18            .byte	$18
36475 FBBB                        30            .byte	$30
36476 FBBC                        60            .byte	$60
36477 FBBD                        00            .byte	0
36478                                           ! 8579  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
36479 FBBE                        00            .byte	0
36480 FBBF                        66            .byte	$66
36481 FBC0                        3C            .byte	$3C
36482 FBC1                        FF            .byte	$FF
36483 FBC2                        3C            .byte	$3C
36484 FBC3                        66            .byte	$66
36485 FBC4                        00            .byte	0
36486 FBC5                        00            .byte	0
36487                                           ! 8580  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
36488 FBC6                        00            .byte	0
36489 FBC7                        30            .byte	$30
36490 FBC8                        30            .byte	$30
36491 FBC9                        FC            .byte	$FC
36492 FBCA                        30            .byte	$30
36493 FBCB                        30            .byte	$30
36494 FBCC                        00            .byte	0
36495 FBCD                        00            .byte	0
36496                                           ! 8581  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
36497 FBCE                        00            .byte	0
36498 FBCF                        00            .byte	0
36499 FBD0                        00            .byte	0
36500 FBD1                        00            .byte	0
36501 FBD2                        00            .byte	0
36502 FBD3                        30            .byte	$30
36503 FBD4                        30            .byte	$30
36504 FBD5                        60            .byte	$60
36505                                           ! 8582  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
36506 FBD6                        00            .byte	0
36507 FBD7                        00            .byte	0
36508 FBD8                        00            .byte	0
36509 FBD9                        FC            .byte	$FC
36510 FBDA                        00            .byte	0
36511 FBDB                        00            .byte	0
36512 FBDC                        00            .byte	0
36513 FBDD                        00            .byte	0
36514                                           ! 8583  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
36515 FBDE                        00            .byte	0
36516 FBDF                        00            .byte	0
36517 FBE0                        00            .byte	0
36518 FBE1                        00            .byte	0
36519 FBE2                        00            .byte	0
36520 FBE3                        30            .byte	$30
36521 FBE4                        30            .byte	$30
36522 FBE5                        00            .byte	0
36523                                           ! 8584  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
36524 FBE6                        06            .byte	6
36525 FBE7                        0C            .byte	$C
36526 FBE8                        18            .byte	$18
36527 FBE9                        30            .byte	$30
36528 FBEA                        60            .byte	$60
36529 FBEB                        C0            .byte	$C0
36530 FBEC                        80            .byte	$80
36531 FBED                        00            .byte	0
36532                                           ! 8585  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
36533 FBEE                        7C            .byte	$7C
36534 FBEF                        C6            .byte	$C6
36535 FBF0                        CE            .byte	$CE
36536 FBF1                        DE            .byte	$DE
36537 FBF2                        F6            .byte	$F6
36538 FBF3                        E6            .byte	$E6
36539 FBF4                        7C            .byte	$7C
36540 FBF5                        00            .byte	0
36541                                           ! 8586  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
36542 FBF6                        30            .byte	$30
36543 FBF7                        70            .byte	$70
36544 FBF8                        30            .byte	$30
36545 FBF9                        30            .byte	$30
36546 FBFA                        30            .byte	$30
36547 FBFB                        30            .byte	$30
36548 FBFC                        FC            .byte	$FC
36549 FBFD                        00            .byte	0
36550                                           ! 8587  0x78, 0xcc, 0x0c, 0x38, 0x60, 0x
36551 FBFE                        78            .byte	$78
36552 FBFF                        CC            .byte	$CC
36553 FC00                        0C            .byte	$C
36554 FC01                        38            .byte	$38
36555 FC02                        60            .byte	$60
36556                                           ! 8587 cc, 0xfc, 0x00,
36557 FC03                        CC            .byte	$CC
36558 FC04                        FC            .byte	$FC
36559 FC05                        00            .byte	0
36560                                           ! 8588  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
36561 FC06                        78            .byte	$78
36562 FC07                        CC            .byte	$CC
36563 FC08                        0C            .byte	$C
36564 FC09                        38            .byte	$38
36565 FC0A                        0C            .byte	$C
36566 FC0B                        CC            .byte	$CC
36567 FC0C                        78            .byte	$78
36568 FC0D                        00            .byte	0
36569                                           ! 8589  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
36570 FC0E                        1C            .byte	$1C
36571 FC0F                        3C            .byte	$3C
36572 FC10                        6C            .byte	$6C
36573 FC11                        CC            .byte	$CC
36574 FC12                        FE            .byte	$FE
36575 FC13                        0C            .byte	$C
36576 FC14                        1E            .byte	$1E
36577 FC15                        00            .byte	0
36578                                           ! 8590  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
36579 FC16                        FC            .byte	$FC
36580 FC17                        C0            .byte	$C0
36581 FC18                        F8            .byte	$F8
36582 FC19                        0C            .byte	$C
36583 FC1A                        0C            .byte	$C
36584 FC1B                        CC            .byte	$CC
36585 FC1C                        78            .byte	$78
36586 FC1D                        00            .byte	0
36587                                           ! 8591  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
36588 FC1E                        38            .byte	$38
36589 FC1F                        60            .byte	$60
36590 FC20                        C0            .byte	$C0
36591 FC21                        F8            .byte	$F8
36592 FC22                        CC            .byte	$CC
36593 FC23                        CC            .byte	$CC
36594 FC24                        78            .byte	$78
36595 FC25                        00            .byte	0
36596                                           ! 8592  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
36597 FC26                        FC            .byte	$FC
36598 FC27                        CC            .byte	$CC
36599 FC28                        0C            .byte	$C
36600 FC29                        18            .byte	$18
36601 FC2A                        30            .byte	$30
36602 FC2B                        30            .byte	$30
36603 FC2C                        30            .byte	$30
36604 FC2D                        00            .byte	0
36605                                           ! 8593  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
36606 FC2E                        78            .byte	$78
36607 FC2F                        CC            .byte	$CC
36608 FC30                        CC            .byte	$CC
36609 FC31                        78            .byte	$78
36610 FC32                        CC            .byte	$CC
36611 FC33                        CC            .byte	$CC
36612 FC34                        78            .byte	$78
36613 FC35                        00            .byte	0
36614                                           ! 8594  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
36615 FC36                        78            .byte	$78
36616 FC37                        CC            .byte	$CC
36617 FC38                        CC            .byte	$CC
36618 FC39                        7C            .byte	$7C
36619 FC3A                        0C            .byte	$C
36620 FC3B                        18            .byte	$18
36621 FC3C                        70            .byte	$70
36622 FC3D                        00            .byte	0
36623                                           ! 8595  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
36624 FC3E                        00            .byte	0
36625 FC3F                        30            .byte	$30
36626 FC40                        30            .byte	$30
36627 FC41                        00            .byte	0
36628 FC42                        00            .byte	0
36629 FC43                        30            .byte	$30
36630 FC44                        30            .byte	$30
36631 FC45                        00            .byte	0
36632                                           ! 8596  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
36633 FC46                        00            .byte	0
36634 FC47                        30            .byte	$30
36635 FC48                        30            .byte	$30
36636 FC49                        00            .byte	0
36637 FC4A                        00            .byte	0
36638 FC4B                        30            .byte	$30
36639 FC4C                        30            .byte	$30
36640 FC4D                        60            .byte	$60
36641                                           ! 8597  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
36642 FC4E                        18            .byte	$18
36643 FC4F                        30            .byte	$30
36644 FC50                        60            .byte	$60
36645 FC51                        C0            .byte	$C0
36646 FC52                        60            .byte	$60
36647 FC53                        30            .byte	$30
36648 FC54                        18            .byte	$18
36649 FC55                        00            .byte	0
36650                                           ! 8598  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
36651 FC56                        00            .byte	0
36652 FC57                        00            .byte	0
36653 FC58                        FC            .byte	$FC
36654 FC59                        00            .byte	0
36655 FC5A                        00            .byte	0
36656 FC5B                        FC            .byte	$FC
36657 FC5C                        00            .byte	0
36658 FC5D                        00            .byte	0
36659                                           ! 8599  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
36660 FC5E                        60            .byte	$60
36661 FC5F                        30            .byte	$30
36662 FC60                        18            .byte	$18
36663 FC61                        0C            .byte	$C
36664 FC62                        18            .byte	$18
36665 FC63                        30            .byte	$30
36666 FC64                        60            .byte	$60
36667 FC65                        00            .byte	0
36668                                           ! 8600  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
36669 FC66                        78            .byte	$78
36670 FC67                        CC            .byte	$CC
36671 FC68                        0C            .byte	$C
36672 FC69                        18            .byte	$18
36673 FC6A                        30            .byte	$30
36674 FC6B                        00            .byte	0
36675 FC6C                        30            .byte	$30
36676 FC6D                        00            .byte	0
36677                                           ! 8601  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
36678 FC6E                        7C            .byte	$7C
36679 FC6F                        C6            .byte	$C6
36680 FC70                        DE            .byte	$DE
36681 FC71                        DE            .byte	$DE
36682 FC72                        DE            .byte	$DE
36683 FC73                        C0            .byte	$C0
36684 FC74                        78            .byte	$78
36685 FC75                        00            .byte	0
36686                                           ! 8602  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
36687 FC76                        30            .byte	$30
36688 FC77                        78            .byte	$78
36689 FC78                        CC            .byte	$CC
36690 FC79                        CC            .byte	$CC
36691 FC7A                        FC            .byte	$FC
36692 FC7B                        CC            .byte	$CC
36693 FC7C                        CC            .byte	$CC
36694 FC7D                        00            .byte	0
36695                                           ! 8603  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
36696 FC7E                        FC            .byte	$FC
36697 FC7F                        66            .byte	$66
36698 FC80                        66            .byte	$66
36699 FC81                        7C            .byte	$7C
36700 FC82                        66            .byte	$66
36701 FC83                        66            .byte	$66
36702 FC84                        FC            .byte	$FC
36703 FC85                        00            .byte	0
36704                                           ! 8604  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
36705 FC86                        3C            .byte	$3C
36706 FC87                        66            .byte	$66
36707 FC88                        C0            .byte	$C0
36708 FC89                        C0            .byte	$C0
36709 FC8A                        C0            .byte	$C0
36710 FC8B                        66            .byte	$66
36711 FC8C                        3C            .byte	$3C
36712 FC8D                        00            .byte	0
36713                                           ! 8605  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
36714 FC8E                        F8            .byte	$F8
36715 FC8F                        6C            .byte	$6C
36716 FC90                        66            .byte	$66
36717 FC91                        66            .byte	$66
36718 FC92                        66            .byte	$66
36719 FC93                        6C            .byte	$6C
36720 FC94                        F8            .byte	$F8
36721 FC95                        00            .byte	0
36722                                           ! 8606  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
36723 FC96                        FE            .byte	$FE
36724 FC97                        62            .byte	$62
36725 FC98                        68            .byte	$68
36726 FC99                        78            .byte	$78
36727 FC9A                        68            .byte	$68
36728 FC9B                        62            .byte	$62
36729 FC9C                        FE            .byte	$FE
36730 FC9D                        00            .byte	0
36731                                           ! 8607  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
36732 FC9E                        FE            .byte	$FE
36733 FC9F                        62            .byte	$62
36734 FCA0                        68            .byte	$68
36735 FCA1                        78            .byte	$78
36736 FCA2                        68            .byte	$68
36737 FCA3                        60            .byte	$60
36738 FCA4                        F0            .byte	$F0
36739 FCA5                        00            .byte	0
36740                                           ! 8608  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
36741 FCA6                        3C            .byte	$3C
36742 FCA7                        66            .byte	$66
36743 FCA8                        C0            .byte	$C0
36744 FCA9                        C0            .byte	$C0
36745 FCAA                        CE            .byte	$CE
36746 FCAB                        66            .byte	$66
36747 FCAC                        3E            .byte	$3E
36748 FCAD                        00            .byte	0
36749                                           ! 8609  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
36750 FCAE                        CC            .byte	$CC
36751 FCAF                        CC            .byte	$CC
36752 FCB0                        CC            .byte	$CC
36753 FCB1                        FC            .byte	$FC
36754 FCB2                        CC            .byte	$CC
36755 FCB3                        CC            .byte	$CC
36756 FCB4                        CC            .byte	$CC
36757 FCB5                        00            .byte	0
36758                                           ! 8610  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
36759 FCB6                        78            .byte	$78
36760 FCB7                        30            .byte	$30
36761 FCB8                        30            .byte	$30
36762 FCB9                        30            .byte	$30
36763 FCBA                        30            .byte	$30
36764 FCBB                        30            .byte	$30
36765 FCBC                        78            .byte	$78
36766 FCBD                        00            .byte	0
36767                                           ! 8611  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
36768 FCBE                        1E            .byte	$1E
36769 FCBF                        0C            .byte	$C
36770 FCC0                        0C            .byte	$C
36771 FCC1                        0C            .byte	$C
36772 FCC2                        CC            .byte	$CC
36773 FCC3                        CC            .byte	$CC
36774 FCC4                        78            .byte	$78
36775 FCC5                        00            .byte	0
36776                                           ! 8612  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
36777 FCC6                        E6            .byte	$E6
36778 FCC7                        66            .byte	$66
36779 FCC8                        6C            .byte	$6C
36780 FCC9                        78            .byte	$78
36781 FCCA                        6C            .byte	$6C
36782 FCCB                        66            .byte	$66
36783 FCCC                        E6            .byte	$E6
36784 FCCD                        00            .byte	0
36785                                           ! 8613  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
36786 FCCE                        F0            .byte	$F0
36787 FCCF                        60            .byte	$60
36788 FCD0                        60            .byte	$60
36789 FCD1                        60            .byte	$60
36790 FCD2                        62            .byte	$62
36791 FCD3                        66            .byte	$66
36792 FCD4                        FE            .byte	$FE
36793 FCD5                        00            .byte	0
36794                                           ! 8614  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
36795 FCD6                        C6            .byte	$C6
36796 FCD7                        EE            .byte	$EE
36797 FCD8                        FE            .byte	$FE
36798 FCD9                        FE            .byte	$FE
36799 FCDA                        D6            .byte	$D6
36800 FCDB                        C6            .byte	$C6
36801 FCDC                        C6            .byte	$C6
36802 FCDD                        00            .byte	0
36803                                           ! 8615  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
36804 FCDE                        C6            .byte	$C6
36805 FCDF                        E6            .byte	$E6
36806 FCE0                        F6            .byte	$F6
36807 FCE1                        DE            .byte	$DE
36808 FCE2                        CE            .byte	$CE
36809 FCE3                        C6            .byte	$C6
36810 FCE4                        C6            .byte	$C6
36811 FCE5                        00            .byte	0
36812                                           ! 8616  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
36813 FCE6                        38            .byte	$38
36814 FCE7                        6C            .byte	$6C
36815 FCE8                        C6            .byte	$C6
36816 FCE9                        C6            .byte	$C6
36817 FCEA                        C6            .byte	$C6
36818 FCEB                        6C            .byte	$6C
36819 FCEC                        38            .byte	$38
36820 FCED                        00            .byte	0
36821                                           ! 8617  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
36822 FCEE                        FC            .byte	$FC
36823 FCEF                        66            .byte	$66
36824 FCF0                        66            .byte	$66
36825 FCF1                        7C            .byte	$7C
36826 FCF2                        60            .byte	$60
36827 FCF3                        60            .byte	$60
36828 FCF4                        F0            .byte	$F0
36829 FCF5                        00            .byte	0
36830                                           ! 8618  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
36831 FCF6                        78            .byte	$78
36832 FCF7                        CC            .byte	$CC
36833 FCF8                        CC            .byte	$CC
36834 FCF9                        CC            .byte	$CC
36835 FCFA                        DC            .byte	$DC
36836 FCFB                        78            .byte	$78
36837 FCFC                        1C            .byte	$1C
36838 FCFD                        00            .byte	0
36839                                           ! 8619  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
36840 FCFE                        FC            .byte	$FC
36841 FCFF                        66            .byte	$66
36842 FD00                        66            .byte	$66
36843 FD01                        7C            .byte	$7C
36844 FD02                        6C            .byte	$6C
36845 FD03                        66            .byte	$66
36846 FD04                        E6            .byte	$E6
36847 FD05                        00            .byte	0
36848                                           ! 8620  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
36849 FD06                        78            .byte	$78
36850 FD07                        CC            .byte	$CC
36851 FD08                        E0            .byte	$E0
36852 FD09                        70            .byte	$70
36853 FD0A                        1C            .byte	$1C
36854 FD0B                        CC            .byte	$CC
36855 FD0C                        78            .byte	$78
36856 FD0D                        00            .byte	0
36857                                           ! 8621  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
36858 FD0E                        FC            .byte	$FC
36859 FD0F                        B4            .byte	$B4
36860 FD10                        30            .byte	$30
36861 FD11                        30            .byte	$30
36862 FD12                        30            .byte	$30
36863 FD13                        30            .byte	$30
36864 FD14                        78            .byte	$78
36865 FD15                        00            .byte	0
36866                                           ! 8622  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
36867 FD16                        CC            .byte	$CC
36868 FD17                        CC            .byte	$CC
36869 FD18                        CC            .byte	$CC
36870 FD19                        CC            .byte	$CC
36871 FD1A                        CC            .byte	$CC
36872 FD1B                        CC            .byte	$CC
36873 FD1C                        FC            .byte	$FC
36874 FD1D                        00            .byte	0
36875                                           ! 8623  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
36876 FD1E                        CC            .byte	$CC
36877 FD1F                        CC            .byte	$CC
36878 FD20                        CC            .byte	$CC
36879 FD21                        CC            .byte	$CC
36880 FD22                        CC            .byte	$CC
36881 FD23                        78            .byte	$78
36882 FD24                        30            .byte	$30
36883 FD25                        00            .byte	0
36884                                           ! 8624  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
36885 FD26                        C6            .byte	$C6
36886 FD27                        C6            .byte	$C6
36887 FD28                        C6            .byte	$C6
36888 FD29                        D6            .byte	$D6
36889 FD2A                        FE            .byte	$FE
36890 FD2B                        EE            .byte	$EE
36891 FD2C                        C6            .byte	$C6
36892 FD2D                        00            .byte	0
36893                                           ! 8625  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
36894 FD2E                        C6            .byte	$C6
36895 FD2F                        C6            .byte	$C6
36896 FD30                        6C            .byte	$6C
36897 FD31                        38            .byte	$38
36898 FD32                        38            .byte	$38
36899 FD33                        6C            .byte	$6C
36900 FD34                        C6            .byte	$C6
36901 FD35                        00            .byte	0
36902                                           ! 8626  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
36903 FD36                        CC            .byte	$CC
36904 FD37                        CC            .byte	$CC
36905 FD38                        CC            .byte	$CC
36906 FD39                        78            .byte	$78
36907 FD3A                        30            .byte	$30
36908 FD3B                        30            .byte	$30
36909 FD3C                        78            .byte	$78
36910 FD3D                        00            .byte	0
36911                                           ! 8627  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
36912 FD3E                        FE            .byte	$FE
36913 FD3F                        C6            .byte	$C6
36914 FD40                        8C            .byte	$8C
36915 FD41                        18            .byte	$18
36916 FD42                        32            .byte	$32
36917 FD43                        66            .byte	$66
36918 FD44                        FE            .byte	$FE
36919 FD45                        00            .byte	0
36920                                           ! 8628  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
36921 FD46                        78            .byte	$78
36922 FD47                        60            .byte	$60
36923 FD48                        60            .byte	$60
36924 FD49                        60            .byte	$60
36925 FD4A                        60            .byte	$60
36926 FD4B                        60            .byte	$60
36927 FD4C                        78            .byte	$78
36928 FD4D                        00            .byte	0
36929                                           ! 8629  0xc0, 0x60, 0x30, 0x18
36930 FD4E                        C0            .byte	$C0
36931 FD4F                        60            .byte	$60
36932 FD50                        30            .byte	$30
36933                                           ! 8629 , 0x0c, 0x06, 0x02, 0x00,
36934 FD51                        18            .byte	$18
36935 FD52                        0C            .byte	$C
36936 FD53                        06            .byte	6
36937 FD54                        02            .byte	2
36938 FD55                        00            .byte	0
36939                                           ! 8630  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
36940 FD56                        78            .byte	$78
36941 FD57                        18            .byte	$18
36942 FD58                        18            .byte	$18
36943 FD59                        18            .byte	$18
36944 FD5A                        18            .byte	$18
36945 FD5B                        18            .byte	$18
36946 FD5C                        78            .byte	$78
36947 FD5D                        00            .byte	0
36948                                           ! 8631  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
36949 FD5E                        10            .byte	$10
36950 FD5F                        38            .byte	$38
36951 FD60                        6C            .byte	$6C
36952 FD61                        C6            .byte	$C6
36953 FD62                        00            .byte	0
36954 FD63                        00            .byte	0
36955 FD64                        00            .byte	0
36956 FD65                        00            .byte	0
36957                                           ! 8632  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
36958 FD66                        00            .byte	0
36959 FD67                        00            .byte	0
36960 FD68                        00            .byte	0
36961 FD69                        00            .byte	0
36962 FD6A                        00            .byte	0
36963 FD6B                        00            .byte	0
36964 FD6C                        00            .byte	0
36965 FD6D                        FF            .byte	$FF
36966                                           ! 8633  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
36967 FD6E                        30            .byte	$30
36968 FD6F                        30            .byte	$30
36969 FD70                        18            .byte	$18
36970 FD71                        00            .byte	0
36971 FD72                        00            .byte	0
36972 FD73                        00            .byte	0
36973 FD74                        00            .byte	0
36974 FD75                        00            .byte	0
36975                                           ! 8634  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
36976 FD76                        00            .byte	0
36977 FD77                        00            .byte	0
36978 FD78                        78            .byte	$78
36979 FD79                        0C            .byte	$C
36980 FD7A                        7C            .byte	$7C
36981 FD7B                        CC            .byte	$CC
36982 FD7C                        76            .byte	$76
36983 FD7D                        00            .byte	0
36984                                           ! 8635  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
36985 FD7E                        E0            .byte	$E0
36986 FD7F                        60            .byte	$60
36987 FD80                        60            .byte	$60
36988 FD81                        7C            .byte	$7C
36989 FD82                        66            .byte	$66
36990 FD83                        66            .byte	$66
36991 FD84                        DC            .byte	$DC
36992 FD85                        00            .byte	0
36993                                           ! 8636  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
36994 FD86                        00            .byte	0
36995 FD87                        00            .byte	0
36996 FD88                        78            .byte	$78
36997 FD89                        CC            .byte	$CC
36998 FD8A                        C0            .byte	$C0
36999 FD8B                        CC            .byte	$CC
37000 FD8C                        78            .byte	$78
37001 FD8D                        00            .byte	0
37002                                           ! 8637  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
37003 FD8E                        1C            .byte	$1C
37004 FD8F                        0C            .byte	$C
37005 FD90                        0C            .byte	$C
37006 FD91                        7C            .byte	$7C
37007 FD92                        CC            .byte	$CC
37008 FD93                        CC            .byte	$CC
37009 FD94                        76            .byte	$76
37010 FD95                        00            .byte	0
37011                                           ! 8638  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
37012 FD96                        00            .byte	0
37013 FD97                        00            .byte	0
37014 FD98                        78            .byte	$78
37015 FD99                        CC            .byte	$CC
37016 FD9A                        FC            .byte	$FC
37017 FD9B                        C0            .byte	$C0
37018 FD9C                        78            .byte	$78
37019 FD9D                        00            .byte	0
37020                                           ! 8639  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
37021 FD9E                        38            .byte	$38
37022 FD9F                        6C            .byte	$6C
37023 FDA0                        60            .byte	$60
37024 FDA1                        F0            .byte	$F0
37025 FDA2                        60            .byte	$60
37026 FDA3                        60            .byte	$60
37027 FDA4                        F0            .byte	$F0
37028 FDA5                        00            .byte	0
37029                                           ! 8640  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37030 FDA6                        00            .byte	0
37031 FDA7                        00            .byte	0
37032 FDA8                        76            .byte	$76
37033 FDA9                        CC            .byte	$CC
37034 FDAA                        CC            .byte	$CC
37035 FDAB                        7C            .byte	$7C
37036 FDAC                        0C            .byte	$C
37037 FDAD                        F8            .byte	$F8
37038                                           ! 8641  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
37039 FDAE                        E0            .byte	$E0
37040 FDAF                        60            .byte	$60
37041 FDB0                        6C            .byte	$6C
37042 FDB1                        76            .byte	$76
37043 FDB2                        66            .byte	$66
37044 FDB3                        66            .byte	$66
37045 FDB4                        E6            .byte	$E6
37046 FDB5                        00            .byte	0
37047                                           ! 8642  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
37048 FDB6                        30            .byte	$30
37049 FDB7                        00            .byte	0
37050 FDB8                        70            .byte	$70
37051 FDB9                        30            .byte	$30
37052 FDBA                        30            .byte	$30
37053 FDBB                        30            .byte	$30
37054 FDBC                        78            .byte	$78
37055 FDBD                        00            .byte	0
37056                                           ! 8643  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
37057 FDBE                        0C            .byte	$C
37058 FDBF                        00            .byte	0
37059 FDC0                        0C            .byte	$C
37060 FDC1                        0C            .byte	$C
37061 FDC2                        0C            .byte	$C
37062 FDC3                        CC            .byte	$CC
37063 FDC4                        CC            .byte	$CC
37064 FDC5                        78            .byte	$78
37065                                           ! 8644  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
37066 FDC6                        E0            .byte	$E0
37067 FDC7                        60            .byte	$60
37068 FDC8                        66            .byte	$66
37069 FDC9                        6C            .byte	$6C
37070 FDCA                        78            .byte	$78
37071 FDCB                        6C            .byte	$6C
37072 FDCC                        E6            .byte	$E6
37073 FDCD                        00            .byte	0
37074                                           ! 8645  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37075 FDCE                        70            .byte	$70
37076 FDCF                        30            .byte	$30
37077 FDD0                        30            .byte	$30
37078 FDD1                        30            .byte	$30
37079 FDD2                        30            .byte	$30
37080 FDD3                        30            .byte	$30
37081 FDD4                        78            .byte	$78
37082 FDD5                        00            .byte	0
37083                                           ! 8646  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
37084 FDD6                        00            .byte	0
37085 FDD7                        00            .byte	0
37086 FDD8                        CC            .byte	$CC
37087 FDD9                        FE            .byte	$FE
37088 FDDA                        FE            .byte	$FE
37089 FDDB                        D6            .byte	$D6
37090 FDDC                        C6            .byte	$C6
37091 FDDD                        00            .byte	0
37092                                           ! 8647  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
37093 FDDE                        00            .byte	0
37094 FDDF                        00            .byte	0
37095 FDE0                        F8            .byte	$F8
37096 FDE1                        CC            .byte	$CC
37097 FDE2                        CC            .byte	$CC
37098 FDE3                        CC            .byte	$CC
37099 FDE4                        CC            .byte	$CC
37100 FDE5                        00            .byte	0
37101                                           ! 8648  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
37102 FDE6                        00            .byte	0
37103 FDE7                        00            .byte	0
37104 FDE8                        78            .byte	$78
37105 FDE9                        CC            .byte	$CC
37106 FDEA                        CC            .byte	$CC
37107 FDEB                        CC            .byte	$CC
37108 FDEC                        78            .byte	$78
37109 FDED                        00            .byte	0
37110                                           ! 8649  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
37111 FDEE                        00            .byte	0
37112 FDEF                        00            .byte	0
37113 FDF0                        DC            .byte	$DC
37114 FDF1                        66            .byte	$66
37115 FDF2                        66            .byte	$66
37116 FDF3                        7C            .byte	$7C
37117 FDF4                        60            .byte	$60
37118 FDF5                        F0            .byte	$F0
37119                                           ! 8650  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
37120 FDF6                        00            .byte	0
37121 FDF7                        00            .byte	0
37122 FDF8                        76            .byte	$76
37123 FDF9                        CC            .byte	$CC
37124 FDFA                        CC            .byte	$CC
37125 FDFB                        7C            .byte	$7C
37126 FDFC                        0C            .byte	$C
37127 FDFD                        1E            .byte	$1E
37128                                           ! 8651  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
37129 FDFE                        00            .byte	0
37130 FDFF                        00            .byte	0
37131 FE00                        DC            .byte	$DC
37132 FE01                        76            .byte	$76
37133 FE02                        66            .byte	$66
37134 FE03                        60            .byte	$60
37135 FE04                        F0            .byte	$F0
37136 FE05                        00            .byte	0
37137                                           ! 8652  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
37138 FE06                        00            .byte	0
37139 FE07                        00            .byte	0
37140 FE08                        7C            .byte	$7C
37141 FE09                        C0            .byte	$C0
37142 FE0A                        78            .byte	$78
37143 FE0B                        0C            .byte	$C
37144 FE0C                        F8            .byte	$F8
37145 FE0D                        00            .byte	0
37146                                           ! 8653  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
37147 FE0E                        10            .byte	$10
37148 FE0F                        30            .byte	$30
37149 FE10                        7C            .byte	$7C
37150 FE11                        30            .byte	$30
37151 FE12                        30            .byte	$30
37152 FE13                        34            .byte	$34
37153 FE14                        18            .byte	$18
37154 FE15                        00            .byte	0
37155                                           ! 8654  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
37156 FE16                        00            .byte	0
37157 FE17                        00            .byte	0
37158 FE18                        CC            .byte	$CC
37159 FE19                        CC            .byte	$CC
37160 FE1A                        CC            .byte	$CC
37161 FE1B                        CC            .byte	$CC
37162 FE1C                        76            .byte	$76
37163 FE1D                        00            .byte	0
37164                                           ! 8655  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
37165 FE1E                        00            .byte	0
37166 FE1F                        00            .byte	0
37167 FE20                        CC            .byte	$CC
37168 FE21                        CC            .byte	$CC
37169 FE22                        CC            .byte	$CC
37170 FE23                        78            .byte	$78
37171 FE24                        30            .byte	$30
37172 FE25                        00            .byte	0
37173                                           ! 8656  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
37174 FE26                        00            .byte	0
37175 FE27                        00            .byte	0
37176 FE28                        C6            .byte	$C6
37177 FE29                        D6            .byte	$D6
37178 FE2A                        FE            .byte	$FE
37179 FE2B                        FE            .byte	$FE
37180 FE2C                        6C            .byte	$6C
37181 FE2D                        00            .byte	0
37182                                           ! 8657  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
37183 FE2E                        00            .byte	0
37184 FE2F                        00            .byte	0
37185 FE30                        C6            .byte	$C6
37186 FE31                        6C            .byte	$6C
37187 FE32                        38            .byte	$38
37188 FE33                        6C            .byte	$6C
37189 FE34                        C6            .byte	$C6
37190 FE35                        00            .byte	0
37191                                           ! 8658  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37192 FE36                        00            .byte	0
37193 FE37                        00            .byte	0
37194 FE38                        CC            .byte	$CC
37195 FE39                        CC            .byte	$CC
37196 FE3A                        CC            .byte	$CC
37197 FE3B                        7C            .byte	$7C
37198 FE3C                        0C            .byte	$C
37199 FE3D                        F8            .byte	$F8
37200                                           ! 8659  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
37201 FE3E                        00            .byte	0
37202 FE3F                        00            .byte	0
37203 FE40                        FC            .byte	$FC
37204 FE41                        98            .byte	$98
37205 FE42                        30            .byte	$30
37206 FE43                        64            .byte	$64
37207 FE44                        FC            .byte	$FC
37208 FE45                        00            .byte	0
37209                                           ! 8660  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
37210 FE46                        1C            .byte	$1C
37211 FE47                        30            .byte	$30
37212 FE48                        30            .byte	$30
37213 FE49                        E0            .byte	$E0
37214 FE4A                        30            .byte	$30
37215 FE4B                        30            .byte	$30
37216 FE4C                        1C            .byte	$1C
37217 FE4D                        00            .byte	0
37218                                           ! 8661  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
37219 FE4E                        18            .byte	$18
37220 FE4F                        18            .byte	$18
37221 FE50                        18            .byte	$18
37222 FE51                        00            .byte	0
37223 FE52                        18            .byte	$18
37224 FE53                        18            .byte	$18
37225 FE54                        18            .byte	$18
37226 FE55                        00            .byte	0
37227                                           ! 8662  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
37228 FE56                        E0            .byte	$E0
37229 FE57                        30            .byte	$30
37230 FE58                        30            .byte	$30
37231 FE59                        1C            .byte	$1C
37232 FE5A                        30            .byte	$30
37233 FE5B                        30            .byte	$30
37234 FE5C                        E0            .byte	$E0
37235 FE5D                        00            .byte	0
37236                                           ! 8663  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37237 FE5E                        76            .byte	$76
37238 FE5F                        DC            .byte	$DC
37239 FE60                        00            .byte	0
37240 FE61                        00            .byte	0
37241 FE62                        00            .byte	0
37242 FE63                        00            .byte	0
37243 FE64                        00            .byte	0
37244 FE65                        00            .byte	0
37245                                           ! 8664  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
37246 FE66                        00            .byte	0
37247 FE67                        10            .byte	$10
37248 FE68                        38            .byte	$38
37249 FE69                        6C            .byte	$6C
37250 FE6A                        C6            .byte	$C6
37251 FE6B                        C6            .byte	$C6
37252 FE6C                        FE            .byte	$FE
37253 FE6D                        00            .byte	0
37254                                           ! 8665 };
37255                                           !BCC_EOS
37256                                           ! 8666 #asm
37257                                           !BCC_ASM
37258 CC00                                      .org 0xcc00
37259                       0000CC00            bios_table_area_end:
37260 CC00                        28            .ascii "(c) 2001-2021  The Bochs Project"
37261                                           ! 8670 endasm
37262                                           !BCC_ENDASM
37263                                           ! 8671 
37264                       0000CC20            .7C8:
37265                       0000CC20            .7D7:
37266 CC20                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
37267 CC48                        20            .ascii	" found at index %d"
37268 CC5A                        0A            .byte	$A
37269 CC5B                        00            .byte	0
37270                       0000CC5C            .7C6:
37271                       0000CC5C            .7D8:
37272 CC5C                        50            .ascii	"PCI device %04x:%04x not found at index "
37273 CC84                        25            .ascii	"%d"
37274 CC86                        0A            .byte	$A
37275 CC87                        00            .byte	0
37276                       0000CC88            .7C0:
37277                       0000CC88            .7D9:
37278 CC88                        62            .ascii	"bad PCI vendor ID %04x"
37279 CC9E                        0A            .byte	$A
37280 CC9F                        00            .byte	0
37281                       0000CCA0            .7BC:
37282                       0000CCA0            .7DA:
37283 CCA0                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
37284 CCC4                        0A            .byte	$A
37285 CCC5                        00            .byte	0
37286                       0000CCC6            .7B8:
37287                       0000CCC6            .7DB:
37288 CCC6                        50            .ascii	"PCI BIOS: PCI not present"
37289 CCDF                        0A            .byte	$A
37290 CCE0                        00            .byte	0
37291                       0000CCE1            .79D:
37292                       0000CCE1            .7DC:
37293 CCE1                        42            .ascii	"Booting from %x:%x"
37294 CCF3                        0A            .byte	$A
37295 CCF4                        00            .byte	0
37296                       0000CCF5            .788:
37297                       0000CCF5            .7DD:
37298 CCF5                        49            .ascii	"Invalid boot device (0x%x)"
37299 CD0F                        0A            .byte	$A
37300 CD10                        00            .byte	0
37301                       0000CD11            .785:
37302                       0000CD11            .7DE:
37303 CD11                        4E            .ascii	"No bootable device."
37304 CD24                        0A            .byte	$A
37305 CD25                        00            .byte	0
37306                       0000CD26            .76F:
37307                       0000CD26            .7DF:
37308 CD26                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
37309 CD4B                        0A            .byte	$A
37310 CD4C                        00            .byte	0
37311                       0000CD4D            .76A:
37312                       0000CD4D            .7E0:
37313 CD4D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
37314 CD70                        0A            .byte	$A
37315 CD71                        00            .byte	0
37316                       0000CD72            .706:
37317                       0000CD72            .7E1:
37318 CD72                        66            .ascii	"floppy: int13: bad floppy type"
37319 CD90                        0A            .byte	$A
37320 CD91                        00            .byte	0
37321                       0000CD92            .6EE:
37322                       0000CD92            .7E2:
37323 CD92                        69            .ascii	"int13_diskette_function: write error"
37324 CDB6                        0A            .byte	$A
37325 CDB7                        00            .byte	0
37326                       0000CDB8            .6E8:
37327                       0000CDB8            .7E3:
37328 CDB8                        69            .ascii	"int13_diskette: ctrl not ready"
37329 CDD6                        0A            .byte	$A
37330 CDD7                        00            .byte	0
37331                       0000CDD8            .6CE:
37332                       0000CDD8            .7E4:
37333 CDD8                        69            .ascii	"int13_diskette_function: write error"
37334 CDFC                        0A            .byte	$A
37335 CDFD                        00            .byte	0
37336                       0000CDFE            .6C5:
37337                       0000CDFE            .7E5:
37338 CDFE                        69            .ascii	"int13_diskette: ctrl not ready"
37339 CE1C                        0A            .byte	$A
37340 CE1D                        00            .byte	0
37341                       0000CE1E            .6AD:
37342                       0000CE1E            .7E6:
37343 CE1E                        69            .ascii	"int13_diskette: read/write/verify: param"
37344 CE46                        65            .ascii	"eter out of range"
37345 CE57                        0A            .byte	$A
37346 CE58                        00            .byte	0
37347                       0000CE59            .655:
37348                       0000CE59            .7E7:
37349 CE59                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
37350 CE81                        2C            .ascii	", returns fail"
37351 CE8F                        0A            .byte	$A
37352 CE90                        00            .byte	0
37353                       0000CE91            .63D:
37354                       0000CE91            .7E8:
37355 CE91                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
37356 CEB9                        0A            .byte	$A
37357 CEBA                        00            .byte	0
37358                       0000CEBB            .61F:
37359                       0000CEBB            .7E9:
37360 CEBB                        69            .ascii	"int13_cdemu: function %02x, emulation no"
37361 CEE3                        74            .ascii	"t active for DL= %02x"
37362 CEF8                        0A            .byte	$A
37363 CEF9                        00            .byte	0
37364                       0000CEFA            .61B:
37365                       0000CEFA            .7EA:
37366 CEFA                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
37367 CF1D                        0A            .byte	$A
37368 CF1E                        00            .byte	0
37369                       0000CF1F            .616:
37370                       0000CF1F            .7EB:
37371 CF1F                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
37372 CF47                        20            .ascii	" report"
37373 CF4E                        0A            .byte	$A
37374 CF4F                        00            .byte	0
37375                       0000CF50            .60B:
37376                       0000CF50            .7EC:
37377 CF50                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
37378 CF70                        0A            .byte	$A
37379 CF71                        00            .byte	0
37380                       0000CF72            .5DD:
37381                       0000CF72            .7ED:
37382 CF72                        69            .ascii	"int13_cdrom: function %02x, status %02x "
37383 CF9A                        21            .ascii	"!"
37384 CF9B                        0A            .byte	$A
37385 CF9C                        00            .byte	0
37386                       0000CF9D            .5D7:
37387                       0000CF9D            .7EE:
37388 CF9D                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
37389 CFC5                        62            .ascii	"bits lba"
37390 CFCD                        0A            .byte	$A
37391 CFCE                        00            .byte	0
37392                       0000CFCF            .5BD:
37393                       0000CFCF            .7EF:
37394 CFCF                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
37395 CFF7                        69            .ascii	"ice for ELDL=%02x"
37396 D008                        0A            .byte	$A
37397 D009                        00            .byte	0
37398                       0000D00A            .5BA:
37399                       0000D00A            .7F0:
37400 D00A                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
37401 D032                        72            .ascii	"range %02x"
37402 D03C                        0A            .byte	$A
37403 D03D                        00            .byte	0
37404                       0000D03E            .5B2:
37405                       0000D03E            .7F1:
37406 D03E                        69            .ascii	"int13_harddisk: function %02xh unsupport"
37407 D066                        65            .ascii	"ed, returns fail"
37408 D076                        0A            .byte	$A
37409 D077                        00            .byte	0
37410                       0000D078            .5AC:
37411                       0000D078            .7F2:
37412 D078                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
37413 D0A0                        6E            .ascii	"nted, returns success"
37414 D0B5                        0A            .byte	$A
37415 D0B6                        00            .byte	0
37416                       0000D0B7            .597:
37417                       0000D0B7            .7F3:
37418 D0B7                        69            .ascii	"int13_harddisk: function %02x, error %02"
37419 D0DF                        78            .ascii	"x !"
37420 D0E2                        0A            .byte	$A
37421 D0E3                        00            .byte	0
37422                       0000D0E4            .58E:
37423                       0000D0E4            .7F4:
37424 D0E4                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
37425 D10C                        66            .ascii	"f range"
37426 D113                        0A            .byte	$A
37427 D114                        00            .byte	0
37428                       0000D115            .58A:
37429                       0000D115            .7F5:
37430 D115                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
37431 D13D                        66            .ascii	"f range"
37432 D144                        0A            .byte	$A
37433 D145                        00            .byte	0
37434                       0000D146            .57C:
37435                       0000D146            .7F6:
37436 D146                        66            .ascii	"format disk track called"
37437 D15E                        0A            .byte	$A
37438 D15F                        00            .byte	0
37439                       0000D160            .57A:
37440                       0000D160            .7F7:
37441 D160                        69            .ascii	"int13_harddisk: function %02x, error %02"
37442 D188                        78            .ascii	"x !"
37443 D18B                        0A            .byte	$A
37444 D18C                        00            .byte	0
37445                       0000D18D            .56F:
37446                       0000D18D            .7F8:
37447 D18D                        69            .ascii	"int13_harddisk: function %02x, parameter"
37448 D1B5                        73            .ascii	"s out of range %04x/%04x/%04x!"
37449 D1D3                        0A            .byte	$A
37450 D1D4                        00            .byte	0
37451                       0000D1D5            .56A:
37452                       0000D1D5            .7F9:
37453 D1D5                        69            .ascii	"int13_harddisk: function %02x, parameter"
37454 D1FD                        20            .ascii	" out of range!"
37455 D20B                        0A            .byte	$A
37456 D20C                        00            .byte	0
37457                       0000D20D            .55A:
37458                       0000D20D            .7FA:
37459 D20D                        69            .ascii	"int13_harddisk: function %02x, unmapped "
37460 D235                        64            .ascii	"device for ELDL=%02x"
37461 D249                        0A            .byte	$A
37462 D24A                        00            .byte	0
37463                       0000D24B            .557:
37464                       0000D24B            .7FB:
37465 D24B                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
37466 D273                        6F            .ascii	"of range %02x"
37467 D280                        0A            .byte	$A
37468 D281                        00            .byte	0
37469                       0000D282            .4F9:
37470                       0000D282            .7FC:
37471 D282                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
37472 D2AA                        6F            .ascii	"ode are zero?"
37473 D2B7                        0A            .byte	$A
37474 D2B8                        00            .byte	0
37475                       0000D2B9            .4DD:
37476                       0000D2B9            .7FD:
37477 D2B9                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
37478 D2E1                        72            .ascii	"read: 0x%02x!"
37479 D2EE                        0A            .byte	$A
37480 D2EF                        00            .byte	0
37481                       0000D2F0            .4A8:
37482                       0000D2F0            .7FE:
37483 D2F0                        4B            .ascii	"KBD: int09 handler: AL=0"
37484 D308                        0A            .byte	$A
37485 D309                        00            .byte	0
37486                       0000D30A            .4A5:
37487                       0000D30A            .7FF:
37488 D30A                        73            .ascii	"setkbdcomm"
37489 D314                        00            .byte	0
37490                       0000D315            .49E:
37491                       0000D315            .800:
37492 D315                        73            .ascii	"sendmouse"
37493 D31E                        00            .byte	0
37494                       0000D31F            .49B:
37495                       0000D31F            .801:
37496 D31F                        65            .ascii	"enabmouse"
37497 D328                        00            .byte	0
37498                       0000D329            .494:
37499                       0000D329            .802:
37500 D329                        65            .ascii	"enabmouse"
37501 D332                        00            .byte	0
37502                       0000D333            .491:
37503                       0000D333            .803:
37504 D333                        69            .ascii	"inhibmouse"
37505 D33D                        00            .byte	0
37506                       0000D33E            .48A:
37507                       0000D33E            .804:
37508 D33E                        69            .ascii	"inhibmouse"
37509 D348                        00            .byte	0
37510                       0000D349            .47D:
37511                       0000D349            .805:
37512 D349                        4B            .ascii	"KBD: unsupported int 16h function %02x"
37513 D36F                        0A            .byte	$A
37514 D370                        00            .byte	0
37515                       0000D371            .46C:
37516                       0000D371            .806:
37517 D371                        4B            .ascii	"KBD: int16h: out of keyboard input"
37518 D393                        0A            .byte	$A
37519 D394                        00            .byte	0
37520                       0000D395            .43E:
37521                       0000D395            .807:
37522 D395                        4B            .ascii	"KBD: int16h: out of keyboard input"
37523 D3B7                        0A            .byte	$A
37524 D3B8                        00            .byte	0
37525                       0000D3B9            .42B:
37526                       0000D3B9            .808:
37527 D3B9                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37528 D3E1                        74            .ascii	"t yet supported!"
37529 D3F1                        0A            .byte	$A
37530 D3F2                        00            .byte	0
37531                       0000D3F3            .400:
37532                       0000D3F3            .809:
37533 D3F3                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37534 D41B                        74            .ascii	"t yet supported!"
37535 D42B                        0A            .byte	$A
37536 D42C                        00            .byte	0
37537                       0000D42D            .3F4:
37538                       0000D42D            .80A:
37539 D42D                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
37540 D445                        0A            .byte	$A
37541 D446                        00            .byte	0
37542                       0000D447            .3DE:
37543                       0000D447            .80B:
37544 D447                        4D            .ascii	"Mouse status returned %02x (should be ac"
37545 D46F                        6B            .ascii	"k)"
37546 D471                        0A            .byte	$A
37547 D472                        00            .byte	0
37548                       0000D473            .3CE:
37549                       0000D473            .80C:
37550 D473                        4D            .ascii	"Mouse status returned %02x (should be ac"
37551 D49B                        6B            .ascii	"k)"
37552 D49D                        0A            .byte	$A
37553 D49E                        00            .byte	0
37554                       0000D49F            .3CB:
37555                       0000D49F            .80D:
37556 D49F                        4D            .ascii	"Mouse status returned %02x (should be ac"
37557 D4C7                        6B            .ascii	"k)"
37558 D4C9                        0A            .byte	$A
37559 D4CA                        00            .byte	0
37560                       0000D4CB            .3A9:
37561                       0000D4CB            .80E:
37562 D4CB                        4D            .ascii	"Mouse reset returned %02x (should be ack"
37563 D4F3                        29            .ascii	")"
37564 D4F4                        0A            .byte	$A
37565 D4F5                        00            .byte	0
37566                       0000D4F6            .381:
37567                       0000D4F6            .80F:
37568 D4F6                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37569 D51E                        74            .ascii	"t yet supported!"
37570 D52E                        0A            .byte	$A
37571 D52F                        00            .byte	0
37572                       0000D530            .37F:
37573                       0000D530            .810:
37574 D530                        45            .ascii	"EISA BIOS not present"
37575 D545                        0A            .byte	$A
37576 D546                        00            .byte	0
37577                       0000D547            .37B:
37578                       0000D547            .811:
37579 D547                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
37580 D56F                        72            .ascii	"rted!"
37581 D574                        0A            .byte	$A
37582 D575                        00            .byte	0
37583                       0000D576            .365:
37584                       0000D576            .812:
37585 D576                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
37586 D59E                        20            .ascii	" control not supported"
37587 D5B4                        0A            .byte	$A
37588 D5B5                        00            .byte	0
37589                       0000D5B6            .2FF:
37590                       0000D5B6            .813:
37591 D5B6                        61            .ascii	"ata_is_ready returned %d"
37592 D5CE                        0A            .byte	$A
37593 D5CF                        00            .byte	0
37594                       0000D5D0            .2E9:
37595                       0000D5D0            .814:
37596 D5D0                        25            .ascii	"%dMB medium detected"
37597 D5E4                        0A            .byte	$A
37598 D5E5                        00            .byte	0
37599                       0000D5E6            .2E4:
37600                       0000D5E6            .815:
37601 D5E6                        55            .ascii	"Unsupported sector size %u"
37602 D600                        0A            .byte	$A
37603 D601                        00            .byte	0
37604                       0000D602            .2DF:
37605                       0000D602            .816:
37606 D602                        57            .ascii	"Waiting for device to detect medium... "
37607 D629                        00            .byte	0
37608                       0000D62A            .2D1:
37609                       0000D62A            .817:
37610 D62A                        6E            .ascii	"not implemented for non-ATAPI device"
37611 D64E                        0A            .byte	$A
37612 D64F                        00            .byte	0
37613                       0000D650            .297:
37614                       0000D650            .818:
37615 D650                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
37616 D678                        65            .ascii	"et"
37617 D67A                        0A            .byte	$A
37618 D67B                        00            .byte	0
37619                       0000D67C            .255:
37620                       0000D67C            .819:
37621 D67C                        0A            .byte	$A
37622 D67D                        00            .byte	0
37623                       0000D67E            .250:
37624                       0000D67E            .81A:
37625 D67E                        6D            .ascii	"master"
37626 D684                        00            .byte	0
37627                       0000D685            .24F:
37628                       0000D685            .81B:
37629 D685                        20            .ascii	" slave"
37630 D68B                        00            .byte	0
37631                       0000D68C            .24E:
37632                       0000D68C            .81C:
37633 D68C                        61            .ascii	"ata%d %s: Unknown device"
37634 D6A4                        0A            .byte	$A
37635 D6A5                        00            .byte	0
37636                       0000D6A6            .24C:
37637                       0000D6A6            .81D:
37638 D6A6                        20            .ascii	" ATAPI-%d Device"
37639 D6B6                        0A            .byte	$A
37640 D6B7                        00            .byte	0
37641                       0000D6B8            .24A:
37642                       0000D6B8            .81E:
37643 D6B8                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
37644 D6D0                        0A            .byte	$A
37645 D6D1                        00            .byte	0
37646                       0000D6D2            .246:
37647                       0000D6D2            .81F:
37648 D6D2                        25            .ascii	"%c"
37649 D6D4                        00            .byte	0
37650                       0000D6D5            .23F:
37651                       0000D6D5            .820:
37652 D6D5                        6D            .ascii	"master"
37653 D6DB                        00            .byte	0
37654                       0000D6DC            .23E:
37655                       0000D6DC            .821:
37656 D6DC                        20            .ascii	" slave"
37657 D6E2                        00            .byte	0
37658                       0000D6E3            .23D:
37659                       0000D6E3            .822:
37660 D6E3                        61            .ascii	"ata%d %s: "
37661 D6ED                        00            .byte	0
37662                       0000D6EE            .23B:
37663                       0000D6EE            .823:
37664 D6EE                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
37665 D70C                        0A            .byte	$A
37666 D70D                        00            .byte	0
37667                       0000D70E            .239:
37668                       0000D70E            .824:
37669 D70E                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
37670 D72C                        0A            .byte	$A
37671 D72D                        00            .byte	0
37672                       0000D72E            .235:
37673                       0000D72E            .825:
37674 D72E                        25            .ascii	"%c"
37675 D730                        00            .byte	0
37676                       0000D731            .22E:
37677                       0000D731            .826:
37678 D731                        6D            .ascii	"master"
37679 D737                        00            .byte	0
37680                       0000D738            .22D:
37681                       0000D738            .827:
37682 D738                        20            .ascii	" slave"
37683 D73E                        00            .byte	0
37684                       0000D73F            .22C:
37685                       0000D73F            .828:
37686 D73F                        61            .ascii	"ata%d %s: "
37687 D749                        00            .byte	0
37688                       0000D74A            .1FB:
37689                       0000D74A            .829:
37690 D74A                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
37691 D772                        65            .ascii	"e"
37692 D773                        0A            .byte	$A
37693 D774                        00            .byte	0
37694                       0000D775            .1F6:
37695                       0000D775            .82A:
37696 D775                        20            .ascii	" LCHS=%d/%d/%d"
37697 D783                        0A            .byte	$A
37698 D784                        00            .byte	0
37699                       0000D785            .1D6:
37700                       0000D785            .82B:
37701 D785                        72            .ascii	"r-echs"
37702 D78B                        00            .byte	0
37703                       0000D78C            .1D4:
37704                       0000D78C            .82C:
37705 D78C                        6C            .ascii	"large"
37706 D791                        00            .byte	0
37707                       0000D792            .1D2:
37708                       0000D792            .82D:
37709 D792                        6C            .ascii	"lba"
37710 D795                        00            .byte	0
37711                       0000D796            .1D0:
37712                       0000D796            .82E:
37713 D796                        6E            .ascii	"none"
37714 D79A                        00            .byte	0
37715                       0000D79B            .1C6:
37716                       0000D79B            .82F:
37717 D79B                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
37718 D7BF                        00            .byte	0
37719                       0000D7C0            .1BF:
37720                       0000D7C0            .830:
37721 D7C0                        61            .ascii	"ata-detect: Failed to detect ATA device"
37722 D7E7                        0A            .byte	$A
37723 D7E8                        00            .byte	0
37724                       0000D7E9            .19E:
37725                       0000D7E9            .831:
37726 D7E9                        49            .ascii	"IDE time out"
37727 D7F5                        0A            .byte	$A
37728 D7F6                        00            .byte	0
37729                       0000D7F7            .162:
37730                       0000D7F7            .832:
37731 D7F7                        53            .ascii	"S3 resume jump to %x:%x"
37732 D80E                        0A            .byte	$A
37733 D80F                        00            .byte	0
37734                       0000D810            .15E:
37735                       0000D810            .833:
37736 D810                        53            .ascii	"S3 resume called %x 0x%lx"
37737 D829                        0A            .byte	$A
37738 D82A                        00            .byte	0
37739                       0000D82B            .158:
37740                       0000D82B            .834:
37741 D82B                        25            .ascii	"%s"
37742 D82D                        0A            .byte	$A
37743 D82E                        00            .byte	0
37744                       0000D82F            .157:
37745                       0000D82F            .835:
37746 D82F                        49            .ascii	"INT18: BOOT FAILURE"
37747 D842                        0A            .byte	$A
37748 D843                        00            .byte	0
37749                       0000D844            .156:
37750                       0000D844            .836:
37751 D844                        4E            .ascii	"NMI Handler called"
37752 D856                        0A            .byte	$A
37753 D857                        00            .byte	0
37754                       0000D858            .155:
37755                       0000D858            .837:
37756 D858                        43            .ascii	"CDROM boot failure code : %04x"
37757 D876                        0A            .byte	$A
37758 D877                        00            .byte	0
37759                       0000D878            .154:
37760                       0000D878            .838:
37761 D878                        0A            .byte	$A,$A
37762 D87A                        00            .byte	0
37763                       0000D87B            .153:
37764                       0000D87B            .839:
37765 D87B                        3A            .ascii	": could not read the boot disk"
37766 D899                        00            .byte	0
37767                       0000D89A            .151:
37768                       0000D89A            .83A:
37769 D89A                        3A            .ascii	": not a bootable disk"
37770 D8AF                        00            .byte	0
37771                       0000D8B0            .14C:
37772                       0000D8B0            .83B:
37773 D8B0                        42            .ascii	"Boot failed"
37774 D8BB                        00            .byte	0
37775                       0000D8BC            .14B:
37776                       0000D8BC            .83C:
37777 D8BC                        42            .ascii	"Bad drive type"
37778 D8CA                        0A            .byte	$A
37779 D8CB                        00            .byte	0
37780                       0000D8CC            .147:
37781                       0000D8CC            .83D:
37782 D8CC                        2E            .ascii	"..."
37783 D8CF                        0A            .byte	$A
37784 D8D0                        00            .byte	0
37785                       0000D8D1            .146:
37786                       0000D8D1            .83E:
37787 D8D1                        20            .ascii	" [%S]"
37788 D8D6                        00            .byte	0
37789                       0000D8D7            .142:
37790                       0000D8D7            .83F:
37791 D8D7                        42            .ascii	"Booting from %s"
37792 D8E6                        00            .byte	0
37793                       0000D8E7            .141:
37794                       0000D8E7            .840:
37795 D8E7                        42            .ascii	"Bad drive type"
37796 D8F5                        0A            .byte	$A
37797 D8F6                        00            .byte	0
37798                       0000D8F7            .13B:
37799                       0000D8F7            .841:
37800 D8F7                        0A            .byte	$A
37801 D8F8                        00            .byte	0
37802                       0000D8F9            .12F:
37803                       0000D8F9            .842:
37804 D8F9                        0A            .byte	$A
37805 D8FA                        00            .byte	0
37806                       0000D8FB            .12E:
37807                       0000D8FB            .843:
37808 D8FB                        20            .ascii	" [%S]"
37809 D900                        00            .byte	0
37810                       0000D901            .12B:
37811                       0000D901            .844:
37812 D901                        25            .ascii	"%s"
37813 D903                        00            .byte	0
37814                       0000D904            .129:
37815                       0000D904            .845:
37816 D904                        25            .ascii	"%s"
37817 D906                        0A            .byte	$A
37818 D907                        00            .byte	0
37819                       0000D908            .122:
37820                       0000D908            .846:
37821 D908                        25            .ascii	"%d. "
37822 D90C                        00            .byte	0
37823                       0000D90D            .11D:
37824                       0000D90D            .847:
37825 D90D                        53            .ascii	"Select boot device:"
37826 D920                        0A            .byte	$A,$A
37827 D922                        00            .byte	0
37828                       0000D923            .114:
37829                       0000D923            .848:
37830 D923                        50            .ascii	"Press F12 for boot menu."
37831 D93B                        0A            .byte	$A,$A
37832 D93D                        00            .byte	0
37833                       0000D93E            .106:
37834                       0000D93E            .849:
37835 D93E                        61            .ascii	"apmbios pcibios pnpbios eltorito "
37836 D95F                        0A            .byte	$A,$A
37837 D961                        00            .byte	0
37838                       0000D962            .105:
37839                       0000D962            .84A:
37840 D962                        30            .ascii	"08/01/21"
37841 D96A                        00            .byte	0
37842                       0000D96B            .104:
37843                       0000D96B            .84B:
37844 D96B                        42            .ascii	"Bochs 2.7 BIOS - build: %s"
37845 D985                        0A            .byte	$A
37846 D986                        25            .ascii	"%s"
37847 D988                        0A            .byte	$A
37848 D989                        4F            .ascii	"Options: "
37849 D992                        00            .byte	0
37850                       0000D993            .103:
37851                       0000D993            .84C:
37852 D993                        52            .ascii	"Returned from s3_resume."
37853 D9AB                        0A            .byte	$A
37854 D9AC                        00            .byte	0
37855                       0000D9AD            .102:
37856                       0000D9AD            .84D:
37857 D9AD                        55            .ascii	"Unimplemented shutdown status: %02x"
37858 D9D0                        0A            .byte	$A
37859 D9D1                        00            .byte	0
37860                       0000D9D2            .101:
37861                       0000D9D2            .84E:
37862 D9D2                        4B            .ascii	"Keyboard error:%u"
37863 D9E3                        0A            .byte	$A
37864 D9E4                        00            .byte	0
37865                       0000D9E5            .7C:
37866                       0000D9E5            .84F:
37867 D9E5                        62            .ascii	"bios_printf: unknown format"
37868 DA00                        0A            .byte	$A
37869 DA01                        00            .byte	0
37870                       0000DA02            .38:
37871                       0000DA02            .850:
37872 DA02                        46            .ascii	"FATAL: "
37873 DA09                        00            .byte	0
37874 DA0A                                      .bss
37875                                           
37876                                           ! 0 errors detected

Symbols:
..FFD8                      0 FFFC A   ..FFD9                      0 FFE0 A   
..FFDA                      0 FFDC A   ..FFDB                      0 FFDC A   
..FFDC                      0 FFF6 A   ..FFDD                      0 FFC6 A   
..FFDE                      0 FFC6 A   ..FFDF                      0 FFC6 A   
..FFE0                      0 FFC6 A   ..FFE1                      0 FFC6 A   
..FFE2                      0 FFC6 A   ..FFE3                      0 FFFC A   
..FFE4                      0 FFFC A   ..FFE5                      0 FFFC A   
..FFE6                      0 FFE0 A   ..FFE7                      0 FFE0 A   
..FFE8                      0 FFE0 A   ..FFE9                      0 FFE0 A   
..FFEA                      0 FFE0 A   ..FFEB                      0 FFE0 A   
..FFEC                      0 FFDA A   ..FFED                      0 FFDA A   
..FFEE                      0 FFDA A   ..FFEF                      0 FFDA A   
..FFF0                      0 FFDA A   ..FFF1                      0 FFDA A   
..FFF2                      0 FFF8 A   ..FFF3                      0 FFF4 A   
..FFF4                      0 FFF0 A   ..FFF5                      0 FFF0 A   
..FFF6                      0 FFF0 A   ..FFF7                      0 FFEA A   
..FFF8                      0 FFF6 A   ..FFF9                      0 F7E0 A   
..FFFA                      0 FFD4 A   ..FFFB                      0 FDB6 A   
..FFFC                      0 FDB6 A   ..FFFD                      0 FDD8 A   
..FFFE                      0 FDD8 A   ..FFFF                      0 FFC4 A   
.1                          0 0165 A   .10                         0 070D A   
.100                        0 1187 A   .101                        0 D9D2 A   
.102                        0 D9AD A   .103                        0 D993 A   
.104                        0 D96B A   .105                        0 D962 A   
.106                        0 D93E A   .107                        0 1208 A   
.108                        0 1212 A   .109                        0 121C A   
.10A                        0 1226 A   .10B                        0 1230 A   
.10C                        0 1394 A   .10D                        0 138E A   
.10E                        0 13D5 A   .10F                        0 13CE A   
.11                         0 06F7 A   .110                        0 13CB A   
.111                        0 13D5 A   .112                        0 13E8 A   
.113                        0 13E4 A   .114                        0 D923 A   
.115                        0 15AE A   .116                        0 140D A   
.117                        0 15AE A   .118                        0 141C A   
.119                        0 1428 A   .11A                        0 1421 A   
.11B                        0 141E A   .11C                        0 1428 A   
.11D                        0 D90D A   .11E                        0 1547 A   
.11F                        0 1534 A   .12                         0 073B A   
.120                        0 153B A   .121                        0 144F A   
.122                        0 D908 A   .123                        0 1534 A   
.125                        0 1518 A   .126                        0 1489 A   
.127                        0 1489 A   .128                        0 1489 A   
.129                        0 D904 A   .12A                        0 14AC A   
.12B                        0 D901 A   .12C                        0 1506 A   
.12D                        0 14D5 A   .12E                        0 D8FB A   
.12F                        0 D8F9 A   .13                         0 0727 A   
.130                        0 1547 A   .131                        0 15A0 A   
.132                        0 1599 A   .133                        0 1550 A   
.134                        0 156C A   .135                        0 1564 A   
.136                        0 155D A   .137                        0 1599 A   
.138                        0 1599 A   .139                        0 1576 A   
.13A                        0 15A0 A   .13B                        0 D8F7 A   
.13C                        0 15D4 A   .13D                        0 15CE A   
.13E                        0 15F1 A   .13F                        0 15E3 A   
.14                         0 071C A   .140                        0 15DB A   
.141                        0 D8E7 A   .142                        0 D8D7 A   
.143                        0 166A A   .144                        0 1633 A   
.145                        0 1619 A   .146                        0 D8D1 A   
.147                        0 D8CC A   .148                        0 169B A   
.149                        0 168E A   .14A                        0 1686 A   
.14B                        0 D8BC A   .14C                        0 D8B0 A   
.14D                        0 16D3 A   .14E                        0 16B0 A   
.14F                        0 16C6 A   .15                         0 070F A   
.150                        0 16B7 A   .151                        0 D89A A   
.152                        0 16D3 A   .153                        0 D87B A   
.154                        0 D878 A   .155                        0 D858 A   
.156                        0 D844 A   .157                        0 D82F A   
.158                        0 D82B A   .159                        0 175D A   
.15A                        0 1749 A   .15B                        0 176F A   
.15C                        0 177C A   .15D                        0 177E A   
.15E                        0 D810 A   .15F                        0 17F2 A   
.16                         0 0727 A   .160                        0 17EC A   
.161                        0 17E1 A   .162                        0 D7F7 A   
.163                        0 18B3 A   .164                        0 18A5 A   
.165                        0 18AC A   .166                        0 1861 A   
.167                        0 18B3 A   .168                        0 19E5 A   
.169                        0 19D5 A   .16A                        0 19DC A   
.16B                        0 18BB A   .16C                        0 19E5 A   
.16D                        0 1A14 A   .16E                        0 1A06 A   
.16F                        0 1A0D A   .17                         0 073B A   
.170                        0 19EC A   .171                        0 1A14 A   
.172                        0 1B75 A   .173                        0 1B72 A   
.174                        0 1A55 A   .175                        0 1A84 A   
.176                        0 1A79 A   .177                        0 1B18 A   
.178                        0 1AA0 A   .179                        0 1A8B A   
.17A                        0 1A98 A   .17B                        0 1A94 A   
.17C                        0 1A9A A   .17D                        0 1B18 A   
.17E                        0 1AC4 A   .17F                        0 1AA7 A   
.18                         0 072E A   .180                        0 1ABD A   
.181                        0 1AB9 A   .182                        0 1AB0 A   
.183                        0 1ABF A   .184                        0 1B18 A   
.185                        0 1AE8 A   .186                        0 1ACB A   
.187                        0 1AE1 A   .188                        0 1ADD A   
.189                        0 1AD4 A   .18A                        0 1AE3 A   
.18B                        0 1B18 A   .18C                        0 1B0C A   
.18D                        0 1AEF A   .18E                        0 1B05 A   
.18F                        0 1B01 A   .19                         0 07A8 A   
.190                        0 1AF8 A   .191                        0 1B07 A   
.192                        0 1B18 A   .193                        0 1B18 A   
.194                        0 1B13 A   .195                        0 1B25 A   
.196                        0 1B1F A   .197                        0 1B33 A   
.198                        0 1B2D A   .199                        0 1B43 A   
.19A                        0 1B3C A   .19B                        0 1B72 A   
.19C                        0 1B70 A   .19D                        0 1B4A A   
.19E                        0 D7E9 A   .19F                        0 281F A   
.1A                         0 078F A   .1A0                        0 280F A   
.1A1                        0 2816 A   .1A2                        0 1C06 A   
.1A3                        0 1C65 A   .1A4                        0 1C61 A   
.1A5                        0 1C67 A   .1A6                        0 1E2C A   
.1A7                        0 1D16 A   .1A8                        0 1D0C A   
.1A9                        0 1D3F A   .1AA                        0 1D3B A   
.1AB                        0 1D41 A   .1AC                        0 1E2C A   
.1AD                        0 1D87 A   .1AE                        0 1D7D A   
.1AF                        0 1DDE A   .1B                         0 07D6 A   
.1B0                        0 1DCA A   .1B1                        0 1DC2 A   
.1B2                        0 1E2C A   .1B3                        0 1E0A A   
.1B4                        0 1DF6 A   .1B5                        0 1DEE A   
.1B6                        0 1DE6 A   .1B7                        0 1E2C A   
.1B8                        0 1E2C A   .1B9                        0 1E1A A   
.1BA                        0 1E12 A   .1BB                        0 2315 A   
.1BC                        0 1E48 A   .1BD                        0 1EB6 A   
.1BE                        0 1EA8 A   .1BF                        0 D7C0 A   
.1C                         0 07C2 A   .1C0                        0 1EDE A   
.1C1                        0 1EDA A   .1C2                        0 1EE0 A   
.1C3                        0 1F57 A   .1C4                        0 1F2D A   
.1C5                        0 1F77 A   .1C6                        0 D79B A   
.1C7                        0 20A3 A   .1C8                        0 2092 A   
.1C9                        0 209B A   .1CA                        0 2084 A   
.1CB                        0 20A3 A   .1CC                        0 2119 A   
.1CE                        0 2109 A   .1CF                        0 20C7 A   
.1D                         0 07B7 A   .1D0                        0 D796 A   
.1D1                        0 20D7 A   .1D2                        0 D792 A   
.1D3                        0 20E7 A   .1D4                        0 D78C A   
.1D5                        0 20F7 A   .1D6                        0 D785 A   
.1D7                        0 2297 A   .1D9                        0 2281 A   
.1DA                        0 2120 A   .1DB                        0 2123 A   
.1DC                        0 217A A   .1DD                        0 2171 A   
.1DE                        0 21B7 A   .1DF                        0 218C A   
.1E                         0 07AA A   .1E0                        0 2183 A   
.1E1                        0 21B7 A   .1E2                        0 219E A   
.1E3                        0 2195 A   .1E4                        0 21B7 A   
.1E5                        0 21B0 A   .1E6                        0 21A7 A   
.1E7                        0 21B7 A   .1E8                        0 21D8 A   
.1E9                        0 2253 A   .1EA                        0 21E1 A   
.1EB                        0 220C A   .1EC                        0 2205 A   
.1ED                        0 2253 A   .1EE                        0 227D A   
.1EF                        0 2274 A   .1F                         0 07C2 A   
.1F0                        0 2255 A   .1F1                        0 2274 A   
.1F2                        0 2272 A   .1F3                        0 227D A   
.1F4                        0 22A7 A   .1F5                        0 22A0 A   
.1F6                        0 D775 A   .1F7                        0 243D A   
.1F8                        0 231E A   .1F9                        0 238C A   
.1FA                        0 237E A   .1FB                        0 D74A A   
.1FC                        0 23B0 A   .1FD                        0 23AC A   
.1FE                        0 23B2 A   .1FF                        0 23C8 A   
.2                          0 05D8 A   .20                         0 07D6 A   
.200                        0 23C4 A   .201                        0 23CA A   
.202                        0 2665 A   .204                        0 2659 A   
.205                        0 2446 A   .206                        0 2482 A   
.208                        0 2476 A   .209                        0 244C A   
.20A                        0 245A A   .20B                        0 2468 A   
.20C                        0 24E2 A   .20D                        0 2539 A   
.20E                        0 2528 A   .20F                        0 2531 A   
.21                         0 07C9 A   .210                        0 250F A   
.211                        0 2528 A   .212                        0 2526 A   
.213                        0 2539 A   .214                        0 25B2 A   
.215                        0 25A1 A   .216                        0 25AA A   
.217                        0 2541 A   .218                        0 25B2 A   
.219                        0 260D A   .21A                        0 25FC A   
.21B                        0 2605 A   .21C                        0 25C8 A   
.21D                        0 25FA A   .21E                        0 25E0 A   
.21F                        0 25FC A   .22                         0 0849 A   
.220                        0 260D A   .221                        0 2655 A   
.222                        0 2615 A   .223                        0 2655 A   
.224                        0 2644 A   .225                        0 264D A   
.226                        0 262B A   .227                        0 2655 A   
.228                        0 2809 A   .22A                        0 27F9 A   
.22B                        0 266B A   .22C                        0 D73F A   
.22D                        0 D738 A   .22E                        0 D731 A   
.22F                        0 2678 A   .23                         0 0836 A   
.230                        0 2673 A   .231                        0 267B A   
.232                        0 26D0 A   .233                        0 26AE A   
.234                        0 2699 A   .235                        0 D72E A   
.236                        0 26D0 A   .237                        0 26F9 A   
.238                        0 26DE A   .239                        0 D70E A   
.23A                        0 2725 A   .23B                        0 D6EE A   
.23C                        0 2728 A   .23D                        0 D6E3 A   
.23E                        0 D6DC A   .23F                        0 D6D5 A   
.24                         0 0820 A   .240                        0 2735 A   
.241                        0 2730 A   .242                        0 2738 A   
.243                        0 278D A   .244                        0 276B A   
.245                        0 2756 A   .246                        0 D6D2 A   
.247                        0 278D A   .248                        0 27B8 A   
.249                        0 27A1 A   .24A                        0 D6B8 A   
.24B                        0 27CD A   .24C                        0 D6A6 A   
.24D                        0 27CF A   .24E                        0 D68C A   
.24F                        0 D685 A   .25                         0 0849 A   
.250                        0 D67E A   .251                        0 27DC A   
.252                        0 27D7 A   .253                        0 27DF A   
.254                        0 281F A   .255                        0 D67C A   
.256                        0 2965 A   .257                        0 28E1 A   
.258                        0 28EC A   .259                        0 28E8 A   
.25A                        0 28EE A   .25B                        0 2954 A   
.25C                        0 2929 A   .25D                        0 2922 A   
.25E                        0 2943 A   .25F                        0 2930 A   
.26                         0 08EB A   .260                        0 2954 A   
.261                        0 29E4 A   .262                        0 29DC A   
.263                        0 29D4 A   .264                        0 29F5 A   
.265                        0 2A08 A   .266                        0 29FC A   
.267                        0 2A10 A   .268                        0 2A44 A   
.269                        0 2A3D A   .26A                        0 2B53 A   
.26B                        0 2A5E A   .26C                        0 2B25 A   
.26D                        0 2A9F A   .26E                        0 2A80 A   
.26F                        0 2A75 A   .27                         0 08DF A   
.270                        0 2A69 A   .271                        0 2A6B A   
.273                        0 2BB1 A   .274                        0 2BAD A   
.275                        0 2BB3 A   .276                        0 2C08 A   
.277                        0 2BFF A   .278                        0 2C18 A   
.279                        0 2C18 A   .27A                        0 2C11 A   
.27B                        0 2D2F A   .27C                        0 2D2C A   
.27D                        0 2C19 A   .27E                        0 2C56 A   
.27F                        0 2C20 A   .28                         0 0871 A   
.280                        0 2C8C A   .281                        0 2CBA A   
.282                        0 2CA9 A   .283                        0 2CFF A   
.284                        0 2CD0 A   .285                        0 2CEB A   
.286                        0 2CD7 A   .287                        0 2CE7 A   
.288                        0 2CE0 A   .289                        0 2CFD A   
.28A                        0 2CFB A   .28B                        0 2CF4 A   
.28C                        0 2D2C A   .28D                        0 2D1A A   
.28E                        0 2D06 A   .28F                        0 2D16 A   
.29                         0 08B3 A   .290                        0 2D0F A   
.291                        0 2D2C A   .292                        0 2D2A A   
.293                        0 2D23 A   .294                        0 2D2F A   
.295                        0 2D80 A   .296                        0 2D6B A   
.297                        0 D650 A   .298                        0 2D90 A   
.299                        0 2D89 A   .29A                        0 2DE6 A   
.29B                        0 2DE1 A   .29C                        0 2DF2 A   
.29D                        0 2DED A   .29E                        0 2E33 A   
.29F                        0 2E2C A   .2A                         0 088D A   
.2A0                        0 2E9E A   .2A1                        0 2E9A A   
.2A2                        0 2EA0 A   .2A3                        0 2EF3 A   
.2A4                        0 2EEA A   .2A5                        0 2F03 A   
.2A6                        0 2F03 A   .2A7                        0 2EFC A   
.2A8                        0 2F5A A   .2A9                        0 2F37 A   
.2AA                        0 31C9 A   .2AB                        0 31C6 A   
.2AC                        0 31C3 A   .2AD                        0 2F63 A   
.2AE                        0 2F8C A   .2AF                        0 2F6A A   
.2B                         0 08D3 A   .2B0                        0 2F9D A   
.2B1                        0 2FDE A   .2B2                        0 2FDB A   
.2B3                        0 2FD2 A   .2B4                        0 2FEE A   
.2B5                        0 2FE7 A   .2B6                        0 3041 A   
.2B7                        0 302B A   .2B8                        0 3055 A   
.2B9                        0 3082 A   .2BA                        0 3062 A   
.2BB                        0 30A3 A   .2BC                        0 30BD A   
.2BD                        0 30B8 A   .2BE                        0 30CB A   
.2BF                        0 30C6 A   .2C                         0 08D3 A   
.2C0                        0 30D9 A   .2C1                        0 30D4 A   
.2C2                        0 3100 A   .2C3                        0 30E2 A   
.2C4                        0 3100 A   .2C5                        0 30F9 A   
.2C6                        0 30F0 A   .2C7                        0 3127 A   
.2C8                        0 3107 A   .2C9                        0 313F A   
.2CA                        0 31C6 A   .2CB                        0 31D9 A   
.2CC                        0 31D2 A   .2CD                        0 324B A   
.2CE                        0 3244 A   .2CF                        0 32B2 A   
.2D                         0 08C1 A   .2D0                        0 329D A   
.2D1                        0 D62A A   .2D2                        0 33A4 A   
.2D3                        0 3394 A   .2D4                        0 32E9 A   
.2D5                        0 331E A   .2D6                        0 3318 A   
.2D7                        0 3378 A   .2D8                        0 3337 A   
.2D9                        0 3345 A   .2DA                        0 333E A   
.2DB                        0 3378 A   .2DC                        0 335A A   
.2DD                        0 3353 A   .2DE                        0 334C A   
.2DF                        0 D602 A   .2E                         0 08EB A   
.2E0                        0 33A4 A   .2E1                        0 340E A   
.2E2                        0 33F3 A   .2E3                        0 33DB A   
.2E4                        0 D5E6 A   .2E5                        0 346E A   
.2E6                        0 345C A   .2E7                        0 34B4 A   
.2E8                        0 3490 A   .2E9                        0 D5D0 A   
.2EA                        0 34F0 A   .2EB                        0 34EA A   
.2EC                        0 3514 A   .2ED                        0 350E A   
.2EE                        0 3538 A   .2EF                        0 3532 A   
.2F                         0 0935 A   .2F0                        0 3596 A   
.2F1                        0 359C A   .2F2                        0 35EE A   
.2F3                        0 35DD A   .2F4                        0 35E6 A   
.2F5                        0 35CB A   .2F6                        0 35DD A   
.2F7                        0 35DB A   .2F8                        0 35EE A   
.2F9                        0 35FD A   .2FA                        0 35F6 A   
.2FB                        0 362F A   .2FC                        0 361D A   
.2FD                        0 3611 A   .2FE                        0 3613 A   
.2FF                        0 D5B6 A   .3                          0 05CD A   
.30                         0 0926 A   .300                        0 36A6 A   
.301                        0 369F A   .302                        0 36B5 A   
.303                        0 36AE A   .304                        0 3701 A   
.305                        0 36EF A   .306                        0 36F8 A   
.307                        0 36BD A   .308                        0 36EF A   
.309                        0 36E8 A   .30A                        0 3701 A   
.30B                        0 374F A   .30C                        0 373D A   
.30D                        0 3746 A   .30E                        0 3709 A   
.30F                        0 373D A   .31                         0 092D A   
.310                        0 3736 A   .311                        0 374F A   
.312                        0 37DE A   .313                        0 37D7 A   
.314                        0 37ED A   .315                        0 37E6 A   
.316                        0 37FC A   .317                        0 37F5 A   
.318                        0 380B A   .319                        0 3804 A   
.31A                        0 381A A   .31B                        0 3813 A   
.31C                        0 3829 A   .31D                        0 3822 A   
.31E                        0 384A A   .31F                        0 3843 A   
.32                         0 0915 A   .320                        0 385E A   
.321                        0 3859 A   .322                        0 3852 A   
.323                        0 385E A   .324                        0 388B A   
.325                        0 3884 A   .326                        0 3978 A   
.327                        0 3969 A   .328                        0 3A2F A   
.32A                        0 3A19 A   .32B                        0 397E A   
.32C                        0 3993 A   .32D                        0 39A8 A   
.32E                        0 39BC A   .32F                        0 3A69 A   
.33                         0 0926 A   .330                        0 3A36 A   
.331                        0 3A60 A   .332                        0 3A3D A   
.333                        0 3A69 A   .334                        0 3A75 A   
.335                        0 3A70 A   .336                        0 3CB4 A   
.337                        0 3AC7 A   .338                        0 3ABE A   
.339                        0 3CB2 A   .33B                        0 3C9A A   
.33C                        0 3ACD A   .33D                        0 3B12 A   
.33E                        0 3AF4 A   .33F                        0 3B49 A   
.34                         0 0924 A   .340                        0 3B87 A   
.341                        0 3BC3 A   .342                        0 3BAA A   
.343                        0 3B8F A   .344                        0 3BAA A   
.345                        0 3B9D A   .346                        0 3BC3 A   
.347                        0 3BBC A   .348                        0 3BEA A   
.349                        0 3BCA A   .34A                        0 3BEF A   
.34B                        0 3BFA A   .34C                        0 3C36 A   
.34D                        0 3C1D A   .34E                        0 3C02 A   
.34F                        0 3C1D A   .35                         0 0935 A   
.350                        0 3C10 A   .351                        0 3C36 A   
.352                        0 3C2F A   .353                        0 3C59 A   
.354                        0 3C3D A   .355                        0 3C5E A   
.356                        0 3C68 A   .357                        0 3C90 A   
.358                        0 3CBC A   .359                        0 41A0 A   
.35B                        0 4156 A   .35C                        0 3CD4 A   
.35D                        0 3D5E A   .35F                        0 3D4C A   
.36                         0 0982 A   .360                        0 3CD9 A   
.361                        0 3CD9 A   .362                        0 3CF3 A   
.363                        0 3D14 A   .364                        0 3D29 A   
.365                        0 D576 A   .366                        0 3D61 A   
.367                        0 3D71 A   .368                        0 3D7C A   
.369                        0 3D8C A   .36A                        0 3E17 A   
.36B                        0 3D9C A   .36C                        0 3E08 A   
.36D                        0 3DA5 A   .36E                        0 3E15 A   
.36F                        0 3E5F A   .37                         0 0967 A   
.370                        0 3E4B A   .371                        0 3E1E A   
.372                        0 3E5F A   .373                        0 3E62 A   
.374                        0 3E9D A   .375                        0 3E96 A   
.376                        0 3FEA A   .377                        0 4010 A   
.378                        0 400A A   .379                        0 401B A   
.37A                        0 40C9 A   .37B                        0 D547 A   
.37C                        0 40E7 A   .37D                        0 4103 A   
.37E                        0 4114 A   .37F                        0 D530 A   
.38                         0 DA02 A   .380                        0 4131 A   
.381                        0 D4F6 A   .382                        0 482A A   
.384                        0 4822 A   .385                        0 41B8 A   
.386                        0 47FB A   .388                        0 47D6 A   
.389                        0 41BE A   .38A                        0 42BB A   
.38C                        0 42AD A   .38D                        0 41C4 A   
.38E                        0 4205 A   .38F                        0 41DA A   
.39                         0 0C45 A   .390                        0 4205 A   
.391                        0 41F4 A   .392                        0 41ED A   
.393                        0 421A A   .394                        0 4244 A   
.395                        0 4233 A   .396                        0 4288 A   
.397                        0 425A A   .398                        0 4288 A   
.399                        0 4274 A   .39A                        0 426D A   
.39B                        0 429A A   .39C                        0 42BE A   
.39D                        0 42BE A   .39E                        0 4335 A   
.39F                        0 42C5 A   .3A                         0 0C37 A   
.3A0                        0 42E4 A   .3A1                        0 42D3 A   
.3A2                        0 42CC A   .3A3                        0 43D4 A   
.3A4                        0 434D A   .3A5                        0 436C A   
.3A6                        0 4360 A   .3A7                        0 4387 A   
.3A8                        0 4373 A   .3A9                        0 D4CB A   
.3AA                        0 43D4 A   .3AB                        0 438E A   
.3AC                        0 43D4 A   .3AD                        0 43A1 A   
.3AE                        0 43D4 A   .3AF                        0 43B4 A   
.3B                         0 0985 A   .3B0                        0 43E6 A   
.3B1                        0 4446 A   .3B3                        0 4423 A   
.3B4                        0 43EB A   .3B5                        0 43F2 A   
.3B6                        0 43F9 A   .3B7                        0 4400 A   
.3B8                        0 4407 A   .3B9                        0 440E A   
.3BA                        0 4415 A   .3BB                        0 441C A   
.3BC                        0 4444 A   .3BD                        0 4436 A   
.3BE                        0 44A6 A   .3BF                        0 444F A   
.3C                         0 099A A   .3C0                        0 4497 A   
.3C1                        0 4462 A   .3C2                        0 44A4 A   
.3C3                        0 44B3 A   .3C4                        0 44B6 A   
.3C5                        0 4554 A   .3C6                        0 44C5 A   
.3C7                        0 4545 A   .3C8                        0 44DA A   
.3C9                        0 4501 A   .3CA                        0 44ED A   
.3CB                        0 D49F A   .3CC                        0 4536 A   
.3CD                        0 4522 A   .3CE                        0 D473 A   
.3CF                        0 4552 A   .3D                         0 098C A   
.3D0                        0 4561 A   .3D1                        0 456F A   
.3D2                        0 45B2 A   .3D3                        0 4585 A   
.3D4                        0 45BF A   .3D5                        0 45C2 A   
.3D6                        0 473A A   .3D8                        0 4726 A   
.3D9                        0 45C8 A   .3DA                        0 467C A   
.3DB                        0 45E3 A   .3DC                        0 460A A   
.3DD                        0 45F6 A   .3DE                        0 D447 A   
.3DF                        0 467C A   .3E                         0 0C30 A   
.3E0                        0 4613 A   .3E1                        0 467C A   
.3E2                        0 4628 A   .3E3                        0 467C A   
.3E4                        0 463B A   .3E5                        0 467C A   
.3E6                        0 464E A   .3E7                        0 4699 A   
.3E8                        0 4699 A   .3E9                        0 46B4 A   
.3EA                        0 46A6 A   .3EB                        0 46C0 A   
.3EC                        0 46E0 A   .3ED                        0 46C7 A   
.3EE                        0 46DB A   .3EF                        0 46DD A   
.3F                         0 0C21 A   .3F0                        0 46F6 A   
.3F1                        0 46E7 A   .3F2                        0 4703 A   
.3F3                        0 4710 A   .3F4                        0 D42D A   
.3F5                        0 473D A   .3F6                        0 479D A   
.3F7                        0 4787 A   .3F8                        0 4780 A   
.3F9                        0 479B A   .3FA                        0 4790 A   
.3FB                        0 47A5 A   .3FC                        0 47C7 A   
.3FD                        0 47F9 A   .3FE                        0 47E9 A   
.3FF                        0 47FD A   .4                          0 05B8 A   
.40                         0 09A3 A   .400                        0 D3F3 A   
.401                        0 4D7D A   .403                        0 4D6F A   
.404                        0 48F8 A   .405                        0 493E A   
.406                        0 4D48 A   .408                        0 4D3C A   
.409                        0 4944 A   .40A                        0 4CDA A   
.40B                        0 495F A   .40C                        0 49AF A   
.40D                        0 49A3 A   .40E                        0 4A44 A   
.40F                        0 49F4 A   .41                         0 09D2 A   
.410                        0 4CB9 A   .412                        0 4C94 A   
.413                        0 4A73 A   .414                        0 4AA5 A   
.415                        0 4AD8 A   .416                        0 4B17 A   
.417                        0 4B0A A   .418                        0 4B22 A   
.419                        0 4B25 A   .41A                        0 4B56 A   
.41B                        0 4BC2 A   .41C                        0 4C04 A   
.41D                        0 4C4B A   .41E                        0 4C3E A   
.41F                        0 4C33 A   .42                         0 09B1 A   
.420                        0 4C55 A   .421                        0 4C57 A   
.422                        0 4C8A A   .423                        0 4CB7 A   
.424                        0 4CA7 A   .425                        0 4CDF A   
.426                        0 4CE1 A   .427                        0 4D0F A   
.428                        0 4D09 A   .429                        0 4D35 A   
.42A                        0 4D4A A   .42B                        0 D3B9 A   
.42C                        0 4E44 A   .42D                        0 4DAF A   
.42E                        0 4DDD A   .42F                        0 4DCE A   
.43                         0 09AA A   .430                        0 4DC0 A   
.431                        0 4DDD A   .432                        0 4E43 A   
.433                        0 4DEA A   .434                        0 4E34 A   
.435                        0 4E25 A   .436                        0 4E17 A   
.437                        0 4E34 A   .438                        0 512F A   
.43A                        0 50E8 A   .43B                        0 4E4A A   
.43C                        0 4E6E A   .43D                        0 4E60 A   
.43E                        0 D395 A   .43F                        0 4E83 A   
.44                         0 0C1F A   .440                        0 4E7C A   
.441                        0 4E75 A   .442                        0 4E8F A   
.443                        0 4E8F A   .444                        0 4E8A A   
.445                        0 4EA1 A   .446                        0 4EC2 A   
.447                        0 4EB6 A   .448                        0 4ED7 A   
.449                        0 4ED0 A   .44A                        0 4EC9 A   
.44B                        0 4EE3 A   .44C                        0 4EE3 A   
.44D                        0 4EDE A   .44E                        0 4EFD A   
.44F                        0 4F0C A   .45                         0 0A52 A   
.450                        0 4F29 A   .451                        0 4F22 A   
.452                        0 4F2E A   .453                        0 4F31 A   
.454                        0 4F39 A   .455                        0 4F80 A   
.456                        0 4F66 A   .457                        0 4F59 A   
.458                        0 4F80 A   .459                        0 4F75 A   
.45A                        0 4FF6 A   .45B                        0 4F89 A   
.45C                        0 4FF6 A   .45D                        0 4F96 A   
.45E                        0 4FF6 A   .45F                        0 4FEB A   
.46                         0 09EE A   .460                        0 4F96 A   
.461                        0 4FC5 A   .462                        0 4FAB A   
.463                        0 4F9E A   .464                        0 4FC5 A   
.465                        0 4FBA A   .466                        0 4FEB A   
.467                        0 4FCC A   .468                        0 4FF6 A   
.469                        0 4FFF A   .46A                        0 5023 A   
.46B                        0 5015 A   .46C                        0 D371 A   
.46D                        0 5036 A   .46E                        0 5031 A   
.46F                        0 502A A   .47                         0 09FB A   
.470                        0 5048 A   .471                        0 5069 A   
.472                        0 505D A   .473                        0 507C A   
.474                        0 5077 A   .475                        0 5070 A   
.476                        0 5096 A   .477                        0 50BD A   
.478                        0 50C4 A   .479                        0 50C6 A   
.47A                        0 50D2 A   .47B                        0 50CD A   
.47C                        0 50D2 A   .47D                        0 D349 A   
.47E                        0 5121 A   .47F                        0 50FB A   
.48                         0 09F5 A   .480                        0 51B6 A   
.481                        0 5159 A   .482                        0 51AD A   
.483                        0 5191 A   .484                        0 51A7 A   
.485                        0 51A1 A   .486                        0 51BC A   
.487                        0 51C0 A   .488                        0 5206 A   
.489                        0 51F4 A   .48A                        0 D33E A   
.48B                        0 5225 A   .48C                        0 5216 A   
.48D                        0 5216 A   .48E                        0 5225 A   
.48F                        0 5258 A   .49                         0 0A4F A   
.490                        0 5246 A   .491                        0 D333 A   
.492                        0 52B3 A   .493                        0 52A1 A   
.494                        0 D329 A   .495                        0 52D2 A   
.496                        0 52C3 A   .497                        0 52C3 A   
.498                        0 52D2 A   .499                        0 52FF A   
.49A                        0 52ED A   .49B                        0 D31F A   
.49C                        0 5357 A   .49D                        0 5345 A   
.49E                        0 D315 A   .49F                        0 5391 A   
.4A                         0 0A41 A   .4A0                        0 5382 A   
.4A1                        0 5382 A   .4A2                        0 5391 A   
.4A3                        0 53D5 A   .4A4                        0 53C4 A   
.4A5                        0 D30A A   .4A6                        0 5425 A   
.4A7                        0 5413 A   .4A8                        0 D2F0 A   
.4A9                        0 594F A   .4AB                        0 58F8 A   
.4AC                        0 5442 A   .4AD                        0 5461 A   
.4AE                        0 5472 A   .4AF                        0 5483 A   
.4B                         0 0A48 A   .4B0                        0 5494 A   
.4B1                        0 54A5 A   .4B2                        0 54B6 A   
.4B3                        0 54F4 A   .4B4                        0 54BF A   
.4B5                        0 54E6 A   .4B6                        0 54D6 A   
.4B7                        0 54F4 A   .4B8                        0 54F7 A   
.4B9                        0 5535 A   .4BA                        0 5500 A   
.4BB                        0 5527 A   .4BC                        0 5517 A   
.4BD                        0 5535 A   .4BE                        0 5538 A   
.4BF                        0 555F A   .4C                         0 0A04 A   
.4C0                        0 554F A   .4C1                        0 556D A   
.4C2                        0 5570 A   .4C3                        0 5597 A   
.4C4                        0 5587 A   .4C5                        0 55A5 A   
.4C6                        0 55A8 A   .4C7                        0 55CD A   
.4C8                        0 55B1 A   .4C9                        0 55D0 A   
.4CA                        0 55E7 A   .4CB                        0 55D9 A   
.4CC                        0 55EA A   .4CD                        0 562E A   
.4CE                        0 5605 A   .4CF                        0 55F3 A   
.4D                         0 0A2B A   .4D0                        0 55FC A   
.4D1                        0 564A A   .4D2                        0 564D A   
.4D3                        0 566A A   .4D4                        0 5668 A   
.4D5                        0 5656 A   .4D6                        0 565F A   
.4D7                        0 5678 A   .4D8                        0 567B A   
.4D9                        0 5687 A   .4DA                        0 5684 A   
.4DB                        0 56A6 A   .4DC                        0 568E A   
.4DD                        0 D2B9 A   .4DE                        0 56C1 A   
.4DF                        0 56AD A   .4E                         0 0A23 A   
.4E0                        0 56C1 A   .4E1                        0 56B6 A   
.4E2                        0 5710 A   .4E3                        0 56D3 A   
.4E4                        0 58BD A   .4E5                        0 5756 A   
.4E6                        0 5719 A   .4E7                        0 58BD A   
.4E8                        0 5791 A   .4E9                        0 576D A   
.4EA                        0 575F A   .4EB                        0 5766 A   
.4EC                        0 58BD A   .4ED                        0 582E A   
.4EE                        0 579C A   .4EF                        0 57F1 A   
.4F                         0 0A37 A   .4F0                        0 57BB A   
.4F1                        0 582B A   .4F2                        0 58BD A   
.4F3                        0 5889 A   .4F4                        0 584D A   
.4F5                        0 58BD A   .4F6                        0 58E2 A   
.4F7                        0 58D4 A   .4F8                        0 58CD A   
.4F9                        0 D282 A   .4FA                        0 5960 A   
.4FB                        0 5958 A   .4FC                        0 59B8 A   
.4FD                        0 59B2 A   .4FE                        0 59CE A   
.4FF                        0 59C0 A   .5                          0 05CD A   
.50                         0 0A4F A   .500                        0 5A1A A   
.501                        0 5A16 A   .502                        0 5A3F A   
.503                        0 5A3B A   .504                        0 5ABE A   
.505                        0 5A64 A   .506                        0 5A8B A   
.507                        0 5A6B A   .508                        0 5AA3 A   
.509                        0 5ABC A   .50A                        0 5AB6 A   
.50B                        0 5AC5 A   .50C                        0 5B0C A   
.50D                        0 5B0E A   .50E                        0 5B22 A   
.50F                        0 5B1B A   .51                         0 0C1A A   
.510                        0 5D07 A   .511                        0 5B2C A   
.512                        0 5C37 A   .513                        0 5B5C A   
.514                        0 5C31 A   .515                        0 5C24 A   
.516                        0 5BD4 A   .517                        0 5C15 A   
.518                        0 5C17 A   .51A                        0 5C37 A   
.51B                        0 5C6E A   .51C                        0 5C3E A   
.51D                        0 5ECD A   .51E                        0 5D11 A   
.51F                        0 5DC3 A   .52                         0 0A6E A   
.520                        0 5DBF A   .521                        0 5DC5 A   
.522                        0 5E27 A   .523                        0 5DD8 A   
.524                        0 5DE3 A   .525                        0 5DDF A   
.526                        0 5DE5 A   .527                        0 5DFC A   
.528                        0 5DF8 A   .529                        0 5DFE A   
.52A                        0 5E17 A   .52B                        0 5E13 A   
.52C                        0 5E19 A   .52D                        0 5E3E A   
.52E                        0 5E2E A   .52F                        0 5EB9 A   
.53                         0 0A59 A   .530                        0 5EAB A   
.531                        0 5EB2 A   .532                        0 5E95 A   
.533                        0 5EB9 A   .534                        0 613F A   
.535                        0 5ED7 A   .536                        0 5F26 A   
.537                        0 5F22 A   .538                        0 5F28 A   
.539                        0 5F7B A   .53A                        0 5F51 A   
.53B                        0 5F7B A   .53C                        0 5FD5 A   
.53D                        0 5F82 A   .53E                        0 602E A   
.53F                        0 602E A   .54                         0 0C1A A   
.540                        0 5FDE A   .541                        0 605B A   
.542                        0 6035 A   .543                        0 605B A   
.544                        0 60B8 A   .545                        0 609A A   
.546                        0 60CB A   .547                        0 60BF A   
.548                        0 60D5 A   .549                        0 6112 A   
.54A                        0 60F9 A   .54B                        0 6100 A   
.54C                        0 60E1 A   .54D                        0 6112 A   
.54E                        0 610B A   .54F                        0 6107 A   
.55                         0 0B79 A   .550                        0 610D A   
.551                        0 6131 A   .552                        0 6124 A   
.553                        0 613C A   .554                        0 618A A   
.555                        0 616A A   .556                        0 6163 A   
.557                        0 D24B A   .558                        0 61C2 A   
.559                        0 61A2 A   .55A                        0 D20D A   
.55B                        0 68B1 A   .55D                        0 6836 A   
.55E                        0 61C8 A   .55F                        0 61DC A   
.56                         0 0A77 A   .560                        0 6213 A   
.561                        0 620B A   .562                        0 6219 A   
.563                        0 621C A   .564                        0 621C A   
.565                        0 621C A   .566                        0 628C A   
.567                        0 6272 A   .568                        0 626B A   
.569                        0 6264 A   .56A                        0 D1D5 A   
.56B                        0 6300 A   .56C                        0 62DD A   
.56D                        0 62D5 A   .56E                        0 62CD A   
.56F                        0 D18D A   .57                         0 0AE8 A   
.570                        0 630D A   .571                        0 6307 A   
.572                        0 63B5 A   .573                        0 6343 A   
.574                        0 633B A   .575                        0 63F2 A   
.576                        0 63BC A   .577                        0 6427 A   
.578                        0 6459 A   .579                        0 6434 A   
.57A                        0 D160 A   .57B                        0 6462 A   
.57C                        0 D146 A   .57D                        0 647D A   
.57E                        0 64FD A   .57F                        0 652B A   
.58                         0 0AA6 A   .580                        0 6523 A   
.581                        0 6536 A   .582                        0 6539 A   
.583                        0 65B8 A   .584                        0 65D2 A   
.585                        0 65D2 A   .586                        0 65D2 A   
.587                        0 65D2 A   .588                        0 6658 A   
.589                        0 663E A   .58A                        0 D115 A   
.58B                        0 66C2 A   .58C                        0 66A8 A   
.58D                        0 668C A   .58E                        0 D0E4 A   
.58F                        0 66D6 A   .59                         0 0AD0 A   
.590                        0 66D0 A   .591                        0 66C9 A   
.592                        0 6713 A   .593                        0 66DD A   
.594                        0 6748 A   .595                        0 678C A   
.596                        0 6767 A   .597                        0 D0B7 A   
.598                        0 6795 A   .599                        0 6795 A   
.59A                        0 679E A   .59B                        0 67AC A   
.59C                        0 67C8 A   .59D                        0 67C2 A   
.59E                        0 67D1 A   .59F                        0 67F8 A   
.5A                         0 0AB0 A   .5A1                        0 67E6 A   
.5A2                        0 67D6 A   .5A3                        0 67D6 A   
.5A4                        0 67D6 A   .5A5                        0 67D6 A   
.5A6                        0 67DE A   .5A7                        0 67FB A   
.5A8                        0 67FB A   .5A9                        0 67FB A   
.5AA                        0 67FB A   .5AB                        0 67FB A   
.5AC                        0 D078 A   .5AD                        0 6818 A   
.5AE                        0 6818 A   .5AF                        0 6818 A   
.5B                         0 0AE5 A   .5B0                        0 6818 A   
.5B1                        0 6818 A   .5B2                        0 D03E A   
.5B3                        0 687B A   .5B4                        0 6849 A   
.5B5                        0 68AE A   .5B6                        0 688E A   
.5B7                        0 693D A   .5B8                        0 691D A   
.5B9                        0 6916 A   .5BA                        0 D00A A   
.5BB                        0 6975 A   .5BC                        0 6955 A   
.5BD                        0 CFCF A   .5BE                        0 6DA6 A   
.5C                         0 0B76 A   .5C0                        0 6D2B A   
.5C1                        0 697B A   .5C2                        0 697B A   
.5C3                        0 697B A   .5C4                        0 697B A   
.5C5                        0 697B A   .5C6                        0 697B A   
.5C7                        0 697B A   .5C8                        0 697B A   
.5C9                        0 6984 A   .5CA                        0 6984 A   
.5CB                        0 6984 A   .5CC                        0 6992 A   
.5CD                        0 69C9 A   .5CE                        0 69C1 A   
.5CF                        0 69CF A   .5D                         0 0B06 A   
.5D0                        0 69D2 A   .5D1                        0 69E0 A   
.5D2                        0 69FA A   .5D3                        0 69FA A   
.5D4                        0 69FA A   .5D5                        0 6A7B A   
.5D6                        0 6A61 A   .5D7                        0 CF9D A   
.5D8                        0 6AA7 A   .5D9                        0 6AA1 A   
.5DA                        0 6A9A A   .5DB                        0 6B82 A   
.5DC                        0 6B5D A   .5DD                        0 CF72 A   
.5DE                        0 6B8B A   .5DF                        0 6B98 A   
.5E                         0 0AEF A   .5E0                        0 6B92 A   
.5E1                        0 6C54 A   .5E3                        0 6C46 A   
.5E4                        0 6BB1 A   .5E5                        0 6BC8 A   
.5E6                        0 6BB8 A   .5E7                        0 6BEC A   
.5E8                        0 6C03 A   .5E9                        0 6BF3 A   
.5EA                        0 6C2B A   .5EB                        0 6C27 A   
.5EC                        0 6C2D A   .5ED                        0 6C32 A   
.5EE                        0 6C3D A   .5EF                        0 6C39 A   
.5F                         0 0B76 A   .5F0                        0 6C3F A   
.5F1                        0 6C5D A   .5F2                        0 6C82 A   
.5F3                        0 6C77 A   .5F4                        0 6CA7 A   
.5F5                        0 6C9C A   .5F6                        0 6CB0 A   
.5F7                        0 6CCC A   .5F8                        0 6CC6 A   
.5F9                        0 6CD5 A   .5FA                        0 6CE3 A   
.5FB                        0 6D0A A   .5FD                        0 6CF8 A   
.5FE                        0 6CE8 A   .5FF                        0 6CE8 A   
.6                          0 05C7 A   .60                         0 0B76 A   
.600                        0 6CE8 A   .601                        0 6CE8 A   
.602                        0 6CF0 A   .603                        0 6D0D A   
.604                        0 6D0D A   .605                        0 6D0D A   
.606                        0 6D0D A   .607                        0 6D0D A   
.608                        0 6D0D A   .609                        0 6D0D A   
.60A                        0 6D0D A   .60B                        0 CF50 A   
.60C                        0 6D70 A   .60D                        0 6D3E A   
.60E                        0 6DA3 A   .60F                        0 6D83 A   
.61                         0 0B0F A   .610                        0 6FA9 A   
.612                        0 6F8F A   .613                        0 6DFE A   
.614                        0 6DFE A   .615                        0 6DFE A   
.616                        0 CF1F A   .617                        0 6E18 A   
.618                        0 6F6B A   .619                        0 6F5B A   
.61A                        0 6F72 A   .61B                        0 CEFA A   
.61C                        0 7050 A   .61D                        0 7030 A   
.61E                        0 7027 A   .61F                        0 CEBB A   
.62                         0 0B1C A   .620                        0 741A A   
.622                        0 739F A   .623                        0 7056 A   
.624                        0 7056 A   .625                        0 7056 A   
.626                        0 7056 A   .627                        0 7056 A   
.628                        0 7056 A   .629                        0 7056 A   
.62A                        0 7056 A   .62B                        0 705F A   
.62C                        0 705F A   .62D                        0 706D A   
.62E                        0 70A4 A   .62F                        0 709C A   
.63                         0 0B16 A   .630                        0 70AA A   
.631                        0 70AD A   .632                        0 70AD A   
.633                        0 7110 A   .634                        0 710A A   
.635                        0 712E A   .636                        0 7128 A   
.637                        0 7120 A   .638                        0 7118 A   
.639                        0 713B A   .63A                        0 7135 A   
.63B                        0 72E6 A   .63C                        0 72BC A   
.63D                        0 CE91 A   .63E                        0 72EF A   
.63F                        0 735D A   .64                         0 0B76 A   
.641                        0 7351 A   .642                        0 733A A   
.643                        0 7341 A   .644                        0 7348 A   
.645                        0 7373 A   .646                        0 7381 A   
.647                        0 7381 A   .648                        0 7381 A   
.649                        0 7381 A   .64A                        0 7381 A   
.64B                        0 7381 A   .64C                        0 7381 A   
.64D                        0 7381 A   .64E                        0 7381 A   
.64F                        0 7381 A   .65                         0 0B68 A   
.650                        0 7381 A   .651                        0 7381 A   
.652                        0 7381 A   .653                        0 7381 A   
.654                        0 7381 A   .655                        0 CE59 A   
.656                        0 73E4 A   .657                        0 73B2 A   
.658                        0 7417 A   .659                        0 73F7 A   
.65A                        0 74AB A   .65B                        0 74A2 A   
.65C                        0 7496 A   .65D                        0 74AB A   
.65E                        0 74E5 A   .65F                        0 74DE A   
.66                         0 0B6F A   .660                        0 74EA A   
.661                        0 7525 A   .662                        0 751C A   
.663                        0 7510 A   .664                        0 7525 A   
.665                        0 754B A   .666                        0 752C A   
.667                        0 753C A   .668                        0 7533 A   
.669                        0 752D A   .66A                        0 753C A   
.66B                        0 756C A   .66C                        0 7562 A   
.66D                        0 7581 A   .66E                        0 757B A   
.66F                        0 7595 A   .67                         0 0B25 A   
.670                        0 758E A   .671                        0 75B8 A   
.672                        0 75B2 A   .673                        0 75D7 A   
.674                        0 75D1 A   .675                        0 75F8 A   
.676                        0 75EA A   .677                        0 7600 A   
.678                        0 7685 A   .67A                        0 7660 A   
.67B                        0 7605 A   .67C                        0 7605 A   
.67D                        0 7617 A   .67E                        0 7617 A   
.67F                        0 7629 A   .68                         0 0B52 A   
.680                        0 763B A   .681                        0 763B A   
.682                        0 763B A   .683                        0 764D A   
.684                        0 7683 A   .685                        0 7673 A   
.686                        0 7694 A   .687                        0 768C A   
.688                        0 769A A   .689                        0 76E8 A   
.68A                        0 76E1 A   .68B                        0 76D9 A   
.68C                        0 76E8 A   .68D                        0 7713 A   
.68E                        0 7703 A   .68F                        0 7721 A   
.69                         0 0B4A A   .690                        0 775B A   
.691                        0 774D A   .692                        0 7763 A   
.693                        0 7772 A   .694                        0 776A A   
.695                        0 7779 A   .696                        0 8628 A   
.698                        0 85E9 A   .699                        0 778F A   
.69A                        0 77B6 A   .69B                        0 779C A   
.69C                        0 77D7 A   .69D                        0 77C9 A   
.69E                        0 77DF A   .69F                        0 7800 A   
.6A                         0 0B5E A   .6A0                        0 77E6 A   
.6A1                        0 7828 A   .6A2                        0 784B A   
.6A3                        0 7843 A   .6A4                        0 784F A   
.6A5                        0 784F A   .6A6                        0 784F A   
.6A7                        0 78BD A   .6A8                        0 7890 A   
.6A9                        0 7889 A   .6AA                        0 7882 A   
.6AB                        0 787B A   .6AC                        0 7874 A   
.6AD                        0 CE1E A   .6AE                        0 78EB A   
.6AF                        0 78CC A   .6B                         0 0B76 A   
.6B0                        0 7928 A   .6B1                        0 78FA A   
.6B2                        0 7928 A   .6B3                        0 7909 A   
.6B4                        0 7935 A   .6B5                        0 792F A   
.6B6                        0 7965 A   .6B7                        0 795E A   
.6B8                        0 79A3 A   .6B9                        0 7984 A   
.6BA                        0 7A68 A   .6BB                        0 7A0C A   
.6BC                        0 7AB4 A   .6BD                        0 7B7A A   
.6BE                        0 7B73 A   .6BF                        0 7B3C A   
.6C                         0 0C1A A   .6C0                        0 7B6B A   
.6C1                        0 7B49 A   .6C2                        0 7B7A A   
.6C3                        0 7BB7 A   .6C4                        0 7BA9 A   
.6C5                        0 CDFE A   .6C6                        0 7C81 A   
.6C7                        0 7C2E A   .6C8                        0 7C56 A   
.6C9                        0 7C35 A   .6CA                        0 7C81 A   
.6CB                        0 7C73 A   .6CC                        0 7C5F A   
.6CD                        0 7C81 A   .6CE                        0 CDD8 A   
.6CF                        0 7CA3 A   .6D                         0 0BB8 A   
.6D0                        0 7CF4 A   .6D1                        0 7CDE A   
.6D2                        0 7CD7 A   .6D3                        0 7CD0 A   
.6D4                        0 7CC9 A   .6D5                        0 7CC2 A   
.6D6                        0 7D1D A   .6D7                        0 7D03 A   
.6D8                        0 7D5A A   .6D9                        0 7D2C A   
.6DA                        0 7D5A A   .6DB                        0 7D3B A   
.6DC                        0 7D8A A   .6DD                        0 7D83 A   
.6DE                        0 7DC7 A   .6DF                        0 7DA8 A   
.6E                         0 0B80 A   .6E0                        0 7EFF A   
.6E1                        0 7EF8 A   .6E2                        0 7EC6 A   
.6E3                        0 7EF0 A   .6E4                        0 7ED3 A   
.6E5                        0 7EFF A   .6E6                        0 7F3C A   
.6E7                        0 7F2E A   .6E8                        0 CDB8 A   
.6E9                        0 7FDE A   .6EA                        0 7FB3 A   
.6EB                        0 7FD0 A   .6EC                        0 7FBC A   
.6ED                        0 7FDE A   .6EE                        0 CD92 A   
.6EF                        0 8006 A   .6F                         0 0BA4 A   
.6F0                        0 8043 A   .6F1                        0 8013 A   
.6F2                        0 8064 A   .6F3                        0 805D A   
.6F4                        0 8074 A   .6F5                        0 806D A   
.6F6                        0 8089 A   .6F7                        0 807B A   
.6F8                        0 8091 A   .6F9                        0 8160 A   
.6FB                        0 8139 A   .6FC                        0 80B2 A   
.6FD                        0 80BF A   .6FE                        0 80CD A   
.6FF                        0 80DB A   .7                          0 05D8 A   
.70                         0 0B8A A   .700                        0 80E8 A   
.701                        0 80F5 A   .702                        0 8102 A   
.703                        0 810F A   .704                        0 811C A   
.705                        0 8129 A   .706                        0 CD72 A   
.707                        0 815E A   .708                        0 814C A   
.709                        0 8179 A   .70A                        0 8197 A   
.70B                        0 8186 A   .70C                        0 81B8 A   
.70D                        0 81AA A   .70E                        0 81C0 A   
.70F                        0 81D6 A   .71                         0 0BB6 A   
.710                        0 81CF A   .711                        0 81DB A   
.712                        0 81DF A   .713                        0 8206 A   
.714                        0 81EC A   .715                        0 8220 A   
.716                        0 824D A   .717                        0 8233 A   
.718                        0 8276 A   .719                        0 825C A   
.71A                        0 8281 A   .71B                        0 827D A   
.71C                        0 8283 A   .71D                        0 8319 A   
.71F                        0 8307 A   .72                         0 0C1A A   
.720                        0 829D A   .721                        0 82A7 A   
.722                        0 82B1 A   .723                        0 82BB A   
.724                        0 82E1 A   .725                        0 82D7 A   
.726                        0 82CA A   .727                        0 82E9 A   
.728                        0 82EB A   .729                        0 833A A   
.72A                        0 8385 A   .72B                        0 836B A   
.72C                        0 83AE A   .72D                        0 8394 A   
.72E                        0 83E6 A   .72F                        0 83BD A   
.73                         0 0BD1 A   .730                        0 83E6 A   
.731                        0 83CC A   .732                        0 8407 A   
.733                        0 83F9 A   .734                        0 840F A   
.735                        0 841A A   .736                        0 8416 A   
.737                        0 841C A   .738                        0 8572 A   
.73A                        0 854B A   .73B                        0 843C A   
.73C                        0 843F A   .73D                        0 843F A   
.73E                        0 843F A   .73F                        0 843F A   
.74                         0 0BBF A   .740                        0 8462 A   
.741                        0 8455 A   .742                        0 8447 A   
.743                        0 844E A   .744                        0 8465 A   
.745                        0 848A A   .746                        0 847B A   
.747                        0 846D A   .748                        0 8474 A   
.749                        0 84A6 A   .74A                        0 84A6 A   
.74B                        0 8499 A   .74C                        0 8492 A   
.74D                        0 84A9 A   .74E                        0 84C5 A   
.74F                        0 84B8 A   .75                         0 0C1A A   
.750                        0 84B1 A   .751                        0 84C8 A   
.752                        0 84FA A   .753                        0 84D0 A   
.754                        0 84E6 A   .755                        0 84D7 A   
.756                        0 84FA A   .757                        0 84FA A   
.758                        0 84ED A   .759                        0 84FD A   
.75A                        0 8545 A   .75B                        0 8505 A   
.75C                        0 851B A   .75D                        0 850C A   
.75E                        0 8545 A   .75F                        0 8531 A   
.76                         0 0BF7 A   .760                        0 8522 A   
.761                        0 8545 A   .762                        0 8545 A   
.763                        0 8538 A   .764                        0 8547 A   
.765                        0 8570 A   .766                        0 855E A   
.767                        0 8590 A   .768                        0 8579 A   
.769                        0 85B9 A   .76A                        0 CD4D A   
.76B                        0 860E A   .76C                        0 85FC A   
.76D                        0 865B A   .76E                        0 864E A   
.76F                        0 CD26 A   .77                         0 0BD8 A   
.770                        0 8793 A   .771                        0 86A7 A   
.772                        0 869E A   .773                        0 8694 A   
.774                        0 8727 A   .775                        0 86C1 A   
.776                        0 8727 A   .777                        0 8710 A   
.778                        0 8709 A   .779                        0 8727 A   
.77A                        0 8720 A   .77B                        0 8765 A   
.77C                        0 872E A   .77D                        0 8789 A   
.77E                        0 8781 A   .77F                        0 879B A   
.78                         0 0C1A A   .780                        0 8834 A   
.781                        0 8808 A   .782                        0 8849 A   
.783                        0 8849 A   .784                        0 883B A   
.785                        0 CD11 A   .786                        0 8876 A   
.787                        0 8861 A   .788                        0 CCF5 A   
.789                        0 89A5 A   .78B                        0 898B A   
.78C                        0 8885 A   .78D                        0 8885 A   
.78E                        0 8891 A   .78F                        0 888D A   
.79                         0 0C0C A   .790                        0 8893 A   
.791                        0 88E3 A   .792                        0 88D2 A   
.793                        0 891C A   .794                        0 88FA A   
.795                        0 88EB A   .796                        0 891C A   
.797                        0 890C A   .798                        0 8934 A   
.799                        0 895A A   .79A                        0 8941 A   
.79B                        0 8977 A   .79C                        0 8985 A   
.79D                        0 CCE1 A   .79E                        0 8D80 A   
.7A                         0 0BFE A   .7A0                        0 8D55 A   
.7A1                        0 89E7 A   .7A2                        0 8A0B A   
.7A3                        0 8A2E A   .7A4                        0 8A40 A   
.7A5                        0 8A35 A   .7A6                        0 8A87 A   
.7A7                        0 8A91 A   .7A8                        0 8A8E A   
.7A9                        0 8B01 A   .7AA                        0 8B18 A   
.7AB                        0 8B0D A   .7AC                        0 8B59 A   
.7AD                        0 8B6E A   .7AE                        0 8B60 A   
.7AF                        0 8BE2 A   .7B                         0 0C1A A   
.7B0                        0 8C07 A   .7B1                        0 8BFC A   
.7B2                        0 8C11 A   .7B3                        0 8C0E A   
.7B4                        0 8C78 A   .7B5                        0 8CAC A   
.7B6                        0 8CC3 A   .7B7                        0 8CB3 A   
.7B8                        0 CCC6 A   .7B9                        0 8D3B A   
.7BA                        0 8CE0 A   .7BB                        0 8CCA A   
.7BC                        0 CCA0 A   .7BD                        0 8D3B A   
.7BE                        0 8CFA A   .7BF                        0 8CE7 A   
.7C                         0 D9E5 A   .7C0                        0 CC88 A   
.7C1                        0 8D3B A   .7C2                        0 8D3B A   
.7C3                        0 8D01 A   .7C4                        0 8D21 A   
.7C5                        0 8D08 A   .7C6                        0 CC5C A   
.7C7                        0 8D3B A   .7C8                        0 CC20 A   
.7C9                        0 8D4B A   .7CA                        0 8D78 A   
.7CB                        0 8D68 A   .7CC                        0 8E68 A   
.7CD                        0 8DB6 A   .7CE                        0 8DC3 A   
.7CF                        0 8DBF A   .7D                         0 0C30 A   
.7D0                        0 8E68 A   .7D1                        0 8DCE A   
.7D2                        0 8E68 A   .7D3                        0 8DD7 A   
.7D4                        0 8E3C A   .7D5                        0 8DF4 A   
.7D6                        0 8E65 A   .7D7                        0 CC20 A   
.7D8                        0 CC5C A   .7D9                        0 CC88 A   
.7DA                        0 CCA0 A   .7DB                        0 CCC6 A   
.7DC                        0 CCE1 A   .7DD                        0 CCF5 A   
.7DE                        0 CD11 A   .7DF                        0 CD26 A   
.7E                         0 0C45 A   .7E0                        0 CD4D A   
.7E1                        0 CD72 A   .7E2                        0 CD92 A   
.7E3                        0 CDB8 A   .7E4                        0 CDD8 A   
.7E5                        0 CDFE A   .7E6                        0 CE1E A   
.7E7                        0 CE59 A   .7E8                        0 CE91 A   
.7E9                        0 CEBB A   .7EA                        0 CEFA A   
.7EB                        0 CF1F A   .7EC                        0 CF50 A   
.7ED                        0 CF72 A   .7EE                        0 CF9D A   
.7EF                        0 CFCF A   .7F                         0 0C52 A   
.7F0                        0 D00A A   .7F1                        0 D03E A   
.7F2                        0 D078 A   .7F3                        0 D0B7 A   
.7F4                        0 D0E4 A   .7F5                        0 D115 A   
.7F6                        0 D146 A   .7F7                        0 D160 A   
.7F8                        0 D18D A   .7F9                        0 D1D5 A   
.7FA                        0 D20D A   .7FB                        0 D24B A   
.7FC                        0 D282 A   .7FD                        0 D2B9 A   
.7FE                        0 D2F0 A   .7FF                        0 D30A A   
.8                          0 06A1 A   .80                         0 0C4E A   
.800                        0 D315 A   .801                        0 D31F A   
.802                        0 D329 A   .803                        0 D333 A   
.804                        0 D33E A   .805                        0 D349 A   
.806                        0 D371 A   .807                        0 D395 A   
.808                        0 D3B9 A   .809                        0 D3F3 A   
.80A                        0 D42D A   .80B                        0 D447 A   
.80C                        0 D473 A   .80D                        0 D49F A   
.80E                        0 D4CB A   .80F                        0 D4F6 A   
.81                         0 0C92 A   .810                        0 D530 A   
.811                        0 D547 A   .812                        0 D576 A   
.813                        0 D5B6 A   .814                        0 D5D0 A   
.815                        0 D5E6 A   .816                        0 D602 A   
.817                        0 D62A A   .818                        0 D650 A   
.819                        0 D67C A   .81A                        0 D67E A   
.81B                        0 D685 A   .81C                        0 D68C A   
.81D                        0 D6A6 A   .81E                        0 D6B8 A   
.81F                        0 D6D2 A   .82                         0 0C78 A   
.820                        0 D6D5 A   .821                        0 D6DC A   
.822                        0 D6E3 A   .823                        0 D6EE A   
.824                        0 D70E A   .825                        0 D72E A   
.826                        0 D731 A   .827                        0 D738 A   
.828                        0 D73F A   .829                        0 D74A A   
.82A                        0 D775 A   .82B                        0 D785 A   
.82C                        0 D78C A   .82D                        0 D792 A   
.82E                        0 D796 A   .82F                        0 D79B A   
.83                         0 0C6B A   .830                        0 D7C0 A   
.831                        0 D7E9 A   .832                        0 D7F7 A   
.833                        0 D810 A   .834                        0 D82B A   
.835                        0 D82F A   .836                        0 D844 A   
.837                        0 D858 A   .838                        0 D878 A   
.839                        0 D87B A   .83A                        0 D89A A   
.83B                        0 D8B0 A   .83C                        0 D8BC A   
.83D                        0 D8CC A   .83E                        0 D8D1 A   
.83F                        0 D8D7 A   .84                         0 0C92 A   
.840                        0 D8E7 A   .841                        0 D8F7 A   
.842                        0 D8F9 A   .843                        0 D8FB A   
.844                        0 D901 A   .845                        0 D904 A   
.846                        0 D908 A   .847                        0 D90D A   
.848                        0 D923 A   .849                        0 D93E A   
.84A                        0 D962 A   .84B                        0 D96B A   
.84C                        0 D993 A   .84D                        0 D9AD A   
.84E                        0 D9D2 A   .84F                        0 D9E5 A   
.85                         0 0C87 A   .850                        0 DA02 A   
.86                         0 0CD0 A   .87                         0 0CC5 A   
.88                         0 0C9A A   .89                         0 0CC5 A   
.8A                         0 0CB6 A   .8B                         0 0CD0 A   
.8C                         0 0D0D A   .8D                         0 0CF3 A   
.8E                         0 0CE6 A   .8F                         0 0D0D A   
.9                          0 0692 A   .90                         0 0D02 A   
.91                         0 0D1C A   .92                         0 0D14 A   
.93                         0 0D4C A   .94                         0 0D32 A   
.95                         0 0D24 A   .96                         0 0D4C A   
.97                         0 0D41 A   .98                         0 0D5C A   
.99                         0 0D53 A   .9A                         0 0D72 A   
.9B                         0 0D69 A   .9C                         0 0DB0 A   
.9D                         0 0D96 A   .9E                         0 0D88 A   
.9F                         0 0DB0 A   .A                          0 06B9 A   
.A0                         0 0DA5 A   .A1                         0 0DC0 A   
.A2                         0 0DB7 A   .A3                         0 0DF0 A   
.A4                         0 0DD6 A   .A5                         0 0DC8 A   
.A6                         0 0DF0 A   .A7                         0 0DE5 A   
.A8                         0 0E00 A   .A9                         0 0DF7 A   
.AA                         0 0E16 A   .AB                         0 0E0D A   
.AC                         0 0E54 A   .AD                         0 0E3A A   
.AE                         0 0E2C A   .AF                         0 0E54 A   
.B                          0 06AA A   .B0                         0 0E49 A   
.B1                         0 0E64 A   .B2                         0 0E5B A   
.B3                         0 0EA2 A   .B4                         0 0E88 A   
.B5                         0 0E7A A   .B6                         0 0EA2 A   
.B7                         0 0E97 A   .B8                         0 0EB2 A   
.B9                         0 0EA9 A   .BA                         0 0EF0 A   
.BB                         0 0ED6 A   .BC                         0 0EC8 A   
.BD                         0 0EF0 A   .BE                         0 0EE5 A   
.BF                         0 0F00 A   .C                          0 06DD A   
.C0                         0 0EF7 A   .C1                         0 0F30 A   
.C2                         0 0F16 A   .C3                         0 0F08 A   
.C4                         0 0F30 A   .C5                         0 0F25 A   
.C6                         0 0F40 A   .C7                         0 0F37 A   
.C8                         0 0F56 A   .C9                         0 0F4D A   
.CA                         0 0F86 A   .CB                         0 0F6C A   
.CC                         0 0F5E A   .CD                         0 0F86 A   
.CE                         0 0F7B A   .CF                         0 0F96 A   
.D                          0 06C2 A   .D0                         0 0F8D A   
.D1                         0 0FAC A   .D2                         0 0FA3 A   
.D3                         0 0FEA A   .D4                         0 0FD0 A   
.D5                         0 0FC2 A   .D6                         0 0FEA A   
.D7                         0 0FDF A   .D8                         0 0FFA A   
.D9                         0 0FF1 A   .DA                         0 102A A   
.DB                         0 1010 A   .DC                         0 1002 A   
.DD                         0 102A A   .DE                         0 101F A   
.DF                         0 103A A   .E                          0 06D2 A   
.E0                         0 1031 A   .E1                         0 1050 A   
.E2                         0 1047 A   .E3                         0 108E A   
.E4                         0 1074 A   .E5                         0 1066 A   
.E6                         0 108E A   .E7                         0 1083 A   
.E8                         0 109E A   .E9                         0 1095 A   
.EA                         0 10DC A   .EB                         0 10C2 A   
.EC                         0 10B4 A   .ED                         0 10DC A   
.EE                         0 10D1 A   .EF                         0 10EC A   
.F                          0 06C9 A   .F0                         0 10E3 A   
.F1                         0 112A A   .F2                         0 1110 A   
.F3                         0 1102 A   .F4                         0 112A A   
.F5                         0 111F A   .F6                         0 113A A   
.F7                         0 1131 A   .F8                         0 116A A   
.F9                         0 1150 A   .FA                         0 1142 A   
.FB                         0 116A A   .FC                         0 115F A   
.FD                         0 117A A   .FE                         0 1171 A   
.FF                         0 1190 A   .FFDA                       0 7C81 A   
.FFDD                       0 7444 A   .FFDE                       0 7433 A   
.FFDF                       0 741F A   .FFE0                       0 743F A   
.FFE2                       0 741A A   .FFE3                       0 6FCE A   
.FFE4                       0 6FA9 A   .FFE6                       0 6DD0 A   
.FFE7                       0 6DBF A   .FFE8                       0 6DAB A   
.FFE9                       0 6DCB A   .FFEB                       0 6DA6 A   
.FFEC                       0 68B6 A   .FFED                       0 68DB A   
.FFEE                       0 68CA A   .FFEF                       0 68D6 A   
.FFF1                       0 68B1 A   .FFF4                       0 4D4A A   
.FFFA                       0 33AB A   BcdToBin                    0 929E A   
__memcpyb                   0 001B A E __memcpyd                   0 0038 A E 
__memsetb                   0 0000 A E __read_byte                 0 05DF A E 
__read_dword                0 0056 A E __read_word                 0 05ED A E 
__write_byte                0 05FB A E __write_byte_SS             0 0637 A E 
__write_dword               0 0067 A E __write_word                0 060E A E 
__write_word_SS             0 0647 A E _apm16_entry                0 942B A   
_apm32_entry                0 9346 A   _apmreal_entry              0 94F6 A   
_ata_cmd_data_io            0 2981 A E _ata_cmd_non_data           0 297A A E 
_ata_cmd_packet             0 2D46 A E _ata_detect                 0 1B8A A E 
_ata_init                   0 1848 A E _ata_reset                  0 285A A E 
_atapi_get_sense            0 31F0 A E _atapi_is_cdrom             0 34D8 A E 
_atapi_is_ready             0 3275 A E _await_ide                  0 1A2A A   
_bios_printf                0 0939 A E _bios_svn_version_string    0 0165 A   
_cdemu_emulated_drive       0 357A A E _cdemu_init                 0 353F A E 
_cdemu_isactive             0 355E A E _cdrom_boot                 0 35B4 A E 
_check_for_keystroke        0 08F2 A E _debugger_off               0 1796 A E 
_debugger_on                0 1784 A E _delay_ticks                0 084D A E 
_delay_ticks_and_check_for+ 0 0908 A E _dequeue_key                0 5133 A E 
_determine_floppy_media     0 8675 A E _drivetypes                 0 1208 A   
_eltorito                   0 359C A   _enable_mouse_int_and_even+ 0 528D A E 
_enqueue_key                0 5972 A E _floppy_drive_exists        0 7735 A E 
_floppy_drive_recal         0 76AF A E _floppy_media_known         0 754F A E 
_floppy_media_sense         0 75BF A E _floppy_prepare_controller  0 74AF A E 
_floppy_reset_controller    0 7461 A E _get_CS                     0 0657 A E 
_get_SS                     0 065A A E _get_boot_vector            0 1369 A   
_get_ebda_seg               0 0667 A E _get_keystroke              0 0900 A E 
_get_mouse_data             0 537B A E _inb                        0 0529 A E 
_inb_cmos                   0 056E A E _inhibit_mouse_int_and_eve+ 0 51E0 A E 
_init_boot_vectors          0 123A A   _init_rtc                   0 057A A E 
_int09_function             0 5400 A E _int13_cdemu                0 6FF0 A E 
_int13_cdrom                0 68F8 A E _int13_diskette_function    0 777D A E 
_int13_edd                  0 5ACF A E _int13_eltorito             0 6DED A E 
_int13_harddisk             0 6145 A E _int14_function             0 3A93 A E 
_int15_function             0 3CC0 A E _int15_function32           0 48CC A E 
_int15_function_mouse       0 41A4 A E _int16_function             0 4D81 A E 
_int17_function             0 8676 A E _int18_panic_msg            0 1709 A E 
_int19_function             0 879F A E _int1a_function             0 89DB A E 
_int70_function             0 8D84 A E _int74_function             0 59F6 A E 
_interactive_bootkey        0 13B6 A E _inw                        0 0534 A E 
_isotag                     0 3596 A   _keyboard_init              0 0C5E A E 
_keyboard_panic             0 11A2 A E _log_bios_start             0 171B A E 
_nmi_handler_msg            0 16F7 A E _outb                       0 053F A E 
_outb_cmos                  0 055F A E _outw                       0 054F A E 
_panic_msg_keyb_buffer_ful+ 0 51C0 A   _print_bios_banner          0 11E1 A E 
_print_boot_device          0 15B2 A E _print_boot_failure         0 167C A E 
_print_cdromboot_failure    0 16E2 A E _put_luint                  0 0762 A E 
_put_str                    0 0819 A E _put_uint                   0 06DF A E 
_read_byte_SS               0 0621 A E _read_dword_SS              0 007E A E 
_read_word_SS               0 062C A E _rtc_updating               0 05AB A E 
_s3_resume                  0 17A7 A E _s3_resume_panic            0 11CF A E 
_scan_to_scanascii          0 01AF A   _send                       0 0686 A E 
_send_to_mouse_ctrl         0 5331 A E _set_DS                     0 065D A E 
_set_diskette_current_cyl   0 8644 A E _set_diskette_ret_status    0 862C A E 
_set_e820_range             0 482E A E _set_enable_a20             0 1731 A E 
_set_kbd_command_byte       0 53B2 A E _shutdown_status_panic      0 11B7 A E 
_vgafont8                   0 FA6E A   _wrch                       0 0676 A E 
apm16_04                    0 942C A   apm16_05                    0 9433 A   
apm16_07                    0 943C A   apm16_07_1                  0 9460 A   
apm16_07_poweroff           0 9456 A   apm16_07_poweroff_str       0 9412 A   
apm16_07_standby            0 9472 A   apm16_07_standby_str        0 9423 A   
apm16_07_suspend            0 9463 A   apm16_07_suspend_str        0 941B A   
apm16_08                    0 9481 A   apm16_0a                    0 9487 A   
apm16_0b                    0 949B A   apm16_0e                    0 94A3 A   
apm16_0f                    0 94AD A   apm16_10                    0 94B3 A   
apm16_error                 0 94C1 A   apm16_ok                    0 94BE A   
apm16_out_str               0 93FA A   apm16_out_str1              0 9401 A   
apm16_out_str2              0 940D A   apm16_unimplemented         0 94C1 A   
apm32_04                    0 9348 A   apm32_05                    0 9351 A   
apm32_07                    0 935C A   apm32_07_1                  0 938D A   
apm32_07_poweroff           0 937F A   apm32_07_poweroff_str       0 932D A   
apm32_07_standby            0 93A1 A   apm32_07_standby_str        0 933E A   
apm32_07_suspend            0 9390 A   apm32_07_suspend_str        0 9336 A   
apm32_08                    0 93B2 A   apm32_0a                    0 93B8 A   
apm32_0b                    0 93CE A   apm32_0e                    0 93D6 A   
apm32_0f                    0 93E0 A   apm32_10                    0 93E6 A   
apm32_error                 0 93F6 A   apm32_ok                    0 93F2 A   
apm32_out_str               0 931A A   apm32_out_str1              0 931E A   
apm32_out_str2              0 932A A   apm32_unimplemented         0 93F6 A   
apm_call                    0 F894 A   apmreal_00                  0 94F6 A   
apmreal_01                  0 9508 A   apmreal_02                  0 950F A   
apmreal_03                  0 9525 A   apmreal_04                  0 9544 A   
apmreal_05                  0 954B A   apmreal_07                  0 9554 A   
apmreal_07_1                0 9578 A   apmreal_07_poweroff         0 956E A   
apmreal_07_poweroff_str     0 94DC A   apmreal_07_standby          0 958A A   
apmreal_07_standby_str      0 94ED A   apmreal_07_suspend          0 957B A   
apmreal_07_suspend_str      0 94E5 A   apmreal_08                  0 9599 A   
apmreal_0a                  0 959F A   apmreal_0b                  0 95B3 A   
apmreal_0e                  0 95BB A   apmreal_0f                  0 95C5 A   
apmreal_10                  0 95CB A   apmreal_error               0 95DB A   
apmreal_ok                  0 95D6 A   apmreal_out_str             0 94C4 A   
apmreal_out_str1            0 94CB A   apmreal_out_str2            0 94D7 A   
apmreal_unimplemented       0 95DB A   ata_in_16                   0 2C46 A   
ata_in_32                   0 2C4A A   ata_in_adjust               0 2C32 A   
ata_in_done                 0 2C4D A   ata_in_no_adjust            0 2C39 A   
ata_out_16                  0 2C7C A   ata_out_32                  0 2C81 A   
ata_out_adjust              0 2C68 A   ata_out_done                0 2C85 A   
ata_out_no_adjust           0 2C6F A   ata_packet_after            0 317B A   
ata_packet_done             0 3195 A   ata_packet_in_16            0 3174 A   
ata_packet_in_32            0 3178 A   ata_packet_in_after_16      0 3188 A   
ata_packet_in_after_32      0 318D A   ata_packet_in_after_32_loo+ 0 318F A   
ata_packet_in_before_16     0 3152 A   ata_packet_in_before_32     0 3157 A   
ata_packet_in_before_32_lo+ 0 3159 A   ata_packet_no_before        0 315F A   
bios32_end                  0 9638 A   bios32_entry_point          0 95F0 A   
bios32_structure            0 95E0 A   bios_table_area_end         0 CC00 A   
bios_table_area_start       0 9E50 A   block_count_rounded         0 9CDD A   
carry_set                   0 8EA3 A   check_for_hd1               0 9136 A   
checksum_loop               0 9C2E A   checksum_out                0 9C48 A   
detect_parport              0 9BD3 A   detect_serial               0 9BF2 A   
diskette_param_table        0 EFC7 A   diskette_param_table2       0 EFDE A   
done                        0 08FF A   dummy_iret_handler          0 FF53 A   
dummy_master_pic_irq_handl+ 0 E9E6 A   dummy_slave_pic_irq_handle+ 0 E9EC A   
ebda_post                   0 9220 A   enable_iomem_space          0 9AD1 A   
eoi_both_pics               0 9295 A   eoi_jmp_post                0 9235 A   
eoi_master_pic              0 9299 A   f0_missing                  0 8FB4 A   
f1_missing                  0 8FBF A   floppy_drive_post           0 8F79 A   
halt2_loop                  0 0C4F A   hard_drive_post             0 9000 A   
hd0_post_above_2048         0 90F8 A   hd0_post_above_4096         0 9106 A   
hd0_post_above_8192         0 9114 A   hd0_post_checksum_loop      0 9129 A   
hd0_post_logical_chs        0 90D7 A   hd0_post_physical_chs       0 90C9 A   
hd0_post_store_logical      0 911A A   hd1_post_above_2048         0 91E1 A   
hd1_post_above_4096         0 91EF A   hd1_post_above_8192         0 91FD A   
hd1_post_checksum_loop      0 9212 A   hd1_post_logical_chs        0 91C0 A   
hd1_post_physical_chs       0 91B3 A   hd1_post_store_logical      0 9203 A   
idiv_                       0 0136 A   idiv_u                      0 013A A   
init_io_base                0 9AA4 A   initial_int_vector_offset_+ 0 FEF3 A   
int08_floppy_off            0 FEC4 A   int08_handler               0 FEA5 A   
int08_store_ticks           0 FED9 A   int09_check_pause           0 E9BB A   
int09_done                  0 E9CC A   int09_finish                0 E9D7 A   
int09_handler               0 E987 A   int09_process_key           0 E9C9 A   
int0e_handler               0 EF57 A   int0e_loop1                 0 EF69 A   
int0e_loop2                 0 EF73 A   int0e_normal                0 EF81 A   
int10_handler               0 F065 A   int11_handler               0 F84D A   
int12_handler               0 F841 A   int13_cdemu_inactive        0 8EFB A   
int13_cdrom_rme_end         0 6C94 A   int13_disk                  0 8F30 A   
int13_diskette              0 EC59 A   int13_handler               0 E3FE A   
int13_legacy                0 8F03 A   int13_nocdemu               0 8EE8 A   
int13_noeltorito            0 8EFF A   int13_not_eltorito          0 8EBF A   
int13_notcdrom              0 8F30 A   int13_notfloppy             0 8F17 A   
int13_out                   0 8F3D A   int13_relocated             0 8EAC A   
int14_handler               0 E739 A   int1586_tick                0 492D A   
int1586_tick_end            0 493B A   int15_handler               0 F859 A   
int15_handler32             0 F8A2 A   int15_handler32_ret         0 F88E A   
int15_handler_mouse         0 F89D A   int15_handler_mouse_ret     0 F88D A   
int15_stub                  0 F897 A   int16_F00                   0 E859 A   
int16_handler               0 E82E A   int16_key_found             0 E876 A   
int16_wait_for_key          0 E869 A   int16_zero_clear            0 E847 A   
int16_zero_set              0 E850 A   int17_handler               0 EFD2 A   
int18_handler               0 8F41 A   int19_handler               0 E6F2 A   
int19_load_done             0 88C6 A   int19_next_boot             0 8F74 A   
int19_relocated             0 8F5D A   int1a_callfunction          0 FE8D A   
int1a_handler               0 FE6E A   int1a_normal                0 FE87 A   
int70_handler               0 FE93 A   int71_handler               0 E9DD A   
int74_done                  0 8E8E A   int74_handler               0 8E6F A   
int75_handler               0 E2C7 A   int76_handler               0 9303 A   
iret_modify_cf              0 8E98 A   iret_post_0x467             0 9269 A   
is_master_pic               0 9AF9 A   jmp_post_0x467              0 9261 A   
laddl                       0 0094 A   laddul                      0 0094 A   
landl                       0 008C A   landul                      0 008C A   
lcmpl                       0 009C A   lcmpul                      0 009C A   
ldecl                       0 00D3 A   ldecul                      0 00D3 A   
ldivul                      0 013F A   lincl                       0 00E0 A   
lincul                      0 00E0 A   lmull                       0 00BA A   
lmulul                      0 00BA A   look_drive0                 0 8FAB A   
look_drive1                 0 8FB6 A   lorl                        0 00D8 A   
lorul                       0 00D8 A   lsl_exit                    0 0135 A   
lsl_loop                    0 0129 A   lsll                        0 0118 A   
lslul                       0 0118 A   lsr_exit                    0 0117 A   
lsr_loop                    0 010B A   lsrul                       0 00FA A   
lsubl                       0 00B2 A   lsubul                      0 00B2 A   
ltstl                       0 00E5 A   ltstul                      0 00E5 A   
memcpyb_end                 0 0031 A   memcpyd_end                 0 004F A   
memsetb_end                 0 0015 A   next_pci_base               0 9AC3 A   
next_pci_dev                0 9ADD A   next_pci_func               0 9BBA A   
next_pir_entry              0 9BC4 A   nmi                         0 E2C3 A   
no_bcv                      0 9D2D A   no_bev                      0 9D66 A   
no_key                      0 08FD A   no_parport                  0 9BF1 A   
no_prod_str                 0 9D5E A   no_serial                   0 9C15 A   
normal_post                 0 E0A3 A   pci_found                   0 9623 A   
pci_init_end                0 9BD0 A   pci_init_io_loop1           0 9A45 A   
pci_init_io_loop2           0 9A62 A   pci_init_irq_loop1          0 9B53 A   
pci_init_irq_loop2          0 9B58 A   pci_irq_list                0 9A10 A   
pci_present                 0 97F7 A   pci_pro_devloop             0 966E A   
pci_pro_devloop2            0 96A4 A   pci_pro_f02                 0 965D A   
pci_pro_f03                 0 9699 A   pci_pro_f08                 0 96D2 A   
pci_pro_f09                 0 96F1 A   pci_pro_f0a                 0 970F A   
pci_pro_f0b                 0 9723 A   pci_pro_f0c                 0 973F A   
pci_pro_f0d                 0 975D A   pci_pro_fail                0 9773 A   
pci_pro_get_max_bus         0 977F A   pci_pro_nextdev             0 9689 A   
pci_pro_nextdev2            0 96C2 A   pci_pro_no_i440bx           0 979E A   
pci_pro_ok                  0 9778 A   pci_pro_select_reg          0 97A0 A   
pci_pro_unknown             0 9771 A   pci_real_devloop            0 982B A   
pci_real_devloop2           0 985D A   pci_real_f02                0 9818 A   
pci_real_f03                0 9854 A   pci_real_f08                0 988A A   
pci_real_f09                0 98A2 A   pci_real_f0a                0 98BA A   
pci_real_f0b                0 98CD A   pci_real_f0c                0 98E4 A   
pci_real_f0d                0 98FB A   pci_real_f0e                0 990E A   
pci_real_fail               0 993E A   pci_real_get_max_bus        0 994C A   
pci_real_nextdev            0 9841 A   pci_real_nextdev2           0 9877 A   
pci_real_no_i440bx          0 996C A   pci_real_ok                 0 9944 A   
pci_real_select_reg         0 996F A   pci_real_too_small          0 9936 A   
pci_real_unknown            0 993C A   pci_routing_table_structur+ 0 9990 A   
pci_routing_table_structur+ 0 9A10 A   pci_routing_table_structur+ 0 99B0 A   
pci_test_int_pin            0 9B6D A   pcibios_error               0 FE7B A   
pcibios_init_iomem_bases    0 9A2F A   pcibios_init_irqs           0 9B06 A   
pcibios_init_sel_reg        0 9A14 A   pcibios_init_set_elcr       0 9AED A   
pcibios_protected           0 9640 A   pcibios_real                0 97BD A   
pirq_found                  0 9BA9 A   pmode_IDT_info              0 F8AB A   
pnpbios_00                  0 9C97 A   pnpbios_code                0 9C7E A   
pnpbios_exit                0 9CB6 A   pnpbios_fail                0 9CB3 A   
pnpbios_prot                0 9C71 A   pnpbios_real                0 9C78 A   
pnpbios_structure           0 9C50 A   post                        0 E05B A   
post_d0_extended            0 9062 A   post_d0_type47              0 9073 A   
post_d1_exists              0 9141 A   post_d1_extended            0 914C A   
post_d1_type47              0 915D A   post_default_master_pic_in+ 0 9DBA A   
post_default_slave_pic_int+ 0 9DCA A   post_init_ivt               0 9D9F A   
post_init_pic               0 9D7A A   protected_mode              0 3F93 A   
protmode_switch             0 40A5 A   real_mode                   0 3FBD A   
retf_post_0x467             0 9276 A   rmode_IDT_info              0 F8B1 A   
rom_checksum                0 9C17 A   rom_scan                    0 9CB9 A   
rom_scan_increment          0 9D68 A   rom_scan_loop               0 9CB9 A   
s3_post                     0 9283 A   timer_tick_post             0 92AD A   
unknown_service             0 9636 A   vga_init_ok                 0 E215 A   

00000 errors
00000 warnings
