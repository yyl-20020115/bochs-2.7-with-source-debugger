00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void _memsetb(value,offset,seg,count);
00040                                           !BCC_EOS
00041                                           ! 32   void _memcpyb(doffset,dseg,soffset,sseg,count);
00042                                           !BCC_EOS
00043                                           ! 33   void _memcpyd(doffset,dseg,soffset,sseg,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   _memsetb(value,offset,seg,count)
00047                                           ! 36     Bit16u value;
00048                                           export	__memsetb
00049                       00000000            __memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u seg;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            __memsetb.count	set	8
00061                       00000006            __memsetb.seg	set	6
00062                       00000002            __memsetb.value	set	2
00063                       00000004            __memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           E3           09                  jcxz memsetb_end
00072 000C           C47E         06                  les di, 6[bp] ; segment & offset
00073 000F           8A46         04                  mov al, 4[bp] ; value
00074 0012           FC                               cld
00075 0013           F3                               rep
00076 0014           AA                                stosb
00077                       00000015              memsetb_end:
00078 0015           5F                               pop di
00079 0016           07                               pop es
00080 0017           59                               pop cx
00081 0018           58                               pop ax
00082 0019           5D                             pop bp
00083                                           ! 61 endasm
00084                                           !BCC_ENDASM
00085                                           ! 62   }
00086 001A           C3                         ret
00087                                           ! 63     void
00088                                           ! 64   _memcpyb(doffset,dseg,soffset,sseg,count)
00089                                           ! 65     Bit16u doffset;
00090                                           export	__memcpyb
00091                       0000001B            __memcpyb:
00092                                           !BCC_EOS
00093                                           ! 66     Bit16u dseg;
00094                                           !BCC_EOS
00095                                           ! 67     Bit16u soffset;
00096                                           !BCC_EOS
00097                                           ! 68     Bit16u sseg;
00098                                           !BCC_EOS
00099                                           ! 69     Bit16u count;
00100                                           !BCC_EOS
00101                                           ! 70   {
00102                                           ! 71 #asm
00103                                           !BCC_ASM
00104                       0000000A            __memcpyb.count	set	$A
00105                       00000008            __memcpyb.sseg	set	8
00106                       00000006            __memcpyb.soffset	set	6
00107                       00000004            __memcpyb.dseg	set	4
00108                       00000002            __memcpyb.doffset	set	2
00109 001B           55                             push bp
00110 001C           89E5                           mov bp, sp
00111 001E           51                               push cx
00112 001F           06                               push es
00113 0020           57                               push di
00114 0021           1E                               push ds
00115 0022           56                               push si
00116 0023           8B4E         0C                  mov cx, 12[bp] ; count
00117 0026           E3           09                  jcxz memcpyb_end
00118 0028           C47E         04                  les di, 4[bp] ; dsegment & doffset
00119 002B           C576         08                  lds si, 8[bp] ; ssegment & soffset
00120 002E           FC                               cld
00121 002F           F3                               rep
00122 0030           A4                                movsb
00123                       00000031              memcpyb_end:
00124 0031           5E                               pop si
00125 0032           1F                               pop ds
00126 0033           5F                               pop di
00127 0034           07                               pop es
00128 0035           59                               pop cx
00129 0036           5D                             pop bp
00130                                           ! 93 endasm
00131                                           !BCC_ENDASM
00132                                           ! 94   }
00133 0037           C3                         ret
00134                                           ! 95     void
00135                                           ! 96   _memcpyd(doffset,dseg,soffset,sseg,count)
00136                                           ! 97     Bit16u doffset;
00137                                           export	__memcpyd
00138                       00000038            __memcpyd:
00139                                           !BCC_EOS
00140                                           ! 98     Bit16u dseg;
00141                                           !BCC_EOS
00142                                           ! 99     Bit16u soffset;
00143                                           !BCC_EOS
00144                                           ! 100     Bit16u sseg;
00145                                           !BCC_EOS
00146                                           ! 101     Bit16u count;
00147                                           !BCC_EOS
00148                                           ! 102   {
00149                                           ! 103 #asm
00150                                           !BCC_ASM
00151                       0000000A            __memcpyd.count	set	$A
00152                       00000008            __memcpyd.sseg	set	8
00153                       00000006            __memcpyd.soffset	set	6
00154                       00000004            __memcpyd.dseg	set	4
00155                       00000002            __memcpyd.doffset	set	2
00156 0038           55                             push bp
00157 0039           89E5                           mov bp, sp
00158 003B           51                               push cx
00159 003C           06                               push es
00160 003D           57                               push di
00161 003E           1E                               push ds
00162 003F           56                               push si
00163 0040           8B4E         0C                  mov cx, 12[bp] ; count
00164 0043           E3           0A                  jcxz memcpyd_end
00165 0045           C47E         04                  les di, 4[bp] ; dsegment & doffset
00166 0048           C576         08                  lds si, 8[bp] ; ssegment & soffset
00167 004B           FC                               cld
00168 004C           F3                               rep
00169 004D     66    A5                                movsd
00170                       0000004F              memcpyd_end:
00171 004F           5E                               pop si
00172 0050           1F                               pop ds
00173 0051           5F                               pop di
00174 0052           07                               pop es
00175 0053           59                               pop cx
00176 0054           5D                             pop bp
00177                                           ! 125 endasm
00178                                           !BCC_ENDASM
00179                                           ! 126   }
00180 0055           C3                         ret
00181                                           ! 127   static Bit32u _read_dword();
00182                                           !BCC_EOS
00183                                           ! 128   static void _write_dword();
00184                                           !BCC_EOS
00185                                           ! 129   static Bit32u read_dword_SS();
00186                                           !BCC_EOS
00187                                           ! 130     Bit32u
00188                                           ! 131   _read_dword(offset, seg)
00189                                           ! 132     Bit16u seg;
00190                                           export	__read_dword
00191                       00000056            __read_dword:
00192                                           !BCC_EOS
00193                                           ! 133     Bit16u offset;
00194                                           !BCC_EOS
00195                                           ! 134   {
00196                                           ! 135 #asm
00197                                           !BCC_ASM
00198                       00000004            __read_dword.seg	set	4
00199                       00000002            __read_dword.offset	set	2
00200 0056           55                             push bp
00201 0057           89E5                           mov bp, sp
00202 0059           53                               push bx
00203 005A           1E                               push ds
00204 005B           C55E         04                  lds bx, 4[bp] ; segment & offset
00205 005E           8B07                             mov ax, [bx]
00206 0060           8B57         02                  mov dx, 2[bx]
00207                                                 ;; ax = return value (word)
00208                                                 ;; dx = return value (word)
00209 0063           1F                               pop ds
00210 0064           5B                               pop bx
00211 0065           5D                             pop bp
00212                                           ! 148 endasm
00213                                           !BCC_ENDASM
00214                                           ! 149   }
00215 0066           C3                         ret
00216                                           ! 150     void
00217                                           ! 151   _write_dword(data, offset, seg)
00218                                           ! 152     Bit32u data;
00219                                           export	__write_dword
00220                       00000067            __write_dword:
00221                                           !BCC_EOS
00222                                           ! 153     Bit16u offset;
00223                                           !BCC_EOS
00224                                           ! 154     Bit16u seg;
00225                                           !BCC_EOS
00226                                           ! 155   {
00227                                           ! 156 #asm
00228                                           !BCC_ASM
00229                       00000008            __write_dword.seg	set	8
00230                       00000002            __write_dword.data	set	2
00231                       00000006            __write_dword.offset	set	6
00232 0067           55                             push bp
00233 0068           89E5                           mov bp, sp
00234 006A     66    50                               push eax
00235 006C           53                               push bx
00236 006D           1E                               push ds
00237 006E           C55E         08                  lds bx, 8[bp] ; segment & offset
00238 0071     66    8B46         04                  mov eax, 4[bp] ; data dword
00239 0075     66    8907                             mov [bx], eax ; write data dword
00240 0078           1F                               pop ds
00241 0079           5B                               pop bx
00242 007A     66    58                               pop eax
00243 007C           5D                             pop bp
00244                                           ! 169 endasm
00245                                           !BCC_ENDASM
00246                                           ! 170   }
00247 007D           C3                         ret
00248                                           ! 171     Bit32u
00249                                           ! 172   read_dword_SS(offset)
00250                                           ! 173     Bit16u offset;
00251                                           export	_read_dword_SS
00252                       0000007E            _read_dword_SS:
00253                                           !BCC_EOS
00254                                           ! 174   {
00255                                           ! 175 #asm
00256                                           !BCC_ASM
00257                       00000002            _read_dword_SS.offset	set	2
00258 007E           55                             push bp
00259 007F           89E5                           mov bp, sp
00260 0081           8B6E         04                mov bp, 4[bp] ; offset
00261 0084           8B46         00                mov ax, [bp]
00262 0087           8B56         02                mov dx, 2[bp]
00263                                               ;; ax = return value (word)
00264                                               ;; dx = return value (word)
00265 008A           5D                             pop bp
00266                                           ! 184 endasm
00267                                           !BCC_ENDASM
00268                                           ! 185   }
00269 008B           C3                         ret
00270                                           ! 186 #asm
00271                                           !BCC_ASM
00272                       00000002            _read_dword_SS.offset	set	2
00273                                             ;; and function
00274                       0000008C              landl:
00275                       0000008C              landul:
00276 008C           36                             SEG SS
00277 008D           2305                             and ax,[di]
00278 008F           36                             SEG SS
00279 0090           235D         02                  and bx,2[di]
00280 0093           C3                             ret
00281                                             ;; add function
00282                       00000094              laddl:
00283                       00000094              laddul:
00284 0094           36                             SEG SS
00285 0095           0305                             add ax,[di]
00286 0097           36                             SEG SS
00287 0098           135D         02                  adc bx,2[di]
00288 009B           C3                             ret
00289                                             ;; cmp function
00290                       0000009C              lcmpl:
00291                       0000009C              lcmpul:
00292 009C     66    25               0000FFFF      and eax, #0x0000FFFF
00293 00A2     66    C1E3                   10      shl ebx, #16
00294 00A6     66    09D8                           or eax, ebx
00295 00A9     66    C1EB                   10      shr ebx, #16
00296 00AD           36                             SEG SS
00297 00AE     66    3B05                             cmp eax, dword ptr [di]
00298 00B1           C3                             ret
00299                                             ;; sub function
00300                       000000B2              lsubl:
00301                       000000B2              lsubul:
00302 00B2           36                             SEG SS
00303 00B3           2B05                           sub ax,[di]
00304 00B5           36                             SEG SS
00305 00B6           1B5D         02                sbb bx,2[di]
00306 00B9           C3                             ret
00307                                             ;; mul function
00308                       000000BA              lmull:
00309                       000000BA              lmulul:
00310 00BA     66    25               0000FFFF      and eax, #0x0000FFFF
00311 00C0     66    C1E3                   10      shl ebx, #16
00312 00C4     66    09D8                           or eax, ebx
00313 00C7           36                             SEG SS
00314 00C8     66    F725                           mul eax, dword ptr [di]
00315 00CB     66    89C3                           mov ebx, eax
00316 00CE     66    C1EB                   10      shr ebx, #16
00317 00D2           C3                             ret
00318                                             ;; dec function
00319                       000000D3              ldecl:
00320                       000000D3              ldecul:
00321 00D3           36                             SEG SS
00322 00D4     66    FF0F                           dec dword ptr [bx]
00323 00D7           C3                             ret
00324                                             ;; or function
00325                       000000D8              lorl:
00326                       000000D8              lorul:
00327 00D8           36                             SEG SS
00328 00D9           0B05                           or ax,[di]
00329 00DB           36                             SEG SS
00330 00DC           0B5D         02                or bx,2[di]
00331 00DF           C3                             ret
00332                                             ;; inc function
00333                       000000E0              lincl:
00334                       000000E0              lincul:
00335 00E0           36                             SEG SS
00336 00E1     66    FF07                           inc dword ptr [bx]
00337 00E4           C3                             ret
00338                                             ;; tst function
00339                       000000E5              ltstl:
00340                       000000E5              ltstul:
00341 00E5     66    25               0000FFFF      and eax, #0x0000FFFF
00342 00EB     66    C1E3                   10      shl ebx, #16
00343 00EF     66    09D8                           or eax, ebx
00344 00F2     66    C1EB                   10      shr ebx, #16
00345 00F6     66    85C0                           test eax, eax
00346 00F9           C3                             ret
00347                                             ;; sr function
00348                       000000FA              lsrul:
00349 00FA           89F9                           mov cx,di
00350 00FC           E3           19                jcxz lsr_exit
00351 00FE     66    25               0000FFFF      and eax, #0x0000FFFF
00352 0104     66    C1E3                   10      shl ebx, #16
00353 0108     66    09D8                           or eax, ebx
00354                       0000010B              lsr_loop:
00355 010B     66    D1E8                           shr eax, #1
00356 010E           E2           FB                loop lsr_loop
00357 0110     66    89C3                           mov ebx, eax
00358 0113     66    C1EB                   10      shr ebx, #16
00359                       00000117              lsr_exit:
00360 0117           C3                             ret
00361                                             ;; sl function
00362                       00000118              lsll:
00363                       00000118              lslul:
00364 0118           89F9                           mov cx,di
00365 011A           E3           19                jcxz lsl_exit
00366 011C     66    25               0000FFFF      and eax, #0x0000FFFF
00367 0122     66    C1E3                   10      shl ebx, #16
00368 0126     66    09D8                           or eax, ebx
00369                       00000129              lsl_loop:
00370 0129     66    D1E0                           shl eax, #1
00371 012C           E2           FB                loop lsl_loop
00372 012E     66    89C3                           mov ebx, eax
00373 0131     66    C1EB                   10      shr ebx, #16
00374                       00000135              lsl_exit:
00375 0135           C3                             ret
00376                       00000136              idiv_:
00377 0136           99                             cwd
00378 0137           F7FB                           idiv bx
00379 0139           C3                             ret
00380                       0000013A              idiv_u:
00381 013A           31D2                           xor dx,dx
00382 013C           F7F3                           div bx
00383 013E           C3                             ret
00384                       0000013F              ldivul:
00385 013F     66    25               0000FFFF      and eax, #0x0000FFFF
00386 0145     66    C1E3                   10      shl ebx, #16
00387 0149     66    09D8                           or eax, ebx
00388 014C     66    31D2                           xor edx, edx
00389 014F           36                             SEG SS
00390 0150           8B5D         02                mov bx, 2[di]
00391 0153     66    C1E3                   10      shl ebx, #16
00392 0157           36                             SEG SS
00393 0158           8B1D                           mov bx, [di]
00394 015A     66    F7F3                           div ebx
00395 015D     66    89C3                           mov ebx, eax
00396 0160     66    C1EB                   10      shr ebx, #16
00397 0164           C3                             ret
00398                                           ! 312 endasm
00399                                           !BCC_ENDASM
00400                                           ! 313 typedef struct {
00401                                           ! 314   unsigned char filler1[0x400];
00402                                           !BCC_EOS
00403                                           ! 315   unsigned char filler2[0x6c];
00404                                           !BCC_EOS
00405                                           ! 316   Bit16u ticks_low;
00406                                           !BCC_EOS
00407                                           ! 317   Bit16u ticks_high;
00408                                           !BCC_EOS
00409                                           ! 318   Bit8u midnight_flag;
00410                                           !BCC_EOS
00411                                           ! 319 } bios_data_t;
00412                                           !BCC_EOS
00413                                           ! 320   typedef struct {
00414                                           ! 321     Bit16u heads;
00415                                           !BCC_EOS
00416                                           ! 322     Bit16u cylinders;
00417                                           !BCC_EOS
00418                                           ! 323     Bit16u spt;
00419                                           !BCC_EOS
00420                                           ! 324   } chs_t;
00421                                           !BCC_EOS
00422                                           ! 325   typedef struct {
00423                                           ! 326     Bit16u iobase1;
00424                                           !BCC_EOS
00425                                           ! 327     Bit16u iobase2;
00426                                           !BCC_EOS
00427                                           ! 328     Bit8u prefix;
00428                                           !BCC_EOS
00429                                           ! 329     Bit8u unused;
00430                                           !BCC_EOS
00431                                           ! 330     Bit8u irq;
00432                                           !BCC_EOS
00433                                           ! 331     Bit8u blkcount;
00434                                           !BCC_EOS
00435                                           ! 332     Bit8u dma;
00436                                           !BCC_EOS
00437                                           ! 333     Bit8u pio;
00438                                           !BCC_EOS
00439                                           ! 334     Bit16u options;
00440                                           !BCC_EOS
00441                                           ! 335     Bit16u reserved;
00442                                           !BCC_EOS
00443                                           ! 336     Bit8u revision;
00444                                           !BCC_EOS
00445                                           ! 337     Bit8u checksum;
00446                                           !BCC_EOS
00447                                           ! 338   } dpte_t;
00448                                           !BCC_EOS
00449                                           ! 339   typedef struct {
00450                                           ! 340     Bit8u iface;
00451                                           !BCC_EOS
00452                                           ! 341     Bit16u iobase1;
00453                                           !BCC_EOS
00454                                           ! 342     Bit16u iobase2;
00455                                           !BCC_EOS
00456                                           ! 343     Bit8u irq;
00457                                           !BCC_EOS
00458                                           ! 344   } ata_channel_t;
00459                                           !BCC_EOS
00460                                           ! 345   typedef struct {
00461                                           ! 346     Bit8u type;
00462                                           !BCC_EOS
00463                                           ! 347     Bit8u device;
00464                                           !BCC_EOS
00465                                           ! 348     Bit8u removable;
00466                                           !BCC_EOS
00467                                           ! 349     Bit8u lock;
00468                                           !BCC_EOS
00469                                           ! 350     Bit8u mode;
00470                                           !BCC_EOS
00471                                           ! 351     Bit16u blksize;
00472                                           !BCC_EOS
00473                                           ! 352     Bit8u translation;
00474                                           !BCC_EOS
00475                                           ! 353     chs_t lchs;
00476                                           !BCC_EOS
00477                                           ! 354     chs_t pchs;
00478                                           !BCC_EOS
00479                                           ! 355     Bit32u sectors_low;
00480                                           !BCC_EOS
00481                                           ! 356     Bit32u sectors_high;
00482                                           !BCC_EOS
00483                                           ! 357   } ata_device_t;
00484                                           !BCC_EOS
00485                                           ! 358   typedef struct {
00486                                           ! 359     ata_channel_t channels[4];
00487                                           !BCC_EOS
00488                                           ! 360     ata_device_t devices[(4*2)];
00489                                           !BCC_EOS
00490                                           ! 361     Bit8u hdcount, hdidmap[(4*2)];
00491                                           !BCC_EOS
00492                                           ! 362     Bit8u cdcount, cdidmap[(4*2)
00493                                           ! 362 ];
00494                                           !BCC_EOS
00495                                           ! 363     dpte_t dpte;
00496                                           !BCC_EOS
00497                                           ! 364     Bit16u trsfsectors;
00498                                           !BCC_EOS
00499                                           ! 365     Bit32u trsfbytes;
00500                                           !BCC_EOS
00501                                           ! 366   } ata_t;
00502                                           !BCC_EOS
00503                                           ! 367   typedef struct {
00504                                           ! 368     Bit8u active;
00505                                           !BCC_EOS
00506                                           ! 369     Bit8u media;
00507                                           !BCC_EOS
00508                                           ! 370     Bit8u emulated_drive;
00509                                           !BCC_EOS
00510                                           ! 371     Bit8u controller_index;
00511                                           !BCC_EOS
00512                                           ! 372     Bit16u device_spec;
00513                                           !BCC_EOS
00514                                           ! 373     Bit32u ilba;
00515                                           !BCC_EOS
00516                                           ! 374     Bit16u buffer_segment;
00517                                           !BCC_EOS
00518                                           ! 375     Bit16u load_segment;
00519                                           !BCC_EOS
00520                                           ! 376     Bit16u sector_count;
00521                                           !BCC_EOS
00522                                           ! 377     chs_t vdevice;
00523                                           !BCC_EOS
00524                                           ! 378   } cdemu_t;
00525                                           !BCC_EOS
00526                                           ! 379   typedef struct {
00527                                           ! 380     Bit8u size;
00528                                           !BCC_EOS
00529                                           ! 381     unsigned char filler0[0x21];
00530                                           !BCC_EOS
00531                                           ! 382     Bit16u mouse_driver_offset;
00532                                           !BCC_EOS
00533                                           ! 383     Bit16u mouse_driver_seg;
00534                                           !BCC_EOS
00535                                           ! 384     Bit8u mouse_flag1;
00536                                           !BCC_EOS
00537                                           ! 385     Bit8u mouse_flag2;
00538                                           !BCC_EOS
00539                                           ! 386     Bit8u mouse_data[0x08];
00540                                           !BCC_EOS
00541                                           ! 387     unsigned char filler1[0x0D];
00542                                           !BCC_EOS
00543                                           ! 388     unsigned char fdpt0[0x10];
00544                                           !BCC_EOS
00545                                           ! 389     unsigned char fdpt1[0x10];
00546                                           !BCC_EOS
00547                                           ! 390     unsigned char filler2[0xC4];
00548                                           !BCC_EOS
00549                                           ! 391     ata_t ata;
00550                                           !BCC_EOS
00551                                           ! 392     cdemu_t cdemu;
00552                                           !BCC_EOS
00553                                           ! 393   } ebda_data_t;
00554                                           !BCC_EOS
00555                                           ! 394   typedef struct {
00556                                           ! 395     Bit8u size;
00557                                           !BCC_EOS
00558                                           ! 396     Bit8u reserved;
00559                                           !BCC_EOS
00560                                           ! 397     Bit16u count;
00561                                           !BCC_EOS
00562                                           ! 398     Bit16u offset;
00563                                           !BCC_EOS
00564                                           ! 399     Bit16u segment;
00565                                           !BCC_EOS
00566                                           ! 400     Bit32u lba1;
00567                                           !BCC_EOS
00568                                           ! 401     Bit32u lba2;
00569                                           !BCC_EOS
00570                                           ! 402   } int13ext_t;
00571                                           !BCC_EOS
00572                                           ! 403   typedef struct {
00573                                           ! 404     Bit16u size;
00574                                           !BCC_EOS
00575                                           ! 405     Bit16u infos;
00576                                           !BCC_EOS
00577                                           ! 406     Bit32u cylinders;
00578                                           !BCC_EOS
00579                                           ! 407     Bit32u heads;
00580                                           !BCC_EOS
00581                                           ! 408     Bit32u spt;
00582                                           !BCC_EOS
00583                                           ! 409     Bit32u sector_count1;
00584                                           !BCC_EOS
00585                                           ! 410     Bit32u sector_count2;
00586                                           !BCC_EOS
00587                                           ! 411     Bit16u blksize;
00588                                           !BCC_EOS
00589                                           ! 412     Bit16u dpte_offset;
00590                                           !BCC_EOS
00591                                           ! 413     Bit16u dpte_segment;
00592                                           !BCC_EOS
00593                                           ! 414     union {
00594                                           ! 415       struct {
00595                                           ! 416         Bit16u key;
00596                                           !BCC_EOS
00597                                           ! 417         Bit8u dpi_length;
00598                                           !BCC_EOS
00599                                           ! 418         Bit8u reserved1;
00600                                           !BCC_EOS
00601                                           ! 419         Bit16u reserved2;
00602                                           !BCC_EOS
00603                                           ! 420         Bit8u host_bus[4];
00604                                           !BCC_EOS
00605                                           ! 421         Bit8u iface_type[8];
00606                                           !BCC_EOS
00607                                           ! 422         Bit8u iface_path[8];
00608                                           !BCC_EOS
00609                                           ! 423         Bit8u device_path[8];
00610                                           !BCC_EOS
00611                                           ! 424         Bit8u reserved3;
00612                                           !BCC_EOS
00613                                           ! 425         Bit8u checksum;
00614                                           !BCC_EOS
00615                                           ! 426       } phoenix;
00616                                           !BCC_EOS
00617                                           ! 427       struct {
00618                                           ! 428         Bit16u key;
00619                                           !BCC_EOS
00620                                           ! 429         Bit8u dpi_length;
00621                                           !BCC_EOS
00622                                           ! 430         Bit8u reserved1;
00623                                           !BCC_EOS
00624                                           ! 431         Bit16u reserved2;
00625                                           !BCC_EOS
00626                                           ! 432         Bit8u host_bus[4];
00627                                           !BCC_EOS
00628                                           ! 433         Bit8u iface_type[8];
00629                                           !BCC_EOS
00630                                           ! 434         Bit8u iface_path[8];
00631                                           !BCC_EOS
00632                                           ! 435         Bit8u device_path[16];
00633                                           !BCC_EOS
00634                                           ! 436         Bit8u reserved3;
00635                                           !BCC_EOS
00636                                           ! 437         Bit8u checksum;
00637                                           !BCC_EOS
00638                                           ! 438       } t13;
00639                                           !BCC_EOS
00640                                           ! 439     } dpi;
00641                                           !BCC_EOS
00642                                           ! 440   } dpt_t;
00643                                           !BCC_EOS
00644                                           ! 441 typedef struct {
00645                                           ! 442   union {
00646                                           ! 443     struct {
00647                                           ! 444       Bit16u di, si, bp, sp;
00648                                           !BCC_EOS
00649                                           ! 445       Bit16u bx, dx, cx, ax;
00650                                           !BCC_EOS
00651                                           ! 446     } r16;
00652                                           !BCC_EOS
00653                                           ! 447     struct {
00654                                           ! 448       Bit16u filler[4];
00655                                           !BCC_EOS
00656                                           ! 449       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00657                                           !BCC_EOS
00658                                           ! 450     } r8;
00659                                           !BCC_EOS
00660                                           ! 451   } u;
00661                                           !BCC_EOS
00662                                           ! 452 } pusha_regs_t;
00663                                           !BCC_EOS
00664                                           ! 453 typedef struct {
00665                                           ! 454  union {
00666                                           ! 455   struct {
00667                                           ! 456     Bit32u edi, esi, ebp, esp;
00668                                           !BCC_EOS
00669                                           ! 457     Bit32u ebx, edx, ecx, eax;
00670                                           ! 457 
00671                                           !BCC_EOS
00672                                           ! 458   } r32;
00673                                           !BCC_EOS
00674                                           ! 459   struct {
00675                                           ! 460     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00676                                           !BCC_EOS
00677                                           ! 461     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00678                                           !BCC_EOS
00679                                           ! 462   } r16;
00680                                           !BCC_EOS
00681                                           ! 463   struct {
00682                                           ! 464     Bit32u filler[4];
00683                                           !BCC_EOS
00684                                           ! 465     Bit8u bl, bh;
00685                                           !BCC_EOS
00686                                           ! 466     Bit16u filler1;
00687                                           !BCC_EOS
00688                                           ! 467     Bit8u dl, dh;
00689                                           !BCC_EOS
00690                                           ! 468     Bit16u filler2;
00691                                           !BCC_EOS
00692                                           ! 469     Bit8u cl, ch;
00693                                           !BCC_EOS
00694                                           ! 470     Bit16u filler3;
00695                                           !BCC_EOS
00696                                           ! 471     Bit8u al, ah;
00697                                           !BCC_EOS
00698                                           ! 472     Bit16u filler4;
00699                                           !BCC_EOS
00700                                           ! 473   } r8;
00701                                           !BCC_EOS
00702                                           ! 474  } u;
00703                                           !BCC_EOS
00704                                           ! 475 } pushad_regs_t;
00705                                           !BCC_EOS
00706                                           ! 476 typedef struct {
00707                                           ! 477   union {
00708                                           ! 478     struct {
00709                                           ! 479       Bit16u flags;
00710                                           !BCC_EOS
00711                                           ! 480     } r16;
00712                                           !BCC_EOS
00713                                           ! 481     struct {
00714                                           ! 482       Bit8u flagsl;
00715                                           !BCC_EOS
00716                                           ! 483       Bit8u flagsh;
00717                                           !BCC_EOS
00718                                           ! 484     } r8;
00719                                           !BCC_EOS
00720                                           ! 485   } u;
00721                                           !BCC_EOS
00722                                           ! 486 } flags_t;
00723                                           !BCC_EOS
00724                                           ! 487 typedef struct {
00725                                           ! 488   Bit16u ip;
00726                                           !BCC_EOS
00727                                           ! 489   Bit16u cs;
00728                                           !BCC_EOS
00729                                           ! 490   flags_t flags;
00730                                           !BCC_EOS
00731                                           ! 491 } iret_addr_t;
00732                                           !BCC_EOS
00733                                           ! 492 typedef struct {
00734                                           ! 493   Bit16u type;
00735                                           !BCC_EOS
00736                                           ! 494   Bit16u flags;
00737                                           !BCC_EOS
00738                                           ! 495   Bit32u vector;
00739                                           !BCC_EOS
00740                                           ! 496   Bit32u description;
00741                                           !BCC_EOS
00742                                           ! 497   Bit32u reserved;
00743                                           !BCC_EOS
00744                                           ! 498 } ipl_entry_t;
00745                                           !BCC_EOS
00746                                           ! 499 static Bit8u inb();
00747                                           !BCC_EOS
00748                                           ! 500 static Bit8u inb_cmos();
00749                                           !BCC_EOS
00750                                           ! 501 static void outb();
00751                                           !BCC_EOS
00752                                           ! 502 static void outb_cmos();
00753                                           !BCC_EOS
00754                                           ! 503 static Bit16u inw();
00755                                           !BCC_EOS
00756                                           ! 504 static void outw();
00757                                           !BCC_EOS
00758                                           ! 505 static void init_rtc();
00759                                           !BCC_EOS
00760                                           ! 506 static bx_bool rtc_updating();
00761                                           !BCC_EOS
00762                                           ! 507 static Bit8u _read_byte();
00763                                           !BCC_EOS
00764                                           ! 508 static Bit16u _read_word();
00765                                           !BCC_EOS
00766                                           ! 509 static void _write_byte();
00767                                           !BCC_EOS
00768                                           ! 510 static void _write_word();
00769                                           !BCC_EOS
00770                                           ! 511 static Bit8u read_byte_SS();
00771                                           !BCC_EOS
00772                                           ! 512 static Bit16u read_word_SS();
00773                                           !BCC_EOS
00774                                           ! 513 static void _write_byte_SS();
00775                                           !BCC_EOS
00776                                           ! 514 static void _write_word_SS();
00777                                           !BCC_EOS
00778                                           ! 515 static void bios_printf();
00779                                           !BCC_EOS
00780                                           ! 516 static Bit8u inhibit_mouse_int_and_events();
00781                                           !BCC_EOS
00782                                           ! 517 static void enable_mouse_int_and_events();
00783                                           !BCC_EOS
00784                                           ! 518 static Bit8u send_to_mouse_ctrl();
00785                                           !BCC_EOS
00786                                           ! 519 static Bit8u get_mouse_data();
00787                                           !BCC_EOS
00788                                           ! 520 static void set_kbd_command_byte();
00789                                           !BCC_EOS
00790                                           ! 521 static void int09_function();
00791                                           !BCC_EOS
00792                                           ! 522 static void int13_harddisk();
00793                                           !BCC_EOS
00794                                           ! 523 static void int13_cdrom();
00795                                           !BCC_EOS
00796                                           ! 524 static void int13_cdemu();
00797                                           !BCC_EOS
00798                                           ! 525 static void int13_eltorito();
00799                                           !BCC_EOS
00800                                           ! 526 static void int13_diskette_function();
00801                                           !BCC_EOS
00802                                           ! 527 static void int14_function();
00803                                           !BCC_EOS
00804                                           ! 528 static void int15_function();
00805                                           !BCC_EOS
00806                                           ! 529 static void int16_function();
00807                                           !BCC_EOS
00808                                           ! 530 static void int17_function();
00809                                           !BCC_EOS
00810                                           ! 531 static void int19_function();
00811                                           !BCC_EOS
00812                                           ! 532 static void int1a_function();
00813                                           !BCC_EOS
00814                                           ! 533 static void int70_function();
00815                                           !BCC_EOS
00816                                           ! 534 static void int74_function();
00817                                           !BCC_EOS
00818                                           ! 535 static Bit16u get_CS();
00819                                           !BCC_EOS
00820                                           ! 536 static Bit16u get_SS();
00821                                           !BCC_EOS
00822                                           ! 537 static Bit16u set_DS();
00823                                           !BCC_EOS
00824                                           ! 538 static unsigned int enqueue_key();
00825                                           !BCC_EOS
00826                                           ! 539 static unsigned int dequeue_key();
00827                                           !BCC_EOS
00828                                           ! 540 static void get_hd_geometry();
00829                                           !BCC_EOS
00830                                           ! 541 static void set_diskette_ret_status();
00831                                           !BCC_EOS
00832                                           ! 542 static void set_diskette_current_cyl();
00833                                           !BCC_EOS
00834                                           ! 543 static void determine_
00835                                           ! 543 floppy_media();
00836                                           !BCC_EOS
00837                                           ! 544 static bx_bool floppy_drive_exists();
00838                                           !BCC_EOS
00839                                           ! 545 static bx_bool floppy_drive_recal();
00840                                           !BCC_EOS
00841                                           ! 546 static bx_bool floppy_media_known();
00842                                           !BCC_EOS
00843                                           ! 547 static bx_bool floppy_media_sense();
00844                                           !BCC_EOS
00845                                           ! 548 static bx_bool set_enable_a20();
00846                                           !BCC_EOS
00847                                           ! 549 static void debugger_on();
00848                                           !BCC_EOS
00849                                           ! 550 static void debugger_off();
00850                                           !BCC_EOS
00851                                           ! 551 static void keyboard_init();
00852                                           !BCC_EOS
00853                                           ! 552 static void keyboard_panic();
00854                                           !BCC_EOS
00855                                           ! 553 static void shutdown_status_panic();
00856                                           !BCC_EOS
00857                                           ! 554 static void nmi_handler_msg();
00858                                           !BCC_EOS
00859                                           ! 555 static void delay_ticks();
00860                                           !BCC_EOS
00861                                           ! 556 static void delay_ticks_and_check_for_keystroke();
00862                                           !BCC_EOS
00863                                           ! 557 static void interactive_bootkey();
00864                                           !BCC_EOS
00865                                           ! 558 static void print_bios_banner();
00866                                           !BCC_EOS
00867                                           ! 559 static void print_boot_device();
00868                                           !BCC_EOS
00869                                           ! 560 static void print_boot_failure();
00870                                           !BCC_EOS
00871                                           ! 561 static void print_cdromboot_failure();
00872                                           !BCC_EOS
00873                                           ! 562 void ata_init();
00874                                           !BCC_EOS
00875                                           ! 563 void ata_detect();
00876                                           !BCC_EOS
00877                                           ! 564 void ata_reset();
00878                                           !BCC_EOS
00879                                           ! 565 Bit16u ata_cmd_non_data();
00880                                           !BCC_EOS
00881                                           ! 566 Bit16u ata_cmd_data_io();
00882                                           !BCC_EOS
00883                                           ! 567 Bit16u ata_cmd_packet();
00884                                           !BCC_EOS
00885                                           ! 568 Bit16u atapi_get_sense();
00886                                           !BCC_EOS
00887                                           ! 569 Bit16u atapi_is_ready();
00888                                           !BCC_EOS
00889                                           ! 570 Bit16u atapi_is_cdrom();
00890                                           !BCC_EOS
00891                                           ! 571 void cdemu_init();
00892                                           !BCC_EOS
00893                                           ! 572 Bit8u cdemu_isactive();
00894                                           !BCC_EOS
00895                                           ! 573 Bit8u cdemu_emulated_drive();
00896                                           !BCC_EOS
00897                                           ! 574 Bit16u cdrom_boot();
00898                                           !BCC_EOS
00899                                           ! 575 static char bios_svn_version_string[] = "$Revision: 14314 $ $Date: 2021-07-14 18:10:19 +0200 (Mi, 14. Jul 2021) $";
00900                                           
00901                       00000165            _bios_svn_version_string:
00902                       00000165            .1:
00903 0165                        24            .ascii	"$Revision: 14314 $ $Date: 2021-07-14 18:"
00904 018D                        31            .ascii	"10:19 +0200 (Mi, 14. Jul 2021) $"
00905 01AD                        00            .byte	0
00906                                           !BCC_EOS
00907                                           ! 576 static struct {
00908                                           ! 577   Bit16u normal;
00909                                           !BCC_EOS
00910                                           ! 578   Bit16u shift;
00911                                           !BCC_EOS
00912                                           ! 579   Bit16u control;
00913                                           !BCC_EOS
00914                                           ! 580   Bit16u alt;
00915                                           !BCC_EOS
00916                                           ! 581   Bit8u lock_flags;
00917                                           !BCC_EOS
00918                                           ! 582   } scan_to_scanascii[0x58 + 1] = {
00919 01AE                  00000001            .blkb	1
00920                       000001AF            _scan_to_scanascii:
00921                                           ! 583       { 0, 0, 0, 0, 0 },
00922 01AF                      0000            .word	0
00923 01B1                      0000            .word	0
00924 01B3                      0000            .word	0
00925 01B5                      0000            .word	0
00926 01B7                        00            .byte	0
00927 01B8                  00000001            .blkb	1
00928                                           ! 584       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00929 01B9                      011B            .word	$11B
00930 01BB                      011B            .word	$11B
00931 01BD                      011B            .word	$11B
00932 01BF                      0100            .word	$100
00933 01C1                        00            .byte	0
00934 01C2                  00000001            .blkb	1
00935                                           ! 585       { 0x0231, 0x0221, 0, 0x7800, 0 },
00936 01C3                      0231            .word	$231
00937 01C5                      0221            .word	$221
00938 01C7                      0000            .word	0
00939 01C9                      7800            .word	$7800
00940 01CB                        00            .byte	0
00941 01CC                  00000001            .blkb	1
00942                                           ! 586       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00943 01CD                      0332            .word	$332
00944 01CF                      0340            .word	$340
00945 01D1                      0300            .word	$300
00946 01D3                      7900            .word	$7900
00947 01D5                        00            .byte	0
00948 01D6                  00000001            .blkb	1
00949                                           ! 587       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00950 01D7                      0433            .word	$433
00951 01D9                      0423            .word	$423
00952 01DB                      0000            .word	0
00953 01DD                      7A00            .word	$7A00
00954 01DF                        00            .byte	0
00955 01E0                  00000001            .blkb	1
00956                                           ! 588       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00957 01E1                      0534            .word	$534
00958 01E3                      0524            .word	$524
00959 01E5                      0000            .word	0
00960 01E7                      7B00            .word	$7B00
00961 01E9                        00            .byte	0
00962 01EA                  00000001            .blkb	1
00963                                           ! 589       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00964 01EB                      0635            .word	$635
00965 01ED                      0625            .word	$625
00966 01EF                      0000            .word	0
00967 01F1                      7C00            .word	$7C00
00968 01F3                        00            .byte	0
00969 01F4                  00000001            .blkb	1
00970                                           ! 590       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00971 01F5                      0736            .word	$736
00972 01F7                      075E            .word	$75E
00973 01F9                      071E            .word	$71E
00974 01FB                      7D00            .word	$7D00
00975 01FD                        00            .byte	0
00976 01FE                  00000001            .blkb	1
00977                                           ! 591       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00978 01FF                      0837            .word	$837
00979 0201                      0826            .word	$826
00980 0203                      0000            .word	0
00981 0205                      7E00            .word	$7E00
00982 0207                        00            .byte	0
00983 0208                  00000001            .blkb	1
00984                                           ! 592       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00985 0209                      0938            .word	$938
00986 020B                      092A            .word	$92A
00987 020D                      0000            .word	0
00988 020F                      7F00            .word	$7F00
00989 0211                        00            .byte	0
00990 0212                  00000001            .blkb	1
00991                                           ! 593       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00992 0213                      0A39            .word	$A39
00993 0215                      0A28            .word	$A28
00994 0217                      0000            .word	0
00995 0219                      8000            .word	$8000
00996 021B                        00            .byte	0
00997 021C                  00000001            .blkb	1
00998                                           ! 594       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00999 021D                      0B30            .word	$B30
01000 021F                      0B29            .word	$B29
01001 0221                      0000            .word	0
01002 0223                      8100            .word	$8100
01003 0225                        00            .byte	0
01004 0226                  00000001            .blkb	1
01005                                           ! 595       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01006 0227                      0C2D            .word	$C2D
01007 0229                      0C5F            .word	$C5F
01008 022B                      0C1F            .word	$C1F
01009 022D                      8200            .word	$8200
01010 022F                        00            .byte	0
01011 0230                  00000001            .blkb	1
01012                                           ! 596       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01013 0231                      0D3D            .word	$D3D
01014 0233                      0D2B            .word	$D2B
01015 0235                      0000            .word	0
01016 0237                      8300            .word	$8300
01017 0239                        00            .byte	0
01018 023A                  00000001            .blkb	1
01019                                           ! 597       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01020 023B                      0E08            .word	$E08
01021 023D                      0E08            .word	$E08
01022 023F                      0E7F            .word	$E7F
01023 0241                      0000            .word	0
01024 0243                        00            .byte	0
01025 0244                  00000001            .blkb	1
01026                                           ! 598       { 0x0f09, 0x0f00, 0, 0, 0 },
01027 0245                      0F09            .word	$F09
01028 0247                      0F00            .word	$F00
01029 0249                      0000            .word	0
01030 024B                      0000            .word	0
01031 024D                        00            .byte	0
01032 024E                  00000001            .blkb	1
01033                                           ! 599       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01034 024F                      1071            .word	$1071
01035 0251                      1051            .word	$1051
01036 0253                      1011            .word	$1011
01037 0255                      1000            .word	$1000
01038 0257                        40            .byte	$40
01039 0258                  00000001            .blkb	1
01040                                           ! 600       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01041 0259                      1177            .word	$1177
01042 025B                      1157            .word	$1157
01043 025D                      1117            .word	$1117
01044 025F                      1100            .word	$1100
01045 0261                        40            .byte	$40
01046 0262                  00000001            .blkb	1
01047                                           ! 601       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01048 0263                      1265            .word	$1265
01049 0265                      1245            .word	$1245
01050 0267                      1205            .word	$1205
01051 0269                      1200            .word	$1200
01052 026B                        40            .byte	$40
01053 026C                  00000001            .blkb	1
01054                                           ! 602       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01055 026D                      1372            .word	$1372
01056 026F                      1352            .word	$1352
01057 0271                      1312            .word	$1312
01058 0273                      1300            .word	$1300
01059 0275                        40            .byte	$40
01060 0276                  00000001            .blkb	1
01061                                           ! 603       { 0x1474, 0x1454, 0x141
01062 0277                      1474            .word	$1474
01063 0279                      1454            .word	$1454
01064                                           ! 603 4, 0x1400, 0x40 },
01065 027B                      1414            .word	$1414
01066 027D                      1400            .word	$1400
01067 027F                        40            .byte	$40
01068 0280                  00000001            .blkb	1
01069                                           ! 604       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01070 0281                      1579            .word	$1579
01071 0283                      1559            .word	$1559
01072 0285                      1519            .word	$1519
01073 0287                      1500            .word	$1500
01074 0289                        40            .byte	$40
01075 028A                  00000001            .blkb	1
01076                                           ! 605       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01077 028B                      1675            .word	$1675
01078 028D                      1655            .word	$1655
01079 028F                      1615            .word	$1615
01080 0291                      1600            .word	$1600
01081 0293                        40            .byte	$40
01082 0294                  00000001            .blkb	1
01083                                           ! 606       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01084 0295                      1769            .word	$1769
01085 0297                      1749            .word	$1749
01086 0299                      1709            .word	$1709
01087 029B                      1700            .word	$1700
01088 029D                        40            .byte	$40
01089 029E                  00000001            .blkb	1
01090                                           ! 607       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01091 029F                      186F            .word	$186F
01092 02A1                      184F            .word	$184F
01093 02A3                      180F            .word	$180F
01094 02A5                      1800            .word	$1800
01095 02A7                        40            .byte	$40
01096 02A8                  00000001            .blkb	1
01097                                           ! 608       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01098 02A9                      1970            .word	$1970
01099 02AB                      1950            .word	$1950
01100 02AD                      1910            .word	$1910
01101 02AF                      1900            .word	$1900
01102 02B1                        40            .byte	$40
01103 02B2                  00000001            .blkb	1
01104                                           ! 609       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01105 02B3                      1A5B            .word	$1A5B
01106 02B5                      1A7B            .word	$1A7B
01107 02B7                      1A1B            .word	$1A1B
01108 02B9                      0000            .word	0
01109 02BB                        00            .byte	0
01110 02BC                  00000001            .blkb	1
01111                                           ! 610       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01112 02BD                      1B5D            .word	$1B5D
01113 02BF                      1B7D            .word	$1B7D
01114 02C1                      1B1D            .word	$1B1D
01115 02C3                      0000            .word	0
01116 02C5                        00            .byte	0
01117 02C6                  00000001            .blkb	1
01118                                           ! 611       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01119 02C7                      1C0D            .word	$1C0D
01120 02C9                      1C0D            .word	$1C0D
01121 02CB                      1C0A            .word	$1C0A
01122 02CD                      0000            .word	0
01123 02CF                        00            .byte	0
01124 02D0                  00000001            .blkb	1
01125                                           ! 612       { 0, 0, 0, 0, 0 },
01126 02D1                      0000            .word	0
01127 02D3                      0000            .word	0
01128 02D5                      0000            .word	0
01129 02D7                      0000            .word	0
01130 02D9                        00            .byte	0
01131 02DA                  00000001            .blkb	1
01132                                           ! 613       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01133 02DB                      1E61            .word	$1E61
01134 02DD                      1E41            .word	$1E41
01135 02DF                      1E01            .word	$1E01
01136 02E1                      1E00            .word	$1E00
01137 02E3                        40            .byte	$40
01138 02E4                  00000001            .blkb	1
01139                                           ! 614       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01140 02E5                      1F73            .word	$1F73
01141 02E7                      1F53            .word	$1F53
01142 02E9                      1F13            .word	$1F13
01143 02EB                      1F00            .word	$1F00
01144 02ED                        40            .byte	$40
01145 02EE                  00000001            .blkb	1
01146                                           ! 615       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01147 02EF                      2064            .word	$2064
01148 02F1                      2044            .word	$2044
01149 02F3                      2004            .word	$2004
01150 02F5                      2000            .word	$2000
01151 02F7                        40            .byte	$40
01152 02F8                  00000001            .blkb	1
01153                                           ! 616       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01154 02F9                      2166            .word	$2166
01155 02FB                      2146            .word	$2146
01156 02FD                      2106            .word	$2106
01157 02FF                      2100            .word	$2100
01158 0301                        40            .byte	$40
01159 0302                  00000001            .blkb	1
01160                                           ! 617       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01161 0303                      2267            .word	$2267
01162 0305                      2247            .word	$2247
01163 0307                      2207            .word	$2207
01164 0309                      2200            .word	$2200
01165 030B                        40            .byte	$40
01166 030C                  00000001            .blkb	1
01167                                           ! 618       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01168 030D                      2368            .word	$2368
01169 030F                      2348            .word	$2348
01170 0311                      2308            .word	$2308
01171 0313                      2300            .word	$2300
01172 0315                        40            .byte	$40
01173 0316                  00000001            .blkb	1
01174                                           ! 619       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01175 0317                      246A            .word	$246A
01176 0319                      244A            .word	$244A
01177 031B                      240A            .word	$240A
01178 031D                      2400            .word	$2400
01179 031F                        40            .byte	$40
01180 0320                  00000001            .blkb	1
01181                                           ! 620       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01182 0321                      256B            .word	$256B
01183 0323                      254B            .word	$254B
01184 0325                      250B            .word	$250B
01185 0327                      2500            .word	$2500
01186 0329                        40            .byte	$40
01187 032A                  00000001            .blkb	1
01188                                           ! 621       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01189 032B                      266C            .word	$266C
01190 032D                      264C            .word	$264C
01191 032F                      260C            .word	$260C
01192 0331                      2600            .word	$2600
01193 0333                        40            .byte	$40
01194 0334                  00000001            .blkb	1
01195                                           ! 622       { 0x273b, 0x273a, 0, 0, 0 },
01196 0335                      273B            .word	$273B
01197 0337                      273A            .word	$273A
01198 0339                      0000            .word	0
01199 033B                      0000            .word	0
01200 033D                        00            .byte	0
01201 033E                  00000001            .blkb	1
01202                                           ! 623       { 0x2827, 0x2822, 0, 0, 0 },
01203 033F                      2827            .word	$2827
01204 0341                      2822            .word	$2822
01205 0343                      0000            .word	0
01206 0345                      0000            .word	0
01207 0347                        00            .byte	0
01208 0348                  00000001            .blkb	1
01209                                           ! 624       { 0x2960, 0x297e, 0, 0, 0 },
01210 0349                      2960            .word	$2960
01211 034B                      297E            .word	$297E
01212 034D                      0000            .word	0
01213 034F                      0000            .word	0
01214 0351                        00            .byte	0
01215 0352                  00000001            .blkb	1
01216                                           ! 625       { 0, 0, 0, 0, 0 },
01217 0353                      0000            .word	0
01218 0355                      0000            .word	0
01219 0357                      0000            .word	0
01220 0359                      0000            .word	0
01221 035B                        00            .byte	0
01222 035C                  00000001            .blkb	1
01223                                           ! 626       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01224 035D                      2B5C            .word	$2B5C
01225 035F                      2B7C            .word	$2B7C
01226 0361                      2B1C            .word	$2B1C
01227 0363                      0000            .word	0
01228 0365                        00            .byte	0
01229 0366                  00000001            .blkb	1
01230                                           ! 627       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01231 0367                      2C7A            .word	$2C7A
01232 0369                      2C5A            .word	$2C5A
01233 036B                      2C1A            .word	$2C1A
01234 036D                      2C00            .word	$2C00
01235 036F                        40            .byte	$40
01236 0370                  00000001            .blkb	1
01237                                           ! 628       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01238 0371                      2D78            .word	$2D78
01239 0373                      2D58            .word	$2D58
01240 0375                      2D18            .word	$2D18
01241 0377                      2D00            .word	$2D00
01242 0379                        40            .byte	$40
01243 037A                  00000001            .blkb	1
01244                                           ! 629       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01245 037B                      2E63            .word	$2E63
01246 037D                      2E43            .word	$2E43
01247 037F                      2E03            .word	$2E03
01248 0381                      2E00            .word	$2E00
01249 0383                        40            .byte	$40
01250 0384                  00000001            .blkb	1
01251                                           ! 630       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01252 0385                      2F76            .word	$2F76
01253 0387                      2F56            .word	$2F56
01254 0389                      2F16            .word	$2F16
01255 038B                      2F00            .word	$2F00
01256 038D                        40            .byte	$40
01257 038E                  00000001            .blkb	1
01258                                           ! 631       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01259 038F                      3062            .word	$3062
01260 0391                      3042            .word	$3042
01261 0393                      3002            .word	$3002
01262 0395                      3000            .word	$3000
01263 0397                        40            .byte	$40
01264 0398                  00000001            .blkb	1
01265                                           ! 632       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01266 0399                      316E            .word	$316E
01267 039B                      314E            .word	$314E
01268 039D                      310E            .word	$310E
01269 039F                      3100            .word	$3100
01270 03A1                        40            .byte	$40
01271 03A2                  00000001            .blkb	1
01272                                           ! 633       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01273 03A3                      326D            .word	$326D
01274 03A5                      324D            .word	$324D
01275 03A7                      320D            .word	$320D
01276 03A9                      3200            .word	$3200
01277 03AB                        40            .byte	$40
01278 03AC                  00000001            .blkb	1
01279                                           ! 634       { 0x332c, 0x333c, 0, 0, 0 },
01280 03AD                      332C            .word	$332C
01281 03AF                      333C            .word	$333C
01282 03B1                      0000            .word	0
01283 03B3                      0000            .word	0
01284 03B5                        00            .byte	0
01285 03B6                  00000001            .blkb	1
01286                                           ! 635       { 0x342e, 0x343e, 0, 0, 0 },
01287 03B7                      342E            .word	$342E
01288 03B9                      343E            .word	$343E
01289 03BB                      0000            .word	0
01290 03BD                      0000            .word	0
01291 03BF                        00            .byte	0
01292 03C0                  00000001            .blkb	1
01293                                           ! 636       { 0x352f, 0x353f, 0, 0, 0 },
01294 03C1                      352F            .word	$352F
01295 03C3                      353F            .word	$353F
01296 03C5                      0000            .word	0
01297 03C7                      0000            .word	0
01298 03C9                        00            .byte	0
01299 03CA                  00000001            .blkb	1
01300                                           ! 637       { 0, 0, 0, 0, 0 },
01301 03CB                      0000            .word	0
01302 03CD                      0000            .word	0
01303 03CF                      0000            .word	0
01304 03D1                      0000            .word	0
01305 03D3                        00            .byte	0
01306 03D4                  00000001            .blkb	1
01307                                           ! 638       { 0x372a, 0x372a, 0, 0, 0 },
01308 03D5                      372A            .word	$372A
01309 03D7                      372A            .word	$372A
01310 03D9                      0000            .word	0
01311 03DB                      0000            .word	0
01312 03DD                        00            .byte	0
01313 03DE                  00000001            .blkb	1
01314                                           ! 639       { 0, 0, 0, 0, 0 },
01315 03DF                      0000            .word	0
01316 03E1                      0000            .word	0
01317 03E3                      0000            .word	0
01318 03E5                      0000            .word	0
01319 03E7                        00            .byte	0
01320 03E8                  00000001            .blkb	1
01321                                           ! 640       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01322 03E9                      3920            .word	$3920
01323 03EB                      3920            .word	$3920
01324 03ED                      3920            .word	$3920
01325 03EF                      3920            .word	$3920
01326 03F1                        00            .byte	0
01327 03F2                  00000001            .blkb	1
01328                                           ! 641       { 0, 0, 0, 0, 0 },
01329 03F3                      0000            .word	0
01330 03F5                      0000            .word	0
01331 03F7                      0000            .word	0
01332 03F9                      0000            .word	0
01333 03FB                        00            .byte	0
01334 03FC                  00000001            .blkb	1
01335                                           ! 642       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01336 03FD                      3B00            .word	$3B00
01337 03FF                      5400            .word	$5400
01338 0401                      5E00            .word	$5E00
01339 0403                      6800            .word	$6800
01340 0405                        00            .byte	0
01341 0406                  00000001            .blkb	1
01342                                           ! 643       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01343 0407                      3C00            .word	$3C00
01344 0409                      5500            .word	$5500
01345 040B                      5F00            .word	$5F00
01346 040D                      6900            .word	$6900
01347 040F                        00            .byte	0
01348 0410                  00000001            .blkb	1
01349                                           ! 644       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01350 0411                      3D00            .word	$3D00
01351 0413                      5600            .word	$5600
01352 0415                      6000            .word	$6000
01353 0417                      6A00            .word	$6A00
01354 0419                        00            .byte	0
01355 041A                  00000001            .blkb	1
01356                                           ! 645       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01357 041B                      3E00            .word	$3E00
01358 041D                      5700            .word	$5700
01359 041F                      6100            .word	$6100
01360 0421                      6B00            .word	$6B00
01361 0423                        00            .byte	0
01362 0424                  00000001            .blkb	1
01363                                           ! 646       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01364 0425                      3F00            .word	$3F00
01365 0427                      5800            .word	$5800
01366 0429                      6200            .word	$6200
01367 042B                      6C00            .word	$6C00
01368 042D                        00            .byte	0
01369 042E                  00000001            .blkb	1
01370                                           ! 647       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01371 042F                      4000            .word	$4000
01372 0431                      5900            .word	$5900
01373 0433                      6300            .word	$6300
01374 0435                      6D00            .word	$6D00
01375 0437                        00            .byte	0
01376 0438                  00000001            .blkb	1
01377                                           ! 648       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01378 0439                      4100            .word	$4100
01379 043B                      5A00            .word	$5A00
01380 043D                      6400            .word	$6400
01381 043F                      6E00            .word	$6E00
01382 0441                        00            .byte	0
01383 0442                  00000001            .blkb	1
01384                                           ! 649       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01385 0443                      4200            .word	$4200
01386 0445                      5B00            .word	$5B00
01387 0447                      6500            .word	$6500
01388 0449                      6F00            .word	$6F00
01389 044B                        00            .byte	0
01390 044C                  00000001            .blkb	1
01391                                           ! 650       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01392 044D                      4300            .word	$4300
01393 044F                      5C00            .word	$5C00
01394 0451                      6600            .word	$6600
01395 0453                      7000            .word	$7000
01396 0455                        00            .byte	0
01397 0456                  00000001            .blkb	1
01398                                           ! 651       { 0x4400, 0x5d00, 0x6700, 0x7100, 0
01399 0457                      4400            .word	$4400
01400 0459                      5D00            .word	$5D00
01401 045B                      6700            .word	$6700
01402 045D                      7100            .word	$7100
01403                                           ! 651  },
01404 045F                        00            .byte	0
01405 0460                  00000001            .blkb	1
01406                                           ! 652       { 0, 0, 0, 0, 0 },
01407 0461                      0000            .word	0
01408 0463                      0000            .word	0
01409 0465                      0000            .word	0
01410 0467                      0000            .word	0
01411 0469                        00            .byte	0
01412 046A                  00000001            .blkb	1
01413                                           ! 653       { 0, 0, 0, 0, 0 },
01414 046B                      0000            .word	0
01415 046D                      0000            .word	0
01416 046F                      0000            .word	0
01417 0471                      0000            .word	0
01418 0473                        00            .byte	0
01419 0474                  00000001            .blkb	1
01420                                           ! 654       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01421 0475                      4700            .word	$4700
01422 0477                      4737            .word	$4737
01423 0479                      7700            .word	$7700
01424 047B                      0000            .word	0
01425 047D                        20            .byte	$20
01426 047E                  00000001            .blkb	1
01427                                           ! 655       { 0x4800, 0x4838, 0, 0, 0x20 },
01428 047F                      4800            .word	$4800
01429 0481                      4838            .word	$4838
01430 0483                      0000            .word	0
01431 0485                      0000            .word	0
01432 0487                        20            .byte	$20
01433 0488                  00000001            .blkb	1
01434                                           ! 656       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01435 0489                      4900            .word	$4900
01436 048B                      4939            .word	$4939
01437 048D                      8400            .word	$8400
01438 048F                      0000            .word	0
01439 0491                        20            .byte	$20
01440 0492                  00000001            .blkb	1
01441                                           ! 657       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01442 0493                      4A2D            .word	$4A2D
01443 0495                      4A2D            .word	$4A2D
01444 0497                      0000            .word	0
01445 0499                      0000            .word	0
01446 049B                        00            .byte	0
01447 049C                  00000001            .blkb	1
01448                                           ! 658       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01449 049D                      4B00            .word	$4B00
01450 049F                      4B34            .word	$4B34
01451 04A1                      7300            .word	$7300
01452 04A3                      0000            .word	0
01453 04A5                        20            .byte	$20
01454 04A6                  00000001            .blkb	1
01455                                           ! 659       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01456 04A7                      4C00            .word	$4C00
01457 04A9                      4C35            .word	$4C35
01458 04AB                      0000            .word	0
01459 04AD                      0000            .word	0
01460 04AF                        20            .byte	$20
01461 04B0                  00000001            .blkb	1
01462                                           ! 660       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01463 04B1                      4D00            .word	$4D00
01464 04B3                      4D36            .word	$4D36
01465 04B5                      7400            .word	$7400
01466 04B7                      0000            .word	0
01467 04B9                        20            .byte	$20
01468 04BA                  00000001            .blkb	1
01469                                           ! 661       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01470 04BB                      4E2B            .word	$4E2B
01471 04BD                      4E2B            .word	$4E2B
01472 04BF                      0000            .word	0
01473 04C1                      0000            .word	0
01474 04C3                        00            .byte	0
01475 04C4                  00000001            .blkb	1
01476                                           ! 662       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01477 04C5                      4F00            .word	$4F00
01478 04C7                      4F31            .word	$4F31
01479 04C9                      7500            .word	$7500
01480 04CB                      0000            .word	0
01481 04CD                        20            .byte	$20
01482 04CE                  00000001            .blkb	1
01483                                           ! 663       { 0x5000, 0x5032, 0, 0, 0x20 },
01484 04CF                      5000            .word	$5000
01485 04D1                      5032            .word	$5032
01486 04D3                      0000            .word	0
01487 04D5                      0000            .word	0
01488 04D7                        20            .byte	$20
01489 04D8                  00000001            .blkb	1
01490                                           ! 664       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01491 04D9                      5100            .word	$5100
01492 04DB                      5133            .word	$5133
01493 04DD                      7600            .word	$7600
01494 04DF                      0000            .word	0
01495 04E1                        20            .byte	$20
01496 04E2                  00000001            .blkb	1
01497                                           ! 665       { 0x5200, 0x5230, 0, 0, 0x20 },
01498 04E3                      5200            .word	$5200
01499 04E5                      5230            .word	$5230
01500 04E7                      0000            .word	0
01501 04E9                      0000            .word	0
01502 04EB                        20            .byte	$20
01503 04EC                  00000001            .blkb	1
01504                                           ! 666       { 0x5300, 0x532e, 0, 0, 0x20 },
01505 04ED                      5300            .word	$5300
01506 04EF                      532E            .word	$532E
01507 04F1                      0000            .word	0
01508 04F3                      0000            .word	0
01509 04F5                        20            .byte	$20
01510 04F6                  00000001            .blkb	1
01511                                           ! 667       { 0, 0, 0, 0, 0 },
01512 04F7                      0000            .word	0
01513 04F9                      0000            .word	0
01514 04FB                      0000            .word	0
01515 04FD                      0000            .word	0
01516 04FF                        00            .byte	0
01517 0500                  00000001            .blkb	1
01518                                           ! 668       { 0, 0, 0, 0, 0 },
01519 0501                      0000            .word	0
01520 0503                      0000            .word	0
01521 0505                      0000            .word	0
01522 0507                      0000            .word	0
01523 0509                        00            .byte	0
01524 050A                  00000001            .blkb	1
01525                                           ! 669       { 0x565c, 0x567c, 0, 0, 0 },
01526 050B                      565C            .word	$565C
01527 050D                      567C            .word	$567C
01528 050F                      0000            .word	0
01529 0511                      0000            .word	0
01530 0513                        00            .byte	0
01531 0514                  00000001            .blkb	1
01532                                           ! 670       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01533 0515                      8500            .word	$8500
01534 0517                      8700            .word	$8700
01535 0519                      8900            .word	$8900
01536 051B                      8B00            .word	$8B00
01537 051D                        00            .byte	0
01538 051E                  00000001            .blkb	1
01539                                           ! 671       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01540 051F                      8600            .word	$8600
01541 0521                      8800            .word	$8800
01542 0523                      8A00            .word	$8A00
01543 0525                      8C00            .word	$8C00
01544 0527                        00            .byte	0
01545 0528                  00000001            .blkb	1
01546                                           ! 672       };
01547                                           !BCC_EOS
01548                                           ! 673   Bit8u
01549                                           ! 674 inb(port)
01550                                           ! 675   Bit16u port;
01551                                           
01552                                           export	_inb
01553                       00000529            _inb:
01554                                           !BCC_EOS
01555                                           ! 676 {
01556                                           ! 677 #asm
01557                                           !BCC_ASM
01558                       00000002            _inb.port	set	2
01559 0529           55                           push bp
01560 052A           89E5                         mov bp, sp
01561 052C           52                             push dx
01562 052D           8B56         04                mov dx, 4[bp]
01563 0530           EC                             in al, dx
01564 0531           5A                             pop dx
01565 0532           5D                           pop bp
01566                                           ! 685 endasm
01567                                           !BCC_ENDASM
01568                                           ! 686 }
01569 0533           C3                         ret
01570                                           ! 687   Bit16u
01571                                           ! 688 inw(port)
01572                                           ! 689   Bit16u port;
01573                                           export	_inw
01574                       00000534            _inw:
01575                                           !BCC_EOS
01576                                           ! 690 {
01577                                           ! 691 #asm
01578                                           !BCC_ASM
01579                       00000002            _inw.port	set	2
01580 0534           55                           push bp
01581 0535           89E5                         mov bp, sp
01582 0537           52                             push dx
01583 0538           8B56         04                mov dx, 4[bp]
01584 053B           ED                             in ax, dx
01585 053C           5A                             pop dx
01586 053D           5D                           pop bp
01587                                           ! 699 endasm
01588                                           !BCC_ENDASM
01589                                           ! 700 }
01590 053E           C3                         ret
01591                                           ! 701   void
01592                                           ! 702 outb(port, val)
01593                                           ! 703   Bit16u port;
01594                                           export	_outb
01595                       0000053F            _outb:
01596                                           !BCC_EOS
01597                                           ! 704   Bit8u val;
01598                                           !BCC_EOS
01599                                           ! 705 {
01600                                           ! 706 #asm
01601                                           !BCC_ASM
01602                       00000004            _outb.val	set	4
01603                       00000002            _outb.port	set	2
01604 053F           55                           push bp
01605 0540           89E5                         mov bp, sp
01606 0542           50                             push ax
01607 0543           52                             push dx
01608 0544           8B56         04                mov dx, 4[bp]
01609 0547           8A46         06                mov al, 6[bp]
01610 054A           EE                             out dx, al
01611 054B           5A                             pop dx
01612 054C           58                             pop ax
01613 054D           5D                           pop bp
01614                                           ! 717 endasm
01615                                           !BCC_ENDASM
01616                                           ! 718 }
01617 054E           C3                         ret
01618                                           ! 719   void
01619                                           ! 720 outw(port, val)
01620                                           ! 721   Bit16u port;
01621                                           export	_outw
01622                       0000054F            _outw:
01623                                           !BCC_EOS
01624                                           ! 722   Bit16u val;
01625                                           !BCC_EOS
01626                                           ! 723 {
01627                                           ! 724 #asm
01628                                           !BCC_ASM
01629                       00000004            _outw.val	set	4
01630                       00000002            _outw.port	set	2
01631 054F           55                           push bp
01632 0550           89E5                         mov bp, sp
01633 0552           50                             push ax
01634 0553           52                             push dx
01635 0554           8B56         04                mov dx, 4[bp]
01636 0557           8B46         06                mov ax, 6[bp]
01637 055A           EF                             out dx, ax
01638 055B           5A                             pop dx
01639 055C           58                             pop ax
01640 055D           5D                           pop bp
01641                                           ! 735 endasm
01642                                           !BCC_ENDASM
01643                                           ! 736 }
01644 055E           C3                         ret
01645                                           ! 737   void
01646                                           ! 738 outb_cmos(cmos_reg, val)
01647                                           ! 739   Bit8u cmos_reg;
01648                                           export	_outb_cmos
01649                       0000055F            _outb_cmos:
01650                                           !BCC_EOS
01651                                           ! 740   Bit8u val;
01652                                           !BCC_EOS
01653                                           ! 741 {
01654                                           ! 742 #asm
01655                                           !BCC_ASM
01656                       00000002            _outb_cmos.cmos_reg	set	2
01657                       00000004            _outb_cmos.val	set	4
01658 055F           55                           push bp
01659 0560           89E5                         mov bp, sp
01660 0562           8A46         04                mov al, 4[bp] ;; cmos_reg
01661 0565           E6                     70      out 0x0070, al
01662 0567           8A46         06                mov al, 6[bp] ;; val
01663 056A           E6                     71      out 0x0071, al
01664 056C           5D                           pop bp
01665                                           ! 750 endasm
01666                                           !BCC_ENDASM
01667                                           ! 751 }
01668 056D           C3                         ret
01669                                           ! 752   Bit8u
01670                                           ! 753 inb_cmos(cmos_reg)
01671                                           ! 754   Bit8u cmos_reg;
01672                                           export	_inb_cmos
01673                       0000056E            _inb_cmos:
01674                                           !BCC_EOS
01675                                           ! 755 {
01676                                           ! 756 #asm
01677                                           !BCC_ASM
01678                       00000002            _inb_cmos.cmos_reg	set	2
01679 056E           55                           push bp
01680 056F           89E5                         mov bp, sp
01681 0571           8A46         04                mov al, 4[bp] ;; cmos_reg
01682 0574           E6                     70      out 0x0070, al
01683 0576           E4                     71      in al, 0x0071
01684 0578           5D                           pop bp
01685                                           ! 763 endasm
01686                                           !BCC_ENDASM
01687                                           ! 764 }
01688 0579           C3                         ret
01689                                           ! 765   void
01690                                           ! 766 init_rtc()
01691                                           ! 767 {
01692                                           export	_init_rtc
01693                       0000057A            _init_rtc:
01694                                           ! 768   outb_cmos(0x0a, 0x26);
01695 057A           55                         push	bp
01696 057B           89E5                       mov	bp,sp
01697                                           ! Debug: list int = const $26 (used reg = )
01698 057D           B8                   0026  mov	ax,*$26
01699 0580           50                         push	ax
01700                                           ! Debug: list int = const $A (used reg = )
01701 0581           B8                   000A  mov	ax,*$A
01702 0584           50                         push	ax
01703                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01704 0585           E8         FFD7            call	_outb_cmos
01705 0588           89EC                       mov	sp,bp
01706                                           !BCC_EOS
01707                                           ! 769   outb_cmos(0x0b, 0x02);
01708                                           ! Debug: list int = const 2 (used reg = )
01709 058A           B8                   0002  mov	ax,*2
01710 058D           50                         push	ax
01711                                           ! Debug: list int = const $B (used reg = )
01712 058E           B8                   000B  mov	ax,*$B
01713 0591           50                         push	ax
01714                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01715 0592           E8         FFCA            call	_outb_cmos
01716 0595           89EC                       mov	sp,bp
01717                                           !BCC_EOS
01718                                           ! 770   inb_cmos(0x0c);
01719                                           ! Debug: list int = const $C (used reg = )
01720 0597           B8                   000C  mov	ax,*$C
01721 059A           50                         push	ax
01722                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01723 059B           E8         FFD0            call	_inb_cmos
01724 059E           89EC                       mov	sp,bp
01725                                           !BCC_EOS
01726                                           ! 771   inb_cmos(0x0d);
01727                                           ! Debug: list int = const $D (used reg = )
01728 05A0           B8                   000D  mov	ax,*$D
01729 05A3           50                         push	ax
01730                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01731 05A4           E8         FFC7            call	_inb_cmos
01732 05A7           89EC                       mov	sp,bp
01733                                           !BCC_EOS
01734                                           ! 772 }
01735 05A9           5D                         pop	bp
01736 05AA           C3                         ret
01737                                           ! 773   bx_bool
01738                                           ! 774 rtc_updating()
01739                                           ! 775 {
01740                                           export	_rtc_updating
01741                       000005AB            _rtc_updating:
01742                                           ! 776   Bit16u count;
01743                                           !BCC_EOS
01744                                           ! 777   count = 25000;
01745 05AB           55                         push	bp
01746 05AC           89E5                       mov	bp,sp
01747 05AE           4C                         dec	sp
01748 05AF           4C                         dec	sp
01749                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01750 05B0           B8                   61A8  mov	ax,#$61A8
01751 05B3           8946         FE            mov	-2[bp],ax
01752                                           !BCC_EOS
01753                                           ! 778   while (--count != 0) {
01754 05B6           EB           15            jmp .3
01755                       000005B8            .4:
01756                                           ! 779     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01757                                           ! Debug: list int = const $A (used reg = )
01758 05B8           B8                   000A  mov	ax,*$A
01759 05BB           50                         push	ax
01760                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01761 05BC           E8         FFAF            call	_inb_cmos
01762 05BF           44                         inc	sp
01763 05C0           44                         inc	sp
01764                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01765 05C1           24                     80  and	al,#$80
01766                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01767 05C3           84C0                       test	al,al
01768 05C5           75           06            jne 	.5
01769                       000005C7            .6:
01770                                           ! 780       return(0);
01771 05C7           31C0                       xor	ax,ax
01772 05C9           89EC                       mov	sp,bp
01773 05CB           5D                         pop	bp
01774 05CC           C3                         ret
01775                                           !BCC_EOS
01776                                           ! 781     }
01777                       000005CD            .5:
01778                                           ! 782 
01779                                           ! 782   return(1);
01780                       000005CD            .3:
01781                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01782 05CD           8B46         FE            mov	ax,-2[bp]
01783 05D0           48                         dec	ax
01784 05D1           8946         FE            mov	-2[bp],ax
01785                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01786 05D4           85C0                       test	ax,ax
01787 05D6           75           E0            jne	.4
01788                       000005D8            .7:
01789                       000005D8            .2:
01790 05D8           B8                   0001  mov	ax,*1
01791 05DB           89EC                       mov	sp,bp
01792 05DD           5D                         pop	bp
01793 05DE           C3                         ret
01794                                           !BCC_EOS
01795                                           ! 783 }
01796                                           ! 784   Bit8u
01797                                           ! 785 _read_byte(offset, seg)
01798                                           ! 786   Bit16u offset;
01799                                           export	__read_byte
01800                       000005DF            __read_byte:
01801                                           !BCC_EOS
01802                                           ! 787   Bit16u seg;
01803                                           !BCC_EOS
01804                                           ! 788 {
01805                                           ! 789 #asm
01806                                           !BCC_ASM
01807                       00000004            __read_byte.seg	set	4
01808                       00000002            __read_byte.offset	set	2
01809 05DF           55                           push bp
01810 05E0           89E5                         mov bp, sp
01811 05E2           53                             push bx
01812 05E3           1E                             push ds
01813 05E4           C55E         04                lds bx, 4[bp] ; segment & offset
01814 05E7           8A07                           mov al, [bx]
01815                                               ;; al = return value (byte)
01816 05E9           1F                             pop ds
01817 05EA           5B                             pop bx
01818 05EB           5D                           pop bp
01819                                           ! 800 endasm
01820                                           !BCC_ENDASM
01821                                           ! 801 }
01822 05EC           C3                         ret
01823                                           ! 802   Bit16u
01824                                           ! 803 _read_word(offset, seg)
01825                                           ! 804   Bit16u offset;
01826                                           export	__read_word
01827                       000005ED            __read_word:
01828                                           !BCC_EOS
01829                                           ! 805   Bit16u seg;
01830                                           !BCC_EOS
01831                                           ! 806 {
01832                                           ! 807 #asm
01833                                           !BCC_ASM
01834                       00000004            __read_word.seg	set	4
01835                       00000002            __read_word.offset	set	2
01836 05ED           55                           push bp
01837 05EE           89E5                         mov bp, sp
01838 05F0           53                             push bx
01839 05F1           1E                             push ds
01840 05F2           C55E         04                lds bx, 4[bp] ; segment & offset
01841 05F5           8B07                           mov ax, [bx]
01842                                               ;; ax = return value (word)
01843 05F7           1F                             pop ds
01844 05F8           5B                             pop bx
01845 05F9           5D                           pop bp
01846                                           ! 818 endasm
01847                                           !BCC_ENDASM
01848                                           ! 819 }
01849 05FA           C3                         ret
01850                                           ! 820   void
01851                                           ! 821 _write_byte(data, offset, seg)
01852                                           ! 822   Bit8u data;
01853                                           export	__write_byte
01854                       000005FB            __write_byte:
01855                                           !BCC_EOS
01856                                           ! 823   Bit16u offset;
01857                                           !BCC_EOS
01858                                           ! 824   Bit16u seg;
01859                                           !BCC_EOS
01860                                           ! 825 {
01861                                           ! 826 #asm
01862                                           !BCC_ASM
01863                       00000006            __write_byte.seg	set	6
01864                       00000002            __write_byte.data	set	2
01865                       00000004            __write_byte.offset	set	4
01866 05FB           55                           push bp
01867 05FC           89E5                         mov bp, sp
01868 05FE           50                             push ax
01869 05FF           53                             push bx
01870 0600           1E                             push ds
01871 0601           C55E         06                lds bx, 6[bp] ; segment & offset
01872 0604           8A46         04                mov al, 4[bp] ; data byte
01873 0607           8807                           mov [bx], al ; write data byte
01874 0609           1F                             pop ds
01875 060A           5B                             pop bx
01876 060B           58                             pop ax
01877 060C           5D                           pop bp
01878                                           ! 839 endasm
01879                                           !BCC_ENDASM
01880                                           ! 840 }
01881 060D           C3                         ret
01882                                           ! 841   void
01883                                           ! 842 _write_word(data, offset, seg)
01884                                           ! 843   Bit16u data;
01885                                           export	__write_word
01886                       0000060E            __write_word:
01887                                           !BCC_EOS
01888                                           ! 844   Bit16u offset;
01889                                           !BCC_EOS
01890                                           ! 845   Bit16u seg;
01891                                           !BCC_EOS
01892                                           ! 846 {
01893                                           ! 847 #asm
01894                                           !BCC_ASM
01895                       00000006            __write_word.seg	set	6
01896                       00000002            __write_word.data	set	2
01897                       00000004            __write_word.offset	set	4
01898 060E           55                           push bp
01899 060F           89E5                         mov bp, sp
01900 0611           50                             push ax
01901 0612           53                             push bx
01902 0613           1E                             push ds
01903 0614           C55E         06                lds bx, 6[bp] ; segment & offset
01904 0617           8B46         04                mov ax, 4[bp] ; data word
01905 061A           8907                           mov [bx], ax ; write data word
01906 061C           1F                             pop ds
01907 061D           5B                             pop bx
01908 061E           58                             pop ax
01909 061F           5D                           pop bp
01910                                           ! 860 endasm
01911                                           !BCC_ENDASM
01912                                           ! 861 }
01913 0620           C3                         ret
01914                                           ! 862   Bit8u
01915                                           ! 863 read_byte_SS(offset)
01916                                           ! 864   Bit16u offset;
01917                                           export	_read_byte_SS
01918                       00000621            _read_byte_SS:
01919                                           !BCC_EOS
01920                                           ! 865 {
01921                                           ! 866 #asm
01922                                           !BCC_ASM
01923                       00000002            _read_byte_SS.offset	set	2
01924 0621           55                           push bp
01925 0622           89E5                         mov bp, sp
01926 0624           8B6E         04              mov bp, 4[bp] ; offset
01927 0627           8A46         00              mov al, [bp]
01928                                             ;; al = return value (byte)
01929 062A           5D                           pop bp
01930                                           ! 873 endasm
01931                                           !BCC_ENDASM
01932                                           ! 874 }
01933 062B           C3                         ret
01934                                           ! 875   Bit16u
01935                                           ! 876 read_word_SS(offset)
01936                                           ! 877   Bit16u offset;
01937                                           export	_read_word_SS
01938                       0000062C            _read_word_SS:
01939                                           !BCC_EOS
01940                                           ! 878 {
01941                                           ! 879 #asm
01942                                           !BCC_ASM
01943                       00000002            _read_word_SS.offset	set	2
01944 062C           55                           push bp
01945 062D           89E5                         mov bp, sp
01946 062F           8B6E         04              mov bp, 4[bp] ; offset
01947 0632           8B46         00              mov ax, [bp]
01948                                             ;; ax = return value (word)
01949 0635           5D                           pop bp
01950                                           ! 886 endasm
01951                                           !BCC_ENDASM
01952                                           ! 887 }
01953 0636           C3                         ret
01954                                           ! 888   void
01955                                           ! 889 _write_byte_SS(data, offset)
01956                                           ! 890   Bit8u data;
01957                                           export	__write_byte_SS
01958                       00000637            __write_byte_SS:
01959                                           !BCC_EOS
01960                                           ! 891   Bit16u offset;
01961                                           !BCC_EOS
01962                                           ! 892 {
01963                                           ! 893 #asm
01964                                           !BCC_ASM
01965                       00000002            __write_byte_SS.data	set	2
01966                       00000004            __write_byte_SS.offset	set	4
01967 0637           55                           push bp
01968 0638           89E5                         mov bp, sp
01969 063A           50                           push ax
01970 063B           8A46         04              mov al, 4[bp] ; data byte
01971 063E           8B6E         06              mov bp, 6[bp] ; offset
01972 0641           8846         00              mov [bp], al ; write data byte
01973 0644           58                           pop ax
01974 0645           5D                           pop bp
01975                                           ! 902 endasm
01976                                           !BCC_ENDASM
01977                                           ! 903 }
01978 0646           C3                         ret
01979                                           ! 904   void
01980                                           ! 905 _write_word_SS(data, offset)
01981                                           ! 906   Bit16u data;
01982                                           export	__write_word_SS
01983                       00000647            __write_word_SS:
01984                                           !BCC_EOS
01985                                           ! 907   Bit16u offset;
01986                                           !BCC_EOS
01987                                           ! 908 {
01988                                           ! 909 #asm
01989                                           !BCC_ASM
01990                       00000002            __write_word_SS.data	set	2
01991                       00000004            __write_word_SS.offset	set	4
01992 0647           55                           push bp
01993 0648           89E5                         mov bp, sp
01994 064A           50                           push ax
01995 064B           8B46         04              mov ax, 4[bp] ; data word
01996 064E           8B6E         06              mov bp, 6[bp] ; offset
01997 0651           8946         00              mov [bp], ax ; write data word
01998 0654           58                           pop ax
01999 0655           5D                           pop bp
02000                                           ! 918 endasm
02001                                           !BCC_ENDASM
02002                                           ! 919 }
02003 0656           C3                         ret
02004                                           ! 920   Bit16u
02005                                           ! 921 get_CS()
02006                                           ! 922 {
02007                                           export	_get_CS
02008                       00000657            _get_CS:
02009                                           ! 923 #asm
02010                                           !BCC_ASM
02011 0657           8CC8                         mov ax, cs
02012                                           ! 925 endasm
02013                                           !BCC_ENDASM
02014                                           ! 926 }
02015 0659           C3                         ret
02016                                           ! 927   Bit16u
02017                                           ! 928 get_SS()
02018                                           ! 929 {
02019                                           export	_get_SS
02020                       0000065A            _get_SS:
02021                                           ! 930 #asm
02022                                           !BCC_ASM
02023 065A           8CD0                         mov ax, ss
02024                                           ! 932 endasm
02025                                           !BCC_ENDASM
02026                                           ! 933 }
02027 065C           C3                         ret
02028                                           ! 934   Bit16u
02029                                           ! 935 set_DS(seg)
02030                                           ! 936   Bit16u seg;
02031                                           export	_set_DS
02032                       0000065D            _set_DS:
02033                                           !BCC_EOS
02034                                           ! 937 {
02035                                           ! 938 #asm
02036                                           !BCC_ASM
02037                       00000002            _set_DS.seg	set	2
02038 065D           55                           push bp
02039 065E           89E5                         mov bp, sp
02040 0660           1E                           push ds
02041 0661           8E5E         04              mov ds, 4[bp] ;; seg
02042 0664           58                           pop ax
02043 0665           5D                           pop bp
02044                                           ! 945 endasm
02045                                           !BCC_ENDASM
02046                                           ! 946 }
02047 0666           C3                         ret
02048                                           ! 947   Bit16u
02049                                           ! 948 get_ebda_seg()
02050                                           ! 949 {
02051                                           export	_get_ebda_seg
02052                       00000667            _get_ebda_seg:
02053                                           ! 950 #asm
02054                                           !BCC_ASM
02055 0667           53                           push bx
02056 0668           1E                           push ds
02057 0669           B8                   0040    mov ax, #0x0040
02058 066C           8ED8                         mov ds, ax
02059 066E           BB                   000E    mov bx, #0x000e
02060 0671           8B07                         mov ax, [bx]
02061                                             ;; ax = return value (word)
02062 0673           1F                           pop ds
02063 0674           5B                           pop bx
02064                                           ! 960 endasm
02065                                           !BCC_ENDASM
02066                                           ! 961 }
02067 0675           C3                         ret
02068                                           ! 962   void
02069                                           ! 963 wrch(c)
02070                                           ! 964   Bit8u c;
02071                                           export	_wrch
02072                       00000676            _wrch:
02073                                           !BCC_EOS
02074                                           ! 965 {
02075                                           ! 966 #asm
02076                                           !BCC_ASM
02077                       00000002            _wrch.c	set	2
02078 0676           55                           push bp
02079 0677           89E5                         mov bp, sp
02080 0679           53                           push bx
02081 067A           B4                     0E    mov ah, #0x0e
02082 067C           8A46         04              mov al, 4[bp]
02083 067F           31DB                         xor bx,bx
02084 0681           CD                     10    int #0x10
02085 0683           5B                           pop bx
02086 0684           5D                           pop bp
02087                                           ! 976 endasm
02088                                           !BCC_ENDASM
02089                                           ! 977 }
02090 0685           C3                         ret
02091                                           ! 978   void
02092                                           ! 979 send(action, c)
02093                                           ! 980   Bit16u action;
02094                                           export	_send
02095                       00000686            _send:
02096                                           !BCC_EOS
02097                                           ! 981   Bit8u c;
02098                                           !BCC_EOS
02099                                           ! 982 {
02100                                           ! 983   if (action & 8) outb(0x403, c);
02101 0686           55                         push	bp
02102 0687           89E5                       mov	bp,sp
02103                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02104 0689           8A46         04            mov	al,4[bp]
02105 068C           24                     08  and	al,*8
02106 068E           84C0                       test	al,al
02107 0690           74           0F            je  	.8
02108                       00000692            .9:
02109                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02110 0692           8A46         06            mov	al,6[bp]
02111 0695           30E4                       xor	ah,ah
02112 0697           50                         push	ax
02113                                           ! Debug: list int = const $403 (used reg = )
02114 0698           B8                   0403  mov	ax,#$403
02115 069B           50                         push	ax
02116                                           ! Debug: func () void = outb+0 (used reg = )
02117 069C           E8         FEA0            call	_outb
02118 069F           89EC                       mov	sp,bp
02119                                           !BCC_EOS
02120                                           ! 984   if (action & 4) outb(0x402, c);
02121                       000006A1            .8:
02122                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02123 06A1           8A46         04            mov	al,4[bp]
02124 06A4           24                     04  and	al,*4
02125 06A6           84C0                       test	al,al
02126 06A8           74           0F            je  	.A
02127                       000006AA            .B:
02128                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02129 06AA           8A46         06            mov	al,6[bp]
02130 06AD           30E4                       xor	ah,ah
02131 06AF           50                         push	ax
02132                                           ! Debug: list int = const $402 (used reg = )
02133 06B0           B8                   0402  mov	ax,#$402
02134 06B3           50                         push	ax
02135                                           ! Debug: func () void = outb+0 (used reg = )
02136 06B4           E8         FE88            call	_outb
02137 06B7           89EC                       mov	sp,bp
02138                                           !BCC_EOS
02139                                           ! 985   if (action & 2) {
02140                       000006B9            .A:
02141                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02142 06B9           8A46         04            mov	al,4[bp]
02143 06BC           24                     02  and	al,*2
02144 06BE           84C0                       test	al,al
02145 06C0           74           1B            je  	.C
02146                       000006C2            .D:
02147                                           ! 986     if (c == '\n') wrch('\r');
02148                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02149 06C2           8A46         06            mov	al,6[bp]
02150 06C5           3C                     0A  cmp	al,*$A
02151 06C7           75           09            jne 	.E
02152                       000006C9            .F:
02153                                           ! Debug: list int = const $D (used reg = )
02154 06C9           B8                   000D  mov	ax,*$D
02155 06CC           50                         push	ax
02156                                           ! Debug: func () void = wrch+0 (used reg = )
02157 06CD           E8         FFA6            call	_wrch
02158 06D0           89EC                       mov	sp,bp
02159                                           !BCC_EOS
02160                                           ! 987     wrch(c);
02161                       000006D2            .E:
02162                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02163 06D2           8A46         06            mov	al,6[bp]
02164 06D5           30E4                       xor	ah,ah
02165 06D7           50                         push	ax
02166                                           ! Debug: func () void = wrch+0 (used reg = )
02167 06D8           E8         FF9B            call	_wrch
02168 06DB           89EC                       mov	sp,bp
02169                                           !BCC_EOS
02170                                           ! 988   }
02171                                           ! 989 }
02172                       000006DD            .C:
02173 06DD           5D                         pop	bp
02174 06DE           C3                         ret
02175                                           ! 990   void
02176                                           ! 991 put_uint(action, val, width, neg)
02177                                           ! 992   Bit16u action;
02178                                           export	_put_uint
02179                       000006DF            _put_uint:
02180                                           !BCC_EOS
02181                                           ! 993   unsigned short val;
02182                                           !BCC_EOS
02183                                           ! 994   short width;
02184                                           !BCC_EOS
02185                                           ! 995   bx_bool neg;
02186                                           !BCC_EOS
02187                                           ! 996 {
02188                                           ! 997   unsigned short nval = val / 10;
02189 06DF           55                         push	bp
02190 06E0           89E5                       mov	bp,sp
02191 06E2           4C                         dec	sp
02192 06E3           4C                         dec	sp
02193                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02194 06E4           8B46         06            mov	ax,6[bp]
02195 06E7           BB                   000A  mov	bx,*$A
02196 06EA           E8         FA4D            call	idiv_u
02197                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02198 06ED           8946         FE            mov	-2[bp],ax
02199                                           !BCC_EOS
02200                                           ! 998   if (nval)
02201 06F0           8B46         FE            mov	ax,-2[bp]
02202 06F3           85C0                       test	ax,ax
02203 06F5           74           16            je  	.10
02204                       000006F7            .11:
02205                                           ! 999     put_uint(action, nval, width - 1, neg);
02206                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02207 06F7           FF76         0A            push	$A[bp]
02208                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02209 06FA           8B46         08            mov	ax,8[bp]
02210                                           ! Debug: list int = ax-1 (used reg = )
02211 06FD           48                         dec	ax
02212 06FE           50                         push	ax
02213                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02214 06FF           FF76         FE            push	-2[bp]
02215                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02216 0702           FF76         04            push	4[bp]
02217                                           ! Debug: func () void = put_uint+0 (used reg = )
02218 0705           E8         FFD7            call	_put_uint
02219 0708           83C4                   08  add	sp,*8
02220                                           !BCC_EOS
02221                                           ! 1000   else {
02222 070B           EB           2E            jmp .12
02223                       0000070D            .10:
02224                                           ! 1001     while (--width > 0) send(action, ' ');
02225 070D           EB           0D            jmp .14
02226                       0000070F            .15:
02227                                           ! Debug: list int = const $20 (used reg = )
02228 070F           B8                   0020  mov	ax,*$20
02229 0712           50                         push	ax
02230                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02231 0713           FF76         04            push	4[bp]
02232                                           ! Debug: func () void = send+0 (used reg = )
02233 0716           E8         FF6D            call	_send
02234 0719           83C4                   04  add	sp,*4
02235                                           !BCC_EOS
02236                                           ! 1002     if (neg) send(action, '-');
02237                       0000071C            .14:
02238                                           ! Debug: predec short width = [S+4+6] (used reg = )
02239 071C           8B46         08            mov	ax,8[bp]
02240 071F           48                         dec	ax
02241 0720           8946         08            mov	8[bp],ax
02242                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02243 0723           85C0                       test	ax,ax
02244 0725           7F           E8            jg 	.15
02245                       00000727            .16:
02246                       00000727            .13:
02247 0727           8B46         0A            mov	ax,$A[bp]
02248 072A           85C0                       test	ax,ax
02249 072C           74           0D            je  	.17
02250                       0000072E            .18:
02251                                           ! Debug: list int = const $2D (used reg = )
02252 072E           B8                   002D  mov	ax,*$2D
02253 0731           50                         push	ax
02254                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02255 0732           FF76         04            push	4[bp]
02256                                           ! Debug: func () void = send+0 (used reg = )
02257 0735           E8         FF4E            call	_send
02258 0738           83C4                   04  add	sp,*4
02259                                           !BCC_EOS
02260                                           ! 1003   }
02261                       0000073B            .17:
02262                                           ! 1004   send(action, val - (nval * 10) + '0');
02263                       0000073B            .12:
02264                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02265 073B           8B46         FE            mov	ax,-2[bp]
02266 073E           89C2                       mov	dx,ax
02267 0740           D1E0                       shl	ax,*1
02268 0742           D1E0                       shl	ax,*1
02269 0744           01D0                       add	ax,dx
02270 0746           D1E0                       shl	ax,*1
02271                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02272 0748           50                         push	ax
02273 0749           8B46         06            mov	ax,6[bp]
02274 074C           2B46         FC            sub	ax,-4[bp]
02275 074F           44                         inc	sp
02276 0750           44                         inc	sp
02277                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02278                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02279 0751           05                   0030  add	ax,*$30
02280 0754           50                         push	ax
02281                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02282 0755           FF76         04            push	4[bp]
02283                                           ! Debug: func () void = send+0 (used reg = )
02284 0758           E8         FF2B            call	_send
02285 075B           83C4                   04  add	sp,*4
02286                                           !BCC_EOS
02287                                           ! 1005 }
02288 075E           89EC                       mov	sp,bp
02289 0760           5D                         pop	bp
02290 0761           C3                         ret
02291                                           ! 1006   void
02292                                           ! Register BX used in function put_uint
02293                                           ! 1007 put_luint(action, val, width, neg)
02294                                           ! 1008   Bit16u action;
02295                                           export	_put_luint
02296                       00000762            _put_luint:
02297                                           !BCC_EOS
02298                                           ! 1009   unsigned long val;
02299                                           !BCC_EOS
02300                                           ! 1010   short width;
02301                                           !BCC_EOS
02302                                           ! 1011   bx_bool neg;
02303                                           !BCC_EOS
02304                                           ! 1012 {
02305                                           ! 1013   unsigned long nval = val / 10;
02306 0762           55                         push	bp
02307 0763           89E5                       mov	bp,sp
02308 0765           83C4                   FC  add	sp,*-4
02309                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02310 0768           B8                   000A  mov	ax,*$A
02311 076B           31DB                       xor	bx,bx
02312 076D           53                         push	bx
02313 076E           50                         push	ax
02314 076F           8B46         06            mov	ax,6[bp]
02315 0772           8B5E         08            mov	bx,8[bp]
02316 0775           8D7E         F8            lea	di,-8[bp]
02317 0778           E8         F9C4            call	ldivul
02318 077B           83C4                   04  add	sp,*4
02319                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02320 077E           8946         FC            mov	-4[bp],ax
02321 0781           895E         FE            mov	-2[bp],bx
02322                                           !BCC_EOS
02323                                           ! 1014   if (nval)
02324 0784           8B46         FC            mov	ax,-4[bp]
02325 0787           8B5E         FE            mov	bx,-2[bp]
02326 078A           E8         F958            call	ltstl
02327 078D           74           19            je  	.19
02328                       0000078F            .1A:
02329                                           ! 1015     put_luint(action, nval, width - 1, neg);
02330                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02331 078F           FF76         0C            push	$C[bp]
02332                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02333 0792           8B46         0A            mov	ax,$A[bp]
02334                                           ! Debug: list int = ax-1 (used reg = )
02335 0795           48                         dec	ax
02336 0796           50                         push	ax
02337                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02338 0797           FF76         FE            push	-2[bp]
02339 079A           FF76         FC            push	-4[bp]
02340                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02341 079D           FF76         04            push	4[bp]
02342                                           ! Debug: func () void = put_luint+0 (used reg = )
02343 07A0           E8         FFBF            call	_put_luint
02344 07A3           83C4                   0A  add	sp,*$A
02345                                           !BCC_EOS
02346                                           ! 1016   else {
02347 07A6           EB           2E            jmp .1B
02348                       000007A8            .19:
02349                                           ! 1017     while (--width > 0) send(action, ' ');
02350 07A8           EB           0D            jmp .1D
02351                       000007AA            .1E:
02352                                           ! Debug: list int = const $20 (used reg = )
02353 07AA           B8                   0020  mov	ax,*$20
02354 07AD           50                         push	ax
02355                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02356 07AE           FF76         04            push	4[bp]
02357                                           ! Debug: func () void = send+0 (used reg = )
02358 07B1           E8         FED2            call	_send
02359 07B4           83C4                   04  add	sp,*4
02360                                           !BCC_EOS
02361                                           ! 1018     if (neg) send(action, '-');
02362                       000007B7            .1D:
02363                                           ! Debug: predec short width = [S+6+8] (used reg = )
02364 07B7           8B46         0A            mov	ax,$A[bp]
02365 07BA           48                         dec	ax
02366 07BB           8946         0A            mov	$A[bp],ax
02367                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02368 07BE           85C0                       test	ax,ax
02369 07C0           7F           E8            jg 	.1E
02370                       000007C2            .1F:
02371                       000007C2            .1C:
02372 07C2           8B46         0C            mov	ax,$C[bp]
02373 07C5           85C0                       test	ax,ax
02374 07C7           74           0D            je  	.20
02375                       000007C9            .21:
02376                                           ! Debug: list int = const $2D (used reg = )
02377 07C9           B8                   002D  mov	ax,*$2D
02378 07CC           50                         push	ax
02379                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02380 07CD           FF76         04            push	4[bp]
02381                                           ! Debug: func () void = send+0 (used reg = )
02382 07D0           E8         FEB3            call	_send
02383 07D3           83C4                   04  add	sp,*4
02384                                           !BCC_EOS
02385                                           ! 1019   }
02386                       000007D6            .20:
02387                                           ! 1020   send(action, val - (nval * 10) + '0');
02388                       000007D6            .1B:
02389                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02390                                           ! Debug: expression subtree swapping
02391 07D6           B8                   000A  mov	ax,*$A
02392 07D9           31DB                       xor	bx,bx
02393 07DB           8D7E         FC            lea	di,-4[bp]
02394 07DE           E8         F8D9            call	lmulul
02395                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02396 07E1           53                         push	bx
02397 07E2           50                         push	ax
02398 07E3           8B46         06            mov	ax,6[bp]
02399 07E6           8B5E         08            mov	bx,8[bp]
02400 07E9           8D7E         F8            lea	di,-8[bp]
02401 07EC           E8         F8C3            call	lsubul
02402 07EF           83C4                   04  add	sp,*4
02403                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02404 07F2           53                         push	bx
02405 07F3           50                         push	ax
02406 07F4           B8                   0030  mov	ax,*$30
02407 07F7           31DB                       xor	bx,bx
02408 07F9           53                         push	bx
02409 07FA           50                         push	ax
02410 07FB           8B46         F8            mov	ax,-8[bp]
02411 07FE           8B5E         FA            mov	bx,-6[bp]
02412 0801           8D7E         F4            lea	di,-$C[bp]
02413 0804           E8         F88D            call	laddul
02414 0807           83C4                   08  add	sp,*8
02415                                           ! Debug: list unsigned long = bx+0 (used reg = )
02416 080A           53                         push	bx
02417 080B           50                         push	ax
02418                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02419 080C           FF76         04            push	4[bp]
02420                                           ! Debug: func () void = send+0 (used reg = )
02421 080F           E8         FE74            call	_send
02422 0812           83C4                   06  add	sp,*6
02423                                           !BCC_EOS
02424                                           ! 1021 }
02425 0815           89EC                       mov	sp,bp
02426 0817           5D                         pop	bp
02427 0818           C3                         ret
02428                                           ! 1022 void put_str(action, segment, offset)
02429                                           ! Register BX used in function put_luint
02430                                           ! 1023   Bit16u action;
02431                                           export	_put_str
02432                       00000819            _put_str:
02433                                           !BCC_EOS
02434                                           ! 1024   Bit16u segment;
02435                                           !BCC_EOS
02436                                           ! 1025   Bit16u offset;
02437                                           !BCC_EOS
02438                                           ! 1026 {
02439                                           ! 1027   Bit8u c;
02440                                           !BCC_EOS
02441                                           ! 1028   while (c = _read_byte(offset, segment)) {
02442 0819           55                         push	bp
02443 081A           89E5                       mov	bp,sp
02444 081C           4C                         dec	sp
02445 081D           4C                         dec	sp
02446 081E           EB           16            jmp .23
02447                       00000820            .24:
02448                                           ! 1029     send(action, c);
02449                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02450 0820           8A46         FF            mov	al,-1[bp]
02451 0823           30E4                       xor	ah,ah
02452 0825           50                         push	ax
02453                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02454 0826           FF76         04            push	4[bp]
02455                                           ! Debug: func () void = send+0 (used reg = )
02456 0829           E8         FE5A            call	_send
02457 082C           83C4                   04  add	sp,*4
02458                                           !BCC_EOS
02459                                           ! 1030     offset++;
02460                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02461 082F           8B46         08            mov	ax,8[bp]
02462 0832           40                         inc	ax
02463 0833           8946         08            mov	8[bp],ax
02464                                           !BCC_EOS
02465                                           ! 1031   }
02466                                           ! 1032 }
02467                       00000836            .23:
02468                                           ! Debug: list unsigned short segment = [S+4+4] (used reg = )
02469 0836           FF76         06            push	6[bp]
02470                                           ! Debug: list unsigned short offset = [S+6+6] (used reg = )
02471 0839           FF76         08            push	8[bp]
02472                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
02473 083C           E8         FDA0            call	__read_byte
02474 083F           83C4                   04  add	sp,*4
02475                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02476 0842           8846         FF            mov	-1[bp],al
02477 0845           84C0                       test	al,al
02478 0847           75           D7            jne	.24
02479                       00000849            .25:
02480                       00000849            .22:
02481 0849           89EC                       mov	sp,bp
02482 084B           5D                         pop	bp
02483 084C           C3                         ret
02484                                           ! 1033   void
02485                                           ! 1034 delay_ticks(ticks)
02486                                           ! 1035   Bit16u ticks;
02487                                           export	_delay_ticks
02488                       0000084D            _delay_ticks:
02489                                           !BCC_EOS
02490                                           ! 1036 {
02491                                           ! 1037   long ticks_to_wait, delta;
02492                                           !BCC_EOS
02493                                           ! 1038   Bit32u prev_ticks, t;
02494                                           !BCC_EOS
02495                                           ! 1039 #asm
02496 084D           55                         push	bp
02497 084E           89E5                       mov	bp,sp
02498 0850           83C4                   F0  add	sp,*-$10
02499                                           !BCC_EOS
02500                                           !BCC_ASM
02501                       00000014            _delay_ticks.ticks	set	$14
02502                       00000004            .delay_ticks.ticks	set	4
02503                       00000000            _delay_ticks.t	set	0
02504                       FFFFFFF0            .delay_ticks.t	set	-$10
02505                       00000004            _delay_ticks.prev_ticks	set	4
02506                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02507                       00000008            _delay_ticks.delta	set	8
02508                       FFFFFFF8            .delay_ticks.delta	set	-8
02509                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02510                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02511 0853           9C                           pushf
02512 0854           1E                           push ds
02513 0855           6A                     00    push #0x00
02514 0857           1F                           pop ds
02515 0858           FB                           sti
02516                                           ! 1045 endasm
02517                                           !BCC_ENDASM
02518                                           !BCC_EOS
02519                                           ! 1046   ticks_to_wait = ticks;
02520                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02521 0859           8B46         04            mov	ax,4[bp]
02522 085C           31DB                       xor	bx,bx
02523 085E           8946         FC            mov	-4[bp],ax
02524 0861           895E         FE            mov	-2[bp],bx
02525                                           !BCC_EOS
02526                                           ! 1047   prev_ticks = *((Bit32u *)(0x46c));
02527                                           ! Debug: eq unsigned long = [+$46C] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02528 0864           A1         046C            mov	ax,[$46C]
02529 0867           8B1E       046E            mov	bx,[$46E]
02530 086B           8946         F4            mov	-$C[bp],ax
02531 086E           895E         F6            mov	-$A[bp],bx
02532                                           !BCC_EOS
02533                                           ! 1048   do
02534                                           ! 1049   {
02535                       00000871            .28:
02536                                           ! 1050 #asm
02537                                           !BCC_EOS
02538                                           !BCC_ASM
02539                       00000014            _delay_ticks.ticks	set	$14
02540                       00000004            .delay_ticks.ticks	set	4
02541                       00000000            _delay_ticks.t	set	0
02542                       FFFFFFF0            .delay_ticks.t	set	-$10
02543                       00000004            _delay_ticks.prev_ticks	set	4
02544                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02545                       00000008            _delay_ticks.delta	set	8
02546                       FFFFFFF8            .delay_ticks.delta	set	-8
02547                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02548                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02549 0871           F4                             hlt
02550                                           ! 1052 endasm
02551                                           !BCC_ENDASM
02552                                           !BCC_EOS
02553                                           ! 1053     t = *((Bit32u *)(0x46c));
02554                                           ! Debug: eq unsigned long = [+$46C] to unsigned long t = [S+$12-$12] (used reg = )
02555 0872           A1         046C            mov	ax,[$46C]
02556 0875           8B1E       046E            mov	bx,[$46E]
02557 0879           8946         F0            mov	-$10[bp],ax
02558 087C           895E         F2            mov	-$E[bp],bx
02559                                           !BCC_EOS
02560                                           ! 1054     if (t > prev_ticks)
02561                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02562 087F           8B46         F4            mov	ax,-$C[bp]
02563 0882           8B5E         F6            mov	bx,-$A[bp]
02564 0885           8D7E         F0            lea	di,-$10[bp]
02565 0888           E8         F811            call	lcmpul
02566 088B           73           26            jae 	.29
02567                       0000088D            .2A:
02568                                           ! 1055     {
02569                                           ! 1056       delta = t - prev_ticks;
02570                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02571 088D           8B46         F0            mov	ax,-$10[bp]
02572 0890           8B5E         F2            mov	bx,-$E[bp]
02573 0893           8D7E         F4            lea	di,-$C[bp]
02574 0896           E8         F819            call	lsubul
02575                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02576 0899           8946         F8            mov	-8[bp],ax
02577 089C           895E         FA            mov	-6[bp],bx
02578                                           !BCC_EOS
02579                                           ! 1057       ticks_to_wait -= delta;
02580                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02581 089F           8B46         FC            mov	ax,-4[bp]
02582 08A2           8B5E         FE            mov	bx,-2[bp]
02583 08A5           8D7E         F8            lea	di,-8[bp]
02584 08A8           E8         F807            call	lsubl
02585 08AB           8946         FC            mov	-4[bp],ax
02586 08AE           895E         FE            mov	-2[bp],bx
02587                                           !BCC_EOS
02588                                           ! 1058     }
02589                                           ! 1059     else if (t < prev_ticks)
02590 08B1           EB           20            jmp .2B
02591                       000008B3            .29:
02592                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02593 08B3           8B46         F4            mov	ax,-$C[bp]
02594 08B6           8B5E         F6            mov	bx,-$A[bp]
02595 08B9           8D7E         F0            lea	di,-$10[bp]
02596 08BC           E8         F7DD            call	lcmpul
02597 08BF           76           12            jbe 	.2C
02598                       000008C1            .2D:
02599                                           ! 1060     {
02600                                           ! 1061       ticks_to_wait -= t;
02601                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02602 08C1           8B46         FC            mov	ax,-4[bp]
02603 08C4           8B5E         FE            mov	bx,-2[bp]
02604 08C7           8D7E         F0            lea	di,-$10[bp]
02605 08CA           E8         F7E5            call	lsubul
02606 08CD           8946         FC            mov	-4[bp],ax
02607 08D0           895E         FE            mov	-2[bp],bx
02608                                           !BCC_EOS
02609                                           ! 1062     }
02610                                           ! 1063     prev_ticks = t;
02611                       000008D3            .2C:
02612                       000008D3            .2B:
02613                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02614 08D3           8B46         F0            mov	ax,-$10[bp]
02615 08D6           8B5E         F2            mov	bx,-$E[bp]
02616 08D9           8946         F4            mov	-$C[bp],ax
02617 08DC           895E         F6            mov	-$A[bp],bx
02618                                           !BCC_EOS
02619                                           ! 1064   } while (ticks_to_wait > 0);
02620                       000008DF            .27:
02621                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02622 08DF           31C0                       xor	ax,ax
02623 08E1           31DB                       xor	bx,bx
02624 08E3           8D7E         FC            lea	di,-4[bp]
02625 08E6           E8         F7B3            call	lcmpl
02626 08E9           7C           86            jl 	.28
02627                       000008EB            .2E:
02628                                           !BCC_EOS
02629                                           ! 1065 #asm
02630                       000008EB            .26:
02631                                           !BCC_EOS
02632                                           !BCC_ASM
02633                       00000014            _delay_ticks.ticks	set	$14
02634                       00000004            .delay_ticks.ticks	set	4
02635                       00000000            _delay_ticks.t	set	0
02636                       FFFFFFF0            .delay_ticks.t	set	-$10
02637                       00000004            _delay_ticks.prev_ticks	set	4
02638                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02639                       00000008            _delay_ticks.delta	set	8
02640                       FFFFFFF8            .delay_ticks.delta	set	-8
02641                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02642                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02643 08EB           FA                           cli
02644 08EC           1F                           pop ds
02645 08ED           9D                           popf
02646                                           ! 1069 endasm
02647                                           !BCC_ENDASM
02648                                           !BCC_EOS
02649                                           ! 1070 }
02650 08EE           89EC                       mov	sp,bp
02651 08F0           5D                         pop	bp
02652 08F1           C3                         ret
02653                                           ! 1071   Bit8u
02654                                           ! Register BX used in function delay_ticks
02655                                           ! 1072 check_for_keystroke()
02656                                           ! 1073 {
02657                                           export	_check_for_keystroke
02658                       000008F2            _check_for_keystroke:
02659                                           ! 1074 #asm
02660                                           !BCC_ASM
02661 08F2           B8                   0100    mov ax, #0x100
02662 08F5           CD                     16    int #0x16
02663 08F7           74           04              jz no_key
02664 08F9           B0                     01    mov al, #1
02665 08FB           EB           02              jmp done
02666                       000008FD            no_key:
02667 08FD           30C0                         xor al, al
02668                       000008FF            done:
02669                                           ! 1083 endasm
02670                                           !BCC_ENDASM
02671                                           ! 1084 }
02672 08FF           C3                         ret
02673                                           ! 1085   Bit8u
02674                                           ! 1086 get_keystroke()
02675                                           ! 1087 {
02676                                           export	_get_keystroke
02677                       00000900            _get_keystroke:
02678                                           ! 1088 #asm
02679                                           !BCC_ASM
02680 0900           B8                   0000    mov ax, #0x0
02681 0903           CD                     16    int #0x16
02682 0905           86C4                         xchg ah, al
02683                                           ! 1092 endasm
02684                                           !BCC_ENDASM
02685                                           ! 1093 }
02686 0907           C3                         ret
02687                                           ! 1094   void
02688                                           ! 1095 delay_ticks_and_check_for_keystroke(ticks, count)
02689                                           ! 1096   Bit16u ticks, count;
02690                                           export	_delay_ticks_and_check_for_keystroke
02691                       00000908            _delay_ticks_and_check_for_keystroke:
02692                                           !BCC_EOS
02693                                           ! 1097 {
02694                                           ! 1098   Bit16u i;
02695                                           !BCC_EOS
02696                                           ! 1099   for (i = 1; i <= count; i++) {
02697 0908           55                         push	bp
02698 0909           89E5                       mov	bp,sp
02699 090B           4C                         dec	sp
02700 090C           4C                         dec	sp
02701                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02702 090D           B8                   0001  mov	ax,*1
02703 0910           8946         FE            mov	-2[bp],ax
02704                                           !BCC_EOS
02705                                           !BCC_EOS
02706 0913           EB           18            jmp .31
02707                       00000915            .32:
02708                                           ! 1100     delay_ticks(ticks);
02709                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02710 0915           FF76         04            push	4[bp]
02711                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02712 0918           E8         FF32            call	_delay_ticks
02713 091B           44                         inc	sp
02714 091C           44                         inc	sp
02715                                           !BCC_EOS
02716                                           ! 1101     if (check_for_keystroke())
02717                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02718 091D           E8         FFD2            call	_check_for_keystroke
02719 0920           84C0                       test	al,al
02720 0922           74           02            je  	.33
02721                       00000924            .34:
02722                                           ! 1102       break;
02723 0924           EB           0F            jmp .2F
02724                                           !BCC_EOS
02725                                           ! 1103   }
02726                       00000926            .33:
02727                                           ! 1104 }
02728                       00000926            .30:
02729                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02730 0926           8B46         FE            mov	ax,-2[bp]
02731 0929           40                         inc	ax
02732 092A           8946         FE            mov	-2[bp],ax
02733                       0000092D            .31:
02734                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02735 092D           8B46         FE            mov	ax,-2[bp]
02736 0930           3B46         06            cmp	ax,6[bp]
02737 0933           76           E0            jbe	.32
02738                       00000935            .35:
02739                       00000935            .2F:
02740 0935           89EC                       mov	sp,bp
02741 0937           5D                         pop	bp
02742 0938           C3                         ret
02743                                           ! 1105   void
02744                                           ! 1106 bios_printf(action, s)
02745                                           ! 1107   Bit16u action;
02746                                           export	_bios_printf
02747                       00000939            _bios_printf:
02748                                           !BCC_EOS
02749                                           ! 1108   Bit8u *s;
02750                                           !BCC_EOS
02751                                           ! 1109 {
02752                                           ! 1110   Bit8u c, format_char;
02753                                           !BCC_EOS
02754                                           ! 1111   bx_bool in_format;
02755                                           !BCC_EOS
02756                                           ! 1112   short i;
02757                                           !BCC_EOS
02758                                           ! 1113   Bit16u *arg_ptr;
02759                                           !BCC_EOS
02760                                           ! 1114   Bit16u arg, nibble, shift_count, format_width;
02761                                           !BCC_EOS
02762                                           ! 1115   Bit16u old_ds = set_DS(get_CS());
02763 0939           55                         push	bp
02764 093A           89E5                       mov	bp,sp
02765 093C           83C4                   EE  add	sp,*-$12
02766                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
02767 093F           E8         FD15            call	_get_CS
02768                                           ! Debug: list unsigned short = ax+0 (used reg = )
02769 0942           50                         push	ax
02770                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
02771 0943           E8         FD17            call	_set_DS
02772 0946           44                         inc	sp
02773 0947           44                         inc	sp
02774                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$14-$14] (used reg = )
02775 0948           8946         EE            mov	-$12[bp],ax
02776                                           !BCC_EOS
02777                                           ! 1116   Bit32u lval;
02778                                           !BCC_EOS
02779                                           ! 1117   arg_ptr = &s;
02780 094B           83C4                   FC  add	sp,*-4
02781                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02782 094E           8D5E         06            lea	bx,6[bp]
02783 0951           895E         F8            mov	-8[bp],bx
02784                                           !BCC_EOS
02785                                           ! 1118   in_format = 0;
02786                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02787 0954           31C0                       xor	ax,ax
02788 0956           8946         FC            mov	-4[bp],ax
02789                                           !BCC_EOS
02790                                           ! 1119   format_width = 0;
02791                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02792 0959           31C0                       xor	ax,ax
02793 095B           8946         F0            mov	-$10[bp],ax
02794                                           !BCC_EOS
02795                                           ! 1120   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02796                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02797 095E           8A46         04            mov	al,4[bp]
02798 0961           24                     07  and	al,*7
02799                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02800 0963           3C                     07  cmp	al,*7
02801 0965           75           1B            jne 	.36
02802                       00000967            .37:
02803                                           ! 1121     outb(0x401, 0x00);
02804                                           ! Debug: list int = const 0 (used reg = )
02805 0967           31C0                       xor	ax,ax
02806 0969           50                         push	ax
02807                                           ! Debug: list int = const $401 (used reg = )
02808 096A           B8                   0401  mov	ax,#$401
02809 096D           50                         push	ax
02810                                           ! Debug: func () void = outb+0 (used reg = )
02811 096E           E8         FBCE            call	_outb
02812 0971           83C4                   04  add	sp,*4
02813                                           !BCC_EOS
02814                                           ! 1122     bios_printf (2, "FATAL: ");
02815                                           ! Debug: list * char = .38+0 (used reg = )
02816 0974           BB                   DA0C  mov	bx,#.38
02817 0977           53                         push	bx
02818                                           ! Debug: list int = const 2 (used reg = )
02819 0978           B8                   0002  mov	ax,*2
02820 097B           50                         push	ax
02821                                           ! Debug: func () void = bios_printf+0 (used reg = )
02822 097C           E8         FFBA            call	_bios_printf
02823 097F           83C4                   04  add	sp,*4
02824                                           !BCC_EOS
02825                                           ! 1123   }
02826                                           ! 1124   while (c = *((Bit8u *)(s))) {
02827                       00000982            .36:
02828 0982           E9         02B2            br 	.3A
02829                       00000985            .3B:
02830                                           ! 1125     if ( c == '%' ) {
02831                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02832 0985           8A46         FF            mov	al,-1[bp]
02833 0988           3C                     25  cmp	al,*$25
02834 098A           75           0E            jne 	.3C
02835                       0000098C            .3D:
02836                                           ! 1126       in_format = 1;
02837                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02838 098C           B8                   0001  mov	ax,*1
02839 098F           8946         FC            mov	-4[bp],ax
02840                                           !BCC_EOS
02841                                           ! 1127       format_width = 0;
02842                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02843 0992           31C0                       xor	ax,ax
02844 0994           8946         F0            mov	-$10[bp],ax
02845                                           !BCC_EOS
02846                                           ! 1128     }
02847                                           ! 1129     else if (in_format) {
02848 0997           E9         0296            br 	.3E
02849                       0000099A            .3C:
02850 099A           8B46         FC            mov	ax,-4[bp]
02851 099D           85C0                       test	ax,ax
02852 099F         0F84         027E            beq 	.3F
02853                       000009A3            .40:
02854                                           ! 1130       if ( (c>='0') && (c<='9') ) {
02855                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02856 09A3           8A46         FF            mov	al,-1[bp]
02857 09A6           3C                     30  cmp	al,*$30
02858 09A8           72           28            jb  	.41
02859                       000009AA            .43:
02860                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02861 09AA           8A46         FF            mov	al,-1[bp]
02862 09AD           3C                     39  cmp	al,*$39
02863 09AF           77           21            ja  	.41
02864                       000009B1            .42:
02865                                           ! 1131         format_width = (format_width * 10) + (c - '0');
02866                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02867 09B1           8A46         FF            mov	al,-1[bp]
02868 09B4           30E4                       xor	ah,ah
02869 09B6           05                   FFD0  add	ax,*-$30
02870 09B9           50                         push	ax
02871                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$12] (used reg = )
02872 09BA           8B46         F0            mov	ax,-$10[bp]
02873 09BD           89C2                       mov	dx,ax
02874 09BF           D1E0                       shl	ax,*1
02875 09C1           D1E0                       shl	ax,*1
02876 09C3           01D0                       add	ax,dx
02877 09C5           D1E0                       shl	ax,*1
02878                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02879 09C7           0346         E8            add	ax,-$18[bp]
02880 09CA           44                         inc	sp
02881 09CB           44                         inc	sp
02882                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$12] (used reg = )
02883 09CC           8946         F0            mov	-$10[bp],ax
02884                                           !BCC_EOS
02885                                           ! 1132       }
02886                                           ! 1133       else {
02887 09CF           E9         024D            br 	.44
02888                       000009D2            .41:
02889                                           ! 1134         arg_ptr++;
02890                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02891 09D2           8B5E         F8            mov	bx,-8[bp]
02892 09D5           43                         inc	bx
02893 09D6           43                         inc	bx
02894 09D7           895E         F8            mov	-8[bp],bx
02895                                           !BCC_EOS
02896                                           ! 1135         arg = read_word_SS(arg_ptr);
02897                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02898 09DA           FF76         F8            push	-8[bp]
02899                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
02900 09DD           E8         FC4C            call	_read_word_SS
02901 09E0           44                         inc	sp
02902 09E1           44                         inc	sp
02903                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02904 09E2           8946         F6            mov	-$A[bp],ax
02905                                           !BCC_EOS
02906                                           ! 1136         if ((c & 0xdf) == 'X') {
02907                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
02908 09E5           8A46         FF            mov	al,-1[bp]
02909 09E8           24                     DF  and	al,#$DF
02910                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
02911 09EA           3C                     58  cmp	al,*$58
02912 09EC           75           64            jne 	.45
02913                       000009EE            .46:
02914                                           ! 1137           if (format_width == 0)
02915                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02916 09EE           8B46         F0            mov	ax,-$10[bp]
02917 09F1           85C0                       test	ax,ax
02918 09F3           75           06            jne 	.47
02919                       000009F5            .48:
02920                                           ! 1138             format_width = 4;
02921                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$12] (used reg = )
02922 09F5           B8                   0004  mov	ax,*4
02923 09F8           8946         F0            mov	-$10[bp],ax
02924                                           !BCC_EOS
02925                                           ! 1139           for (i=format_width-1; i>=0; i--) {
02926                       000009FB            .47:
02927                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
02928 09FB           8B46         F0            mov	ax,-$10[bp]
02929                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02930 09FE           48                         dec	ax
02931 09FF           8946         FA            mov	-6[bp],ax
02932                                           !BCC_EOS
02933                                           !BCC_EOS
02934 0A02           EB           44            jmp .4B
02935                       00000A04            .4C:
02936                                           ! 1140             nibble = (arg >> (4 * i)) & 0x000f;
02937                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02938                                           ! Debug: expression subtree swapping
02939 0A04           8B46         FA            mov	ax,-6[bp]
02940 0A07           D1E0                       shl	ax,*1
02941 0A09           D1E0                       shl	ax,*1
02942                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02943 0A0B           89C3                       mov	bx,ax
02944 0A0D           8B46         F6            mov	ax,-$A[bp]
02945 0A10           89D9                       mov	cx,bx
02946 0A12           D3E8                       shr	ax,cl
02947                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
02948 0A14           24                     0F  and	al,*$F
02949                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
02950 0A16           30E4                       xor	ah,ah
02951 0A18           8946         F4            mov	-$C[bp],ax
02952                                           !BCC_EOS
02953                                           ! 1141             send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
02954                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
02955 0A1B           8B46         F4            mov	ax,-$C[bp]
02956 0A1E           3D                   0009  cmp	ax,*9
02957 0A21           77           08            ja  	.4D
02958                       00000A23            .4E:
02959                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
02960 0A23           8B46         F4            mov	ax,-$C[bp]
02961 0A26           05                   0030  add	ax,*$30
02962 0A29           EB           0C            jmp .4F
02963                       00000A2B            .4D:
02964                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
02965 0A2B           8B46         F4            mov	ax,-$C[bp]
02966 0A2E           0246         FF            add	al,-1[bp]
02967 0A31           80D4                   00  adc	ah,*0
02968                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
02969 0A34           05                   FFDF  add	ax,*-$21
02970                       00000A37            .4F:
02971                                           ! Debug: list unsigned int = ax+0 (used reg = )
02972 0A37           50                         push	ax
02973                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02974 0A38           FF76         04            push	4[bp]
02975                                           ! Debug: func () void = send+0 (used reg = )
02976 0A3B           E8         FC48            call	_send
02977 0A3E           83C4                   04  add	sp,*4
02978                                           !BCC_EOS
02979                                           ! 1142           }
02980                                           ! 1143         }
02981                       00000A41            .4A:
02982                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
02983 0A41           8B46         FA            mov	ax,-6[bp]
02984 0A44           48                         dec	ax
02985 0A45           8946         FA            mov	-6[bp],ax
02986                       00000A48            .4B:
02987                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
02988 0A48           8B46         FA            mov	ax,-6[bp]
02989 0A4B           85C0                       test	ax,ax
02990 0A4D           7D           B5            jge	.4C
02991                       00000A4F            .50:
02992                       00000A4F            .49:
02993                                           ! 1144         else if (c == 'u') {
02994 0A4F           E9         01C8            br 	.51
02995                       00000A52            .45:
02996                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
02997 0A52           8A46         FF            mov	al,-1[bp]
02998 0A55           3C                     75  cmp	al,*$75
02999 0A57           75           15            jne 	.52
03000                       00000A59            .53:
03001                                           ! 1145           put_uint(action, arg, format_width, 0);
03002                                           ! Debug: list int = const 0 (used reg = )
03003 0A59           31C0                       xor	ax,ax
03004 0A5B           50                         push	ax
03005                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03006 0A5C           FF76         F0            push	-$10[bp]
03007                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03008 0A5F           FF76         F6            push	-$A[bp]
03009                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03010 0A62           FF76         04            push	4[bp]
03011                                           ! Debug: func () void = put_uint+0 (used reg = )
03012 0A65           E8         FC77            call	_put_uint
03013 0A68           83C4                   08  add	sp,*8
03014                                           !BCC_EOS
03015                                           ! 1146         }
03016                                           ! 1147         else if (c == 'l') {
03017 0A6B           E9         01AC            br 	.54
03018                       00000A6E            .52:
03019                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03020 0A6E           8A46         FF            mov	al,-1[bp]
03021 0A71           3C                     6C  cmp	al,*$6C
03022 0A73         0F85         0102            bne 	.55
03023                       00000A77            .56:
03024                                           ! 1148           s++;
03025                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03026 0A77           8B5E         06            mov	bx,6[bp]
03027 0A7A           43                         inc	bx
03028 0A7B           895E         06            mov	6[bp],bx
03029                                           !BCC_EOS
03030                                           ! 1149           c = *((Bit8u *)(s));
03031 0A7E           8B5E         06            mov	bx,6[bp]
03032                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03033 0A81           8A07                       mov	al,[bx]
03034 0A83           8846         FF            mov	-1[bp],al
03035                                           !BCC_EOS
03036                                           ! 1150           arg_ptr++;
03037                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03038 0A86           8B5E         F8            mov	bx,-8[bp]
03039 0A89           43                         inc	bx
03040 0A8A           43                         inc	bx
03041 0A8B           895E         F8            mov	-8[bp],bx
03042                                           !BCC_EOS
03043                                           ! 1151           *(((Bit16u *)&lval)+1) = read_word_SS(arg_ptr);
03044                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03045 0A8E           FF76         F8            push	-8[bp]
03046                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03047 0A91           E8         FB98            call	_read_word_SS
03048 0A94           44                         inc	sp
03049 0A95           44                         inc	sp
03050                                           ! Debug: eq unsigned short = ax+0 to unsigned short lval = [S+$18-$16] (used reg = )
03051 0A96           8946         EC            mov	-$14[bp],ax
03052                                           !BCC_EOS
03053                                           ! 1152           *((Bit16u *)&lval) = arg;
03054                                           ! Debug: eq unsigned short arg = [S+$18-$C] to unsigned short lval = [S+$18-$18] (used reg = )
03055 0A99           8B46         F6            mov	ax,-$A[bp]
03056 0A9C           8946         EA            mov	-$16[bp],ax
03057                                           !BCC_EOS
03058                                           ! 1153           if (c == 'd') {
03059                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03060 0A9F           8A46         FF            mov	al,-1[bp]
03061 0AA2           3C                     64  cmp	al,*$64
03062 0AA4           75           42            jne 	.57
03063                       00000AA6            .58:
03064                                           ! 1154             if (*(((Bit16u *)&lval)+1) & 0x8000)
03065                                           ! Debug: and unsigned int = const $8000 to unsigned short lval = [S+$18-$16] (used reg = )
03066 0AA6           8B46         EC            mov	ax,-$14[bp]
03067 0AA9           25                   8000  and	ax,#$8000
03068 0AAC           85C0                       test	ax,ax
03069 0AAE           74           20            je  	.59
03070                       00000AB0            .5A:
03071                                           ! 1155               put_luint(action, 0L-lval, format_width-1, 1);
03072                                           ! Debug: list int = const 1 (used reg = )
03073 0AB0           B8                   0001  mov	ax,*1
03074 0AB3           50                         push	ax
03075                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03076 0AB4           8B46         F0            mov	ax,-$10[bp]
03077                                           ! Debug: list unsigned int = ax-1 (used reg = )
03078 0AB7           48                         dec	ax
03079 0AB8           50                         push	ax
03080                                           ! Debug: sub unsigned long lval = [S+$1C-$18] to long = const 0 (used reg = )
03081 0AB9           31C0                       xor	ax,ax
03082 0ABB           31DB                       xor	bx,bx
03083 0ABD           8D7E         EA            lea	di,-$16[bp]
03084 0AC0           E8         F5EF            call	lsubul
03085                                           ! Debug: list unsigned long = bx+0 (used reg = )
03086 0AC3           53                         push	bx
03087 0AC4           50                         push	ax
03088                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03089 0AC5           FF76         04            push	4[bp]
03090                                           ! Debug: func () void = put_luint+0 (used reg = )
03091 0AC8           E8         FC97            call	_put_luint
03092 0ACB           83C4                   0A  add	sp,*$A
03093                                           !BCC_EOS
03094                                           ! 1156             else
03095                                           ! 1157               put_luint(action, lval, format_width, 0);
03096 0ACE           EB           15            jmp .5B
03097                       00000AD0            .59:
03098                                           ! Debug: list int = const 0 (used reg = )
03099 0AD0           31C0                       xor	ax,ax
03100 0AD2           50                         push	ax
03101                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03102 0AD3           FF76         F0            push	-$10[bp]
03103                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03104 0AD6           FF76         EC            push	-$14[bp]
03105 0AD9           FF76         EA            push	-$16[bp]
03106                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03107 0ADC           FF76         04            push	4[bp]
03108                                           ! Debug: func () void = put_luint+0 (used reg = )
03109 0ADF           E8         FC80            call	_put_luint
03110 0AE2           83C4                   0A  add	sp,*$A
03111                                           !BCC_EOS
03112                                           ! 1158           }
03113                       00000AE5            .5B:
03114                                           ! 1159           else if (c == 'u') {
03115 0AE5           E9         008E            br 	.5C
03116                       00000AE8            .57:
03117                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03118 0AE8           8A46         FF            mov	al,-1[bp]
03119 0AEB           3C                     75  cmp	al,*$75
03120 0AED           75           17            jne 	.5D
03121                       00000AEF            .5E:
03122                                           ! 1160             put_luint(action, lval, format_width, 0);
03123                                           ! Debug: list int = const 0 (used reg = )
03124 0AEF           31C0                       xor	ax,ax
03125 0AF1           50                         push	ax
03126                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03127 0AF2           FF76         F0            push	-$10[bp]
03128                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03129 0AF5           FF76         EC            push	-$14[bp]
03130 0AF8           FF76         EA            push	-$16[bp]
03131                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03132 0AFB           FF76         04            push	4[bp]
03133                                           ! Debug: func () void = put_luint+0 (used reg = )
03134 0AFE           E8         FC61            call	_put_luint
03135 0B01           83C4                   0A  add	sp,*$A
03136                                           !BCC_EOS
03137                                           ! 1161           }
03138                                           ! 1162           else if ((c & 0xdf) == 'X')
03139 0B04           EB           70            jmp .5F
03140                       00000B06            .5D:
03141                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
03142 0B06           8A46         FF            mov	al,-1[bp]
03143 0B09           24                     DF  and	al,#$DF
03144                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
03145 0B0B           3C                     58  cmp	al,*$58
03146 0B0D           75           67            jne 	.60
03147                       00000B0F            .61:
03148                                           ! 1163           {
03149                                           ! 1164             if (format_width == 0)
03150                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
03151 0B0F           8B46         F0            mov	ax,-$10[bp]
03152 0B12           85C0                       test	ax,ax
03153 0B14           75           06            jne 	.62
03154                       00000B16            .63:
03155                                           ! 1165               format_width = 8;
03156                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$12] (used reg = )
03157 0B16           B8                   0008  mov	ax,*8
03158 0B19           8946         F0            mov	-$10[bp],ax
03159                                           !BCC_EOS
03160                                           ! 1166             for (i=format_w
03161                       00000B1C            .62:
03162                                           ! 1166 idth-1; i>=0; i--) {
03163                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
03164 0B1C           8B46         F0            mov	ax,-$10[bp]
03165                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03166 0B1F           48                         dec	ax
03167 0B20           8946         FA            mov	-6[bp],ax
03168                                           !BCC_EOS
03169                                           !BCC_EOS
03170 0B23           EB           4A            jmp .66
03171                       00000B25            .67:
03172                                           ! 1167               nibble = ((Bit16u)(lval >> (4 * i))) & 0x000f;
03173                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03174                                           ! Debug: expression subtree swapping
03175 0B25           8B46         FA            mov	ax,-6[bp]
03176 0B28           D1E0                       shl	ax,*1
03177 0B2A           D1E0                       shl	ax,*1
03178                                           ! Debug: sr int = ax+0 to unsigned long lval = [S+$18-$18] (used reg = )
03179 0B2C           50                         push	ax
03180 0B2D           8B46         EA            mov	ax,-$16[bp]
03181 0B30           8B5E         EC            mov	bx,-$14[bp]
03182 0B33           8B7E         E8            mov	di,-$18[bp]
03183 0B36           E8         F5C1            call	lsrul
03184 0B39           44                         inc	sp
03185 0B3A           44                         inc	sp
03186                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
03187                                           ! Debug: and int = const $F to unsigned short = ax+0 (used reg = )
03188 0B3B           24                     0F  and	al,*$F
03189                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03190 0B3D           30E4                       xor	ah,ah
03191 0B3F           8946         F4            mov	-$C[bp],ax
03192                                           !BCC_EOS
03193                                           ! 1168               send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03194                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03195 0B42           8B46         F4            mov	ax,-$C[bp]
03196 0B45           3D                   0009  cmp	ax,*9
03197 0B48           77           08            ja  	.68
03198                       00000B4A            .69:
03199                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03200 0B4A           8B46         F4            mov	ax,-$C[bp]
03201 0B4D           05                   0030  add	ax,*$30
03202 0B50           EB           0C            jmp .6A
03203                       00000B52            .68:
03204                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03205 0B52           8B46         F4            mov	ax,-$C[bp]
03206 0B55           0246         FF            add	al,-1[bp]
03207 0B58           80D4                   00  adc	ah,*0
03208                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03209 0B5B           05                   FFDF  add	ax,*-$21
03210                       00000B5E            .6A:
03211                                           ! Debug: list unsigned int = ax+0 (used reg = )
03212 0B5E           50                         push	ax
03213                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03214 0B5F           FF76         04            push	4[bp]
03215                                           ! Debug: func () void = send+0 (used reg = )
03216 0B62           E8         FB21            call	_send
03217 0B65           83C4                   04  add	sp,*4
03218                                           !BCC_EOS
03219                                           ! 1169             }
03220                                           ! 1170           }
03221                       00000B68            .65:
03222                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03223 0B68           8B46         FA            mov	ax,-6[bp]
03224 0B6B           48                         dec	ax
03225 0B6C           8946         FA            mov	-6[bp],ax
03226                       00000B6F            .66:
03227                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03228 0B6F           8B46         FA            mov	ax,-6[bp]
03229 0B72           85C0                       test	ax,ax
03230 0B74           7D           AF            jge	.67
03231                       00000B76            .6B:
03232                       00000B76            .64:
03233                                           ! 1171         }
03234                       00000B76            .60:
03235                       00000B76            .5F:
03236                       00000B76            .5C:
03237                                           ! 1172         else if (c == 'd') {
03238 0B76           E9         00A1            br 	.6C
03239                       00000B79            .55:
03240                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03241 0B79           8A46         FF            mov	al,-1[bp]
03242 0B7C           3C                     64  cmp	al,*$64
03243 0B7E           75           38            jne 	.6D
03244                       00000B80            .6E:
03245                                           ! 1173           if (arg & 0x8000)
03246                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$C] (used reg = )
03247 0B80           8B46         F6            mov	ax,-$A[bp]
03248 0B83           25                   8000  and	ax,#$8000
03249 0B86           85C0                       test	ax,ax
03250 0B88           74           1A            je  	.6F
03251                       00000B8A            .70:
03252                                           ! 1174             put_uint(action, -arg, format_width - 1, 1);
03253                                           ! Debug: list int = const 1 (used reg = )
03254 0B8A           B8                   0001  mov	ax,*1
03255 0B8D           50                         push	ax
03256                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03257 0B8E           8B46         F0            mov	ax,-$10[bp]
03258                                           ! Debug: list unsigned int = ax-1 (used reg = )
03259 0B91           48                         dec	ax
03260 0B92           50                         push	ax
03261                                           ! Debug: neg unsigned short arg = [S+$1C-$C] (used reg = )
03262 0B93           31C0                       xor	ax,ax
03263 0B95           2B46         F6            sub	ax,-$A[bp]
03264                                           ! Debug: list unsigned int = ax+0 (used reg = )
03265 0B98           50                         push	ax
03266                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03267 0B99           FF76         04            push	4[bp]
03268                                           ! Debug: func () void = put_uint+0 (used reg = )
03269 0B9C           E8         FB40            call	_put_uint
03270 0B9F           83C4                   08  add	sp,*8
03271                                           !BCC_EOS
03272                                           ! 1175           else
03273                                           ! 1176             put_uint(action, arg, format_width, 0);
03274 0BA2           EB           12            jmp .71
03275                       00000BA4            .6F:
03276                                           ! Debug: list int = const 0 (used reg = )
03277 0BA4           31C0                       xor	ax,ax
03278 0BA6           50                         push	ax
03279                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03280 0BA7           FF76         F0            push	-$10[bp]
03281                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03282 0BAA           FF76         F6            push	-$A[bp]
03283                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03284 0BAD           FF76         04            push	4[bp]
03285                                           ! Debug: func () void = put_uint+0 (used reg = )
03286 0BB0           E8         FB2C            call	_put_uint
03287 0BB3           83C4                   08  add	sp,*8
03288                                           !BCC_EOS
03289                                           ! 1177         }
03290                       00000BB6            .71:
03291                                           ! 1178         else if (c == 's') {
03292 0BB6           EB           62            jmp .72
03293                       00000BB8            .6D:
03294                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03295 0BB8           8A46         FF            mov	al,-1[bp]
03296 0BBB           3C                     73  cmp	al,*$73
03297 0BBD           75           12            jne 	.73
03298                       00000BBF            .74:
03299                                           ! 1179           put_str(action, get_CS(), arg);
03300                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03301 0BBF           FF76         F6            push	-$A[bp]
03302                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03303 0BC2           E8         FA92            call	_get_CS
03304                                           ! Debug: list unsigned short = ax+0 (used reg = )
03305 0BC5           50                         push	ax
03306                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03307 0BC6           FF76         04            push	4[bp]
03308                                           ! Debug: func () void = put_str+0 (used reg = )
03309 0BC9           E8         FC4D            call	_put_str
03310 0BCC           83C4                   06  add	sp,*6
03311                                           !BCC_EOS
03312                                           ! 1180         }
03313                                           ! 1181         else if (c == 'S') {
03314 0BCF           EB           49            jmp .75
03315                       00000BD1            .73:
03316                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03317 0BD1           8A46         FF            mov	al,-1[bp]
03318 0BD4           3C                     53  cmp	al,*$53
03319 0BD6           75           1F            jne 	.76
03320                       00000BD8            .77:
03321                                           ! 1182           arg_ptr++;
03322                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03323 0BD8           8B5E         F8            mov	bx,-8[bp]
03324 0BDB           43                         inc	bx
03325 0BDC           43                         inc	bx
03326 0BDD           895E         F8            mov	-8[bp],bx
03327                                           !BCC_EOS
03328                                           ! 1183           put_str(action, arg, read_word_SS(arg_ptr));
03329                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03330 0BE0           FF76         F8            push	-8[bp]
03331                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03332 0BE3           E8         FA46            call	_read_word_SS
03333 0BE6           44                         inc	sp
03334 0BE7           44                         inc	sp
03335                                           ! Debug: list unsigned short = ax+0 (used reg = )
03336 0BE8           50                         push	ax
03337                                           ! Debug: list unsigned short arg = [S+$1A-$C] (used reg = )
03338 0BE9           FF76         F6            push	-$A[bp]
03339                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03340 0BEC           FF76         04            push	4[bp]
03341                                           ! Debug: func () void = put_str+0 (used reg = )
03342 0BEF           E8         FC27            call	_put_str
03343 0BF2           83C4                   06  add	sp,*6
03344                                           !BCC_EOS
03345                                           ! 1184         }
03346                                           ! 1185         else if (c == 'c') {
03347 0BF5           EB           23            jmp .78
03348                       00000BF7            .76:
03349                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03350 0BF7           8A46         FF            mov	al,-1[bp]
03351 0BFA           3C                     63  cmp	al,*$63
03352 0BFC           75           0E            jne 	.79
03353                       00000BFE            .7A:
03354                                           ! 1186           send(action, arg);
03355                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03356 0BFE           FF76         F6            push	-$A[bp]
03357                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03358 0C01           FF76         04            push	4[bp]
03359                                           ! Debug: func () void = send+0 (used reg = )
03360 0C04           E8         FA7F            call	_send
03361 0C07           83C4                   04  add	sp,*4
03362                                           !BCC_EOS
03363                                           ! 1187         }
03364                                           ! 1188         else
03365                                           ! 1189           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03366 0C0A           EB           0E            jmp .7B
03367                       00000C0C            .79:
03368                                           ! Debug: list * char = .7C+0 (used reg = )
03369 0C0C           BB                   D9EF  mov	bx,#.7C
03370 0C0F           53                         push	bx
03371                                           ! Debug: list int = const 7 (used reg = )
03372 0C10           B8                   0007  mov	ax,*7
03373 0C13           50                         push	ax
03374                                           ! Debug: func () void = bios_printf+0 (used reg = )
03375 0C14           E8         FD22            call	_bios_printf
03376 0C17           83C4                   04  add	sp,*4
03377                                           !BCC_EOS
03378                                           ! 1190           in_format = 0;
03379                       00000C1A            .7B:
03380                       00000C1A            .78:
03381                       00000C1A            .75:
03382                       00000C1A            .72:
03383                       00000C1A            .6C:
03384                       00000C1A            .54:
03385                       00000C1A            .51:
03386                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03387 0C1A           31C0                       xor	ax,ax
03388 0C1C           8946         FC            mov	-4[bp],ax
03389                                           !BCC_EOS
03390                                           ! 1191       }
03391                                           ! 1192     }
03392                       00000C1F            .44:
03393                                           ! 1193     else {
03394 0C1F           EB           0F            jmp .7D
03395                       00000C21            .3F:
03396                                           ! 1194       send(action, c);
03397                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03398 0C21           8A46         FF            mov	al,-1[bp]
03399 0C24           30E4                       xor	ah,ah
03400 0C26           50                         push	ax
03401                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03402 0C27           FF76         04            push	4[bp]
03403                                           ! Debug: func () void = send+0 (used reg = )
03404 0C2A           E8         FA59            call	_send
03405 0C2D           83C4                   04  add	sp,*4
03406                                           !BCC_EOS
03407                                           ! 1195     }
03408                                           ! 1196     s ++;
03409                       00000C30            .7D:
03410                       00000C30            .3E:
03411                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03412 0C30           8B5E         06            mov	bx,6[bp]
03413 0C33           43                         inc	bx
03414 0C34           895E         06            mov	6[bp],bx
03415                                           !BCC_EOS
03416                                           ! 1197   }
03417                                           ! 1198   if (action & 1) {
03418                       00000C37            .3A:
03419 0C37           8B5E         06            mov	bx,6[bp]
03420                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03421 0C3A           8A07                       mov	al,[bx]
03422 0C3C           8846         FF            mov	-1[bp],al
03423 0C3F           84C0                       test	al,al
03424 0C41         0F85         FD40            bne 	.3B
03425                       00000C45            .7E:
03426                       00000C45            .39:
03427                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03428 0C45           8A46         04            mov	al,4[bp]
03429 0C48           24                     01  and	al,*1
03430 0C4A           84C0                       test	al,al
03431 0C4C           74           04            je  	.7F
03432                       00000C4E            .80:
03433                                           ! 1199 #asm
03434                                           !BCC_EOS
03435                                           !BCC_ASM
03436                       00000006            _bios_printf.format_width	set	6
03437                       FFFFFFF0            .bios_printf.format_width	set	-$10
03438                       00000014            _bios_printf.format_char	set	$14
03439                       FFFFFFFE            .bios_printf.format_char	set	-2
03440                       0000000E            _bios_printf.arg_ptr	set	$E
03441                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03442                       0000001A            _bios_printf.action	set	$1A
03443                       00000004            .bios_printf.action	set	4
03444                       00000010            _bios_printf.i	set	$10
03445                       FFFFFFFA            .bios_printf.i	set	-6
03446                       00000008            _bios_printf.shift_count	set	8
03447                       FFFFFFF2            .bios_printf.shift_count	set	-$E
03448                       00000012            _bios_printf.in_format	set	$12
03449                       FFFFFFFC            .bios_printf.in_format	set	-4
03450                       0000001C            _bios_printf.s	set	$1C
03451                       00000006            .bios_printf.s	set	6
03452                       00000000            _bios_printf.lval	set	0
03453                       FFFFFFEA            .bios_printf.lval	set	-$16
03454                       0000000A            _bios_printf.nibble	set	$A
03455                       FFFFFFF4            .bios_printf.nibble	set	-$C
03456                       00000015            _bios_printf.c	set	$15
03457                       FFFFFFFF            .bios_printf.c	set	-1
03458                       0000000C            _bios_printf.arg	set	$C
03459                       FFFFFFF6            .bios_printf.arg	set	-$A
03460                       00000004            _bios_printf.old_ds	set	4
03461                       FFFFFFEE            .bios_printf.old_ds	set	-$12
03462 0C4E           FA                             cli
03463                       00000C4F             halt2_loop:
03464 0C4F           F4                             hlt
03465 0C50           EB           FD                jmp halt2_loop
03466                                           ! 1204 endasm
03467                                           !BCC_ENDASM
03468                                           !BCC_EOS
03469                                           ! 1205   }
03470                                           ! 1206   set_DS(old_ds);
03471                       00000C52            .7F:
03472                                           ! Debug: list unsigned short old_ds = [S+$18-$14] (used reg = )
03473 0C52           FF76         EE            push	-$12[bp]
03474                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
03475 0C55           E8         FA05            call	_set_DS
03476 0C58           44                         inc	sp
03477 0C59           44                         inc	sp
03478                                           !BCC_EOS
03479                                           ! 1207 }
03480 0C5A           89EC                       mov	sp,bp
03481 0C5C           5D                         pop	bp
03482 0C5D           C3                         ret
03483                                           ! 1208   void
03484                                           ! Register BX used in function bios_printf
03485                                           ! 1209 keyboard_init()
03486                                           ! 1210 {
03487                                           export	_keyboard_init
03488                       00000C5E            _keyboard_init:
03489                                           ! 1211     Bit16u max;
03490                                           !BCC_EOS
03491                                           ! 1212     max=0xffff;
03492 0C5E           55                         push	bp
03493 0C5F           89E5                       mov	bp,sp
03494 0C61           4C                         dec	sp
03495 0C62           4C                         dec	sp
03496                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03497 0C63           B8                   FFFF  mov	ax,#$FFFF
03498 0C66           8946         FE            mov	-2[bp],ax
03499                                           !BCC_EOS
03500                                           ! 1213     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03501 0C69           EB           0D            jmp .82
03502                       00000C6B            .83:
03503                                           ! Debug: list int = const 0 (used reg = )
03504 0C6B           31C0                       xor	ax,ax
03505 0C6D           50                         push	ax
03506                                           ! Debug: list int = const $80 (used reg = )
03507 0C6E           B8                   0080  mov	ax,#$80
03508 0C71           50                         push	ax
03509                                           ! Debug: func () void = outb+0 (used reg = )
03510 0C72           E8         F8CA            call	_outb
03511 0C75           83C4                   04  add	sp,*4
03512                                           !BCC_EOS
03513                                           ! 1214     max=0x2000;
03514                       00000C78            .82:
03515                                           ! Debug: list int = const $64 (used reg = )
03516 0C78           B8                   0064  mov	ax,*$64
03517 0C7B           50                         push	ax
03518                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03519 0C7C           E8         F8AA            call	_inb
03520 0C7F           44                         inc	sp
03521 0C80           44                         inc	sp
03522                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03523 0C81           24                     02  and	al,*2
03524 0C83           84C0                       test	al,al
03525 0C85           74           0B            je  	.84
03526                       00000C87            .85:
03527                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03528 0C87           8B46         FE            mov	ax,-2[bp]
03529 0C8A           48                         dec	ax
03530 0C8B           8946         FE            mov	-2[bp],ax
03531                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03532 0C8E           85C0                       test	ax,ax
03533 0C90           75           D9            jne	.83
03534                       00000C92            .84:
03535                       00000C92            .81:
03536                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03537 0C92           B8                   2000  mov	ax,#$2000
03538 0C95           8946         FE            mov	-2[bp],ax
03539                                           !BCC_EOS
03540                                           ! 1215     while (--max > 0) {
03541 0C98           EB           2B            jmp .87
03542                       00000C9A            .88:
03543                                           ! 1216         outb(0x0080, 0x00);
03544                                           ! Debug: list int = const 0 (used reg = )
03545 0C9A           31C0                       xor	ax,ax
03546 0C9C           50                         push	ax
03547                                           ! Debug: list int = const $80 (used reg = )
03548 0C9D           B8                   0080  mov	ax,#$80
03549 0CA0           50                         push	ax
03550                                           ! Debug: func () void = outb+0 (used reg = )
03551 0CA1           E8         F89B            call	_outb
03552 0CA4           83C4                   04  add	sp,*4
03553                                           !BCC_EOS
03554                                           ! 1217         if (inb(0x0064) & 0x01) {
03555                                           ! Debug: list int = const $64 (used reg = )
03556 0CA7           B8                   0064  mov	ax,*$64
03557 0CAA           50                         push	ax
03558                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03559 0CAB           E8         F87B            call	_inb
03560 0CAE           44                         inc	sp
03561 0CAF           44                         inc	sp
03562                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03563 0CB0           24                     01  and	al,*1
03564 0CB2           84C0                       test	al,al
03565 0CB4           74           0F            je  	.89
03566                       00000CB6            .8A:
03567                                           ! 1218             inb(0x0060);
03568                                           ! Debug: list int = const $60 (used reg = )
03569 0CB6           B8                   0060  mov	ax,*$60
03570 0CB9           50                         push	ax
03571                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03572 0CBA           E8         F86C            call	_inb
03573 0CBD           44                         inc	sp
03574 0CBE           44                         inc	sp
03575                                           !BCC_EOS
03576                                           ! 1219             max = 0x2000;
03577                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03578 0CBF           B8                   2000  mov	ax,#$2000
03579 0CC2           8946         FE            mov	-2[bp],ax
03580                                           !BCC_EOS
03581                                           ! 1220         }
03582                                           ! 1221     }
03583                       00000CC5            .89:
03584                                           ! 1222     outb(0x0064, 0xaa);
03585                       00000CC5            .87:
03586                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03587 0CC5           8B46         FE            mov	ax,-2[bp]
03588 0CC8           48                         dec	ax
03589 0CC9           8946         FE            mov	-2[bp],ax
03590                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03591 0CCC           85C0                       test	ax,ax
03592 0CCE           75           CA            jne	.88
03593                       00000CD0            .8B:
03594                       00000CD0            .86:
03595                                           ! Debug: list int = const $AA (used reg = )
03596 0CD0           B8                   00AA  mov	ax,#$AA
03597 0CD3           50                         push	ax
03598                                           ! Debug: list int = const $64 (used reg = )
03599 0CD4           B8                   0064  mov	ax,*$64
03600 0CD7           50                         push	ax
03601                                           ! Debug: func () void = outb+0 (used reg = )
03602 0CD8           E8         F864            call	_outb
03603 0CDB           83C4                   04  add	sp,*4
03604                                           !BCC_EOS
03605                                           ! 1223     max=0xffff;
03606                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03607 0CDE           B8                   FFFF  mov	ax,#$FFFF
03608 0CE1           8946         FE            mov	-2[bp],ax
03609                                           !BCC_EOS
03610                                           ! 1224     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03611 0CE4           EB           0D            jmp .8D
03612                       00000CE6            .8E:
03613                                           ! Debug: list int = const 0 (used reg = )
03614 0CE6           31C0                       xor	ax,ax
03615 0CE8           50                         push	ax
03616                                           ! Debug: list int = const $80 (used reg = )
03617 0CE9           B8                   0080  mov	ax,#$80
03618 0CEC           50                         push	ax
03619                                           ! Debug: func () void = outb+0 (used reg = )
03620 0CED           E8         F84F            call	_outb
03621 0CF0           83C4                   04  add	sp,*4
03622                                           !BCC_EOS
03623                                           ! 1225     if (max==0x0) keyboard_panic(00);
03624                       00000CF3            .8D:
03625                                           ! Debug: list int = const $64 (used reg = )
03626 0CF3           B8                   0064  mov	ax,*$64
03627 0CF6           50                         push	ax
03628                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03629 0CF7           E8         F82F            call	_inb
03630 0CFA           44                         inc	sp
03631 0CFB           44                         inc	sp
03632                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03633 0CFC           24                     02  and	al,*2
03634 0CFE           84C0                       test	al,al
03635 0D00           74           0B            je  	.8F
03636                       00000D02            .90:
03637                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03638 0D02           8B46         FE            mov	ax,-2[bp]
03639 0D05           48                         dec	ax
03640 0D06           8946         FE            mov	-2[bp],ax
03641                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03642 0D09           85C0                       test	ax,ax
03643 0D0B           75           D9            jne	.8E
03644                       00000D0D            .8F:
03645                       00000D0D            .8C:
03646                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03647 0D0D           8B46         FE            mov	ax,-2[bp]
03648 0D10           85C0                       test	ax,ax
03649 0D12           75           08            jne 	.91
03650                       00000D14            .92:
03651                                           ! Debug: list int = const 0 (used reg = )
03652 0D14           31C0                       xor	ax,ax
03653 0D16           50                         push	ax
03654                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03655 0D17           E8         0488            call	_keyboard_panic
03656 0D1A           44                         inc	sp
03657 0D1B           44                         inc	sp
03658                                           !BCC_EOS
03659                                           ! 1226     max=0xffff;
03660                       00000D1C            .91:
03661                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03662 0D1C           B8                   FFFF  mov	ax,#$FFFF
03663 0D1F           8946         FE            mov	-2[bp],ax
03664                                           !BCC_EOS
03665                                           ! 1227     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x01);
03666 0D22           EB           0E            jmp .94
03667                       00000D24            .95:
03668                                           ! Debug: list int = const 1 (used reg = )
03669 0D24           B8                   0001  mov	ax,*1
03670 0D27           50                         push	ax
03671                                           ! Debug: list int = const $80 (used reg = )
03672 0D28           B8                   0080  mov	ax,#$80
03673 0D2B           50                         push	ax
03674                                           ! Debug: func () void = outb+0 (used reg = )
03675 0D2C           E8         F810            call	_outb
03676 0D2F           83C4                   04  add	sp,*4
03677                                           !BCC_EOS
03678                                           ! 1228     if (max==0x0) keyboard_panic(01);
03679                       00000D32            .94:
03680                                           ! Debug: list int = const $64 (used reg = )
03681 0D32           B8                   0064  mov	ax,*$64
03682 0D35           50                         push	ax
03683                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03684 0D36           E8         F7F0            call	_inb
03685 0D39           44                         inc	sp
03686 0D3A           44                         inc	sp
03687                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03688 0D3B           24                     01  and	al,*1
03689                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03690 0D3D           84C0                       test	al,al
03691 0D3F           75           0B            jne 	.96
03692                       00000D41            .97:
03693                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03694 0D41           8B46         FE            mov	ax,-2[bp]
03695 0D44           48                         dec	ax
03696 0D45           8946         FE            mov	-2[bp],ax
03697                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03698 0D48           85C0                       test	ax,ax
03699 0D4A           75           D8            jne	.95
03700                       00000D4C            .96:
03701                       00000D4C            .93:
03702                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03703 0D4C           8B46         FE            mov	ax,-2[bp]
03704 0D4F           85C0                       test	ax,ax
03705 0D51           75           09            jne 	.98
03706                       00000D53            .99:
03707                                           ! Debug: list int = const 1 (used reg = )
03708 0D53           B8                   0001  mov	ax,*1
03709 0D56           50                         push	ax
03710                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03711 0D57           E8         0448            call	_keyboard_panic
03712 0D5A           44                         inc	sp
03713 0D5B           44                         inc	sp
03714                                           !BCC_EOS
03715                                           ! 1229     if ((inb(0x0060) != 0x55)){
03716                       00000D5C            .98:
03717                                           ! Debug: list int = const $60 (used reg = )
03718 0D5C           B8                   0060  mov	ax,*$60
03719 0D5F           50                         push	ax
03720                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03721 0D60           E8         F7C6            call	_inb
03722 0D63           44                         inc	sp
03723 0D64           44                         inc	sp
03724                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03725 0D65           3C                     55  cmp	al,*$55
03726 0D67           74           09            je  	.9A
03727                       00000D69            .9B:
03728                                           ! 1230         keyboard_panic(991);
03729                                           ! Debug: list int = const $3DF (used reg = )
03730 0D69           B8                   03DF  mov	ax,#$3DF
03731 0D6C           50                         push	ax
03732                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03733 0D6D           E8         0432            call	_keyboard_panic
03734 0D70           44                         inc	sp
03735 0D71           44                         inc	sp
03736                                           !BCC_EOS
03737                                           ! 1231     }
03738                                           ! 1232     outb(0x0064,0xab);
03739                       00000D72            .9A:
03740                                           ! Debug: list int = const $AB (used reg = )
03741 0D72           B8                   00AB  mov	ax,#$AB
03742 0D75           50                         push	ax
03743                                           ! Debug: list int = const $64 (used reg = )
03744 0D76           B8                   0064  mov	ax,*$64
03745 0D79           50                         push	ax
03746                                           ! Debug: func () void = outb+0 (used reg = )
03747 0D7A           E8         F7C2            call	_outb
03748 0D7D           83C4                   04  add	sp,*4
03749                                           !BCC_EOS
03750                                           ! 1233     max=0xffff;
03751                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03752 0D80           B8                   FFFF  mov	ax,#$FFFF
03753 0D83           8946         FE            mov	-2[bp],ax
03754                                           !BCC_EOS
03755                                           ! 1234     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03756 0D86           EB           0E            jmp .9D
03757                       00000D88            .9E:
03758                                           ! Debug: list int = const $10 (used reg = )
03759 0D88           B8                   0010  mov	ax,*$10
03760 0D8B           50                         push	ax
03761                                           ! Debug: list int = const $80 (used reg = )
03762 0D8C           B8                   0080  mov	ax,#$80
03763 0D8F           50                         push	ax
03764                                           ! Debug: func () void = outb+0 (used reg = )
03765 0D90           E8         F7AC            call	_outb
03766 0D93           83C4                   04  add	sp,*4
03767                                           !BCC_EOS
03768                                           ! 1235     if (max==0x0) keyboard_panic(10);
03769                       00000D96            .9D:
03770                                           ! Debug: list int = const $64 (used reg = )
03771 0D96           B8                   0064  mov	ax,*$64
03772 0D99           50                         push	ax
03773                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03774 0D9A           E8         F78C            call	_inb
03775 0D9D           44                         inc	sp
03776 0D9E           44                         inc	sp
03777                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03778 0D9F           24                     02  and	al,*2
03779 0DA1           84C0                       test	al,al
03780 0DA3           74           0B            je  	.9F
03781                       00000DA5            .A0:
03782                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03783 0DA5           8B46         FE            mov	ax,-2[bp]
03784 0DA8           48                         dec	ax
03785 0DA9           8946         FE            mov	-2[bp],ax
03786                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03787 0DAC           85C0                       test	ax,ax
03788 0DAE           75           D8            jne	.9E
03789                       00000DB0            .9F:
03790                       00000DB0            .9C:
03791                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03792 0DB0           8B46         FE            mov	ax,-2[bp]
03793 0DB3           85C0                       test	ax,ax
03794 0DB5           75           09            jne 	.A1
03795                       00000DB7            .A2:
03796                                           ! Debug: list int = const $A (used reg = )
03797 0DB7           B8                   000A  mov	ax,*$A
03798 0DBA           50                         push	ax
03799                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03800 0DBB           E8         03E4            call	_keyboard_panic
03801 0DBE           44                         inc	sp
03802 0DBF           44                         inc	sp
03803                                           !BCC_EOS
03804                                           ! 1236     max=0xffff;
03805                       00000DC0            .A1:
03806                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03807 0DC0           B8                   FFFF  mov	ax,#$FFFF
03808 0DC3           8946         FE            mov	-2[bp],ax
03809                                           !BCC_EOS
03810                                           ! 1237     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x11);
03811 0DC6           EB           0E            jmp .A4
03812                       00000DC8            .A5:
03813                                           ! Debug: list int = const $11 (used reg = )
03814 0DC8           B8                   0011  mov	ax,*$11
03815 0DCB           50                         push	ax
03816                                           ! Debug: list int = const $80 (used reg = )
03817 0DCC           B8                   0080  mov	ax,#$80
03818 0DCF           50                         push	ax
03819                                           ! Debug: func () void = outb+0 (used reg = )
03820 0DD0           E8         F76C            call	_outb
03821 0DD3           83C4                   04  add	sp,*4
03822                                           !BCC_EOS
03823                                           ! 1238     if (max==0x0) keyboard_panic(11);
03824                       00000DD6            .A4:
03825                                           ! Debug: list int = const $64 (used reg = )
03826 0DD6           B8                   0064  mov	ax,*$64
03827 0DD9           50                         push	ax
03828                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03829 0DDA           E8         F74C            call	_inb
03830 0DDD           44                         inc	sp
03831 0DDE           44                         inc	sp
03832                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03833 0DDF           24                     01  and	al,*1
03834                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03835 0DE1           84C0                       test	al,al
03836 0DE3           75           0B            jne 	.A6
03837                       00000DE5            .A7:
03838                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03839 0DE5           8B46         FE            mov	ax,-2[bp]
03840 0DE8           48                         dec	ax
03841 0DE9           8946         FE            mov	-2[bp],ax
03842                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03843 0DEC           85C0                       test	ax,ax
03844 0DEE           75           D8            jne	.A5
03845                       00000DF0            .A6:
03846                       00000DF0            .A3:
03847                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03848 0DF0           8B46         FE            mov	ax,-2[bp]
03849 0DF3           85C0                       test	ax,ax
03850 0DF5           75           09            jne 	.A8
03851                       00000DF7            .A9:
03852                                           ! Debug: list int = const $B (used reg = )
03853 0DF7           B8                   000B  mov	ax,*$B
03854 0DFA           50                         push	ax
03855                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03856 0DFB           E8         03A4            call	_keyboard_panic
03857 0DFE           44                         inc	sp
03858 0DFF           44                         inc	sp
03859                                           !BCC_EOS
03860                                           ! 1239     if ((inb(0x0060) != 0x00)) {
03861                       00000E00            .A8:
03862                                           ! Debug: list int = const $60 (used reg = )
03863 0E00           B8                   0060  mov	ax,*$60
03864 0E03           50                         push	ax
03865                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03866 0E04           E8         F722            call	_inb
03867 0E07           44                         inc	sp
03868 0E08           44                         inc	sp
03869                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03870 0E09           84C0                       test	al,al
03871 0E0B           74           09            je  	.AA
03872                       00000E0D            .AB:
03873                                           ! 1240         keyboard_panic(992);
03874                                           ! Debug: list int = const $3E0 (used reg = )
03875 0E0D           B8                   03E0  mov	ax,#$3E0
03876 0E10           50                         push	ax
03877                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03878 0E11           E8         038E            call	_keyboard_panic
03879 0E14           44                         inc	sp
03880 0E15           44                         inc	sp
03881                                           !BCC_EOS
03882                                           ! 1241     }
03883                                           ! 1242     outb(0x0064,0xae);
03884                       00000E16            .AA:
03885                                           ! Debug: list int = const $AE (used reg = )
03886 0E16           B8                   00AE  mov	ax,#$AE
03887 0E19           50                         push	ax
03888                                           ! Debug: list int = const $64 (used reg = )
03889 0E1A           B8                   0064  mov	ax,*$64
03890 0E1D           50                         push	ax
03891                                           ! Debug: func () void = outb+0 (used reg = )
03892 0E1E           E8         F71E            call	_outb
03893 0E21           83C4                   04  add	sp,*4
03894                                           !BCC_EOS
03895                                           ! 1243     max=0xffff;
03896                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03897 0E24           B8                   FFFF  mov	ax,#$FFFF
03898 0E27           8946         FE            mov	-2[bp],ax
03899                                           !BCC_EOS
03900                                           ! 1244     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03901 0E2A           EB           0E            jmp .AD
03902                       00000E2C            .AE:
03903                                           ! Debug: list int = const $10 (used reg = )
03904 0E2C           B8                   0010  mov	ax,*$10
03905 0E2F           50                         push	ax
03906                                           ! Debug: list int = const $80 (used reg = )
03907 0E30           B8                   0080  mov	ax,#$80
03908 0E33           50                         push	ax
03909                                           ! Debug: func () void = outb+0 (used reg = )
03910 0E34           E8         F708            call	_outb
03911 0E37           83C4                   04  add	sp,*4
03912                                           !BCC_EOS
03913                                           ! 1245     if (max==0x0) keyboard_panic(10);
03914                       00000E3A            .AD:
03915                                           ! Debug: list int = const $64 (used reg = )
03916 0E3A           B8                   0064  mov	ax,*$64
03917 0E3D           50                         push	ax
03918                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03919 0E3E           E8         F6E8            call	_inb
03920 0E41           44                         inc	sp
03921 0E42           44                         inc	sp
03922                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03923 0E43           24                     02  and	al,*2
03924 0E45           84C0                       test	al,al
03925 0E47           74           0B            je  	.AF
03926                       00000E49            .B0:
03927                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03928 0E49           8B46         FE            mov	ax,-2[bp]
03929 0E4C           48                         dec	ax
03930 0E4D           8946         FE            mov	-2[bp],ax
03931                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03932 0E50           85C0                       test	ax,ax
03933 0E52           75           D8            jne	.AE
03934                       00000E54            .AF:
03935                       00000E54            .AC:
03936                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03937 0E54           8B46         FE            mov	ax,-2[bp]
03938 0E57           85C0                       test	ax,ax
03939 0E59           75           09            jne 	.B1
03940                       00000E5B            .B2:
03941                                           ! Debug: list int = const $A (used reg = )
03942 0E5B           B8                   000A  mov	ax,*$A
03943 0E5E           50                         push	ax
03944                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03945 0E5F           E8         0340            call	_keyboard_panic
03946 0E62           44                         inc	sp
03947 0E63           44                         inc	sp
03948                                           !BCC_EOS
03949                                           ! 1246     ou
03950                                           ! 1246 tb(0x0064,0xa8);
03951                       00000E64            .B1:
03952                                           ! Debug: list int = const $A8 (used reg = )
03953 0E64           B8                   00A8  mov	ax,#$A8
03954 0E67           50                         push	ax
03955                                           ! Debug: list int = const $64 (used reg = )
03956 0E68           B8                   0064  mov	ax,*$64
03957 0E6B           50                         push	ax
03958                                           ! Debug: func () void = outb+0 (used reg = )
03959 0E6C           E8         F6D0            call	_outb
03960 0E6F           83C4                   04  add	sp,*4
03961                                           !BCC_EOS
03962                                           ! 1247     max=0xffff;
03963                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03964 0E72           B8                   FFFF  mov	ax,#$FFFF
03965 0E75           8946         FE            mov	-2[bp],ax
03966                                           !BCC_EOS
03967                                           ! 1248     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03968 0E78           EB           0E            jmp .B4
03969                       00000E7A            .B5:
03970                                           ! Debug: list int = const $10 (used reg = )
03971 0E7A           B8                   0010  mov	ax,*$10
03972 0E7D           50                         push	ax
03973                                           ! Debug: list int = const $80 (used reg = )
03974 0E7E           B8                   0080  mov	ax,#$80
03975 0E81           50                         push	ax
03976                                           ! Debug: func () void = outb+0 (used reg = )
03977 0E82           E8         F6BA            call	_outb
03978 0E85           83C4                   04  add	sp,*4
03979                                           !BCC_EOS
03980                                           ! 1249     if (max==0x0) keyboard_panic(10);
03981                       00000E88            .B4:
03982                                           ! Debug: list int = const $64 (used reg = )
03983 0E88           B8                   0064  mov	ax,*$64
03984 0E8B           50                         push	ax
03985                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03986 0E8C           E8         F69A            call	_inb
03987 0E8F           44                         inc	sp
03988 0E90           44                         inc	sp
03989                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03990 0E91           24                     02  and	al,*2
03991 0E93           84C0                       test	al,al
03992 0E95           74           0B            je  	.B6
03993                       00000E97            .B7:
03994                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03995 0E97           8B46         FE            mov	ax,-2[bp]
03996 0E9A           48                         dec	ax
03997 0E9B           8946         FE            mov	-2[bp],ax
03998                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03999 0E9E           85C0                       test	ax,ax
04000 0EA0           75           D8            jne	.B5
04001                       00000EA2            .B6:
04002                       00000EA2            .B3:
04003                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04004 0EA2           8B46         FE            mov	ax,-2[bp]
04005 0EA5           85C0                       test	ax,ax
04006 0EA7           75           09            jne 	.B8
04007                       00000EA9            .B9:
04008                                           ! Debug: list int = const $A (used reg = )
04009 0EA9           B8                   000A  mov	ax,*$A
04010 0EAC           50                         push	ax
04011                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04012 0EAD           E8         02F2            call	_keyboard_panic
04013 0EB0           44                         inc	sp
04014 0EB1           44                         inc	sp
04015                                           !BCC_EOS
04016                                           ! 1250     outb(0x0060, 0xff);
04017                       00000EB2            .B8:
04018                                           ! Debug: list int = const $FF (used reg = )
04019 0EB2           B8                   00FF  mov	ax,#$FF
04020 0EB5           50                         push	ax
04021                                           ! Debug: list int = const $60 (used reg = )
04022 0EB6           B8                   0060  mov	ax,*$60
04023 0EB9           50                         push	ax
04024                                           ! Debug: func () void = outb+0 (used reg = )
04025 0EBA           E8         F682            call	_outb
04026 0EBD           83C4                   04  add	sp,*4
04027                                           !BCC_EOS
04028                                           ! 1251     max=0xffff;
04029                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04030 0EC0           B8                   FFFF  mov	ax,#$FFFF
04031 0EC3           8946         FE            mov	-2[bp],ax
04032                                           !BCC_EOS
04033                                           ! 1252     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x20);
04034 0EC6           EB           0E            jmp .BB
04035                       00000EC8            .BC:
04036                                           ! Debug: list int = const $20 (used reg = )
04037 0EC8           B8                   0020  mov	ax,*$20
04038 0ECB           50                         push	ax
04039                                           ! Debug: list int = const $80 (used reg = )
04040 0ECC           B8                   0080  mov	ax,#$80
04041 0ECF           50                         push	ax
04042                                           ! Debug: func () void = outb+0 (used reg = )
04043 0ED0           E8         F66C            call	_outb
04044 0ED3           83C4                   04  add	sp,*4
04045                                           !BCC_EOS
04046                                           ! 1253     if (max==0x0) keyboard_panic(20);
04047                       00000ED6            .BB:
04048                                           ! Debug: list int = const $64 (used reg = )
04049 0ED6           B8                   0064  mov	ax,*$64
04050 0ED9           50                         push	ax
04051                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04052 0EDA           E8         F64C            call	_inb
04053 0EDD           44                         inc	sp
04054 0EDE           44                         inc	sp
04055                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04056 0EDF           24                     02  and	al,*2
04057 0EE1           84C0                       test	al,al
04058 0EE3           74           0B            je  	.BD
04059                       00000EE5            .BE:
04060                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04061 0EE5           8B46         FE            mov	ax,-2[bp]
04062 0EE8           48                         dec	ax
04063 0EE9           8946         FE            mov	-2[bp],ax
04064                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04065 0EEC           85C0                       test	ax,ax
04066 0EEE           75           D8            jne	.BC
04067                       00000EF0            .BD:
04068                       00000EF0            .BA:
04069                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04070 0EF0           8B46         FE            mov	ax,-2[bp]
04071 0EF3           85C0                       test	ax,ax
04072 0EF5           75           09            jne 	.BF
04073                       00000EF7            .C0:
04074                                           ! Debug: list int = const $14 (used reg = )
04075 0EF7           B8                   0014  mov	ax,*$14
04076 0EFA           50                         push	ax
04077                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04078 0EFB           E8         02A4            call	_keyboard_panic
04079 0EFE           44                         inc	sp
04080 0EFF           44                         inc	sp
04081                                           !BCC_EOS
04082                                           ! 1254     max=0xffff;
04083                       00000F00            .BF:
04084                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04085 0F00           B8                   FFFF  mov	ax,#$FFFF
04086 0F03           8946         FE            mov	-2[bp],ax
04087                                           !BCC_EOS
04088                                           ! 1255     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x21);
04089 0F06           EB           0E            jmp .C2
04090                       00000F08            .C3:
04091                                           ! Debug: list int = const $21 (used reg = )
04092 0F08           B8                   0021  mov	ax,*$21
04093 0F0B           50                         push	ax
04094                                           ! Debug: list int = const $80 (used reg = )
04095 0F0C           B8                   0080  mov	ax,#$80
04096 0F0F           50                         push	ax
04097                                           ! Debug: func () void = outb+0 (used reg = )
04098 0F10           E8         F62C            call	_outb
04099 0F13           83C4                   04  add	sp,*4
04100                                           !BCC_EOS
04101                                           ! 1256     if (max==0x0) keyboard_panic(21);
04102                       00000F16            .C2:
04103                                           ! Debug: list int = const $64 (used reg = )
04104 0F16           B8                   0064  mov	ax,*$64
04105 0F19           50                         push	ax
04106                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04107 0F1A           E8         F60C            call	_inb
04108 0F1D           44                         inc	sp
04109 0F1E           44                         inc	sp
04110                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04111 0F1F           24                     01  and	al,*1
04112                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04113 0F21           84C0                       test	al,al
04114 0F23           75           0B            jne 	.C4
04115                       00000F25            .C5:
04116                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04117 0F25           8B46         FE            mov	ax,-2[bp]
04118 0F28           48                         dec	ax
04119 0F29           8946         FE            mov	-2[bp],ax
04120                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04121 0F2C           85C0                       test	ax,ax
04122 0F2E           75           D8            jne	.C3
04123                       00000F30            .C4:
04124                       00000F30            .C1:
04125                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04126 0F30           8B46         FE            mov	ax,-2[bp]
04127 0F33           85C0                       test	ax,ax
04128 0F35           75           09            jne 	.C6
04129                       00000F37            .C7:
04130                                           ! Debug: list int = const $15 (used reg = )
04131 0F37           B8                   0015  mov	ax,*$15
04132 0F3A           50                         push	ax
04133                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04134 0F3B           E8         0264            call	_keyboard_panic
04135 0F3E           44                         inc	sp
04136 0F3F           44                         inc	sp
04137                                           !BCC_EOS
04138                                           ! 1257     if ((inb(0x0060) != 0xfa)) {
04139                       00000F40            .C6:
04140                                           ! Debug: list int = const $60 (used reg = )
04141 0F40           B8                   0060  mov	ax,*$60
04142 0F43           50                         push	ax
04143                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04144 0F44           E8         F5E2            call	_inb
04145 0F47           44                         inc	sp
04146 0F48           44                         inc	sp
04147                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04148 0F49           3C                     FA  cmp	al,#$FA
04149 0F4B           74           09            je  	.C8
04150                       00000F4D            .C9:
04151                                           ! 1258         keyboard_panic(993);
04152                                           ! Debug: list int = const $3E1 (used reg = )
04153 0F4D           B8                   03E1  mov	ax,#$3E1
04154 0F50           50                         push	ax
04155                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04156 0F51           E8         024E            call	_keyboard_panic
04157 0F54           44                         inc	sp
04158 0F55           44                         inc	sp
04159                                           !BCC_EOS
04160                                           ! 1259     }
04161                                           ! 1260     max=0xffff;
04162                       00000F56            .C8:
04163                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04164 0F56           B8                   FFFF  mov	ax,#$FFFF
04165 0F59           8946         FE            mov	-2[bp],ax
04166                                           !BCC_EOS
04167                                           ! 1261     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x31);
04168 0F5C           EB           0E            jmp .CB
04169                       00000F5E            .CC:
04170                                           ! Debug: list int = const $31 (used reg = )
04171 0F5E           B8                   0031  mov	ax,*$31
04172 0F61           50                         push	ax
04173                                           ! Debug: list int = const $80 (used reg = )
04174 0F62           B8                   0080  mov	ax,#$80
04175 0F65           50                         push	ax
04176                                           ! Debug: func () void = outb+0 (used reg = )
04177 0F66           E8         F5D6            call	_outb
04178 0F69           83C4                   04  add	sp,*4
04179                                           !BCC_EOS
04180                                           ! 1262     if (max==0x0) keyboard_panic(31);
04181                       00000F6C            .CB:
04182                                           ! Debug: list int = const $64 (used reg = )
04183 0F6C           B8                   0064  mov	ax,*$64
04184 0F6F           50                         push	ax
04185                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04186 0F70           E8         F5B6            call	_inb
04187 0F73           44                         inc	sp
04188 0F74           44                         inc	sp
04189                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04190 0F75           24                     01  and	al,*1
04191                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04192 0F77           84C0                       test	al,al
04193 0F79           75           0B            jne 	.CD
04194                       00000F7B            .CE:
04195                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04196 0F7B           8B46         FE            mov	ax,-2[bp]
04197 0F7E           48                         dec	ax
04198 0F7F           8946         FE            mov	-2[bp],ax
04199                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04200 0F82           85C0                       test	ax,ax
04201 0F84           75           D8            jne	.CC
04202                       00000F86            .CD:
04203                       00000F86            .CA:
04204                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04205 0F86           8B46         FE            mov	ax,-2[bp]
04206 0F89           85C0                       test	ax,ax
04207 0F8B           75           09            jne 	.CF
04208                       00000F8D            .D0:
04209                                           ! Debug: list int = const $1F (used reg = )
04210 0F8D           B8                   001F  mov	ax,*$1F
04211 0F90           50                         push	ax
04212                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04213 0F91           E8         020E            call	_keyboard_panic
04214 0F94           44                         inc	sp
04215 0F95           44                         inc	sp
04216                                           !BCC_EOS
04217                                           ! 1263     if ((inb(0x0060) != 0xaa)) {
04218                       00000F96            .CF:
04219                                           ! Debug: list int = const $60 (used reg = )
04220 0F96           B8                   0060  mov	ax,*$60
04221 0F99           50                         push	ax
04222                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04223 0F9A           E8         F58C            call	_inb
04224 0F9D           44                         inc	sp
04225 0F9E           44                         inc	sp
04226                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04227 0F9F           3C                     AA  cmp	al,#$AA
04228 0FA1           74           09            je  	.D1
04229                       00000FA3            .D2:
04230                                           ! 1264         keyboard_panic(994);
04231                                           ! Debug: list int = const $3E2 (used reg = )
04232 0FA3           B8                   03E2  mov	ax,#$3E2
04233 0FA6           50                         push	ax
04234                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04235 0FA7           E8         01F8            call	_keyboard_panic
04236 0FAA           44                         inc	sp
04237 0FAB           44                         inc	sp
04238                                           !BCC_EOS
04239                                           ! 1265     }
04240                                           ! 1266     outb(0x0060, 0xf5);
04241                       00000FAC            .D1:
04242                                           ! Debug: list int = const $F5 (used reg = )
04243 0FAC           B8                   00F5  mov	ax,#$F5
04244 0FAF           50                         push	ax
04245                                           ! Debug: list int = const $60 (used reg = )
04246 0FB0           B8                   0060  mov	ax,*$60
04247 0FB3           50                         push	ax
04248                                           ! Debug: func () void = outb+0 (used reg = )
04249 0FB4           E8         F588            call	_outb
04250 0FB7           83C4                   04  add	sp,*4
04251                                           !BCC_EOS
04252                                           ! 1267     max=0xffff;
04253                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04254 0FBA           B8                   FFFF  mov	ax,#$FFFF
04255 0FBD           8946         FE            mov	-2[bp],ax
04256                                           !BCC_EOS
04257                                           ! 1268     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x40);
04258 0FC0           EB           0E            jmp .D4
04259                       00000FC2            .D5:
04260                                           ! Debug: list int = const $40 (used reg = )
04261 0FC2           B8                   0040  mov	ax,*$40
04262 0FC5           50                         push	ax
04263                                           ! Debug: list int = const $80 (used reg = )
04264 0FC6           B8                   0080  mov	ax,#$80
04265 0FC9           50                         push	ax
04266                                           ! Debug: func () void = outb+0 (used reg = )
04267 0FCA           E8         F572            call	_outb
04268 0FCD           83C4                   04  add	sp,*4
04269                                           !BCC_EOS
04270                                           ! 1269     if (max==0x0) keyboard_panic(40);
04271                       00000FD0            .D4:
04272                                           ! Debug: list int = const $64 (used reg = )
04273 0FD0           B8                   0064  mov	ax,*$64
04274 0FD3           50                         push	ax
04275                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04276 0FD4           E8         F552            call	_inb
04277 0FD7           44                         inc	sp
04278 0FD8           44                         inc	sp
04279                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04280 0FD9           24                     02  and	al,*2
04281 0FDB           84C0                       test	al,al
04282 0FDD           74           0B            je  	.D6
04283                       00000FDF            .D7:
04284                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04285 0FDF           8B46         FE            mov	ax,-2[bp]
04286 0FE2           48                         dec	ax
04287 0FE3           8946         FE            mov	-2[bp],ax
04288                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04289 0FE6           85C0                       test	ax,ax
04290 0FE8           75           D8            jne	.D5
04291                       00000FEA            .D6:
04292                       00000FEA            .D3:
04293                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04294 0FEA           8B46         FE            mov	ax,-2[bp]
04295 0FED           85C0                       test	ax,ax
04296 0FEF           75           09            jne 	.D8
04297                       00000FF1            .D9:
04298                                           ! Debug: list int = const $28 (used reg = )
04299 0FF1           B8                   0028  mov	ax,*$28
04300 0FF4           50                         push	ax
04301                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04302 0FF5           E8         01AA            call	_keyboard_panic
04303 0FF8           44                         inc	sp
04304 0FF9           44                         inc	sp
04305                                           !BCC_EOS
04306                                           ! 1270     max=0xffff;
04307                       00000FFA            .D8:
04308                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04309 0FFA           B8                   FFFF  mov	ax,#$FFFF
04310 0FFD           8946         FE            mov	-2[bp],ax
04311                                           !BCC_EOS
04312                                           ! 1271     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x41);
04313 1000           EB           0E            jmp .DB
04314                       00001002            .DC:
04315                                           ! Debug: list int = const $41 (used reg = )
04316 1002           B8                   0041  mov	ax,*$41
04317 1005           50                         push	ax
04318                                           ! Debug: list int = const $80 (used reg = )
04319 1006           B8                   0080  mov	ax,#$80
04320 1009           50                         push	ax
04321                                           ! Debug: func () void = outb+0 (used reg = )
04322 100A           E8         F532            call	_outb
04323 100D           83C4                   04  add	sp,*4
04324                                           !BCC_EOS
04325                                           ! 1272     if (max==0x0) keyboard_panic(41);
04326                       00001010            .DB:
04327                                           ! Debug: list int = const $64 (used reg = )
04328 1010           B8                   0064  mov	ax,*$64
04329 1013           50                         push	ax
04330                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04331 1014           E8         F512            call	_inb
04332 1017           44                         inc	sp
04333 1018           44                         inc	sp
04334                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04335 1019           24                     01  and	al,*1
04336                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04337 101B           84C0                       test	al,al
04338 101D           75           0B            jne 	.DD
04339                       0000101F            .DE:
04340                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04341 101F           8B46         FE            mov	ax,-2[bp]
04342 1022           48                         dec	ax
04343 1023           8946         FE            mov	-2[bp],ax
04344                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04345 1026           85C0                       test	ax,ax
04346 1028           75           D8            jne	.DC
04347                       0000102A            .DD:
04348                       0000102A            .DA:
04349                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04350 102A           8B46         FE            mov	ax,-2[bp]
04351 102D           85C0                       test	ax,ax
04352 102F           75           09            jne 	.DF
04353                       00001031            .E0:
04354                                           ! Debug: list int = const $29 (used reg = )
04355 1031           B8                   0029  mov	ax,*$29
04356 1034           50                         push	ax
04357                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04358 1035           E8         016A            call	_keyboard_panic
04359 1038           44                         inc	sp
04360 1039           44                         inc	sp
04361                                           !BCC_EOS
04362                                           ! 1273     if ((inb(0x0060) != 0xfa)) {
04363                       0000103A            .DF:
04364                                           ! Debug: list int = const $60 (used reg = )
04365 103A           B8                   0060  mov	ax,*$60
04366 103D           50                         push	ax
04367                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04368 103E           E8         F4E8            call	_inb
04369 1041           44                         inc	sp
04370 1042           44                         inc	sp
04371                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04372 1043           3C                     FA  cmp	al,#$FA
04373 1045           74           09            je  	.E1
04374                       00001047            .E2:
04375                                           ! 1274         keyboard_panic(995);
04376                                           ! Debug: list int = const $3E3 (used reg = )
04377 1047           B8                   03E3  mov	ax,#$3E3
04378 104A           50                         push	ax
04379                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04380 104B           E8         0154            call	_keyboard_panic
04381 104E           44                         inc	sp
04382 104F           44                         inc	sp
04383                                           !BCC_EOS
04384                                           ! 1275     }
04385                                           ! 1276     outb(0x0064, 0x60);
04386                       00001050            .E1:
04387                                           ! Debug: list int = const $60 (used reg = )
04388 1050           B8                   0060  mov	ax,*$60
04389 1053           50                         push	ax
04390                                           ! Debug: list int = const $64 (used reg = )
04391 1054           B8                   0064  mov	ax,*$64
04392 1057           50                         push	ax
04393                                           ! Debug: func () void = outb+0 (used reg = )
04394 1058           E8         F4E4            call	_outb
04395 105B           83C4                   04  add	sp,*4
04396                                           !BCC_EOS
04397                                           ! 1277     max=0xffff;
04398                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04399 105E           B8                   FFFF  mov	ax,#$FFFF
04400 1061           8946         FE            mov	-2[bp],ax
04401                                           !BCC_EOS
04402                                           ! 1278     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x50);
04403 1064           EB           0E            jmp .E4
04404                       00001066            .E5:
04405                                           ! Debug: list int = const $50 (used reg = )
04406 1066           B8                   0050  mov	ax,*$50
04407 1069           50                         push	ax
04408                                           ! Debug: list int = const $80 (used reg = )
04409 106A           B8                   0080  mov	ax,#$80
04410 106D           50                         push	ax
04411                                           ! Debug: func () void = outb+0 (used reg = )
04412 106E           E8         F4CE            call	_outb
04413 1071           83C4                   04  add	sp,*4
04414                                           !BCC_EOS
04415                                           ! 1279     if (max==0x0) keyboard_panic(50);
04416                       00001074            .E4:
04417                                           ! Debug: list int = const $64 (used reg = )
04418 1074           B8                   0064  mov	ax,*$64
04419 1077           50                         push	ax
04420                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04421 1078           E8         F4AE            call	_inb
04422 107B           44                         inc	sp
04423 107C           44                         inc	sp
04424                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04425 107D           24                     02  and	al,*2
04426 107F           84C0                       test	al,al
04427 1081           74           0B            je  	.E6
04428                       00001083            .E7:
04429                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04430 1083           8B46         FE            mov	ax,-2[bp]
04431 1086           48                         dec	ax
04432 1087           8946         FE            mov	-2[bp],ax
04433                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04434 108A           85C0                       test	ax,ax
04435 108C           75           D8            jne	.E5
04436                       0000108E            .E6:
04437                       0000108E            .E3:
04438                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04439 108E           8B46         FE            mov	ax,-2[bp]
04440 1091           85C0                       test	ax,ax
04441 1093           75           09            jne 	.E8
04442                       00001095            .E9:
04443                                           ! Debug: list int = const $32 (used reg = )
04444 1095           B8                   0032  mov	ax,*$32
04445 1098           50                         push	ax
04446                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04447 1099           E8         0106            call	_keyboard_panic
04448 109C           44                         inc	sp
04449 109D           44                         inc	sp
04450                                           !BCC_EOS
04451                                           ! 1280     outb(0x0060, 0x61);
04452                       0000109E            .E8:
04453                                           ! Debug: list int = const $61 (used reg = )
04454 109E           B8                   0061  mov	ax,*$61
04455 10A1           50                         push	ax
04456                                           ! Debug: list int = const $60 (used reg = )
04457 10A2           B8                   0060  mov	ax,*$60
04458 10A5           50                         push	ax
04459                                           ! Debug: func () void = outb+0 (used reg = )
04460 10A6           E8         F496            call	_outb
04461 10A9           83C4                   04  add	sp,*4
04462                                           !BCC_EOS
04463                                           ! 1281     max=0xffff;
04464                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04465 10AC           B8                   FFFF  mov	ax,#$FFFF
04466 10AF           8946         FE            mov	-2[bp],ax
04467                                           !BCC_EOS
04468                                           ! 1282     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x60);
04469 10B2           EB           0E            jmp .EB
04470                       000010B4            .EC:
04471                                           ! Debug: list int = const $60 (used reg = )
04472 10B4           B8                   0060  mov	ax,*$60
04473 10B7           50                         push	ax
04474                                           ! Debug: list int = const $80 (used reg = )
04475 10B8           B8                   0080  mov	ax,#$80
04476 10BB           50                         push	ax
04477                                           ! Debug: func () void = outb+0 (used reg = )
04478 10BC           E8         F480            call	_outb
04479 10BF           83C4                   04  add	sp,*4
04480                                           !BCC_EOS
04481                                           ! 1283     if (max==0x0) keyboard_panic(60);
04482                       000010C2            .EB:
04483                                           ! Debug: list int = const $64 (used reg = )
04484 10C2           B8                   0064  mov	ax,*$64
04485 10C5           50                         push	ax
04486                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04487 10C6           E8         F460            call	_inb
04488 10C9           44                         inc	sp
04489 10CA           44                         inc	sp
04490                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04491 10CB           24                     02  and	al,*2
04492 10CD           84C0                       test	al,al
04493 10CF           74           0B            je  	.ED
04494                       000010D1            .EE:
04495                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04496 10D1           8B46         FE            mov	ax,-2[bp]
04497 10D4           48                         dec	ax
04498 10D5           8946         FE            mov	-2[bp],ax
04499                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04500 10D8           85C0                       test	ax,ax
04501 10DA           75           D8            jne	.EC
04502                       000010DC            .ED:
04503                       000010DC            .EA:
04504                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04505 10DC           8B46         FE            mov	ax,-2[bp]
04506 10DF           85C0                       test	ax,ax
04507 10E1           75           09            jne 	.EF
04508                       000010E3            .F0:
04509                                           ! Debug: list int = const $3C (used reg = )
04510 10E3           B8                   003C  mov	ax,*$3C
04511 10E6           50                         push	ax
04512                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04513 10E7           E8         00B8            call	_keyboard_panic
04514 10EA           44                         inc	sp
04515 10EB           44                         inc	sp
04516                                           !BCC_EOS
04517                                           ! 1284     outb(0x0060, 0xf4);
04518                       000010EC            .EF:
04519                                           ! Debug: list int = const $F4 (used reg = )
04520 10EC           B8                   00F4  mov	ax,#$F4
04521 10EF           50                         push	ax
04522                                           ! Debug: list int = const $60 (used reg = )
04523 10F0           B8                   0060  mov	ax,*$60
04524 10F3           50                         push	ax
04525                                           ! Debug: func () void = outb+0 (used reg = )
04526 10F4           E8         F448            call	_outb
04527 10F7           83C4                   04  add	sp,*4
04528                                           !BCC_EOS
04529                                           ! 1285     max=0xffff;
04530                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04531 10FA           B8                   FFFF  mov	ax,#$FFFF
04532 10FD           8946         FE            mov	-2[bp],ax
04533                                           !BCC_EOS
04534                                           ! 1286     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x70);
04535 1100           EB           0E            jmp .F2
04536                       00001102            .F3:
04537                                           ! Debug: list int = const $70 (used reg = )
04538 1102           B8                   0070  mov	ax,*$70
04539 1105           50                         push	ax
04540                                           ! Debug: list int = const $80 (used reg = )
04541 1106           B8                   0080  mov	ax,#$80
04542 1109           50                         push	ax
04543                                           ! Debug: func () void = outb+0 (used reg = )
04544 110A           E8         F432            call	_outb
04545 110D           83C4                   04  add	sp,*4
04546                                           !BCC_EOS
04547                                           ! 1287     if (max==0x0) keyboard_panic(70);
04548                       00001110            .F2:
04549                                           ! Debug: list int = const $64 (used reg = )
04550 1110           B8                   0064  mov	ax,*$64
04551 1113           50                         push	ax
04552                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04553 1114           E8         F412            call	_inb
04554 1117           44                         inc	sp
04555 1118           44                         inc	sp
04556                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04557 1119           24                     02  and	al,*2
04558 111B           84C0                       test	al,al
04559 111D           74           0B            je  	.F4
04560                       0000111F            .F5:
04561                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04562 111F           8B46         FE            mov	ax,-2[bp]
04563 1122           48                         dec	ax
04564 1123           8946         FE            mov	-2[bp],ax
04565                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04566 1126           85C0                       test	ax,ax
04567 1128           75           D8            jne	.F3
04568                       0000112A            .F4:
04569                       0000112A            .F1:
04570                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04571 112A           8B46         FE            mov	ax,-2[bp]
04572 112D           85C0                       test	ax,ax
04573 112F           75           09            jne 	.F6
04574                       00001131            .F7:
04575                                           ! Debug: list int = const $46 (used reg = )
04576 1131           B8                   0046  mov	ax,*$46
04577 1134           50                         push	ax
04578                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04579 1135           E8         006A            call	_keyboard_panic
04580 1138           44                         inc	sp
04581 1139           44                         inc	sp
04582                                           !BCC_EOS
04583                                           ! 1288     max=0xffff;
04584                       0000113A            .F6:
04585                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04586 113A           B8                   FFFF  mov	ax,#$FFFF
04587 113D           8946         FE            mov	-2[bp],ax
04588                                           !BCC_EOS
04589                                           ! 1289     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x71);
04590 1140           EB           0E            jmp .F9
04591                       00001142            .FA:
04592                                           ! Debug: list int = const $71 (used reg = )
04593 1142           B8                   0071  mov	ax,*$71
04594 1145           50                         push	ax
04595                                           ! Debug: list int = const $80 (used reg = )
04596 1146           B8                   0080  mov	ax,#$80
04597 1149           50                         push	ax
04598                                           ! Debug: func () void = outb+0 (used reg = )
04599 114A           E8         F3F2            call	_outb
04600 114D           83C4                   04  add	sp,*4
04601                                           !BCC_EOS
04602                                           ! 1290     if (max==0x0) keyboard_panic(70);
04603                       00001150            .F9:
04604                                           ! Debug: list int = const $64 (used reg = )
04605 1150           B8                   0064  mov	ax,*$64
04606 1153           50                         push	ax
04607                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04608 1154           E8         F3D2            call	_inb
04609 1157           44                         inc	sp
04610 1158           44                         inc	sp
04611                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04612 1159           24                     01  and	al,*1
04613                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04614 115B           84C0                       test	al,al
04615 115D           75           0B            jne 	.FB
04616                       0000115F            .FC:
04617                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04618 115F           8B46         FE            mov	ax,-2[bp]
04619 1162           48                         dec	ax
04620 1163           8946         FE            mov	-2[bp],ax
04621                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04622 1166           85C0                       test	ax,ax
04623 1168           75           D8            jne	.FA
04624                       0000116A            .FB:
04625                       0000116A            .F8:
04626                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04627 116A           8B46         FE            mov	ax,-2[bp]
04628 116D           85C0                       test	ax,ax
04629 116F           75           09            jne 	.FD
04630                       00001171            .FE:
04631                                           ! Debug: list int = const $46 (used reg = )
04632 1171           B8                   0046  mov	ax,*$46
04633 1174           50                         push	ax
04634                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04635 1175           E8         002A            call	_keyboard_panic
04636 1178           44                         inc	sp
04637 1179           44                         inc	sp
04638                                           !BCC_EOS
04639                                           ! 1291     if ((inb(0x0060) != 0xfa)) {
04640                       0000117A            .FD:
04641                                           ! Debug: list int = const $60 (used reg = )
04642 117A           B8                   0060  mov	ax,*$60
04643 117D           50                         push	ax
04644                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04645 117E           E8         F3A8            call	_inb
04646 1181           44                         inc	sp
04647 1182           44                         inc	sp
04648                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04649 1183           3C                     FA  cmp	al,#$FA
04650 1185           74           09            je  	.FF
04651                       00001187            .100:
04652                                           ! 1292         keyboard_panic(996);
04653                                           ! Debug: list int = const $3E4 (used reg = )
04654 1187           B8                   03E4  mov	ax,#$3E4
04655 118A           50                         push	ax
04656                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04657 118B           E8         0014            call	_keyboard_panic
04658 118E           44                         inc	sp
04659 118F           44                         inc	sp
04660                                           !BCC_EOS
04661                                           ! 1293     }
04662                                           ! 1294     outb(0x0080, 0x77);
04663                       00001190            .FF:
04664                                           ! Debug: list int = const $77 (used reg = )
04665 1190           B8                   0077  mov	ax,*$77
04666 1193           50                         push	ax
04667                                           ! Debug: list int = const $80 (used reg = )
04668 1194           B8                   0080  mov	ax,#$80
04669 1197           50                         push	ax
04670                                           ! Debug: func () void = outb+0 (used reg = )
04671 1198           E8         F3A4            call	_outb
04672 119B           83C4                   04  add	sp,*4
04673                                           !BCC_EOS
04674                                           ! 1295 }
04675 119E           89EC                       mov	sp,bp
04676 11A0           5D                         pop	bp
04677 11A1           C3                         ret
04678                                           ! 1296   void
04679                                           ! 1297 keyboard_panic(status)
04680                                           ! 1298   Bit16u status;
04681                                           export	_keyboard_panic
04682                       000011A2            _keyboard_panic:
04683                                           !BCC_EOS
04684                                           ! 1299 {
04685                                           ! 1300   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04686 11A2           55                         push	bp
04687 11A3           89E5                       mov	bp,sp
04688                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04689 11A5           FF76         04            push	4[bp]
04690                                           ! Debug: list * char = .101+0 (used reg = )
04691 11A8           BB                   D9DC  mov	bx,#.101
04692 11AB           53                         push	bx
04693                                           ! Debug: list int = const 7 (used reg = )
04694 11AC           B8                   0007  mov	ax,*7
04695 11AF           50                         push	ax
04696                                           ! Debug: func () void = bios_printf+0 (used reg = )
04697 11B0           E8         F786            call	_bios_printf
04698 11B3           89EC                       mov	sp,bp
04699                                           !BCC_EOS
04700                                           ! 1301 }
04701 11B5           5D                         pop	bp
04702 11B6           C3                         ret
04703                                           ! 1302   void
04704                                           ! Register BX used in function keyboard_panic
04705                                           ! 1303 shutdown_status_panic(status)
04706                                           ! 1304   Bit16u status;
04707                                           export	_shutdown_status_panic
04708                       000011B7            _shutdown_status_panic:
04709                                           !BCC_EOS
04710                                           ! 1305 {
04711                                           ! 1306   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04712 11B7           55                         push	bp
04713 11B8           89E5                       mov	bp,sp
04714                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04715 11BA           8A46         04            mov	al,4[bp]
04716 11BD           30E4                       xor	ah,ah
04717 11BF           50                         push	ax
04718                                           ! Debug: list * char = .102+0 (used reg = )
04719 11C0           BB                   D9B7  mov	bx,#.102
04720 11C3           53                         push	bx
04721                                           ! Debug: list int = const 7 (used reg = )
04722 11C4           B8                   0007  mov	ax,*7
04723 11C7           50                         push	ax
04724                                           ! Debug: func () void = bios_printf+0 (used reg = )
04725 11C8           E8         F76E            call	_bios_printf
04726 11CB           89EC                       mov	sp,bp
04727                                           !BCC_EOS
04728                                           ! 1307 }
04729 11CD           5D                         pop	bp
04730 11CE           C3                         ret
04731                                           ! 1308 void s3_resume_panic()
04732                                           ! Register BX used in function shutdown_status_panic
04733                                           ! 1309 {
04734                                           export	_s3_resume_panic
04735                       000011CF            _s3_resume_panic:
04736                                           ! 1310   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04737 11CF           55                         push	bp
04738 11D0           89E5                       mov	bp,sp
04739                                           ! Debug: list * char = .103+0 (used reg = )
04740 11D2           BB                   D99D  mov	bx,#.103
04741 11D5           53                         push	bx
04742                                           ! Debug: list int = const 7 (used reg = )
04743 11D6           B8                   0007  mov	ax,*7
04744 11D9           50                         push	ax
04745                                           ! Debug: func () void = bios_printf+0 (used reg = )
04746 11DA           E8         F75C            call	_bios_printf
04747 11DD           89EC                       mov	sp,bp
04748                                           !BCC_EOS
04749                                           ! 1311 }
04750 11DF           5D                         pop	bp
04751 11E0           C3                         ret
04752                                           ! 1312 void
04753                                           ! Register BX used in function s3_resume_panic
04754                                           ! 1313 print_bios_banner()
04755                                           ! 1314 {
04756                                           export	_print_bios_banner
04757                       000011E1            _print_bios_banner:
04758                                           ! 1315   bios_printf(2
04759 11E1           55                         push	bp
04760 11E2           89E5                       mov	bp,sp
04761                                           ! 1315 , "Bochs ""2.7"" BIOS - build: %s\n%s\nOptions: ", "08/01/21", bios_svn_version_string);
04762                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
04763 11E4           BB                   0165  mov	bx,#_bios_svn_version_string
04764 11E7           53                         push	bx
04765                                           ! Debug: list * char = .105+0 (used reg = )
04766 11E8           BB                   D96C  mov	bx,#.105
04767 11EB           53                         push	bx
04768                                           ! Debug: list * char = .104+0 (used reg = )
04769 11EC           BB                   D975  mov	bx,#.104
04770 11EF           53                         push	bx
04771                                           ! Debug: list int = const 2 (used reg = )
04772 11F0           B8                   0002  mov	ax,*2
04773 11F3           50                         push	ax
04774                                           ! Debug: func () void = bios_printf+0 (used reg = )
04775 11F4           E8         F742            call	_bios_printf
04776 11F7           89EC                       mov	sp,bp
04777                                           !BCC_EOS
04778                                           ! 1316   bios_printf(2, "apmbios " "pcibios " "pnpbios " "eltorito " "rombios32 " "\n\n");
04779                                           ! Debug: list * char = .106+0 (used reg = )
04780 11F9           BB                   D93E  mov	bx,#.106
04781 11FC           53                         push	bx
04782                                           ! Debug: list int = const 2 (used reg = )
04783 11FD           B8                   0002  mov	ax,*2
04784 1200           50                         push	ax
04785                                           ! Debug: func () void = bios_printf+0 (used reg = )
04786 1201           E8         F735            call	_bios_printf
04787 1204           89EC                       mov	sp,bp
04788                                           !BCC_EOS
04789                                           ! 1317 }
04790 1206           5D                         pop	bp
04791 1207           C3                         ret
04792                                           ! 1318 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04793                                           ! Register BX used in function print_bios_banner
04794                                           
04795                       00001208            _drivetypes:
04796                       00001208            .107:
04797 1208                        00            .byte	0
04798 1209                  00000009            .blkb	9
04799                       00001212            .108:
04800 1212                        46            .ascii	"Floppy"
04801 1218                        00            .byte	0
04802 1219                  00000003            .blkb	3
04803                       0000121C            .109:
04804 121C                        48            .ascii	"Hard Disk"
04805 1225                        00            .byte	0
04806                       00001226            .10A:
04807 1226                        43            .ascii	"CD-Rom"
04808 122C                        00            .byte	0
04809 122D                  00000003            .blkb	3
04810                       00001230            .10B:
04811 1230                        4E            .ascii	"Network"
04812 1237                        00            .byte	0
04813 1238                  00000002            .blkb	2
04814                                           !BCC_EOS
04815                                           ! 1319 static void
04816                                           ! 1320 init_boot_vectors()
04817                                           ! 1321 {
04818                                           
04819                       0000123A            _init_boot_vectors:
04820                                           ! 1322   ipl_entry_t e;
04821                                           !BCC_EOS
04822                                           ! 1323   Bit16u count = 0;
04823 123A           55                         push	bp
04824 123B           89E5                       mov	bp,sp
04825 123D           83C4                   EE  add	sp,*-$12
04826                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04827 1240           31C0                       xor	ax,ax
04828 1242           8946         EE            mov	-$12[bp],ax
04829                                           !BCC_EOS
04830                                           ! 1324   Bit16u ss = get_SS();
04831 1245           4C                         dec	sp
04832 1246           4C                         dec	sp
04833                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04834 1247           E8         F410            call	_get_SS
04835                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04836 124A           8946         EC            mov	-$14[bp],ax
04837                                           !BCC_EOS
04838                                           ! 1325 #asm
04839                                           !BCC_EOS
04840                                           !BCC_ASM
04841                       00000002            _init_boot_vectors.count	set	2
04842                       FFFFFFEE            .init_boot_vectors.count	set	-$12
04843                       00000000            _init_boot_vectors.ss	set	0
04844                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
04845                       00000004            _init_boot_vectors.e	set	4
04846                       FFFFFFF0            .init_boot_vectors.e	set	-$10
04847 124D           1E                           push ds
04848                                           ! 1327 endasm
04849                                           !BCC_ENDASM
04850                                           !BCC_EOS
04851                                           ! 1328   set_DS(0x9ff0);
04852                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04853 124E           B8                   9FF0  mov	ax,#$9FF0
04854 1251           50                         push	ax
04855                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
04856 1252           E8         F408            call	_set_DS
04857 1255           44                         inc	sp
04858 1256           44                         inc	sp
04859                                           !BCC_EOS
04860                                           ! 1329   _memsetb(0,0x0000,0x9ff0,0x86);
04861                                           ! Debug: list int = const $86 (used reg = )
04862 1257           B8                   0086  mov	ax,#$86
04863 125A           50                         push	ax
04864                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04865 125B           B8                   9FF0  mov	ax,#$9FF0
04866 125E           50                         push	ax
04867                                           ! Debug: list int = const 0 (used reg = )
04868 125F           31C0                       xor	ax,ax
04869 1261           50                         push	ax
04870                                           ! Debug: list int = const 0 (used reg = )
04871 1262           31C0                       xor	ax,ax
04872 1264           50                         push	ax
04873                                           ! Debug: func () void = _memsetb+0 (used reg = )
04874 1265           E8         ED98            call	__memsetb
04875 1268           83C4                   08  add	sp,*8
04876                                           !BCC_EOS
04877                                           ! 1330   *((Bit16u *)(0x0084)) = (0xFFFF);
04878                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$84] (used reg = )
04879 126B           B8                   FFFF  mov	ax,#$FFFF
04880 126E           A3         0084            mov	[$84],ax
04881                                           !BCC_EOS
04882                                           ! 1331   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04883                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04884 1271           B8                   0001  mov	ax,*1
04885 1274           8946         F0            mov	-$10[bp],ax
04886                                           !BCC_EOS
04887                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04888 1277           31C0                       xor	ax,ax
04889 1279           8946         F2            mov	-$E[bp],ax
04890                                           !BCC_EOS
04891                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04892 127C           31C0                       xor	ax,ax
04893 127E           31DB                       xor	bx,bx
04894 1280           8946         F4            mov	-$C[bp],ax
04895 1283           895E         F6            mov	-$A[bp],bx
04896                                           !BCC_EOS
04897                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04898 1286           31C0                       xor	ax,ax
04899 1288           31DB                       xor	bx,bx
04900 128A           8946         F8            mov	-8[bp],ax
04901 128D           895E         FA            mov	-6[bp],bx
04902                                           !BCC_EOS
04903                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04904 1290           31C0                       xor	ax,ax
04905 1292           31DB                       xor	bx,bx
04906 1294           8946         FC            mov	-4[bp],ax
04907 1297           895E         FE            mov	-2[bp],bx
04908                                           !BCC_EOS
04909                                           ! 1332   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04910                                           ! Debug: list int = const $10 (used reg = )
04911 129A           B8                   0010  mov	ax,*$10
04912 129D           50                         push	ax
04913                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04914 129E           FF76         EC            push	-$14[bp]
04915                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04916 12A1           8D5E         F0            lea	bx,-$10[bp]
04917 12A4           53                         push	bx
04918                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04919 12A5           B8                   9FF0  mov	ax,#$9FF0
04920 12A8           50                         push	ax
04921                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04922 12A9           8B46         EE            mov	ax,-$12[bp]
04923 12AC           B1                     04  mov	cl,*4
04924 12AE           D3E0                       shl	ax,cl
04925                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04926                                           ! Debug: expression subtree swapping
04927                                           ! Debug: list unsigned int = ax+0 (used reg = )
04928 12B0           50                         push	ax
04929                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04930 12B1           E8         ED67            call	__memcpyb
04931 12B4           83C4                   0A  add	sp,*$A
04932                                           !BCC_EOS
04933                                           ! 1333   count++;
04934                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04935 12B7           8B46         EE            mov	ax,-$12[bp]
04936 12BA           40                         inc	ax
04937 12BB           8946         EE            mov	-$12[bp],ax
04938                                           !BCC_EOS
04939                                           ! 1334   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04940                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
04941 12BE           B8                   0002  mov	ax,*2
04942 12C1           8946         F0            mov	-$10[bp],ax
04943                                           !BCC_EOS
04944                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04945 12C4           31C0                       xor	ax,ax
04946 12C6           8946         F2            mov	-$E[bp],ax
04947                                           !BCC_EOS
04948                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04949 12C9           31C0                       xor	ax,ax
04950 12CB           31DB                       xor	bx,bx
04951 12CD           8946         F4            mov	-$C[bp],ax
04952 12D0           895E         F6            mov	-$A[bp],bx
04953                                           !BCC_EOS
04954                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04955 12D3           31C0                       xor	ax,ax
04956 12D5           31DB                       xor	bx,bx
04957 12D7           8946         F8            mov	-8[bp],ax
04958 12DA           895E         FA            mov	-6[bp],bx
04959                                           !BCC_EOS
04960                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04961 12DD           31C0                       xor	ax,ax
04962 12DF           31DB                       xor	bx,bx
04963 12E1           8946         FC            mov	-4[bp],ax
04964 12E4           895E         FE            mov	-2[bp],bx
04965                                           !BCC_EOS
04966                                           ! 1335   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04967                                           ! Debug: list int = const $10 (used reg = )
04968 12E7           B8                   0010  mov	ax,*$10
04969 12EA           50                         push	ax
04970                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04971 12EB           FF76         EC            push	-$14[bp]
04972                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04973 12EE           8D5E         F0            lea	bx,-$10[bp]
04974 12F1           53                         push	bx
04975                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04976 12F2           B8                   9FF0  mov	ax,#$9FF0
04977 12F5           50                         push	ax
04978                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04979 12F6           8B46         EE            mov	ax,-$12[bp]
04980 12F9           B1                     04  mov	cl,*4
04981 12FB           D3E0                       shl	ax,cl
04982                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04983                                           ! Debug: expression subtree swapping
04984                                           ! Debug: list unsigned int = ax+0 (used reg = )
04985 12FD           50                         push	ax
04986                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04987 12FE           E8         ED1A            call	__memcpyb
04988 1301           83C4                   0A  add	sp,*$A
04989                                           !BCC_EOS
04990                                           ! 1336   count++;
04991                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04992 1304           8B46         EE            mov	ax,-$12[bp]
04993 1307           40                         inc	ax
04994 1308           8946         EE            mov	-$12[bp],ax
04995                                           !BCC_EOS
04996                                           ! 1337   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04997                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
04998 130B           B8                   0003  mov	ax,*3
04999 130E           8946         F0            mov	-$10[bp],ax
05000                                           !BCC_EOS
05001                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05002 1311           31C0                       xor	ax,ax
05003 1313           8946         F2            mov	-$E[bp],ax
05004                                           !BCC_EOS
05005                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05006 1316           31C0                       xor	ax,ax
05007 1318           31DB                       xor	bx,bx
05008 131A           8946         F4            mov	-$C[bp],ax
05009 131D           895E         F6            mov	-$A[bp],bx
05010                                           !BCC_EOS
05011                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05012 1320           31C0                       xor	ax,ax
05013 1322           31DB                       xor	bx,bx
05014 1324           8946         F8            mov	-8[bp],ax
05015 1327           895E         FA            mov	-6[bp],bx
05016                                           !BCC_EOS
05017                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05018 132A           31C0                       xor	ax,ax
05019 132C           31DB                       xor	bx,bx
05020 132E           8946         FC            mov	-4[bp],ax
05021 1331           895E         FE            mov	-2[bp],bx
05022                                           !BCC_EOS
05023                                           ! 1338   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05024                                           ! Debug: list int = const $10 (used reg = )
05025 1334           B8                   0010  mov	ax,*$10
05026 1337           50                         push	ax
05027                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05028 1338           FF76         EC            push	-$14[bp]
05029                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05030 133B           8D5E         F0            lea	bx,-$10[bp]
05031 133E           53                         push	bx
05032                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05033 133F           B8                   9FF0  mov	ax,#$9FF0
05034 1342           50                         push	ax
05035                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05036 1343           8B46         EE            mov	ax,-$12[bp]
05037 1346           B1                     04  mov	cl,*4
05038 1348           D3E0                       shl	ax,cl
05039                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05040                                           ! Debug: expression subtree swapping
05041                                           ! Debug: list unsigned int = ax+0 (used reg = )
05042 134A           50                         push	ax
05043                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05044 134B           E8         ECCD            call	__memcpyb
05045 134E           83C4                   0A  add	sp,*$A
05046                                           !BCC_EOS
05047                                           ! 1339   count++;
05048                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05049 1351           8B46         EE            mov	ax,-$12[bp]
05050 1354           40                         inc	ax
05051 1355           8946         EE            mov	-$12[bp],ax
05052                                           !BCC_EOS
05053                                           ! 1340   *((Bit16u *)(0x0080)) = (count);
05054                                           ! Debug: eq unsigned short count = [S+$16-$14] to unsigned short = [+$80] (used reg = )
05055 1358           8B46         EE            mov	ax,-$12[bp]
05056 135B           A3         0080            mov	[$80],ax
05057                                           !BCC_EOS
05058                                           ! 1341   *((Bit16u *)(0x0082)) = (0xffff);
05059                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$82] (used reg = )
05060 135E           B8                   FFFF  mov	ax,#$FFFF
05061 1361           A3         0082            mov	[$82],ax
05062                                           !BCC_EOS
05063                                           ! 1342 #asm
05064                                           !BCC_EOS
05065                                           !BCC_ASM
05066                       00000002            _init_boot_vectors.count	set	2
05067                       FFFFFFEE            .init_boot_vectors.count	set	-$12
05068                       00000000            _init_boot_vectors.ss	set	0
05069                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
05070                       00000004            _init_boot_vectors.e	set	4
05071                       FFFFFFF0            .init_boot_vectors.e	set	-$10
05072 1364           1F                           pop ds
05073                                           ! 1344 endasm
05074                                           !BCC_ENDASM
05075                                           !BCC_EOS
05076                                           ! 1345 }
05077 1365           89EC                       mov	sp,bp
05078 1367           5D                         pop	bp
05079 1368           C3                         ret
05080                                           ! 1346 static Bit8u
05081                                           ! Register BX used in function init_boot_vectors
05082                                           ! 1347 get_boot_vector(i, e)
05083                                           ! 1348 Bit16u i; ipl_entry_t *e;
05084                       00001369            _get_boot_vector:
05085                                           !BCC_EOS
05086                                           !BCC_EOS
05087                                           ! 1349 {
05088                                           ! 1350   Bit16u count;
05089                                           !BCC_EOS
05090                                           ! 1351   Bit16u ss = get_SS();
05091 1369           55                         push	bp
05092 136A           89E5                       mov	bp,sp
05093 136C           83C4                   FC  add	sp,*-4
05094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05095 136F           E8         F2E8            call	_get_SS
05096                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05097 1372           8946         FC            mov	-4[bp],ax
05098                                           !BCC_EOS
05099                                           ! 1352   count = _read_word(0x0080, 0x9ff0);
05100                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05101 1375           B8                   9FF0  mov	ax,#$9FF0
05102 1378           50                         push	ax
05103                                           ! Debug: list int = const $80 (used reg = )
05104 1379           B8                   0080  mov	ax,#$80
05105 137C           50                         push	ax
05106                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05107 137D           E8         F26D            call	__read_word
05108 1380           83C4                   04  add	sp,*4
05109                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05110 1383           8946         FE            mov	-2[bp],ax
05111                                           !BCC_EOS
05112                                           ! 1353   if (i >= count) return 0;
05113                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05114 1386           8B46         04            mov	ax,4[bp]
05115 1389           3B46         FE            cmp	ax,-2[bp]
05116 138C           72           06            jb  	.10C
05117                       0000138E            .10D:
05118 138E           30C0                       xor	al,al
05119 1390           89EC                       mov	sp,bp
05120 1392           5D                         pop	bp
05121 1393           C3                         ret
05122                                           !BCC_EOS
05123                                           ! 1354   _memcpyb(e,ss,0x0000 + i * sizeof (*e),0x9ff0,sizeof (*e));
05124                       00001394            .10C:
05125                                           ! Debug: list int = const $10 (used reg = )
05126 1394           B8                   0010  mov	ax,*$10
05127 1397           50                         push	ax
05128                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05129 1398           B8                   9FF0  mov	ax,#$9FF0
05130 139B           50                         push	ax
05131                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05132 139C           8B46         04            mov	ax,4[bp]
05133 139F           B1                     04  mov	cl,*4
05134 13A1           D3E0                       shl	ax,cl
05135                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05136                                           ! Debug: expression subtree swapping
05137                                           ! Debug: list unsigned int = ax+0 (used reg = )
05138 13A3           50                         push	ax
05139                                           ! Debug: list unsigned short ss = [S+$C-6] (used reg = )
05140 13A4           FF76         FC            push	-4[bp]
05141                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05142 13A7           FF76         06            push	6[bp]
05143                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05144 13AA           E8         EC6E            call	__memcpyb
05145 13AD           83C4                   0A  add	sp,*$A
05146                                           !BCC_EOS
05147                                           ! 1355   return 1;
05148 13B0           B0                     01  mov	al,*1
05149 13B2           89EC                       mov	sp,bp
05150 13B4           5D                         pop	bp
05151 13B5           C3                         ret
05152                                           !BCC_EOS
05153                                           ! 1356 }
05154                                           ! 1357   void
05155                                           ! 1358 interactive_bootkey()
05156                                           ! 1359 {
05157                                           export	_interactive_bootkey
05158                       000013B6            _interactive_bootkey:
05159                                           ! 1360   ipl_entry_t e;
05160                                           !BCC_EOS
05161                                           ! 1361   Bit16u count;
05162                                           !BCC_EOS
05163                                           ! 1362   char description[33];
05164                                           !BCC_EOS
05165                                           ! 1363   Bit8u scan_code;
05166                                           !BCC_EOS
05167                                           ! 1364   Bit8u i;
05168                                           !BCC_EOS
05169                                           ! 1365   Bit16u ss = get_SS();
05170 13B6           55                         push	bp
05171 13B7           89E5                       mov	bp,sp
05172 13B9           83C4                   C8  add	sp,*-$38
05173                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05174 13BC           E8         F29B            call	_get_SS
05175                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05176 13BF           8946         C8            mov	-$38[bp],ax
05177                                           !BCC_EOS
05178                                           ! 1366   Bit16u valid_choice = 0;
05179 13C2           4C                         dec	sp
05180 13C3           4C                         dec	sp
05181                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05182 13C4           31C0                       xor	ax,ax
05183 13C6           8946         C6            mov	-$3A[bp],ax
05184                                           !BCC_EOS
05185                                           ! 1367   while (check_for_keystroke())
05186                                           ! 1368     get_keystroke();
05187 13C9           EB           03            jmp .10F
05188                       000013CB            .110:
05189                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05190 13CB           E8         F532            call	_get_keystroke
05191                                           !BCC_EOS
05192                                           ! 1369   if ((inb_cmos(0x3f) & 0x01) == 0x01)
05193                       000013CE            .10F:
05194                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05195 13CE           E8         F521            call	_check_for_keystroke
05196 13D1           84C0                       test	al,al
05197 13D3           75           F6            jne	.110
05198                       000013D5            .111:
05199                       000013D5            .10E:
05200                                           ! Debug: list int = const $3F (used reg = )
05201 13D5           B8                   003F  mov	ax,*$3F
05202 13D8           50                         push	ax
05203                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
05204 13D9           E8         F192            call	_inb_cmos
05205 13DC           44                         inc	sp
05206 13DD           44                         inc	sp
05207                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
05208 13DE           24                     01  and	al,*1
05209                                           ! Debug: logeq int = const 1 to unsigned char = al+0 (used reg = )
05210 13E0           3C                     01  cmp	al,*1
05211 13E2           75           04            jne 	.112
05212                       000013E4            .113:
05213                                           ! 1370     return;
05214 13E4           89EC                       mov	sp,bp
05215 13E6           5D                         pop	bp
05216 13E7           C3                         ret
05217                                           !BCC_EOS
05218                                           ! 1371   bios_printf(2, "Press F12 for boot menu.\n\n");
05219                       000013E8            .112:
05220                                           ! Debug: list * char = .114+0 (used reg = )
05221 13E8           BB                   D923  mov	bx,#.114
05222 13EB           53                         push	bx
05223                                           ! Debug: list int = const 2 (used reg = )
05224 13EC           B8                   0002  mov	ax,*2
05225 13EF           50                         push	ax
05226                                           ! Debug: func () void = bios_printf+0 (used reg = )
05227 13F0           E8         F546            call	_bios_printf
05228 13F3           83C4                   04  add	sp,*4
05229                                           !BCC_EOS
05230                                           ! 1372   delay_ticks_and_check_for_keystroke(11, 5);
05231                                           ! Debug: list int = const 5 (used reg = )
05232 13F6           B8                   0005  mov	ax,*5
05233 13F9           50                         push	ax
05234                                           ! Debug: list int = const $B (used reg = )
05235 13FA           B8                   000B  mov	ax,*$B
05236 13FD           50                         push	ax
05237                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05238 13FE           E8         F507            call	_delay_ticks_and_check_for_keystroke
05239 1401           83C4                   04  add	sp,*4
05240                                           !BCC_EOS
05241                                           ! 1373   if (check_for_keystroke())
05242                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05243 1404           E8         F4EB            call	_check_for_keystroke
05244 1407           84C0                       test	al,al
05245 1409         0F84         01A1            beq 	.115
05246                       0000140D            .116:
05247                                           ! 1374   {
05248                                           ! 1375     scan_code = get_keystroke();
05249                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05250 140D           E8         F4F0            call	_get_keystroke
05251                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05252 1410           8846         CC            mov	-$34[bp],al
05253                                           !BCC_EOS
05254                                           ! 1376     if (scan_code == 0x86)
05255                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05256 1413           8A46         CC            mov	al,-$34[bp]
05257 1416           3C                     86  cmp	al,#$86
05258 1418         0F85         0192            bne 	.117
05259                       0000141C            .118:
05260                                           ! 1377     {
05261                                           ! 1378       while (check_for_keystroke())
05262                                           ! 1379         get_keystroke();
05263 141C           EB           03            jmp .11A
05264                       0000141E            .11B:
05265                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05266 141E           E8         F4DF            call	_get_keystroke
05267                                           !BCC_EOS
05268                                           ! 1380       bios_printf(2, "Select boot device:\n\n");
05269                       00001421            .11A:
05270                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05271 1421           E8         F4CE            call	_check_for_keystroke
05272 1424           84C0                       test	al,al
05273 1426           75           F6            jne	.11B
05274                       00001428            .11C:
05275                       00001428            .119:
05276                                           ! Debug: list * char = .11D+0 (used reg = )
05277 1428           BB                   D90D  mov	bx,#.11D
05278 142B           53                         push	bx
05279                                           ! Debug: list int = const 2 (used reg = )
05280 142C           B8                   0002  mov	ax,*2
05281 142F           50                         push	ax
05282                                           ! Debug: func () void = bios_printf+0 (used reg = )
05283 1430           E8         F506            call	_bios_printf
05284 1433           83C4                   04  add	sp,*4
05285                                           !BCC_EOS
05286                                           ! 1381       count = _read_word(0x0080, 0x9ff0);
05287                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05288 1436           B8                   9FF0  mov	ax,#$9FF0
05289 1439           50                         push	ax
05290                                           ! Debug: list int = const $80 (used reg = )
05291 143A           B8                   0080  mov	ax,#$80
05292 143D           50                         push	ax
05293                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05294 143E           E8         F1AC            call	__read_word
05295 1441           83C4                   04  add	sp,*4
05296                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05297 1444           8946         EE            mov	-$12[bp],ax
05298                                           !BCC_EOS
05299                                           ! 1382       for (i = 0; i < count; i++)
05300                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05301 1447           30C0                       xor	al,al
05302 1449           8846         CB            mov	-$35[bp],al
05303                                           !BCC_EOS
05304                                           !BCC_EOS
05305                                           ! 1383       {
05306 144C           E9         00EC            br 	.120
05307                       0000144F            .121:
05308                                           ! 1384         _memcpyb(&e,ss,0x0000 + i * sizeof (e),0x9ff0,sizeof (e));
05309                                           ! Debug: list int = const $10 (used reg = )
05310 144F           B8                   0010  mov	ax,*$10
05311 1452           50                         push	ax
05312                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05313 1453           B8                   9FF0  mov	ax,#$9FF0
05314 1456           50                         push	ax
05315                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05316 1457           8A46         CB            mov	al,-$35[bp]
05317 145A           30E4                       xor	ah,ah
05318 145C           B1                     04  mov	cl,*4
05319 145E           D3E0                       shl	ax,cl
05320                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05321                                           ! Debug: expression subtree swapping
05322                                           ! Debug: list unsigned int = ax+0 (used reg = )
05323 1460           50                         push	ax
05324                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05325 1461           FF76         C8            push	-$38[bp]
05326                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05327 1464           8D5E         F0            lea	bx,-$10[bp]
05328 1467           53                         push	bx
05329                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05330 1468           E8         EBB0            call	__memcpyb
05331 146B           83C4                   0A  add	sp,*$A
05332                                           !BCC_EOS
05333                                           ! 1385         bios_printf(2, "%d. ", i+1);
05334                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05335 146E           8A46         CB            mov	al,-$35[bp]
05336 1471           30E4                       xor	ah,ah
05337                                           ! Debug: list unsigned int = ax+1 (used reg = )
05338 1473           40                         inc	ax
05339 1474           50                         push	ax
05340                                           ! Debug: list * char = .122+0 (used reg = )
05341 1475           BB                   D908  mov	bx,#.122
05342 1478           53                         push	bx
05343                                           ! Debug: list int = const 2 (used reg = )
05344 1479           B8                   0002  mov	ax,*2
05345 147C           50                         push	ax
05346                                           ! Debug: func () void = bios_printf+0 (used reg = )
05347 147D           E8         F4B9            call	_bios_printf
05348 1480           83C4                   06  add	sp,*6
05349                                           !BCC_EOS
05350                                           ! 1386         switch(e.ty
05351                                           ! 1386 pe)
05352 1483           8B46         F0            mov	ax,-$10[bp]
05353                                           ! 1387         {
05354 1486           E9         008F            br 	.125
05355                                           ! 1388           case 0x01:
05356                                           ! 1389           case 0x02:
05357                       00001489            .126:
05358                                           ! 1390           case 0x03:
05359                       00001489            .127:
05360                                           ! 1391             bios_printf(2, "%s\n", drivetypes[e.type]);
05361                       00001489            .128:
05362                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05363 1489           8B5E         F0            mov	bx,-$10[bp]
05364 148C           89DA                       mov	dx,bx
05365 148E           D1E3                       shl	bx,*1
05366 1490           D1E3                       shl	bx,*1
05367 1492           01D3                       add	bx,dx
05368 1494           D1E3                       shl	bx,*1
05369                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05370                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05371 1496           81C3                 1208  add	bx,#_drivetypes
05372 149A           53                         push	bx
05373                                           ! Debug: list * char = .129+0 (used reg = )
05374 149B           BB                   D904  mov	bx,#.129
05375 149E           53                         push	bx
05376                                           ! Debug: list int = const 2 (used reg = )
05377 149F           B8                   0002  mov	ax,*2
05378 14A2           50                         push	ax
05379                                           ! Debug: func () void = bios_printf+0 (used reg = )
05380 14A3           E8         F493            call	_bios_printf
05381 14A6           83C4                   06  add	sp,*6
05382                                           !BCC_EOS
05383                                           ! 1392             break;
05384 14A9           E9         0088            br 	.123
05385                                           !BCC_EOS
05386                                           ! 1393           case 0x80:
05387                                           ! 1394             bios_printf(2, "%s", drivetypes[4]);
05388                       000014AC            .12A:
05389                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05390 14AC           BB                   1230  mov	bx,#_drivetypes+$28
05391 14AF           53                         push	bx
05392                                           ! Debug: list * char = .12B+0 (used reg = )
05393 14B0           BB                   D901  mov	bx,#.12B
05394 14B3           53                         push	bx
05395                                           ! Debug: list int = const 2 (used reg = )
05396 14B4           B8                   0002  mov	ax,*2
05397 14B7           50                         push	ax
05398                                           ! Debug: func () void = bios_printf+0 (used reg = )
05399 14B8           E8         F47E            call	_bios_printf
05400 14BB           83C4                   06  add	sp,*6
05401                                           !BCC_EOS
05402                                           ! 1395             if (e.description != 0)
05403                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05404                                           ! Debug: expression subtree swapping
05405 14BE           31C0                       xor	ax,ax
05406 14C0           31DB                       xor	bx,bx
05407 14C2           53                         push	bx
05408 14C3           50                         push	ax
05409 14C4           8B46         F8            mov	ax,-8[bp]
05410 14C7           8B5E         FA            mov	bx,-6[bp]
05411 14CA           8D7E         C2            lea	di,-2+..FFFF[bp]
05412 14CD           E8         EBCC            call	lcmpul
05413 14D0           8D66         C6            lea	sp,2+..FFFF[bp]
05414 14D3           74           31            je  	.12C
05415                       000014D5            .12D:
05416                                           ! 1396             {
05417                                           ! 1397               _memcpyb(&description,ss,*((Bit16u *)&e.description),*(((Bit16u *)&e.description)+1),32);
05418                                           ! Debug: list int = const $20 (used reg = )
05419 14D5           B8                   0020  mov	ax,*$20
05420 14D8           50                         push	ax
05421                                           ! Debug: list unsigned short e = [S+$3E-8] (used reg = )
05422 14D9           FF76         FA            push	-6[bp]
05423                                           ! Debug: list unsigned short e = [S+$40-$A] (used reg = )
05424 14DC           FF76         F8            push	-8[bp]
05425                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05426 14DF           FF76         C8            push	-$38[bp]
05427                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05428 14E2           8D5E         CD            lea	bx,-$33[bp]
05429 14E5           53                         push	bx
05430                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05431 14E6           E8         EB32            call	__memcpyb
05432 14E9           83C4                   0A  add	sp,*$A
05433                                           !BCC_EOS
05434                                           ! 1398               description[32] = 0;
05435                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05436 14EC           30C0                       xor	al,al
05437 14EE           8846         ED            mov	-$13[bp],al
05438                                           !BCC_EOS
05439                                           ! 1399               bios_printf(2, " [%S]", ss, description);
05440                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05441 14F1           8D5E         CD            lea	bx,-$33[bp]
05442 14F4           53                         push	bx
05443                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05444 14F5           FF76         C8            push	-$38[bp]
05445                                           ! Debug: list * char = .12E+0 (used reg = )
05446 14F8           BB                   D8FB  mov	bx,#.12E
05447 14FB           53                         push	bx
05448                                           ! Debug: list int = const 2 (used reg = )
05449 14FC           B8                   0002  mov	ax,*2
05450 14FF           50                         push	ax
05451                                           ! Debug: func () void = bios_printf+0 (used reg = )
05452 1500           E8         F436            call	_bios_printf
05453 1503           83C4                   08  add	sp,*8
05454                                           !BCC_EOS
05455                                           ! 1400            }
05456                                           ! 1401            bios_printf(2, "\n");
05457                       00001506            .12C:
05458                                           ! Debug: list * char = .12F+0 (used reg = )
05459 1506           BB                   D8F9  mov	bx,#.12F
05460 1509           53                         push	bx
05461                                           ! Debug: list int = const 2 (used reg = )
05462 150A           B8                   0002  mov	ax,*2
05463 150D           50                         push	ax
05464                                           ! Debug: func () void = bios_printf+0 (used reg = )
05465 150E           E8         F428            call	_bios_printf
05466 1511           83C4                   04  add	sp,*4
05467                                           !BCC_EOS
05468                                           ! 1402            break;
05469 1514           EB           1E            jmp .123
05470                                           !BCC_EOS
05471                                           ! 1403         }
05472                                           ! 1404       }
05473 1516           EB           1C            jmp .123
05474                       00001518            .125:
05475 1518           2D                   0001  sub	ax,*1
05476 151B         0F84         FF6A            beq 	.126
05477 151F           2D                   0001  sub	ax,*1
05478 1522         0F84         FF63            beq 	.127
05479 1526           2D                   0001  sub	ax,*1
05480 1529         0F84         FF5C            beq 	.128
05481 152D           2D                   007D  sub	ax,*$7D
05482 1530         0F84         FF78            beq 	.12A
05483                       00001534            .123:
05484                       FFFFFFC4            ..FFFF	=	-$3C
05485                                           ! 1405       count++;
05486                       00001534            .11F:
05487                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05488 1534           8A46         CB            mov	al,-$35[bp]
05489 1537           40                         inc	ax
05490 1538           8846         CB            mov	-$35[bp],al
05491                       0000153B            .120:
05492                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05493 153B           8A46         CB            mov	al,-$35[bp]
05494 153E           30E4                       xor	ah,ah
05495 1540           3B46         EE            cmp	ax,-$12[bp]
05496 1543         0F82         FF08            blo 	.121
05497                       00001547            .130:
05498                       00001547            .11E:
05499                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05500 1547           8B46         EE            mov	ax,-$12[bp]
05501 154A           40                         inc	ax
05502 154B           8946         EE            mov	-$12[bp],ax
05503                                           !BCC_EOS
05504                                           ! 1406       while (!valid_choice) {
05505 154E           EB           49            jmp .132
05506                       00001550            .133:
05507                                           ! 1407         scan_code = get_keystroke();
05508                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05509 1550           E8         F3AD            call	_get_keystroke
05510                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05511 1553           8846         CC            mov	-$34[bp],al
05512                                           !BCC_EOS
05513                                           ! 1408         if (scan_code == 0x01 || scan_code == 0x58)
05514                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05515 1556           8A46         CC            mov	al,-$34[bp]
05516 1559           3C                     01  cmp	al,*1
05517 155B           74           07            je  	.135
05518                       0000155D            .136:
05519                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05520 155D           8A46         CC            mov	al,-$34[bp]
05521 1560           3C                     58  cmp	al,*$58
05522 1562           75           08            jne 	.134
05523                       00001564            .135:
05524                                           ! 1409         {
05525                                           ! 1410           valid_choice = 1;
05526                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05527 1564           B8                   0001  mov	ax,*1
05528 1567           8946         C6            mov	-$3A[bp],ax
05529                                           !BCC_EOS
05530                                           ! 1411         }
05531                                           ! 1412         else if (scan_code <= count)
05532 156A           EB           2D            jmp .137
05533                       0000156C            .134:
05534                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05535 156C           8A46         CC            mov	al,-$34[bp]
05536 156F           30E4                       xor	ah,ah
05537 1571           3B46         EE            cmp	ax,-$12[bp]
05538 1574           77           23            ja  	.138
05539                       00001576            .139:
05540                                           ! 1413         {
05541                                           ! 1414           valid_choice = 1;
05542                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05543 1576           B8                   0001  mov	ax,*1
05544 1579           8946         C6            mov	-$3A[bp],ax
05545                                           !BCC_EOS
05546                                           ! 1415           scan_code -= 1;
05547                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05548 157C           8A46         CC            mov	al,-$34[bp]
05549 157F           30E4                       xor	ah,ah
05550 1581           48                         dec	ax
05551 1582           8846         CC            mov	-$34[bp],al
05552                                           !BCC_EOS
05553                                           ! 1416           _write_word(scan_code, 0x0084, 0x9ff0);
05554                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05555 1585           B8                   9FF0  mov	ax,#$9FF0
05556 1588           50                         push	ax
05557                                           ! Debug: list int = const $84 (used reg = )
05558 1589           B8                   0084  mov	ax,#$84
05559 158C           50                         push	ax
05560                                           ! Debug: list unsigned char scan_code = [S+$40-$36] (used reg = )
05561 158D           8A46         CC            mov	al,-$34[bp]
05562 1590           30E4                       xor	ah,ah
05563 1592           50                         push	ax
05564                                           ! Debug: func () void = _write_word+0 (used reg = )
05565 1593           E8         F078            call	__write_word
05566 1596           83C4                   06  add	sp,*6
05567                                           !BCC_EOS
05568                                           ! 1417         }
05569                                           ! 1418       }
05570                       00001599            .138:
05571                       00001599            .137:
05572                                           ! 1419       bios_printf(2, "\n");
05573                       00001599            .132:
05574 1599           8B46         C6            mov	ax,-$3A[bp]
05575 159C           85C0                       test	ax,ax
05576 159E           74           B0            je 	.133
05577                       000015A0            .13A:
05578                       000015A0            .131:
05579                                           ! Debug: list * char = .13B+0 (used reg = )
05580 15A0           BB                   D8F7  mov	bx,#.13B
05581 15A3           53                         push	bx
05582                                           ! Debug: list int = const 2 (used reg = )
05583 15A4           B8                   0002  mov	ax,*2
05584 15A7           50                         push	ax
05585                                           ! Debug: func () void = bios_printf+0 (used reg = )
05586 15A8           E8         F38E            call	_bios_printf
05587 15AB           83C4                   04  add	sp,*4
05588                                           !BCC_EOS
05589                                           ! 1420     }
05590                                           ! 1421   }
05591                       000015AE            .117:
05592                                           ! 1422 }
05593                       000015AE            .115:
05594 15AE           89EC                       mov	sp,bp
05595 15B0           5D                         pop	bp
05596 15B1           C3                         ret
05597                                           ! 1423 void
05598                                           ! Register BX used in function interactive_bootkey
05599                                           ! 1424 print_boot_device(e)
05600                                           ! 1425   ipl_entry_t *e;
05601                                           export	_print_boot_device
05602                       000015B2            _print_boot_device:
05603                                           !BCC_EOS
05604                                           ! 1426 {
05605                                           ! 1427   Bit16u type;
05606                                           !BCC_EOS
05607                                           ! 1428   char description[33];
05608                                           !BCC_EOS
05609                                           ! 1429   Bit16u ss = get_SS();
05610 15B2           55                         push	bp
05611 15B3           89E5                       mov	bp,sp
05612 15B5           83C4                   DA  add	sp,*-$26
05613                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05614 15B8           E8         F09F            call	_get_SS
05615                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05616 15BB           8946         DA            mov	-$26[bp],ax
05617                                           !BCC_EOS
05618                                           ! 1430   type = e->type;
05619 15BE           8B5E         04            mov	bx,4[bp]
05620                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05621 15C1           8B1F                       mov	bx,[bx]
05622 15C3           895E         FE            mov	-2[bp],bx
05623                                           !BCC_EOS
05624                                           ! 1431   if (type == 0x80) type = 0x4;
05625                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05626 15C6           8B46         FE            mov	ax,-2[bp]
05627 15C9           3D                   0080  cmp	ax,#$80
05628 15CC           75           06            jne 	.13C
05629                       000015CE            .13D:
05630                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05631 15CE           B8                   0004  mov	ax,*4
05632 15D1           8946         FE            mov	-2[bp],ax
05633                                           !BCC_EOS
05634                                           ! 1432   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05635                       000015D4            .13C:
05636                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05637 15D4           8B46         FE            mov	ax,-2[bp]
05638 15D7           85C0                       test	ax,ax
05639 15D9           74           08            je  	.13F
05640                       000015DB            .140:
05641                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05642 15DB           8B46         FE            mov	ax,-2[bp]
05643 15DE           3D                   0004  cmp	ax,*4
05644 15E1           76           0E            jbe 	.13E
05645                       000015E3            .13F:
05646                                           ! Debug: list * char = .141+0 (used reg = )
05647 15E3           BB                   D8E7  mov	bx,#.141
05648 15E6           53                         push	bx
05649                                           ! Debug: list int = const 7 (used reg = )
05650 15E7           B8                   0007  mov	ax,*7
05651 15EA           50                         push	ax
05652                                           ! Debug: func () void = bios_printf+0 (used reg = )
05653 15EB           E8         F34B            call	_bios_printf
05654 15EE           83C4                   04  add	sp,*4
05655                                           !BCC_EOS
05656                                           ! 1433   bios_printf(2, "Booting from %s", drivetypes[type]);
05657                       000015F1            .13E:
05658                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05659 15F1           8B5E         FE            mov	bx,-2[bp]
05660 15F4           89DA                       mov	dx,bx
05661 15F6           D1E3                       shl	bx,*1
05662 15F8           D1E3                       shl	bx,*1
05663 15FA           01D3                       add	bx,dx
05664 15FC           D1E3                       shl	bx,*1
05665                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05666                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05667 15FE           81C3                 1208  add	bx,#_drivetypes
05668 1602           53                         push	bx
05669                                           ! Debug: list * char = .142+0 (used reg = )
05670 1603           BB                   D8D7  mov	bx,#.142
05671 1606           53                         push	bx
05672                                           ! Debug: list int = const 2 (used reg = )
05673 1607           B8                   0002  mov	ax,*2
05674 160A           50                         push	ax
05675                                           ! Debug: func () void = bios_printf+0 (used reg = )
05676 160B           E8         F32B            call	_bios_printf
05677 160E           83C4                   06  add	sp,*6
05678                                           !BCC_EOS
05679                                           ! 1434   if (type == 4 && e->description != 0) {
05680                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05681 1611           8B46         FE            mov	ax,-2[bp]
05682 1614           3D                   0004  cmp	ax,*4
05683 1617           75           51            jne 	.143
05684                       00001619            .145:
05685 1619           8B5E         04            mov	bx,4[bp]
05686                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05687                                           ! Debug: expression subtree swapping
05688 161C           31C0                       xor	ax,ax
05689 161E           31F6                       xor	si,si
05690 1620           56                         push	si
05691 1621           50                         push	ax
05692 1622           8B47         08            mov	ax,8[bx]
05693 1625           8B5F         0A            mov	bx,$A[bx]
05694 1628           8D7E         D6            lea	di,-$2A[bp]
05695 162B           E8         EA6E            call	lcmpul
05696 162E           8D66         DA            lea	sp,-$26[bp]
05697 1631           74           37            je  	.143
05698                       00001633            .144:
05699                                           ! 1435     _memcpyb(&description,ss,*((Bit16u *)&e->description),*(((Bit16u *)&e->description)+1),32);
05700                                           ! Debug: list int = const $20 (used reg = )
05701 1633           B8                   0020  mov	ax,*$20
05702 1636           50                         push	ax
05703 1637           8B5E         04            mov	bx,4[bp]
05704                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05705                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05706                                           ! Debug: ptradd int = const 1 to * unsigned short = bx+8 (used reg = )
05707                                           ! Debug: list unsigned short = [bx+$A] (used reg = )
05708 163A           FF77         0A            push	$A[bx]
05709 163D           8B5E         04            mov	bx,4[bp]
05710                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05711                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05712                                           ! Debug: list unsigned short = [bx+8] (used reg = )
05713 1640           FF77         08            push	8[bx]
05714                                           ! Debug: list unsigned short ss = [S+$2E-$28] (used reg = )
05715 1643           FF76         DA            push	-$26[bp]
05716                                           ! Debug: list * [$21] char description = S+$30-$25 (used reg = )
05717 1646           8D5E         DD            lea	bx,-$23[bp]
05718 1649           53                         push	bx
05719                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05720 164A           E8         E9CE            call	__memcpyb
05721 164D           83C4                   0A  add	sp,*$A
05722                                           !BCC_EOS
05723                                           ! 1436     description[32] = 0;
05724                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05725 1650           30C0                       xor	al,al
05726 1652           8846         FD            mov	-3[bp],al
05727                                           !BCC_EOS
05728                                           ! 1437     bios_printf(2, " [%S]", ss, description);
05729                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05730 1655           8D5E         DD            lea	bx,-$23[bp]
05731 1658           53                         push	bx
05732                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05733 1659           FF76         DA            push	-$26[bp]
05734                                           ! Debug: list * char = .146+0 (used reg = )
05735 165C           BB                   D8D1  mov	bx,#.146
05736 165F           53                         push	bx
05737                                           ! Debug: list int = const 2 (used reg = )
05738 1660           B8                   0002  mov	ax,*2
05739 1663           50                         push	ax
05740                                           ! Debug: func () void = bios_printf+0 (used reg = )
05741 1664           E8         F2D2            call	_bios_printf
05742 1667           83C4                   08  add	sp,*8
05743                                           !BCC_EOS
05744                                           ! 1438   }
05745                                           ! 1439   bios_printf(2, "...\n");
05746                       0000166A            .143:
05747                                           ! Debug: list * char = .147+0 (used reg = )
05748 166A           BB                   D8CC  mov	bx,#.147
05749 166D           53                         push	bx
05750                                           ! Debug: list int = const 2 (used reg = )
05751 166E           B8                   0002  mov	ax,*2
05752 1671           50                         push	ax
05753                                           ! Debug: func () void = bios_printf+0 (used reg = )
05754 1672           E8         F2C4            call	_bios_printf
05755 1675           83C4                   04  add	sp,*4
05756                                           !BCC_EOS
05757                                           ! 1440 }
05758 1678           89EC                       mov	sp,bp
05759 167A           5D                         pop	bp
05760 167B           C3                         ret
05761                                           ! 1441   void
05762                                           ! Register BX used in function print_boot_device
05763                                           ! 1442 print_boot_failure(type, reason)
05764                                           ! 1443   Bit16u type; Bit8u reason;
05765                                           export	_print_boot_failure
05766                       0000167C            _print_boot_failure:
05767                                           !BCC_EOS
05768                                           !BCC_EOS
05769                                           ! 1444 {
05770                                           ! 1445   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05771 167C           55                         push	bp
05772 167D           89E5                       mov	bp,sp
05773                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05774 167F           8B46         04            mov	ax,4[bp]
05775 1682           85C0                       test	ax,ax
05776 1684           74           08            je  	.149
05777                       00001686            .14A:
05778                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05779 1686           8B46         04            mov	ax,4[bp]
05780 1689           3D                   0003  cmp	ax,*3
05781 168C           76           0D            jbe 	.148
05782                       0000168E            .149:
05783                                           ! Debug: list * char = .14B+0 (used reg = )
05784 168E           BB                   D8BC  mov	bx,#.14B
05785 1691           53                         push	bx
05786                                           ! Debug: list int = const 7 (used reg = )
05787 1692           B8                   0007  mov	ax,*7
05788 1695           50                         push	ax
05789                                           ! Debug: func () void = bios_printf+0 (used reg = )
05790 1696           E8         F2A0            call	_bios_printf
05791 1699           89EC                       mov	sp,bp
05792                                           !BCC_EOS
05793                                           ! 1446   bios_printf(2, "Boot failed");
05794                       0000169B            .148:
05795                                           ! Debug: list * char = .14C+0 (used reg = )
05796 169B           BB                   D8B0  mov	bx,#.14C
05797 169E           53                         push	bx
05798                                           ! Debug: list int = const 2 (used reg = )
05799 169F           B8                   0002  mov	ax,*2
05800 16A2           50                         push	ax
05801                                           ! Debug: func () void = bios_printf+0 (used reg = )
05802 16A3           E8         F293            call	_bios_printf
05803 16A6           89EC                       mov	sp,bp
05804                                           !BCC_EOS
05805                                           ! 1447   if (type < 4) {
05806                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05807 16A8           8B46         04            mov	ax,4[bp]
05808 16AB           3D                   0004  cmp	ax,*4
05809 16AE           73           23            jae 	.14D
05810                       000016B0            .14E:
05811                                           ! 1448     if (reason==0)
05812                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05813 16B0           8A46         06            mov	al,6[bp]
05814 16B3           84C0                       test	al,al
05815 16B5           75           0F            jne 	.14F
05816                       000016B7            .150:
05817                                           ! 1449       bios_printf(2, ": not a bootable disk");
05818                                           ! Debug: list * char = .151+0 (used reg = )
05819 16B7           BB                   D89A  mov	bx,#.151
05820 16BA           53                         push	bx
05821                                           ! Debug: list int = const 2 (used reg = )
05822 16BB           B8                   0002  mov	ax,*2
05823 16BE           50                         push	ax
05824                                           ! Debug: func () void = bios_printf+0 (used reg = )
05825 16BF           E8         F277            call	_bios_printf
05826 16C2           89EC                       mov	sp,bp
05827                                           !BCC_EOS
05828                                           ! 1450     else
05829                                           ! 1451       bios_printf(2, ": could not read the boot disk");
05830 16C4           EB           0D            jmp .152
05831                       000016C6            .14F:
05832                                           ! Debug: list * char = .153+0 (used reg = )
05833 16C6           BB                   D87B  mov	bx,#.153
05834 16C9           53                         push	bx
05835                                           ! Debug: list int = const 2 (used reg = )
05836 16CA           B8                   0002  mov	ax,*2
05837 16CD           50                         push	ax
05838                                           ! Debug: func () void = bios_printf+0 (used reg = )
05839 16CE           E8         F268            call	_bios_printf
05840 16D1           89EC                       mov	sp,bp
05841                                           !BCC_EOS
05842                                           ! 1452   }
05843                       000016D3            .152:
05844                                           ! 1453   bios_printf(2, "\n\n");
05845                       000016D3            .14D:
05846                                           ! Debug: list * char = .154+0 (used reg = )
05847 16D3           BB                   D878  mov	bx,#.154
05848 16D6           53                         push	bx
05849                                           ! Debug: list int = const 2 (used reg = )
05850 16D7           B8                   0002  mov	ax,*2
05851 16DA           50                         push	ax
05852                                           ! Debug: func () void = bios_printf+0 (used reg = )
05853 16DB           E8         F25B            call	_bios_printf
05854 16DE           89EC                       mov	sp,bp
05855                                           !BCC_EOS
05856                                           ! 1454 }
05857 16E0           5D                         pop	bp
05858 16E1           C3                         ret
05859                                           ! 1455   void
05860                                           ! Register BX used in function print_boot_failure
05861                                           ! 1456 print_cdromboot_failure( code )
05862                                           ! 1457   Bit16u code;
05863                                           export	_print_cdromboot_failure
05864                       000016E2            _print_cdromboot_failure:
05865                                           !BCC_EOS
05866                                           ! 1458 {
05867                                           ! 1459   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05868 16E2           55                         push	bp
05869 16E3           89E5                       mov	bp,sp
05870                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05871 16E5           FF76         04            push	4[bp]
05872                                           ! Debug: list * char = .155+0 (used reg = )
05873 16E8           BB                   D858  mov	bx,#.155
05874 16EB           53                         push	bx
05875                                           ! Debug: list int = const 6 (used reg = )
05876 16EC           B8                   0006  mov	ax,*6
05877 16EF           50                         push	ax
05878                                           ! Debug: func () void = bios_printf+0 (used reg = )
05879 16F0           E8         F246            call	_bios_printf
05880 16F3           89EC                       mov	sp,bp
05881                                           !BCC_EOS
05882                                           ! 1460   return;
05883 16F5           5D                         pop	bp
05884 16F6           C3                         ret
05885                                           !BCC_EOS
05886                                           ! 1461 }
05887                                           ! 1462 void
05888                                           ! Register BX used in function print_cdromboot_failure
05889                                           ! 1463 nmi_handler_msg()
05890                                           ! 1464 {
05891                                           export	_nmi_handler_msg
05892                       000016F7            _nmi_handler_msg:
05893                                           ! 1465   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05894 16F7           55                         push	bp
05895 16F8           89E5                       mov	bp,sp
05896                                           ! Debug: list * char = .156+0 (used reg = )
05897 16FA           BB                   D844  mov	bx,#.156
05898 16FD           53                         push	bx
05899                                           ! Debug: list int = const 7 (used reg = )
05900 16FE           B8                   0007  mov	ax,*7
05901 1701           50                         push	ax
05902                                           ! Debug: func () void = bios_printf+0 (used reg = )
05903 1702           E8         F234            call	_bios_printf
05904 1705           89EC                       mov	sp,bp
05905                                           !BCC_EOS
05906                                           ! 1466 }
05907 1707           5D                         pop	bp
05908 1708           C3                         ret
05909                                           ! 1467 voi
05910                                           ! 1467 d
05911                                           ! Register BX used in function nmi_handler_msg
05912                                           ! 1468 int18_panic_msg()
05913                                           ! 1469 {
05914                                           export	_int18_panic_msg
05915                       00001709            _int18_panic_msg:
05916                                           ! 1470   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05917 1709           55                         push	bp
05918 170A           89E5                       mov	bp,sp
05919                                           ! Debug: list * char = .157+0 (used reg = )
05920 170C           BB                   D82F  mov	bx,#.157
05921 170F           53                         push	bx
05922                                           ! Debug: list int = const 7 (used reg = )
05923 1710           B8                   0007  mov	ax,*7
05924 1713           50                         push	ax
05925                                           ! Debug: func () void = bios_printf+0 (used reg = )
05926 1714           E8         F222            call	_bios_printf
05927 1717           89EC                       mov	sp,bp
05928                                           !BCC_EOS
05929                                           ! 1471 }
05930 1719           5D                         pop	bp
05931 171A           C3                         ret
05932                                           ! 1472 void
05933                                           ! Register BX used in function int18_panic_msg
05934                                           ! 1473 log_bios_start()
05935                                           ! 1474 {
05936                                           export	_log_bios_start
05937                       0000171B            _log_bios_start:
05938                                           ! 1475   bios_printf(4, "%s\n", bios_svn_version_string);
05939 171B           55                         push	bp
05940 171C           89E5                       mov	bp,sp
05941                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
05942 171E           BB                   0165  mov	bx,#_bios_svn_version_string
05943 1721           53                         push	bx
05944                                           ! Debug: list * char = .158+0 (used reg = )
05945 1722           BB                   D82B  mov	bx,#.158
05946 1725           53                         push	bx
05947                                           ! Debug: list int = const 4 (used reg = )
05948 1726           B8                   0004  mov	ax,*4
05949 1729           50                         push	ax
05950                                           ! Debug: func () void = bios_printf+0 (used reg = )
05951 172A           E8         F20C            call	_bios_printf
05952 172D           89EC                       mov	sp,bp
05953                                           !BCC_EOS
05954                                           ! 1476 }
05955 172F           5D                         pop	bp
05956 1730           C3                         ret
05957                                           ! 1477   bx_bool
05958                                           ! Register BX used in function log_bios_start
05959                                           ! 1478 set_enable_a20(val)
05960                                           ! 1479   bx_bool val;
05961                                           export	_set_enable_a20
05962                       00001731            _set_enable_a20:
05963                                           !BCC_EOS
05964                                           ! 1480 {
05965                                           ! 1481   Bit8u oldval;
05966                                           !BCC_EOS
05967                                           ! 1482   oldval = inb(0x0092);
05968 1731           55                         push	bp
05969 1732           89E5                       mov	bp,sp
05970 1734           4C                         dec	sp
05971 1735           4C                         dec	sp
05972                                           ! Debug: list int = const $92 (used reg = )
05973 1736           B8                   0092  mov	ax,#$92
05974 1739           50                         push	ax
05975                                           ! Debug: func () unsigned char = inb+0 (used reg = )
05976 173A           E8         EDEC            call	_inb
05977 173D           44                         inc	sp
05978 173E           44                         inc	sp
05979                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
05980 173F           8846         FF            mov	-1[bp],al
05981                                           !BCC_EOS
05982                                           ! 1483   if (val)
05983 1742           8B46         04            mov	ax,4[bp]
05984 1745           85C0                       test	ax,ax
05985 1747           74           14            je  	.159
05986                       00001749            .15A:
05987                                           ! 1484     outb(0x0092, oldval | 0x02);
05988                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05989 1749           8A46         FF            mov	al,-1[bp]
05990 174C           0C                     02  or	al,*2
05991                                           ! Debug: list unsigned char = al+0 (used reg = )
05992 174E           30E4                       xor	ah,ah
05993 1750           50                         push	ax
05994                                           ! Debug: list int = const $92 (used reg = )
05995 1751           B8                   0092  mov	ax,#$92
05996 1754           50                         push	ax
05997                                           ! Debug: func () void = outb+0 (used reg = )
05998 1755           E8         EDE7            call	_outb
05999 1758           83C4                   04  add	sp,*4
06000                                           !BCC_EOS
06001                                           ! 1485   else
06002                                           ! 1486     outb(0x0092, oldval & 0xfd);
06003 175B           EB           12            jmp .15B
06004                       0000175D            .159:
06005                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06006 175D           8A46         FF            mov	al,-1[bp]
06007 1760           24                     FD  and	al,#$FD
06008                                           ! Debug: list unsigned char = al+0 (used reg = )
06009 1762           30E4                       xor	ah,ah
06010 1764           50                         push	ax
06011                                           ! Debug: list int = const $92 (used reg = )
06012 1765           B8                   0092  mov	ax,#$92
06013 1768           50                         push	ax
06014                                           ! Debug: func () void = outb+0 (used reg = )
06015 1769           E8         EDD3            call	_outb
06016 176C           83C4                   04  add	sp,*4
06017                                           !BCC_EOS
06018                                           ! 1487   return((oldval & 0x02) != 0);
06019                       0000176F            .15B:
06020                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06021 176F           8A46         FF            mov	al,-1[bp]
06022 1772           24                     02  and	al,*2
06023                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06024 1774           84C0                       test	al,al
06025 1776           74           04            je 	.15C
06026 1778           B0                     01  mov	al,*1
06027 177A           EB           02            jmp	.15D
06028                       0000177C            .15C:
06029 177C           30C0                       xor	al,al
06030                       0000177E            .15D:
06031                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06032 177E           30E4                       xor	ah,ah
06033 1780           89EC                       mov	sp,bp
06034 1782           5D                         pop	bp
06035 1783           C3                         ret
06036                                           !BCC_EOS
06037                                           ! 1488 }
06038                                           ! 1489   void
06039                                           ! 1490 debugger_on()
06040                                           ! 1491 {
06041                                           export	_debugger_on
06042                       00001784            _debugger_on:
06043                                           ! 1492   outb(0xfedc, 0x01);
06044 1784           55                         push	bp
06045 1785           89E5                       mov	bp,sp
06046                                           ! Debug: list int = const 1 (used reg = )
06047 1787           B8                   0001  mov	ax,*1
06048 178A           50                         push	ax
06049                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06050 178B           B8                   FEDC  mov	ax,#$FEDC
06051 178E           50                         push	ax
06052                                           ! Debug: func () void = outb+0 (used reg = )
06053 178F           E8         EDAD            call	_outb
06054 1792           89EC                       mov	sp,bp
06055                                           !BCC_EOS
06056                                           ! 1493 }
06057 1794           5D                         pop	bp
06058 1795           C3                         ret
06059                                           ! 1494   void
06060                                           ! 1495 debugger_off()
06061                                           ! 1496 {
06062                                           export	_debugger_off
06063                       00001796            _debugger_off:
06064                                           ! 1497   outb(0xfedc, 0x00);
06065 1796           55                         push	bp
06066 1797           89E5                       mov	bp,sp
06067                                           ! Debug: list int = const 0 (used reg = )
06068 1799           31C0                       xor	ax,ax
06069 179B           50                         push	ax
06070                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06071 179C           B8                   FEDC  mov	ax,#$FEDC
06072 179F           50                         push	ax
06073                                           ! Debug: func () void = outb+0 (used reg = )
06074 17A0           E8         ED9C            call	_outb
06075 17A3           89EC                       mov	sp,bp
06076                                           !BCC_EOS
06077                                           ! 1498 }
06078 17A5           5D                         pop	bp
06079 17A6           C3                         ret
06080                                           ! 1499 int
06081                                           ! 1500 s3_resume()
06082                                           ! 1501 {
06083                                           export	_s3_resume
06084                       000017A7            _s3_resume:
06085                                           ! 1502     Bit32u s3_wakeup_vector;
06086                                           !BCC_EOS
06087                                           ! 1503     Bit8u s3_resume_flag;
06088                                           !BCC_EOS
06089                                           ! 1504     s3_resume_flag = *((Bit8u *)(0x04b0));
06090 17A7           55                         push	bp
06091 17A8           89E5                       mov	bp,sp
06092 17AA           83C4                   FA  add	sp,*-6
06093                                           ! Debug: eq unsigned char = [+$4B0] to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06094 17AD           A0         04B0            mov	al,[$4B0]
06095 17B0           8846         FB            mov	-5[bp],al
06096                                           !BCC_EOS
06097                                           ! 1505     s3_wakeup_vector = *((Bit32u *)(0x04b2));
06098                                           ! Debug: eq unsigned long = [+$4B2] to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06099 17B3           A1         04B2            mov	ax,[$4B2]
06100 17B6           8B1E       04B4            mov	bx,[$4B4]
06101 17BA           8946         FC            mov	-4[bp],ax
06102 17BD           895E         FE            mov	-2[bp],bx
06103                                           !BCC_EOS
06104                                           ! 1506     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06105                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06106 17C0           FF76         FE            push	-2[bp]
06107 17C3           FF76         FC            push	-4[bp]
06108                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06109 17C6           8A46         FB            mov	al,-5[bp]
06110 17C9           30E4                       xor	ah,ah
06111 17CB           50                         push	ax
06112                                           ! Debug: list * char = .15E+0 (used reg = )
06113 17CC           BB                   D810  mov	bx,#.15E
06114 17CF           53                         push	bx
06115                                           ! Debug: list int = const 4 (used reg = )
06116 17D0           B8                   0004  mov	ax,*4
06117 17D3           50                         push	ax
06118                                           ! Debug: func () void = bios_printf+0 (used reg = )
06119 17D4           E8         F162            call	_bios_printf
06120 17D7           83C4                   0A  add	sp,*$A
06121                                           !BCC_EOS
06122                                           ! 1507     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06123                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06124 17DA           8A46         FB            mov	al,-5[bp]
06125 17DD           3C                     FE  cmp	al,#$FE
06126 17DF           75           0B            jne 	.160
06127                       000017E1            .161:
06128 17E1           8B46         FC            mov	ax,-4[bp]
06129 17E4           8B5E         FE            mov	bx,-2[bp]
06130 17E7           E8         E8FB            call	ltstl
06131 17EA           75           06            jne 	.15F
06132                       000017EC            .160:
06133                                           ! 1508      return 0;
06134 17EC           31C0                       xor	ax,ax
06135 17EE           89EC                       mov	sp,bp
06136 17F0           5D                         pop	bp
06137 17F1           C3                         ret
06138                                           !BCC_EOS
06139                                           ! 1509     *((Bit8u *)(0x04b0)) = (0);
06140                       000017F2            .15F:
06141                                           ! Debug: eq int = const 0 to unsigned char = [+$4B0] (used reg = )
06142 17F2           30C0                       xor	al,al
06143 17F4           A2         04B0            mov	[$4B0],al
06144                                           !BCC_EOS
06145                                           ! 1510     *((Bit16u *)(0x04b6)) = ((s3_wakeup_vector & 0xF));
06146                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06147                                           ! Debug: expression subtree swapping
06148 17F7           B8                   000F  mov	ax,*$F
06149 17FA           31DB                       xor	bx,bx
06150 17FC           8D7E         FC            lea	di,-4[bp]
06151 17FF           E8         E88A            call	landul
06152                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B6] (used reg = )
06153 1802           A3         04B6            mov	[$4B6],ax
06154                                           !BCC_EOS
06155                                           ! 1511     *((Bit16u *)(0x04b8)) = ((s3_wakeup_vector >> 4));
06156                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06157 1805           8B46         FC            mov	ax,-4[bp]
06158 1808           8B5E         FE            mov	bx,-2[bp]
06159 180B           BF                   0004  mov	di,*4
06160 180E           E8         E8E9            call	lsrul
06161                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B8] (used reg = )
06162 1811           A3         04B8            mov	[$4B8],ax
06163                                           !BCC_EOS
06164                                           ! 1512     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06165                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06166                                           ! Debug: expression subtree swapping
06167 1814           B8                   000F  mov	ax,*$F
06168 1817           31DB                       xor	bx,bx
06169 1819           8D7E         FC            lea	di,-4[bp]
06170 181C           E8         E86D            call	landul
06171                                           ! Debug: list unsigned long = bx+0 (used reg = )
06172 181F           53                         push	bx
06173 1820           50                         push	ax
06174                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06175 1821           8B46         FC            mov	ax,-4[bp]
06176 1824           8B5E         FE            mov	bx,-2[bp]
06177 1827           BF                   0004  mov	di,*4
06178 182A           E8         E8CD            call	lsrul
06179                                           ! Debug: list unsigned long = bx+0 (used reg = )
06180 182D           53                         push	bx
06181 182E           50                         push	ax
06182                                           ! Debug: list * char = .162+0 (used reg = )
06183 182F           BB                   D7F7  mov	bx,#.162
06184 1832           53                         push	bx
06185                                           ! Debug: list int = const 4 (used reg = )
06186 1833           B8                   0004  mov	ax,*4
06187 1836           50                         push	ax
06188                                           ! Debug: func () void = bios_printf+0 (used reg = )
06189 1837           E8         F0FF            call	_bios_printf
06190 183A           83C4                   0C  add	sp,*$C
06191                                           !BCC_EOS
06192                                           ! 1513 #asm
06193                                           !BCC_EOS
06194                                           !BCC_ASM
06195                       00000001            _s3_resume.s3_resume_flag	set	1
06196                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06197                       00000002            _s3_resume.s3_wakeup_vector	set	2
06198                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06199 183D           FF2E       04B6                jmpf [0x04b6]
06200                                           ! 1515 endasm
06201                                           !BCC_ENDASM
06202                                           !BCC_EOS
06203                                           ! 1516     return 1;
06204 1841           B8                   0001  mov	ax,*1
06205 1844           89EC                       mov	sp,bp
06206 1846           5D                         pop	bp
06207 1847           C3                         ret
06208                                           !BCC_EOS
06209                                           ! 1517 }
06210                                           ! 1518 void ata_init( )
06211                                           ! Register BX used in function s3_resume
06212                                           ! 1519 {
06213                                           export	_ata_init
06214                       00001848            _ata_init:
06215                                           ! 1520   Bit8u channel, device;
06216                                           !BCC_EOS
06217                                           ! 1521   Bit16u old_ds = set_DS(get_ebda_seg());
06218 1848           55                         push	bp
06219 1849           89E5                       mov	bp,sp
06220 184B           83C4                   FC  add	sp,*-4
06221                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06222 184E           E8         EE16            call	_get_ebda_seg
06223                                           ! Debug: list unsigned short = ax+0 (used reg = )
06224 1851           50                         push	ax
06225                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06226 1852           E8         EE08            call	_set_DS
06227 1855           44                         inc	sp
06228 1856           44                         inc	sp
06229                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+6-6] (used reg = )
06230 1857           8946         FC            mov	-4[bp],ax
06231                                           !BCC_EOS
06232                                           ! 1522   for (channel=0; channel<4; channel++) {
06233                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-3] (used reg = )
06234 185A           30C0                       xor	al,al
06235 185C           8846         FF            mov	-1[bp],al
06236                                           !BCC_EOS
06237                                           !BCC_EOS
06238 185F           EB           4B            jmp .165
06239                       00001861            .166:
06240                                           ! 1523     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface)) = (0x00);
06241                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06242 1861           8A46         FF            mov	al,-1[bp]
06243 1864           30E4                       xor	ah,ah
06244 1866           B1                     03  mov	cl,*3
06245 1868           D3E0                       shl	ax,cl
06246 186A           89C3                       mov	bx,ax
06247                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06248                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
06249                                           ! Debug: eq int = const 0 to unsigned char = [bx+$122] (used reg = )
06250 186C           30C0                       xor	al,al
06251 186E           8887       0122            mov	$122[bx],al
06252                                           !BCC_EOS
06253                                           ! 1524     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1)) = (0x0);
06254                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06255 1872           8A46         FF            mov	al,-1[bp]
06256 1875           30E4                       xor	ah,ah
06257 1877           B1                     03  mov	cl,*3
06258 1879           D3E0                       shl	ax,cl
06259 187B           89C3                       mov	bx,ax
06260                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06261                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
06262                                           ! Debug: eq int = const 0 to unsigned short = [bx+$124] (used reg = )
06263 187D           31C0                       xor	ax,ax
06264 187F           8987       0124            mov	$124[bx],ax
06265                                           !BCC_EOS
06266                                           ! 1525     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2)) = (0x0);
06267                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06268 1883           8A46         FF            mov	al,-1[bp]
06269 1886           30E4                       xor	ah,ah
06270 1888           B1                     03  mov	cl,*3
06271 188A           D3E0                       shl	ax,cl
06272 188C           89C3                       mov	bx,ax
06273                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06274                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
06275                                           ! Debug: eq int = const 0 to unsigned short = [bx+$126] (used reg = )
06276 188E           31C0                       xor	ax,ax
06277 1890           8987       0126            mov	$126[bx],ax
06278                                           !BCC_EOS
06279                                           ! 1526     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq)) = (0);
06280                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06281 1894           8A46         FF            mov	al,-1[bp]
06282 1897           30E4                       xor	ah,ah
06283 1899           B1                     03  mov	cl,*3
06284 189B           D3E0                       shl	ax,cl
06285 189D           89C3                       mov	bx,ax
06286                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06287                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
06288                                           ! Debug: eq int = const 0 to unsigned char = [bx+$128] (used reg = )
06289 189F           30C0                       xor	al,al
06290 18A1           8887       0128            mov	$128[bx],al
06291                                           !BCC_EOS
06292                                           ! 1527   }
06293                                           ! 1528   for (device=0; device<(4*2); device++) {
06294                       000018A5            .164:
06295                                           ! Debug: postinc unsigned char channel = [S+6-3] (used reg = )
06296 18A5           8A46         FF            mov	al,-1[bp]
06297 18A8           40                         inc	ax
06298 18A9           8846         FF            mov	-1[bp],al
06299                       000018AC            .165:
06300                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-3] (used reg = )
06301 18AC           8A46         FF            mov	al,-1[bp]
06302 18AF           3C                     04  cmp	al,*4
06303 18B1           72           AE            jb 	.166
06304                       000018B3            .167:
06305                       000018B3            .163:
06306                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06307 18B3           30C0                       xor	al,al
06308 18B5           8846         FE            mov	-2[bp],al
06309                                           !BCC_EOS
06310                                           !BCC_EOS
06311 18B8           E9         0121            br 	.16A
06312                       000018BB            .16B:
06313                                           ! 1529     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
06314                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06315 18BB           8A46         FE            mov	al,-2[bp]
06316 18BE           30E4                       xor	ah,ah
06317 18C0           B9                   001E  mov	cx,*$1E
06318 18C3           F7E9                       imul	cx
06319 18C5           89C3                       mov	bx,ax
06320                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06321                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
06322                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
06323 18C7           30C0                       xor	al,al
06324 18C9           8887       0142            mov	$142[bx],al
06325                                           !BCC_EOS
06326                                           ! 1530     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x00);
06327                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06328 18CD           8A46         FE            mov	al,-2[bp]
06329 18D0           30E4                       xor	ah,ah
06330 18D2           B9                   001E  mov	cx,*$1E
06331 18D5           F7E9                       imul	cx
06332 18D7           89C3                       mov	bx,ax
06333                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06334                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
06335                                           ! Debug: eq int = const 0 to unsigned char = [bx+$143] (used reg = )
06336 18D9           30C0                       xor	al,al
06337 18DB           8887       0143            mov	$143[bx],al
06338                                           !BCC_EOS
06339                                           ! 1531     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (0);
06340                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06341 18DF           8A46         FE            mov	al,-2[bp]
06342 18E2           30E4                       xor	ah,ah
06343 18E4           B9                   001E  mov	cx,*$1E
06344 18E7           F7E9                       imul	cx
06345 18E9           89C3                       mov	bx,ax
06346                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06347                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
06348                                           ! Debug: eq int = const 0 to unsigned char = [bx+$144] (used reg = )
06349 18EB           30C0                       xor	al,al
06350 18ED           8887       0144            mov	$144[bx],al
06351                                           !BCC_EOS
06352                                           ! 1532     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (0);
06353                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06354 18F1           8A46         FE            mov	al,-2[bp]
06355 18F4           30E4                       xor	ah,ah
06356 18F6           B9                   001E  mov	cx,*$1E
06357 18F9           F7E9                       imul	cx
06358 18FB           89C3                       mov	bx,ax
06359                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06360                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
06361                                           ! Debug: eq int = const 0 to unsigned char = [bx+$145] (used reg = )
06362 18FD           30C0                       xor	al,al
06363 18FF           8887       0145            mov	$145[bx],al
06364                                           !BCC_EOS
06365                                           ! 1533     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
06366                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06367 1903           8A46         FE            mov	al,-2[bp]
06368 1906           30E4                       xor	ah,ah
06369 1908           B9                   001E  mov	cx,*$1E
06370 190B           F7E9                       imul	cx
06371 190D           89C3                       mov	bx,ax
06372                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06373                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
06374                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
06375 190F           30C0                       xor	al,al
06376 1911           8887       0146            mov	$146[bx],al
06377                                           !BCC_EOS
06378                                           ! 1534     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (0);
06379                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06380 1915           8A46         FE            mov	al,-2[bp]
06381 1918           30E4                       xor	ah,ah
06382 191A           B9                   001E  mov	cx,*$1E
06383 191D           F7E9                       imul	cx
06384 191F           89C3                       mov	bx,ax
06385                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06386                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
06387                                           ! Debug: eq int = const 0 to unsigned short = [bx+$148] (used reg = )
06388 1921           31C0                       xor	ax,ax
06389 1923           8987       0148            mov	$148[bx],ax
06390                                           !BCC_EOS
06391                                           ! 1535     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[d
06392                                           ! 1535 evice].translation)) = (0);
06393                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06394 1927           8A46         FE            mov	al,-2[bp]
06395 192A           30E4                       xor	ah,ah
06396 192C           B9                   001E  mov	cx,*$1E
06397 192F           F7E9                       imul	cx
06398 1931           89C3                       mov	bx,ax
06399                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06400                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
06401                                           ! Debug: eq int = const 0 to unsigned char = [bx+$14A] (used reg = )
06402 1933           30C0                       xor	al,al
06403 1935           8887       014A            mov	$14A[bx],al
06404                                           !BCC_EOS
06405                                           ! 1536     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (0);
06406                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06407 1939           8A46         FE            mov	al,-2[bp]
06408 193C           30E4                       xor	ah,ah
06409 193E           B9                   001E  mov	cx,*$1E
06410 1941           F7E9                       imul	cx
06411 1943           89C3                       mov	bx,ax
06412                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06413                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
06414                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14C] (used reg = )
06415 1945           31C0                       xor	ax,ax
06416 1947           8987       014C            mov	$14C[bx],ax
06417                                           !BCC_EOS
06418                                           ! 1537     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (0);
06419                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06420 194B           8A46         FE            mov	al,-2[bp]
06421 194E           30E4                       xor	ah,ah
06422 1950           B9                   001E  mov	cx,*$1E
06423 1953           F7E9                       imul	cx
06424 1955           89C3                       mov	bx,ax
06425                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06426                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
06427                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14E] (used reg = )
06428 1957           31C0                       xor	ax,ax
06429 1959           8987       014E            mov	$14E[bx],ax
06430                                           !BCC_EOS
06431                                           ! 1538     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (0);
06432                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06433 195D           8A46         FE            mov	al,-2[bp]
06434 1960           30E4                       xor	ah,ah
06435 1962           B9                   001E  mov	cx,*$1E
06436 1965           F7E9                       imul	cx
06437 1967           89C3                       mov	bx,ax
06438                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06439                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
06440                                           ! Debug: eq int = const 0 to unsigned short = [bx+$150] (used reg = )
06441 1969           31C0                       xor	ax,ax
06442 196B           8987       0150            mov	$150[bx],ax
06443                                           !BCC_EOS
06444                                           ! 1539     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (0);
06445                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06446 196F           8A46         FE            mov	al,-2[bp]
06447 1972           30E4                       xor	ah,ah
06448 1974           B9                   001E  mov	cx,*$1E
06449 1977           F7E9                       imul	cx
06450 1979           89C3                       mov	bx,ax
06451                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06452                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
06453                                           ! Debug: eq int = const 0 to unsigned short = [bx+$152] (used reg = )
06454 197B           31C0                       xor	ax,ax
06455 197D           8987       0152            mov	$152[bx],ax
06456                                           !BCC_EOS
06457                                           ! 1540     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (0);
06458                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06459 1981           8A46         FE            mov	al,-2[bp]
06460 1984           30E4                       xor	ah,ah
06461 1986           B9                   001E  mov	cx,*$1E
06462 1989           F7E9                       imul	cx
06463 198B           89C3                       mov	bx,ax
06464                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06465                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
06466                                           ! Debug: eq int = const 0 to unsigned short = [bx+$154] (used reg = )
06467 198D           31C0                       xor	ax,ax
06468 198F           8987       0154            mov	$154[bx],ax
06469                                           !BCC_EOS
06470                                           ! 1541     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (0);
06471                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06472 1993           8A46         FE            mov	al,-2[bp]
06473 1996           30E4                       xor	ah,ah
06474 1998           B9                   001E  mov	cx,*$1E
06475 199B           F7E9                       imul	cx
06476 199D           89C3                       mov	bx,ax
06477                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06478                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
06479                                           ! Debug: eq int = const 0 to unsigned short = [bx+$156] (used reg = )
06480 199F           31C0                       xor	ax,ax
06481 19A1           8987       0156            mov	$156[bx],ax
06482                                           !BCC_EOS
06483                                           ! 1542     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (0L);
06484                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06485 19A5           8A46         FE            mov	al,-2[bp]
06486 19A8           30E4                       xor	ah,ah
06487 19AA           B9                   001E  mov	cx,*$1E
06488 19AD           F7E9                       imul	cx
06489 19AF           89C3                       mov	bx,ax
06490                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06491                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
06492                                           ! Debug: eq long = const 0 to unsigned long = [bx+$158] (used reg = )
06493 19B1           31C0                       xor	ax,ax
06494 19B3           31F6                       xor	si,si
06495 19B5           8987       0158            mov	$158[bx],ax
06496 19B9           89B7       015A            mov	$15A[bx],si
06497                                           !BCC_EOS
06498                                           ! 1543     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (0L);
06499                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06500 19BD           8A46         FE            mov	al,-2[bp]
06501 19C0           30E4                       xor	ah,ah
06502 19C2           B9                   001E  mov	cx,*$1E
06503 19C5           F7E9                       imul	cx
06504 19C7           89C3                       mov	bx,ax
06505                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06506                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
06507                                           ! Debug: eq long = const 0 to unsigned long = [bx+$15C] (used reg = )
06508 19C9           31C0                       xor	ax,ax
06509 19CB           31F6                       xor	si,si
06510 19CD           8987       015C            mov	$15C[bx],ax
06511 19D1           89B7       015E            mov	$15E[bx],si
06512                                           !BCC_EOS
06513                                           ! 1544   }
06514                                           ! 1545   for (device=0; device<(4*2); device++) {
06515                       000019D5            .169:
06516                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06517 19D5           8A46         FE            mov	al,-2[bp]
06518 19D8           40                         inc	ax
06519 19D9           8846         FE            mov	-2[bp],al
06520                       000019DC            .16A:
06521                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06522 19DC           8A46         FE            mov	al,-2[bp]
06523 19DF           3C                     08  cmp	al,*8
06524 19E1         0F82         FED6            blo 	.16B
06525                       000019E5            .16C:
06526                       000019E5            .168:
06527                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06528 19E5           30C0                       xor	al,al
06529 19E7           8846         FE            mov	-2[bp],al
06530                                           !BCC_EOS
06531                                           !BCC_EOS
06532 19EA           EB           21            jmp .16F
06533                       000019EC            .170:
06534                                           ! 1546     *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[device])) = ((4*2));
06535                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $233 (used reg = )
06536 19EC           8A46         FE            mov	al,-2[bp]
06537 19EF           30E4                       xor	ah,ah
06538 19F1           89C3                       mov	bx,ax
06539                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06540                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
06541                                           ! Debug: eq int = const 8 to unsigned char = [bx+$233] (used reg = )
06542 19F3           B0                     08  mov	al,*8
06543 19F5           8887       0233            mov	$233[bx],al
06544                                           !BCC_EOS
06545                                           ! 1547     *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[device])) = ((4*2));
06546                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $23C (used reg = )
06547 19F9           8A46         FE            mov	al,-2[bp]
06548 19FC           30E4                       xor	ah,ah
06549 19FE           89C3                       mov	bx,ax
06550                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06551                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
06552                                           ! Debug: eq int = const 8 to unsigned char = [bx+$23C] (used reg = )
06553 1A00           B0                     08  mov	al,*8
06554 1A02           8887       023C            mov	$23C[bx],al
06555                                           !BCC_EOS
06556                                           ! 1548   }
06557                                           ! 1549   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (0);
06558                       00001A06            .16E:
06559                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06560 1A06           8A46         FE            mov	al,-2[bp]
06561 1A09           40                         inc	ax
06562 1A0A           8846         FE            mov	-2[bp],al
06563                       00001A0D            .16F:
06564                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06565 1A0D           8A46         FE            mov	al,-2[bp]
06566 1A10           3C                     08  cmp	al,*8
06567 1A12           72           D8            jb 	.170
06568                       00001A14            .171:
06569                       00001A14            .16D:
06570                                           ! Debug: eq int = const 0 to unsigned char = [+$232] (used reg = )
06571 1A14           30C0                       xor	al,al
06572 1A16           A2         0232            mov	[$232],al
06573                                           !BCC_EOS
06574                                           ! 1550   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (0);
06575                                           ! Debug: eq int = const 0 to unsigned char = [+$23B] (used reg = )
06576 1A19           30C0                       xor	al,al
06577 1A1B           A2         023B            mov	[$23B],al
06578                                           !BCC_EOS
06579                                           ! 1551   set_DS(old_ds);
06580                                           ! Debug: list unsigned short old_ds = [S+6-6] (used reg = )
06581 1A1E           FF76         FC            push	-4[bp]
06582                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06583 1A21           E8         EC39            call	_set_DS
06584 1A24           44                         inc	sp
06585 1A25           44                         inc	sp
06586                                           !BCC_EOS
06587                                           ! 1552 }
06588 1A26           89EC                       mov	sp,bp
06589 1A28           5D                         pop	bp
06590 1A29           C3                         ret
06591                                           ! 1553 int await_ide();
06592                                           ! Register BX used in function ata_init
06593                                           !BCC_EOS
06594                                           ! 1554 static int await_ide(when_done,base,timeout)
06595                                           ! 1555   Bit8u when_done;
06596                       00001A2A            _await_ide:
06597                                           !BCC_EOS
06598                                           ! 1556   Bit16u base;
06599                                           !BCC_EOS
06600                                           ! 1557   Bit16u timeout;
06601                                           !BCC_EOS
06602                                           ! 1558 {
06603                                           ! 1559   Bit32u time=0;
06604 1A2A           55                         push	bp
06605 1A2B           89E5                       mov	bp,sp
06606 1A2D           83C4                   FC  add	sp,*-4
06607                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06608 1A30           31C0                       xor	ax,ax
06609 1A32           31DB                       xor	bx,bx
06610 1A34           8946         FC            mov	-4[bp],ax
06611 1A37           895E         FE            mov	-2[bp],bx
06612                                           !BCC_EOS
06613                                           ! 1560   Bit16u status,last=0;
06614 1A3A           83C4                   FC  add	sp,*-4
06615                                           ! Debug: eq int = const 0 to unsigned short last = [S+$A-$A] (used reg = )
06616 1A3D           31C0                       xor	ax,ax
06617 1A3F           8946         F8            mov	-8[bp],ax
06618                                           !BCC_EOS
06619                                           ! 1561   Bit8u result;
06620                                           !BCC_EOS
06621                                           ! 1562   status = inb(base + 7);
06622 1A42           4C                         dec	sp
06623 1A43           4C                         dec	sp
06624                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06625 1A44           8B46         06            mov	ax,6[bp]
06626                                           ! Debug: list unsigned int = ax+7 (used reg = )
06627 1A47           05                   0007  add	ax,*7
06628 1A4A           50                         push	ax
06629                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06630 1A4B           E8         EADB            call	_inb
06631 1A4E           44                         inc	sp
06632 1A4F           44                         inc	sp
06633                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06634 1A50           30E4                       xor	ah,ah
06635 1A52           8946         FA            mov	-6[bp],ax
06636                                           !BCC_EOS
06637                                           ! 1563   for(;;) {
06638                                           !BCC_EOS
06639                                           !BCC_EOS
06640                       00001A55            .174:
06641                                           ! 1564     status = inb(base+7);
06642                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06643 1A55           8B46         06            mov	ax,6[bp]
06644                                           ! Debug: list unsigned int = ax+7 (used reg = )
06645 1A58           05                   0007  add	ax,*7
06646 1A5B           50                         push	ax
06647                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06648 1A5C           E8         EACA            call	_inb
06649 1A5F           44                         inc	sp
06650 1A60           44                         inc	sp
06651                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06652 1A61           30E4                       xor	ah,ah
06653 1A63           8946         FA            mov	-6[bp],ax
06654                                           !BCC_EOS
06655                                           ! 1565     time++;
06656                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
06657 1A66           8B46         FC            mov	ax,-4[bp]
06658 1A69           8B76         FE            mov	si,-2[bp]
06659 1A6C           8D5E         FC            lea	bx,-4[bp]
06660 1A6F           E8         E66E            call	lincl
06661                                           !BCC_EOS
06662                                           ! 1566     if (when_done == 1)
06663                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
06664 1A72           8A46         04            mov	al,4[bp]
06665 1A75           3C                     01  cmp	al,*1
06666 1A77           75           0B            jne 	.175
06667                       00001A79            .176:
06668                                           ! 1567       result = status & 0x80;
06669                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06670 1A79           8A46         FA            mov	al,-6[bp]
06671 1A7C           24                     80  and	al,#$80
06672                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06673 1A7E           8846         F7            mov	-9[bp],al
06674                                           !BCC_EOS
06675                                           ! 1568     else if (when_done == 2)
06676 1A81           E9         0094            br 	.177
06677                       00001A84            .175:
06678                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
06679 1A84           8A46         04            mov	al,4[bp]
06680 1A87           3C                     02  cmp	al,*2
06681 1A89           75           15            jne 	.178
06682                       00001A8B            .179:
06683                                           ! 1569       result = !(status & 0x80);
06684                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06685 1A8B           8A46         FA            mov	al,-6[bp]
06686 1A8E           24                     80  and	al,#$80
06687 1A90           84C0                       test	al,al
06688 1A92           75           04            jne 	.17A
06689                       00001A94            .17B:
06690 1A94           B0                     01  mov	al,*1
06691 1A96           EB           02            jmp	.17C
06692                       00001A98            .17A:
06693 1A98           30C0                       xor	al,al
06694                       00001A9A            .17C:
06695                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06696 1A9A           8846         F7            mov	-9[bp],al
06697                                           !BCC_EOS
06698                                           ! 1570     else if (when_done == 3)
06699 1A9D           E9         0078            br 	.17D
06700                       00001AA0            .178:
06701                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
06702 1AA0           8A46         04            mov	al,4[bp]
06703 1AA3           3C                     03  cmp	al,*3
06704 1AA5           75           1D            jne 	.17E
06705                       00001AA7            .17F:
06706                                           ! 1571       result = !(status & 0x80) && (status & 0x08);
06707                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06708 1AA7           8A46         FA            mov	al,-6[bp]
06709 1AAA           24                     80  and	al,#$80
06710 1AAC           84C0                       test	al,al
06711 1AAE           75           0D            jne 	.180
06712                       00001AB0            .182:
06713                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06714 1AB0           8A46         FA            mov	al,-6[bp]
06715 1AB3           24                     08  and	al,*8
06716 1AB5           84C0                       test	al,al
06717 1AB7           74           04            je  	.180
06718                       00001AB9            .181:
06719 1AB9           B0                     01  mov	al,*1
06720 1ABB           EB           02            jmp	.183
06721                       00001ABD            .180:
06722 1ABD           30C0                       xor	al,al
06723                       00001ABF            .183:
06724                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06725 1ABF           8846         F7            mov	-9[bp],al
06726                                           !BCC_EOS
06727                                           ! 1572     else if (when_done == 4)
06728 1AC2           EB           54            jmp .184
06729                       00001AC4            .17E:
06730                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
06731 1AC4           8A46         04            mov	al,4[bp]
06732 1AC7           3C                     04  cmp	al,*4
06733 1AC9           75           1D            jne 	.185
06734                       00001ACB            .186:
06735                                           ! 1573       result = !(status & 0x80) && !(status & 0x08);
06736                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06737 1ACB           8A46         FA            mov	al,-6[bp]
06738 1ACE           24                     80  and	al,#$80
06739 1AD0           84C0                       test	al,al
06740 1AD2           75           0D            jne 	.187
06741                       00001AD4            .189:
06742                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06743 1AD4           8A46         FA            mov	al,-6[bp]
06744 1AD7           24                     08  and	al,*8
06745 1AD9           84C0                       test	al,al
06746 1ADB           75           04            jne 	.187
06747                       00001ADD            .188:
06748 1ADD           B0                     01  mov	al,*1
06749 1ADF           EB           02            jmp	.18A
06750                       00001AE1            .187:
06751 1AE1           30C0                       xor	al,al
06752                       00001AE3            .18A:
06753                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06754 1AE3           8846         F7            mov	-9[bp],al
06755                                           !BCC_EOS
06756                                           ! 1574     else if (when_done == 5)
06757 1AE6           EB           30            jmp .18B
06758                       00001AE8            .185:
06759                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
06760 1AE8           8A46         04            mov	al,4[bp]
06761 1AEB           3C                     05  cmp	al,*5
06762 1AED           75           1D            jne 	.18C
06763                       00001AEF            .18D:
06764                                           ! 1575       result = !(status & 0x80) && (status & 0x40);
06765                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06766 1AEF           8A46         FA            mov	al,-6[bp]
06767 1AF2           24                     80  and	al,#$80
06768 1AF4           84C0                       test	al,al
06769 1AF6           75           0D            jne 	.18E
06770                       00001AF8            .190:
06771                                           ! Debug: and int = const $40 to unsigned short status = [S+$C-8] (used reg = )
06772 1AF8           8A46         FA            mov	al,-6[bp]
06773 1AFB           24                     40  and	al,*$40
06774 1AFD           84C0                       test	al,al
06775 1AFF           74           04            je  	.18E
06776                       00001B01            .18F:
06777 1B01           B0                     01  mov	al,*1
06778 1B03           EB           02            jmp	.191
06779                       00001B05            .18E:
06780 1B05           30C0                       xor	al,al
06781                       00001B07            .191:
06782                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06783 1B07           8846         F7            mov	-9[bp],al
06784                                           !BCC_EOS
06785                                           ! 1576     else if (when_done == 0)
06786 1B0A           EB           0C            jmp .192
06787                       00001B0C            .18C:
06788                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
06789 1B0C           8A46         04            mov	al,4[bp]
06790 1B0F           84C0                       test	al,al
06791 1B11           75           05            jne 	.193
06792                       00001B13            .194:
06793                                           ! 1577       result = 0;
06794                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$B] (used reg = )
06795 1B13           30C0                       xor	al,al
06796 1B15           8846         F7            mov	-9[bp],al
06797                                           !BCC_EOS
06798                                           ! 1578     if (result) return 0;
06799                       00001B18            .193:
06800                       00001B18            .192:
06801                       00001B18            .18B:
06802                       00001B18            .184:
06803                       00001B18            .17D:
06804                       00001B18            .177:
06805 1B18           8A46         F7            mov	al,-9[bp]
06806 1B1B           84C0                       test	al,al
06807 1B1D           74           06            je  	.195
06808                       00001B1F            .196:
06809 1B1F           31C0                       xor	ax,ax
06810 1B21           89EC                       mov	sp,bp
06811 1B23           5D                         pop	bp
06812 1B24           C3                         ret
06813                                           !BCC_EOS
06814                                           ! 1579     if (*(((Bit16u *)&time)+1) != last)
06815                       00001B25            .195:
06816                                           ! Debug: ne unsigned short last = [S+$C-$A] to unsigned short time = [S+$C-4] (used reg = )
06817 1B25           8B46         FE            mov	ax,-2[bp]
06818 1B28           3B46         F8            cmp	ax,-8[bp]
06819 1B2B           74           06            je  	.197
06820                       00001B2D            .198:
06821                                           ! 1580     {
06822                                           ! 1581       last = *(((Bit16u *)&time)+1);
06823                                           ! Debug: eq unsigned short time = [S+$C-4] to unsigned short last = [S+$C-$A] (used reg = )
06824 1B2D           8B46         FE            mov	ax,-2[bp]
06825 1B30           8946         F8            mov	-8[bp],ax
06826                                           !BCC_EOS
06827                                           ! 1582       ;
06828                                           !BCC_EOS
06829                                           ! 1583     }
06830                                           ! 1584     if (status & 0x01)
06831                       00001B33            .197:
06832                                           ! Debug: and int = const 1 to unsigned short status = [S+$C-8] (used reg = )
06833 1B33           8A46         FA            mov	al,-6[bp]
06834 1B36           24                     01  and	al,*1
06835 1B38           84C0                       test	al,al
06836 1B3A           74           07            je  	.199
06837                       00001B3C            .19A:
06838                                           ! 1585     {
06839                                           ! 1586       ;
06840                                           !BCC_EOS
06841                                           ! 1587       return -1;
06842 1B3C           B8                   FFFF  mov	ax,*-1
06843 1B3F           89EC                       mov	sp,bp
06844 1B41           5D                         pop	bp
06845 1B42           C3                         ret
06846                                           !BCC_EOS
06847                                           ! 1588     }
06848                                           ! 1589     if ((timeout == 0) || ((time>>11) > timeout)) break;
06849                       00001B43            .199:
06850                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06851 1B43           8B46         08            mov	ax,8[bp]
06852 1B46           85C0                       test	ax,ax
06853 1B48           74           26            je  	.19C
06854                       00001B4A            .19D:
06855                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06856 1B4A           8B46         08            mov	ax,8[bp]
06857 1B4D           31DB                       xor	bx,bx
06858 1B4F           53                         push	bx
06859 1B50           50                         push	ax
06860                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
06861 1B51           8B46         FC            mov	ax,-4[bp]
06862 1B54           8B5E         FE            mov	bx,-2[bp]
06863 1B57           88E0                       mov	al,ah
06864 1B59           88DC                       mov	ah,bl
06865 1B5B           88FB                       mov	bl,bh
06866 1B5D           28FF                       sub	bh,bh
06867 1B5F           BF                   0003  mov	di,*3
06868 1B62           E8         E595            call	lsrul
06869                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
06870 1B65           8D7E         F2            lea	di,-$E[bp]
06871 1B68           E8         E531            call	lcmpul
06872 1B6B           8D66         F6            lea	sp,-$A[bp]
06873 1B6E           76           02            jbe 	.19B
06874                       00001B70            .19C:
06875 1B70           EB           03            jmp .172
06876                                           !BCC_EOS
06877                                           ! 1590   }
06878                       00001B72            .19B:
06879                                           ! 1591   bios_printf(4, "IDE time out\n");
06880                       00001B72            .173:
06881 1B72           E9         FEE0            br 	.174
06882                       00001B75            .172:
06883                                           ! Debug: list * char = .19E+0 (used reg = )
06884 1B75           BB                   D7E9  mov	bx,#.19E
06885 1B78           53                         push	bx
06886                                           ! Debug: list int = const 4 (used reg = )
06887 1B79           B8                   0004  mov	ax,*4
06888 1B7C           50                         push	ax
06889                                           ! Debug: func () void = bios_printf+0 (used reg = )
06890 1B7D           E8         EDB9            call	_bios_printf
06891 1B80           83C4                   04  add	sp,*4
06892                                           !BCC_EOS
06893                                           ! 1592   return -1;
06894 1B83           B8                   FFFF  mov	ax,*-1
06895 1B86           89EC                       mov	sp,bp
06896 1B88           5D                         pop	bp
06897 1B89           C3                         ret
06898                                           !BCC_EOS
06899                                           ! 1593 }
06900                                           ! 1594 void ata_detect( )
06901                                           ! Register BX used in function await_ide
06902                                           ! 1595 {
06903                                           export	_ata_detect
06904                       00001B8A            _ata_detect:
06905                                           ! 1596   Bit8u hdcount, cdcount, device, type;
06906                                           !BCC_EOS
06907                                           ! 1597   Bit8u buffer[0x0200];
06908                                           !BCC_EOS
06909                                           ! 1598   Bit16u old_ds 
06910                                           ! 1598 = set_DS(get_ebda_seg());
06911 1B8A           55                         push	bp
06912 1B8B           89E5                       mov	bp,sp
06913 1B8D           81C4                 FDFA  add	sp,#-$206
06914                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06915 1B91           E8         EAD3            call	_get_ebda_seg
06916                                           ! Debug: list unsigned short = ax+0 (used reg = )
06917 1B94           50                         push	ax
06918                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06919 1B95           E8         EAC5            call	_set_DS
06920 1B98           44                         inc	sp
06921 1B99           44                         inc	sp
06922                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$208-$208] (used reg = )
06923 1B9A           8986       FDFA            mov	-$206[bp],ax
06924                                           !BCC_EOS
06925                                           ! 1599   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].iface)) = (0x00);
06926                                           ! Debug: eq int = const 0 to unsigned char = [+$122] (used reg = )
06927 1B9E           30C0                       xor	al,al
06928 1BA0           A2         0122            mov	[$122],al
06929                                           !BCC_EOS
06930                                           ! 1600   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase1)) = (0x01f0);
06931                                           ! Debug: eq int = const $1F0 to unsigned short = [+$124] (used reg = )
06932 1BA3           B8                   01F0  mov	ax,#$1F0
06933 1BA6           A3         0124            mov	[$124],ax
06934                                           !BCC_EOS
06935                                           ! 1601   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase2)) = (0x3f0);
06936                                           ! Debug: eq int = const $3F0 to unsigned short = [+$126] (used reg = )
06937 1BA9           B8                   03F0  mov	ax,#$3F0
06938 1BAC           A3         0126            mov	[$126],ax
06939                                           !BCC_EOS
06940                                           ! 1602   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].irq)) = (14);
06941                                           ! Debug: eq int = const $E to unsigned char = [+$128] (used reg = )
06942 1BAF           B0                     0E  mov	al,*$E
06943 1BB1           A2         0128            mov	[$128],al
06944                                           !BCC_EOS
06945                                           ! 1603   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].iface)) = (0x00);
06946                                           ! Debug: eq int = const 0 to unsigned char = [+$12A] (used reg = )
06947 1BB4           30C0                       xor	al,al
06948 1BB6           A2         012A            mov	[$12A],al
06949                                           !BCC_EOS
06950                                           ! 1604   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase1)) = (0x0170);
06951                                           ! Debug: eq int = const $170 to unsigned short = [+$12C] (used reg = )
06952 1BB9           B8                   0170  mov	ax,#$170
06953 1BBC           A3         012C            mov	[$12C],ax
06954                                           !BCC_EOS
06955                                           ! 1605   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase2)) = (0x370);
06956                                           ! Debug: eq int = const $370 to unsigned short = [+$12E] (used reg = )
06957 1BBF           B8                   0370  mov	ax,#$370
06958 1BC2           A3         012E            mov	[$12E],ax
06959                                           !BCC_EOS
06960                                           ! 1606   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].irq)) = (15);
06961                                           ! Debug: eq int = const $F to unsigned char = [+$130] (used reg = )
06962 1BC5           B0                     0F  mov	al,*$F
06963 1BC7           A2         0130            mov	[$130],al
06964                                           !BCC_EOS
06965                                           ! 1607   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].iface)) = (0x00);
06966                                           ! Debug: eq int = const 0 to unsigned char = [+$132] (used reg = )
06967 1BCA           30C0                       xor	al,al
06968 1BCC           A2         0132            mov	[$132],al
06969                                           !BCC_EOS
06970                                           ! 1608   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase1)) = (0x1e8);
06971                                           ! Debug: eq int = const $1E8 to unsigned short = [+$134] (used reg = )
06972 1BCF           B8                   01E8  mov	ax,#$1E8
06973 1BD2           A3         0134            mov	[$134],ax
06974                                           !BCC_EOS
06975                                           ! 1609   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase2)) = (0x3e0);
06976                                           ! Debug: eq int = const $3E0 to unsigned short = [+$136] (used reg = )
06977 1BD5           B8                   03E0  mov	ax,#$3E0
06978 1BD8           A3         0136            mov	[$136],ax
06979                                           !BCC_EOS
06980                                           ! 1610   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].irq)) = (12);
06981                                           ! Debug: eq int = const $C to unsigned char = [+$138] (used reg = )
06982 1BDB           B0                     0C  mov	al,*$C
06983 1BDD           A2         0138            mov	[$138],al
06984                                           !BCC_EOS
06985                                           ! 1611   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].iface)) = (0x00);
06986                                           ! Debug: eq int = const 0 to unsigned char = [+$13A] (used reg = )
06987 1BE0           30C0                       xor	al,al
06988 1BE2           A2         013A            mov	[$13A],al
06989                                           !BCC_EOS
06990                                           ! 1612   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase1)) = (0x168);
06991                                           ! Debug: eq int = const $168 to unsigned short = [+$13C] (used reg = )
06992 1BE5           B8                   0168  mov	ax,#$168
06993 1BE8           A3         013C            mov	[$13C],ax
06994                                           !BCC_EOS
06995                                           ! 1613   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase2)) = (0x360);
06996                                           ! Debug: eq int = const $360 to unsigned short = [+$13E] (used reg = )
06997 1BEB           B8                   0360  mov	ax,#$360
06998 1BEE           A3         013E            mov	[$13E],ax
06999                                           !BCC_EOS
07000                                           ! 1614   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].irq)) = (11);
07001                                           ! Debug: eq int = const $B to unsigned char = [+$140] (used reg = )
07002 1BF1           B0                     0B  mov	al,*$B
07003 1BF3           A2         0140            mov	[$140],al
07004                                           !BCC_EOS
07005                                           ! 1615   hdcount=cdcount=0;
07006                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-4] (used reg = )
07007 1BF6           30C0                       xor	al,al
07008 1BF8           8846         FE            mov	-2[bp],al
07009                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-3] (used reg = )
07010 1BFB           8846         FF            mov	-1[bp],al
07011                                           !BCC_EOS
07012                                           ! 1616   for(device=0; device<(4*2); device++) {
07013                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-5] (used reg = )
07014 1BFE           30C0                       xor	al,al
07015 1C00           8846         FD            mov	-3[bp],al
07016                                           !BCC_EOS
07017                                           !BCC_EOS
07018 1C03           E9         0C0F            br 	.1A1
07019                       00001C06            .1A2:
07020                                           ! 1617     Bit16u iobase1, iobase2, blksize;
07021                                           !BCC_EOS
07022                                           ! 1618     Bit8u channel, slave, shift;
07023                                           !BCC_EOS
07024                                           ! 1619     Bit8u sc, sn, cl, ch, st;
07025                                           !BCC_EOS
07026                                           ! 1620     channel = device / 2;
07027 1C06           83C4                   F2  add	sp,*-$E
07028                                           ! Debug: div int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07029 1C09           8A46         FD            mov	al,-3[bp]
07030 1C0C           30E4                       xor	ah,ah
07031 1C0E           D1E8                       shr	ax,*1
07032                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$216-$20F] (used reg = )
07033 1C10           8886       FDF3            mov	-$20D[bp],al
07034                                           !BCC_EOS
07035                                           ! 1621     slave = device % 2;
07036                                           ! Debug: mod int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07037 1C14           8A46         FD            mov	al,-3[bp]
07038 1C17           30E4                       xor	ah,ah
07039 1C19           24                     01  and	al,*1
07040                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$216-$210] (used reg = )
07041 1C1B           8886       FDF2            mov	-$20E[bp],al
07042                                           !BCC_EOS
07043                                           ! 1622     iobase1 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
07044                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07045 1C1F           8A86       FDF3            mov	al,-$20D[bp]
07046 1C23           30E4                       xor	ah,ah
07047 1C25           B1                     03  mov	cl,*3
07048 1C27           D3E0                       shl	ax,cl
07049 1C29           89C3                       mov	bx,ax
07050                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07051                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
07052                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07053 1C2B           8B9F       0124            mov	bx,$124[bx]
07054 1C2F           899E       FDF8            mov	-$208[bp],bx
07055                                           !BCC_EOS
07056                                           ! 1623     iobase2 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
07057                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07058 1C33           8A86       FDF3            mov	al,-$20D[bp]
07059 1C37           30E4                       xor	ah,ah
07060 1C39           B1                     03  mov	cl,*3
07061 1C3B           D3E0                       shl	ax,cl
07062 1C3D           89C3                       mov	bx,ax
07063                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07064                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
07065                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07066 1C3F           8B9F       0126            mov	bx,$126[bx]
07067 1C43           899E       FDF6            mov	-$20A[bp],bx
07068                                           !BCC_EOS
07069                                           ! 1624     outb(iobase2+6, 0x08 | 0x02);
07070                                           ! Debug: list int = const $A (used reg = )
07071 1C47           B8                   000A  mov	ax,*$A
07072 1C4A           50                         push	ax
07073                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$218-$20C] (used reg = )
07074 1C4B           8B86       FDF6            mov	ax,-$20A[bp]
07075                                           ! Debug: list unsigned int = ax+6 (used reg = )
07076 1C4F           05                   0006  add	ax,*6
07077 1C52           50                         push	ax
07078                                           ! Debug: func () void = outb+0 (used reg = )
07079 1C53           E8         E8E9            call	_outb
07080 1C56           83C4                   04  add	sp,*4
07081                                           !BCC_EOS
07082                                           ! 1625     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07083 1C59           8A86       FDF2            mov	al,-$20E[bp]
07084 1C5D           84C0                       test	al,al
07085 1C5F           74           04            je  	.1A3
07086                       00001C61            .1A4:
07087 1C61           B0                     B0  mov	al,#$B0
07088 1C63           EB           02            jmp .1A5
07089                       00001C65            .1A3:
07090 1C65           B0                     A0  mov	al,#$A0
07091                       00001C67            .1A5:
07092                                           ! Debug: list char = al+0 (used reg = )
07093 1C67           30E4                       xor	ah,ah
07094 1C69           50                         push	ax
07095                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07096 1C6A           8B86       FDF8            mov	ax,-$208[bp]
07097                                           ! Debug: list unsigned int = ax+6 (used reg = )
07098 1C6E           05                   0006  add	ax,*6
07099 1C71           50                         push	ax
07100                                           ! Debug: func () void = outb+0 (used reg = )
07101 1C72           E8         E8CA            call	_outb
07102 1C75           83C4                   04  add	sp,*4
07103                                           !BCC_EOS
07104                                           ! 1626     outb(iobase1+2, 0x55);
07105                                           ! Debug: list int = const $55 (used reg = )
07106 1C78           B8                   0055  mov	ax,*$55
07107 1C7B           50                         push	ax
07108                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07109 1C7C           8B86       FDF8            mov	ax,-$208[bp]
07110                                           ! Debug: list unsigned int = ax+2 (used reg = )
07111 1C80           40                         inc	ax
07112 1C81           40                         inc	ax
07113 1C82           50                         push	ax
07114                                           ! Debug: func () void = outb+0 (used reg = )
07115 1C83           E8         E8B9            call	_outb
07116 1C86           83C4                   04  add	sp,*4
07117                                           !BCC_EOS
07118                                           ! 1627     outb(iobase1+3, 0xaa);
07119                                           ! Debug: list int = const $AA (used reg = )
07120 1C89           B8                   00AA  mov	ax,#$AA
07121 1C8C           50                         push	ax
07122                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07123 1C8D           8B86       FDF8            mov	ax,-$208[bp]
07124                                           ! Debug: list unsigned int = ax+3 (used reg = )
07125 1C91           05                   0003  add	ax,*3
07126 1C94           50                         push	ax
07127                                           ! Debug: func () void = outb+0 (used reg = )
07128 1C95           E8         E8A7            call	_outb
07129 1C98           83C4                   04  add	sp,*4
07130                                           !BCC_EOS
07131                                           ! 1628     outb(iobase1+2, 0xaa);
07132                                           ! Debug: list int = const $AA (used reg = )
07133 1C9B           B8                   00AA  mov	ax,#$AA
07134 1C9E           50                         push	ax
07135                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07136 1C9F           8B86       FDF8            mov	ax,-$208[bp]
07137                                           ! Debug: list unsigned int = ax+2 (used reg = )
07138 1CA3           40                         inc	ax
07139 1CA4           40                         inc	ax
07140 1CA5           50                         push	ax
07141                                           ! Debug: func () void = outb+0 (used reg = )
07142 1CA6           E8         E896            call	_outb
07143 1CA9           83C4                   04  add	sp,*4
07144                                           !BCC_EOS
07145                                           ! 1629     outb(iobase1+3, 0x55);
07146                                           ! Debug: list int = const $55 (used reg = )
07147 1CAC           B8                   0055  mov	ax,*$55
07148 1CAF           50                         push	ax
07149                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07150 1CB0           8B86       FDF8            mov	ax,-$208[bp]
07151                                           ! Debug: list unsigned int = ax+3 (used reg = )
07152 1CB4           05                   0003  add	ax,*3
07153 1CB7           50                         push	ax
07154                                           ! Debug: func () void = outb+0 (used reg = )
07155 1CB8           E8         E884            call	_outb
07156 1CBB           83C4                   04  add	sp,*4
07157                                           !BCC_EOS
07158                                           ! 1630     outb(iobase1+2, 0x55);
07159                                           ! Debug: list int = const $55 (used reg = )
07160 1CBE           B8                   0055  mov	ax,*$55
07161 1CC1           50                         push	ax
07162                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07163 1CC2           8B86       FDF8            mov	ax,-$208[bp]
07164                                           ! Debug: list unsigned int = ax+2 (used reg = )
07165 1CC6           40                         inc	ax
07166 1CC7           40                         inc	ax
07167 1CC8           50                         push	ax
07168                                           ! Debug: func () void = outb+0 (used reg = )
07169 1CC9           E8         E873            call	_outb
07170 1CCC           83C4                   04  add	sp,*4
07171                                           !BCC_EOS
07172                                           ! 1631     outb(iobase1+3, 0xaa);
07173                                           ! Debug: list int = const $AA (used reg = )
07174 1CCF           B8                   00AA  mov	ax,#$AA
07175 1CD2           50                         push	ax
07176                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07177 1CD3           8B86       FDF8            mov	ax,-$208[bp]
07178                                           ! Debug: list unsigned int = ax+3 (used reg = )
07179 1CD7           05                   0003  add	ax,*3
07180 1CDA           50                         push	ax
07181                                           ! Debug: func () void = outb+0 (used reg = )
07182 1CDB           E8         E861            call	_outb
07183 1CDE           83C4                   04  add	sp,*4
07184                                           !BCC_EOS
07185                                           ! 1632     sc = inb(iobase1+2);
07186                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07187 1CE1           8B86       FDF8            mov	ax,-$208[bp]
07188                                           ! Debug: list unsigned int = ax+2 (used reg = )
07189 1CE5           40                         inc	ax
07190 1CE6           40                         inc	ax
07191 1CE7           50                         push	ax
07192                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07193 1CE8           E8         E83E            call	_inb
07194 1CEB           44                         inc	sp
07195 1CEC           44                         inc	sp
07196                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07197 1CED           8886       FDF0            mov	-$210[bp],al
07198                                           !BCC_EOS
07199                                           ! 1633     sn = inb(iobase1+3);
07200                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07201 1CF1           8B86       FDF8            mov	ax,-$208[bp]
07202                                           ! Debug: list unsigned int = ax+3 (used reg = )
07203 1CF5           05                   0003  add	ax,*3
07204 1CF8           50                         push	ax
07205                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07206 1CF9           E8         E82D            call	_inb
07207 1CFC           44                         inc	sp
07208 1CFD           44                         inc	sp
07209                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07210 1CFE           8886       FDEF            mov	-$211[bp],al
07211                                           !BCC_EOS
07212                                           ! 1634     if ( (sc == 0x55) && (sn == 0xaa) ) {
07213                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$216-$212] (used reg = )
07214 1D02           8A86       FDF0            mov	al,-$210[bp]
07215 1D06           3C                     55  cmp	al,*$55
07216 1D08         0F85         0120            bne 	.1A6
07217                       00001D0C            .1A8:
07218                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$216-$213] (used reg = )
07219 1D0C           8A86       FDEF            mov	al,-$211[bp]
07220 1D10           3C                     AA  cmp	al,#$AA
07221 1D12         0F85         0116            bne 	.1A6
07222                       00001D16            .1A7:
07223                                           ! 1635       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x01);
07224                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07225 1D16           8A46         FD            mov	al,-3[bp]
07226 1D19           30E4                       xor	ah,ah
07227 1D1B           B9                   001E  mov	cx,*$1E
07228 1D1E           F7E9                       imul	cx
07229 1D20           89C3                       mov	bx,ax
07230                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07231                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07232                                           ! Debug: eq int = const 1 to unsigned char = [bx+$142] (used reg = )
07233 1D22           B0                     01  mov	al,*1
07234 1D24           8887       0142            mov	$142[bx],al
07235                                           !BCC_EOS
07236                                           ! 1636       ata_reset(device);
07237                                           ! Debug: list unsigned char device = [S+$216-5] (used reg = )
07238 1D28           8A46         FD            mov	al,-3[bp]
07239 1D2B           30E4                       xor	ah,ah
07240 1D2D           50                         push	ax
07241                                           ! Debug: func () void = ata_reset+0 (used reg = )
07242 1D2E           E8         0B28            call	_ata_reset
07243 1D31           44                         inc	sp
07244 1D32           44                         inc	sp
07245                                           !BCC_EOS
07246                                           ! 1637       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07247 1D33           8A86       FDF2            mov	al,-$20E[bp]
07248 1D37           84C0                       test	al,al
07249 1D39           74           04            je  	.1A9
07250                       00001D3B            .1AA:
07251 1D3B           B0                     B0  mov	al,#$B0
07252 1D3D           EB           02            jmp .1AB
07253                       00001D3F            .1A9:
07254 1D3F           B0                     A0  mov	al,#$A0
07255                       00001D41            .1AB:
07256                                           ! Debug: list char = al+0 (used reg = )
07257 1D41           30E4                       xor	ah,ah
07258 1D43           50                         push	ax
07259                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07260 1D44           8B86       FDF8            mov	ax,-$208[bp]
07261                                           ! Debug: list unsigned int = ax+6 (used reg = )
07262 1D48           05                   0006  add	ax,*6
07263 1D4B           50                         push	ax
07264                                           ! Debug: func () void = outb+0 (used reg = )
07265 1D4C           E8         E7F0            call	_outb
07266 1D4F           83C4                   04  add	sp,*4
07267                                           !BCC_EOS
07268                                           ! 1638       sc = inb(iobase1+2);
07269                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07270 1D52           8B86       FDF8            mov	ax,-$208[bp]
07271                                           ! Debug: list unsigned int = ax+2 (used reg = )
07272 1D56           40                         inc	ax
07273 1D57           40                         inc	ax
07274 1D58           50                         push	ax
07275                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07276 1D59           E8         E7CD            call	_inb
07277 1D5C           44                         inc	sp
07278 1D5D           44                         inc	sp
07279                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07280 1D5E           8886       FDF0            mov	-$210[bp],al
07281                                           !BCC_EOS
07282                                           ! 1639      
07283                                           ! 1639  sn = inb(iobase1+3);
07284                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07285 1D62           8B86       FDF8            mov	ax,-$208[bp]
07286                                           ! Debug: list unsigned int = ax+3 (used reg = )
07287 1D66           05                   0003  add	ax,*3
07288 1D69           50                         push	ax
07289                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07290 1D6A           E8         E7BC            call	_inb
07291 1D6D           44                         inc	sp
07292 1D6E           44                         inc	sp
07293                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07294 1D6F           8886       FDEF            mov	-$211[bp],al
07295                                           !BCC_EOS
07296                                           ! 1640       if ((sc==0x01) && (sn==0x01)) {
07297                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$216-$212] (used reg = )
07298 1D73           8A86       FDF0            mov	al,-$210[bp]
07299 1D77           3C                     01  cmp	al,*1
07300 1D79         0F85         00AF            bne 	.1AC
07301                       00001D7D            .1AE:
07302                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$216-$213] (used reg = )
07303 1D7D           8A86       FDEF            mov	al,-$211[bp]
07304 1D81           3C                     01  cmp	al,*1
07305 1D83         0F85         00A5            bne 	.1AC
07306                       00001D87            .1AD:
07307                                           ! 1641         cl = inb(iobase1+4);
07308                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07309 1D87           8B86       FDF8            mov	ax,-$208[bp]
07310                                           ! Debug: list unsigned int = ax+4 (used reg = )
07311 1D8B           05                   0004  add	ax,*4
07312 1D8E           50                         push	ax
07313                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07314 1D8F           E8         E797            call	_inb
07315 1D92           44                         inc	sp
07316 1D93           44                         inc	sp
07317                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$216-$214] (used reg = )
07318 1D94           8886       FDEE            mov	-$212[bp],al
07319                                           !BCC_EOS
07320                                           ! 1642         ch = inb(iobase1+5);
07321                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07322 1D98           8B86       FDF8            mov	ax,-$208[bp]
07323                                           ! Debug: list unsigned int = ax+5 (used reg = )
07324 1D9C           05                   0005  add	ax,*5
07325 1D9F           50                         push	ax
07326                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07327 1DA0           E8         E786            call	_inb
07328 1DA3           44                         inc	sp
07329 1DA4           44                         inc	sp
07330                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$216-$215] (used reg = )
07331 1DA5           8886       FDED            mov	-$213[bp],al
07332                                           !BCC_EOS
07333                                           ! 1643         st = inb(iobase1+7);
07334                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07335 1DA9           8B86       FDF8            mov	ax,-$208[bp]
07336                                           ! Debug: list unsigned int = ax+7 (used reg = )
07337 1DAD           05                   0007  add	ax,*7
07338 1DB0           50                         push	ax
07339                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07340 1DB1           E8         E775            call	_inb
07341 1DB4           44                         inc	sp
07342 1DB5           44                         inc	sp
07343                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$216-$216] (used reg = )
07344 1DB6           8886       FDEC            mov	-$214[bp],al
07345                                           !BCC_EOS
07346                                           ! 1644         if ((cl==0x14) && (ch==0xeb)) {
07347                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$216-$214] (used reg = )
07348 1DBA           8A86       FDEE            mov	al,-$212[bp]
07349 1DBE           3C                     14  cmp	al,*$14
07350 1DC0           75           1C            jne 	.1AF
07351                       00001DC2            .1B1:
07352                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$216-$215] (used reg = )
07353 1DC2           8A86       FDED            mov	al,-$213[bp]
07354 1DC6           3C                     EB  cmp	al,#$EB
07355 1DC8           75           14            jne 	.1AF
07356                       00001DCA            .1B0:
07357                                           ! 1645           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x03);
07358                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07359 1DCA           8A46         FD            mov	al,-3[bp]
07360 1DCD           30E4                       xor	ah,ah
07361 1DCF           B9                   001E  mov	cx,*$1E
07362 1DD2           F7E9                       imul	cx
07363 1DD4           89C3                       mov	bx,ax
07364                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07365                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07366                                           ! Debug: eq int = const 3 to unsigned char = [bx+$142] (used reg = )
07367 1DD6           B0                     03  mov	al,*3
07368 1DD8           8887       0142            mov	$142[bx],al
07369                                           !BCC_EOS
07370                                           ! 1646         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07371 1DDC           EB           4E            jmp .1B2
07372                       00001DDE            .1AF:
07373                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$216-$214] (used reg = )
07374 1DDE           8A86       FDEE            mov	al,-$212[bp]
07375 1DE2           84C0                       test	al,al
07376 1DE4           75           24            jne 	.1B3
07377                       00001DE6            .1B6:
07378                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$216-$215] (used reg = )
07379 1DE6           8A86       FDED            mov	al,-$213[bp]
07380 1DEA           84C0                       test	al,al
07381 1DEC           75           1C            jne 	.1B3
07382                       00001DEE            .1B5:
07383                                           ! Debug: ne int = const 0 to unsigned char st = [S+$216-$216] (used reg = )
07384 1DEE           8A86       FDEC            mov	al,-$214[bp]
07385 1DF2           84C0                       test	al,al
07386 1DF4           74           14            je  	.1B3
07387                       00001DF6            .1B4:
07388                                           ! 1647           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x02);
07389                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07390 1DF6           8A46         FD            mov	al,-3[bp]
07391 1DF9           30E4                       xor	ah,ah
07392 1DFB           B9                   001E  mov	cx,*$1E
07393 1DFE           F7E9                       imul	cx
07394 1E00           89C3                       mov	bx,ax
07395                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07396                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07397                                           ! Debug: eq int = const 2 to unsigned char = [bx+$142] (used reg = )
07398 1E02           B0                     02  mov	al,*2
07399 1E04           8887       0142            mov	$142[bx],al
07400                                           !BCC_EOS
07401                                           ! 1648         } else if ((cl==0xff) && (ch==0xff)) {
07402 1E08           EB           22            jmp .1B7
07403                       00001E0A            .1B3:
07404                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$216-$214] (used reg = )
07405 1E0A           8A86       FDEE            mov	al,-$212[bp]
07406 1E0E           3C                     FF  cmp	al,#$FF
07407 1E10           75           1A            jne 	.1B8
07408                       00001E12            .1BA:
07409                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$216-$215] (used reg = )
07410 1E12           8A86       FDED            mov	al,-$213[bp]
07411 1E16           3C                     FF  cmp	al,#$FF
07412 1E18           75           12            jne 	.1B8
07413                       00001E1A            .1B9:
07414                                           ! 1649           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
07415                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07416 1E1A           8A46         FD            mov	al,-3[bp]
07417 1E1D           30E4                       xor	ah,ah
07418 1E1F           B9                   001E  mov	cx,*$1E
07419 1E22           F7E9                       imul	cx
07420 1E24           89C3                       mov	bx,ax
07421                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07422                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07423                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
07424 1E26           30C0                       xor	al,al
07425 1E28           8887       0142            mov	$142[bx],al
07426                                           !BCC_EOS
07427                                           ! 1650         }
07428                                           ! 1651       }
07429                       00001E2C            .1B8:
07430                       00001E2C            .1B7:
07431                       00001E2C            .1B2:
07432                                           ! 1652     }
07433                       00001E2C            .1AC:
07434                                           ! 1653     type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
07435                       00001E2C            .1A6:
07436                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07437 1E2C           8A46         FD            mov	al,-3[bp]
07438 1E2F           30E4                       xor	ah,ah
07439 1E31           B9                   001E  mov	cx,*$1E
07440 1E34           F7E9                       imul	cx
07441 1E36           89C3                       mov	bx,ax
07442                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07443                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07444                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$216-6] (used reg = )
07445 1E38           8A87       0142            mov	al,$142[bx]
07446 1E3C           8846         FC            mov	-4[bp],al
07447                                           !BCC_EOS
07448                                           ! 1654     if(type == 0x02) {
07449                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$216-6] (used reg = )
07450 1E3F           8A46         FC            mov	al,-4[bp]
07451 1E42           3C                     02  cmp	al,*2
07452 1E44         0F85         04CC            bne 	.1BB
07453                       00001E48            .1BC:
07454                                           ! 1655       Bit32u sectors_low, sectors_high;
07455                                           !BCC_EOS
07456                                           ! 1656       Bit16u cylinders, heads, spt;
07457                                           !BCC_EOS
07458                                           ! 1657       Bit8u translation, removable, mode;
07459                                           !BCC_EOS
07460                                           ! 1658       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07461 1E48           83C4                   EE  add	sp,*-$12
07462                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07463 1E4B           8A46         FD            mov	al,-3[bp]
07464 1E4E           30E4                       xor	ah,ah
07465 1E50           B9                   001E  mov	cx,*$1E
07466 1E53           F7E9                       imul	cx
07467 1E55           89C3                       mov	bx,ax
07468                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07469                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07470                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07471 1E57           B0                     FF  mov	al,#$FF
07472 1E59           8887       0143            mov	$143[bx],al
07473                                           !BCC_EOS
07474                                           ! 1659       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
07475                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07476 1E5D           8A46         FD            mov	al,-3[bp]
07477 1E60           30E4                       xor	ah,ah
07478 1E62           B9                   001E  mov	cx,*$1E
07479 1E65           F7E9                       imul	cx
07480 1E67           89C3                       mov	bx,ax
07481                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07483                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
07484 1E69           30C0                       xor	al,al
07485 1E6B           8887       0146            mov	$146[bx],al
07486                                           !BCC_EOS
07487                                           ! 1660       if (ata_cmd_data_io(0, device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07488                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07489 1E6F           8D9E       FDFC            lea	bx,-$204[bp]
07490 1E73           53                         push	bx
07491                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07492 1E74           E8         E7E3            call	_get_SS
07493                                           ! Debug: list unsigned short = ax+0 (used reg = )
07494 1E77           50                         push	ax
07495                                           ! Debug: list long = const 0 (used reg = )
07496 1E78           31C0                       xor	ax,ax
07497 1E7A           31DB                       xor	bx,bx
07498 1E7C           53                         push	bx
07499 1E7D           50                         push	ax
07500                                           ! Debug: list long = const 0 (used reg = )
07501 1E7E           31C0                       xor	ax,ax
07502 1E80           31DB                       xor	bx,bx
07503 1E82           53                         push	bx
07504 1E83           50                         push	ax
07505                                           ! Debug: list int = const 0 (used reg = )
07506 1E84           31C0                       xor	ax,ax
07507 1E86           50                         push	ax
07508                                           ! Debug: list int = const 0 (used reg = )
07509 1E87           31C0                       xor	ax,ax
07510 1E89           50                         push	ax
07511                                           ! Debug: list int = const 0 (used reg = )
07512 1E8A           31C0                       xor	ax,ax
07513 1E8C           50                         push	ax
07514                                           ! Debug: list int = const 1 (used reg = )
07515 1E8D           B8                   0001  mov	ax,*1
07516 1E90           50                         push	ax
07517                                           ! Debug: list int = const $EC (used reg = )
07518 1E91           B8                   00EC  mov	ax,#$EC
07519 1E94           50                         push	ax
07520                                           ! Debug: list unsigned char device = [S+$23E-5] (used reg = )
07521 1E95           8A46         FD            mov	al,-3[bp]
07522 1E98           30E4                       xor	ah,ah
07523 1E9A           50                         push	ax
07524                                           ! Debug: list int = const 0 (used reg = )
07525 1E9B           31C0                       xor	ax,ax
07526 1E9D           50                         push	ax
07527                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
07528 1E9E           E8         0ADF            call	_ata_cmd_data_io
07529 1EA1           83C4                   1A  add	sp,*$1A
07530                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07531 1EA4           85C0                       test	ax,ax
07532 1EA6           74           0E            je  	.1BD
07533                       00001EA8            .1BE:
07534                                           ! 1661         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07535                                           ! Debug: list * char = .1BF+0 (used reg = )
07536 1EA8           BB                   D7C0  mov	bx,#.1BF
07537 1EAB           53                         push	bx
07538                                           ! Debug: list int = const 7 (used reg = )
07539 1EAC           B8                   0007  mov	ax,*7
07540 1EAF           50                         push	ax
07541                                           ! Debug: func () void = bios_printf+0 (used reg = )
07542 1EB0           E8         EA86            call	_bios_printf
07543 1EB3           83C4                   04  add	sp,*4
07544                                           !BCC_EOS
07545                                           ! 1662       removable = (read_byte_SS(buffer+0) & 0x80) >> 7;
07546                       00001EB6            .1BD:
07547                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07548 1EB6           8D9E       FDFC            lea	bx,-$204[bp]
07549 1EBA           53                         push	bx
07550                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07551 1EBB           E8         E763            call	_read_byte_SS
07552 1EBE           44                         inc	sp
07553 1EBF           44                         inc	sp
07554                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07555 1EC0           24                     80  and	al,#$80
07556                                           ! Debug: sr int = const 7 to unsigned char = al+0 (used reg = )
07557 1EC2           30E4                       xor	ah,ah
07558 1EC4           B1                     07  mov	cl,*7
07559 1EC6           D3E8                       shr	ax,cl
07560                                           ! Debug: eq unsigned int = ax+0 to unsigned char removable = [S+$228-$226] (used reg = )
07561 1EC8           8886       FDDC            mov	-$224[bp],al
07562                                           !BCC_EOS
07563                                           ! 1663       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
07564                                           ! Debug: list * unsigned char buffer = S+$228-$1A6 (used reg = )
07565 1ECC           8D9E       FE5C            lea	bx,-$1A4[bp]
07566 1ED0           53                         push	bx
07567                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07568 1ED1           E8         E74D            call	_read_byte_SS
07569 1ED4           44                         inc	sp
07570 1ED5           44                         inc	sp
07571 1ED6           84C0                       test	al,al
07572 1ED8           74           04            je  	.1C0
07573                       00001EDA            .1C1:
07574 1EDA           B0                     01  mov	al,*1
07575 1EDC           EB           02            jmp .1C2
07576                       00001EDE            .1C0:
07577 1EDE           30C0                       xor	al,al
07578                       00001EE0            .1C2:
07579                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07580 1EE0           8886       FDDB            mov	-$225[bp],al
07581                                           !BCC_EOS
07582                                           ! 1664       blksize = read_word_SS(buffer+10);
07583                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
07584 1EE4           8D9E       FE06            lea	bx,-$1FA[bp]
07585 1EE8           53                         push	bx
07586                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07587 1EE9           E8         E740            call	_read_word_SS
07588 1EEC           44                         inc	sp
07589 1EED           44                         inc	sp
07590                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$20E] (used reg = )
07591 1EEE           8986       FDF4            mov	-$20C[bp],ax
07592                                           !BCC_EOS
07593                                           ! 1665       cylinders = read_word_SS(buffer+(1*2));
07594                                           ! Debug: list * unsigned char buffer = S+$228-$204 (used reg = )
07595 1EF2           8D9E       FDFE            lea	bx,-$202[bp]
07596 1EF6           53                         push	bx
07597                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07598 1EF7           E8         E732            call	_read_word_SS
07599 1EFA           44                         inc	sp
07600 1EFB           44                         inc	sp
07601                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
07602 1EFC           8986       FDE2            mov	-$21E[bp],ax
07603                                           !BCC_EOS
07604                                           ! 1666       heads = read_word_SS(buffer+(3*2));
07605                                           ! Debug: list * unsigned char buffer = S+$228-$200 (used reg = )
07606 1F00           8D9E       FE02            lea	bx,-$1FE[bp]
07607 1F04           53                         push	bx
07608                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07609 1F05           E8         E724            call	_read_word_SS
07610 1F08           44                         inc	sp
07611 1F09           44                         inc	sp
07612                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$222] (used reg = )
07613 1F0A           8986       FDE0            mov	-$220[bp],ax
07614                                           !BCC_EOS
07615                                           ! 1667       spt = read_word_SS(buffer+(6*2));
07616                                           ! Debug: list * unsigned char buffer = S+$228-$1FA (used reg = )
07617 1F0E           8D9E       FE08            lea	bx,-$1F8[bp]
07618 1F12           53                         push	bx
07619                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07620 1F13           E8         E716            call	_read_word_SS
07621 1F16           44                         inc	sp
07622 1F17           44                         inc	sp
07623                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$224] (used reg = )
07624 1F18           8986       FDDE            mov	-$222[bp],ax
07625                                           !BCC_EOS
07626                                           ! 1668       if (read_word_SS(buffer+(83*2)) & (1 << 10)) {
07627                                           ! Debug: list * unsigned char buffer = S+$228-$160 (used reg = )
07628 1F1C           8D9E       FEA2            lea	bx,-$15E[bp]
07629 1F20           53                         push	bx
07630                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07631 1F21           E8         E708            call	_read_word_SS
07632 1F24           44                         inc	sp
07633 1F25           44                         inc	sp
07634                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
07635 1F26           25                   0400  and	ax,#$400
07636 1F29           85C0                       test	ax,ax
07637 1F2B           74           2A            je  	.1C3
07638                       00001F2D            .1C4:
07639                                           ! 1669         sectors_low = read_dword_SS(buffer+(100*2));
07640                                           ! Debug: list * unsigned char buffer = S+$228-$13E (used reg = )
07641 1F2D           8D9E       FEC4            lea	bx,-$13C[bp]
07642 1F31           53                         push	bx
07643                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07644 1F32           E8         E149            call	_read_dword_SS
07645 1F35           89D3                       mov	bx,dx
07646 1F37           44                         inc	sp
07647 1F38           44                         inc	sp
07648                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07649 1F39           8986       FDE8            mov	-$218[bp],ax
07650 1F3D           899E       FDEA            mov	-$216[bp],bx
07651                                           !BCC_EOS
07652                                           ! 1670         sectors_high = read_dword_SS(buffer+(102*2));
07653                                           ! Debug: list * unsigned char buffer = S+$228-$13A (used reg = )
07654 1F41           8D9E       FEC8            lea	bx,-$138[bp]
07655 1F45           53                         push	bx
07656                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07657 1F46           E8         E135            call	_read_dword_SS
07658 1F49           89D3                       mov	bx,dx
07659 1F4B           44                         inc	sp
07660 1F4C           44                         inc	sp
07661                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07662 1F4D           8986       FDE4            mov	-$21C[bp],ax
07663 1F51           899E       FDE6            mov	-$21A[bp],bx
07664                                           !BCC_EOS
07665                                           ! 1671       } else {
07666 1F55           EB           20            jmp .1C5
07667                       00001F57            .1C3:
07668                                           ! 1672         sectors_low = read_dword_SS(buffer+(60*2));
07669                                           ! Debug: list * unsigned char buffer = S+$228-$18E (used reg = )
07670 1F57           8D9E       FE74            lea	bx,-$18C[bp]
07671 1F5B           53                         push	bx
07672                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07673 1F5C           E8         E11F            call	_read_dword_SS
07674 1F5F           89D3                       mov	bx,dx
07675 1F61           44                         inc	sp
07676 1F62           44                         inc	sp
07677                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07678 1F63           8986       FDE8            mov	-$218[bp],ax
07679 1F67           899E       FDEA            mov	-$216[bp],bx
07680                                           !BCC_EOS
07681                                           ! 1673         sectors_high = 0;
07682                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07683 1F6B           31C0                       xor	ax,ax
07684 1F6D           31DB                       xor	bx,bx
07685 1F6F           8986       FDE4            mov	-$21C[bp],ax
07686 1F73           899E       FDE6            mov	-$21A[bp],bx
07687                                           !BCC_EOS
07688                                           ! 1674       }
07689                                           ! 1675       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07690                       00001F77            .1C5:
07691                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07692 1F77           8A46         FD            mov	al,-3[bp]
07693 1F7A           30E4                       xor	ah,ah
07694 1F7C           B9                   001E  mov	cx,*$1E
07695 1F7F           F7E9                       imul	cx
07696 1F81           89C3                       mov	bx,ax
07697                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07698                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07699                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07700 1F83           B0                     FF  mov	al,#$FF
07701 1F85           8887       0143            mov	$143[bx],al
07702                                           !BCC_EOS
07703                                           ! 1676       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
07704                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07705 1F89           8A46         FD            mov	al,-3[bp]
07706 1F8C           30E4                       xor	ah,ah
07707 1F8E           B9                   001E  mov	cx,*$1E
07708 1F91           F7E9                       imul	cx
07709 1F93           89C3                       mov	bx,ax
07710                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
07711                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
07712                                           ! Debug: eq unsigned char removable = [S+$228-$226] to unsigned char = [bx+$144] (used reg = )
07713 1F95           8A86       FDDC            mov	al,-$224[bp]
07714 1F99           8887       0144            mov	$144[bx],al
07715                                           !BCC_EOS
07716                                           ! 1677       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
07717                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07718 1F9D           8A46         FD            mov	al,-3[bp]
07719 1FA0           30E4                       xor	ah,ah
07720 1FA2           B9                   001E  mov	cx,*$1E
07721 1FA5           F7E9                       imul	cx
07722 1FA7           89C3                       mov	bx,ax
07723                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07724                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07725                                           ! Debug: eq unsigned char mode = [S+$228-$227] to unsigned char = [bx+$146] (used reg = )
07726 1FA9           8A86       FDDB            mov	al,-$225[bp]
07727 1FAD           8887       0146            mov	$146[bx],al
07728                                           !BCC_EOS
07729                                           ! 1678       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
07730                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07731 1FB1           8A46         FD            mov	al,-3[bp]
07732 1FB4           30E4                       xor	ah,ah
07733 1FB6           B9                   001E  mov	cx,*$1E
07734 1FB9           F7E9                       imul	cx
07735 1FBB           89C3                       mov	bx,ax
07736                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
07737                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
07738                                           ! Debug: eq unsigned short blksize = [S+$228-$20E] to unsigned short = [bx+$148] (used reg = )
07739 1FBD           8B86       FDF4            mov	ax,-$20C[bp]
07740 1FC1           8987       0148            mov	$148[bx],ax
07741                                           !BCC_EOS
07742                                           ! 1679       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (heads);
07743                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07744 1FC5           8A46         FD            mov	al,-3[bp]
07745 1FC8           30E4                       xor	ah,ah
07746 1FCA           B9                   001E  mov	cx,*$1E
07747 1FCD           F7E9                       imul	cx
07748 1FCF           89C3                       mov	bx,ax
07749                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
07750                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
07751                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$152] (used reg = )
07752 1FD1           8B86       FDE0            mov	ax,-$220[bp]
07753 1FD5           8987       0152            mov	$152[bx],ax
07754                                           !BCC_EOS
07755                                           ! 1680     
07756                                           ! 1680   *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (cylinders);
07757                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07758 1FD9           8A46         FD            mov	al,-3[bp]
07759 1FDC           30E4                       xor	ah,ah
07760 1FDE           B9                   001E  mov	cx,*$1E
07761 1FE1           F7E9                       imul	cx
07762 1FE3           89C3                       mov	bx,ax
07763                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
07764                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
07765                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$154] (used reg = )
07766 1FE5           8B86       FDE2            mov	ax,-$21E[bp]
07767 1FE9           8987       0154            mov	$154[bx],ax
07768                                           !BCC_EOS
07769                                           ! 1681       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (spt);
07770                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07771 1FED           8A46         FD            mov	al,-3[bp]
07772 1FF0           30E4                       xor	ah,ah
07773 1FF2           B9                   001E  mov	cx,*$1E
07774 1FF5           F7E9                       imul	cx
07775 1FF7           89C3                       mov	bx,ax
07776                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
07777                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
07778                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$156] (used reg = )
07779 1FF9           8B86       FDDE            mov	ax,-$222[bp]
07780 1FFD           8987       0156            mov	$156[bx],ax
07781                                           !BCC_EOS
07782                                           ! 1682       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (sectors_low);
07783                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07784 2001           8A46         FD            mov	al,-3[bp]
07785 2004           30E4                       xor	ah,ah
07786 2006           B9                   001E  mov	cx,*$1E
07787 2009           F7E9                       imul	cx
07788 200B           89C3                       mov	bx,ax
07789                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
07790                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
07791                                           ! Debug: eq unsigned long sectors_low = [S+$228-$21A] to unsigned long = [bx+$158] (used reg = )
07792 200D           8B86       FDE8            mov	ax,-$218[bp]
07793 2011           8BB6       FDEA            mov	si,-$216[bp]
07794 2015           8987       0158            mov	$158[bx],ax
07795 2019           89B7       015A            mov	$15A[bx],si
07796                                           !BCC_EOS
07797                                           ! 1683       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (sectors_high);
07798                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07799 201D           8A46         FD            mov	al,-3[bp]
07800 2020           30E4                       xor	ah,ah
07801 2022           B9                   001E  mov	cx,*$1E
07802 2025           F7E9                       imul	cx
07803 2027           89C3                       mov	bx,ax
07804                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
07805                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
07806                                           ! Debug: eq unsigned long sectors_high = [S+$228-$21E] to unsigned long = [bx+$15C] (used reg = )
07807 2029           8B86       FDE4            mov	ax,-$21C[bp]
07808 202D           8BB6       FDE6            mov	si,-$21A[bp]
07809 2031           8987       015C            mov	$15C[bx],ax
07810 2035           89B7       015E            mov	$15E[bx],si
07811                                           !BCC_EOS
07812                                           ! 1684       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
07813                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
07814 2039           FFB6       FDDE            push	-$222[bp]
07815                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
07816 203D           FFB6       FDE0            push	-$220[bp]
07817                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
07818 2041           FFB6       FDE2            push	-$21E[bp]
07819                                           ! Debug: list unsigned char slave = [S+$22E-$210] (used reg = )
07820 2045           8A86       FDF2            mov	al,-$20E[bp]
07821 2049           30E4                       xor	ah,ah
07822 204B           50                         push	ax
07823                                           ! Debug: list unsigned char channel = [S+$230-$20F] (used reg = )
07824 204C           8A86       FDF3            mov	al,-$20D[bp]
07825 2050           30E4                       xor	ah,ah
07826 2052           50                         push	ax
07827                                           ! Debug: list * char = .1C6+0 (used reg = )
07828 2053           BB                   D79B  mov	bx,#.1C6
07829 2056           53                         push	bx
07830                                           ! Debug: list int = const 4 (used reg = )
07831 2057           B8                   0004  mov	ax,*4
07832 205A           50                         push	ax
07833                                           ! Debug: func () void = bios_printf+0 (used reg = )
07834 205B           E8         E8DB            call	_bios_printf
07835 205E           83C4                   0E  add	sp,*$E
07836                                           !BCC_EOS
07837                                           ! 1685       translation = inb_cmos(0x39 + channel/2);
07838                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20F] (used reg = )
07839 2061           8A86       FDF3            mov	al,-$20D[bp]
07840 2065           30E4                       xor	ah,ah
07841 2067           D1E8                       shr	ax,*1
07842                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
07843                                           ! Debug: expression subtree swapping
07844                                           ! Debug: list unsigned int = ax+$39 (used reg = )
07845 2069           05                   0039  add	ax,*$39
07846 206C           50                         push	ax
07847                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
07848 206D           E8         E4FE            call	_inb_cmos
07849 2070           44                         inc	sp
07850 2071           44                         inc	sp
07851                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
07852 2072           8886       FDDD            mov	-$223[bp],al
07853                                           !BCC_EOS
07854                                           ! 1686       for (shift=device%4; shift>0; shift--) translation >>= 2;
07855                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-5] (used reg = )
07856 2076           8A46         FD            mov	al,-3[bp]
07857 2079           30E4                       xor	ah,ah
07858 207B           24                     03  and	al,*3
07859                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$211] (used reg = )
07860 207D           8886       FDF1            mov	-$20F[bp],al
07861                                           !BCC_EOS
07862                                           !BCC_EOS
07863 2081           EB           17            jmp .1C9
07864                       00002083            .1CA:
07865                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
07866 2083           8A86       FDDD            mov	al,-$223[bp]
07867 2087           30E4                       xor	ah,ah
07868 2089           D1E8                       shr	ax,*1
07869 208B           D1E8                       shr	ax,*1
07870 208D           8886       FDDD            mov	-$223[bp],al
07871                                           !BCC_EOS
07872                                           ! 1687       translation &= 0x03;
07873                       00002091            .1C8:
07874                                           ! Debug: postdec unsigned char shift = [S+$228-$211] (used reg = )
07875 2091           8A86       FDF1            mov	al,-$20F[bp]
07876 2095           48                         dec	ax
07877 2096           8886       FDF1            mov	-$20F[bp],al
07878                       0000209A            .1C9:
07879                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$211] (used reg = )
07880 209A           8A86       FDF1            mov	al,-$20F[bp]
07881 209E           84C0                       test	al,al
07882 20A0           75           E1            jne	.1CA
07883                       000020A2            .1CB:
07884                       000020A2            .1C7:
07885                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
07886 20A2           8A86       FDDD            mov	al,-$223[bp]
07887 20A6           24                     03  and	al,*3
07888 20A8           8886       FDDD            mov	-$223[bp],al
07889                                           !BCC_EOS
07890                                           ! 1688       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (translation);
07891                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07892 20AC           8A46         FD            mov	al,-3[bp]
07893 20AF           30E4                       xor	ah,ah
07894 20B1           B9                   001E  mov	cx,*$1E
07895 20B4           F7E9                       imul	cx
07896 20B6           89C3                       mov	bx,ax
07897                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
07898                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
07899                                           ! Debug: eq unsigned char translation = [S+$228-$225] to unsigned char = [bx+$14A] (used reg = )
07900 20B8           8A86       FDDD            mov	al,-$223[bp]
07901 20BC           8887       014A            mov	$14A[bx],al
07902                                           !BCC_EOS
07903                                           ! 1689       switch (translation) {
07904 20C0           8A86       FDDD            mov	al,-$223[bp]
07905 20C4           EB           42            jmp .1CE
07906                                           ! 1690         case 0:
07907                                           ! 1691           bios_printf(4, "none");
07908                       000020C6            .1CF:
07909                                           ! Debug: list * char = .1D0+0 (used reg = )
07910 20C6           BB                   D796  mov	bx,#.1D0
07911 20C9           53                         push	bx
07912                                           ! Debug: list int = const 4 (used reg = )
07913 20CA           B8                   0004  mov	ax,*4
07914 20CD           50                         push	ax
07915                                           ! Debug: func () void = bios_printf+0 (used reg = )
07916 20CE           E8         E868            call	_bios_printf
07917 20D1           83C4                   04  add	sp,*4
07918                                           !BCC_EOS
07919                                           ! 1692           break;
07920 20D4           EB           42            jmp .1CC
07921                                           !BCC_EOS
07922                                           ! 1693         case 1:
07923                                           ! 1694           bios_printf(4, "lba");
07924                       000020D6            .1D1:
07925                                           ! Debug: list * char = .1D2+0 (used reg = )
07926 20D6           BB                   D792  mov	bx,#.1D2
07927 20D9           53                         push	bx
07928                                           ! Debug: list int = const 4 (used reg = )
07929 20DA           B8                   0004  mov	ax,*4
07930 20DD           50                         push	ax
07931                                           ! Debug: func () void = bios_printf+0 (used reg = )
07932 20DE           E8         E858            call	_bios_printf
07933 20E1           83C4                   04  add	sp,*4
07934                                           !BCC_EOS
07935                                           ! 1695           break;
07936 20E4           EB           32            jmp .1CC
07937                                           !BCC_EOS
07938                                           ! 1696         case 2:
07939                                           ! 1697           bios_printf(4, "large");
07940                       000020E6            .1D3:
07941                                           ! Debug: list * char = .1D4+0 (used reg = )
07942 20E6           BB                   D78C  mov	bx,#.1D4
07943 20E9           53                         push	bx
07944                                           ! Debug: list int = const 4 (used reg = )
07945 20EA           B8                   0004  mov	ax,*4
07946 20ED           50                         push	ax
07947                                           ! Debug: func () void = bios_printf+0 (used reg = )
07948 20EE           E8         E848            call	_bios_printf
07949 20F1           83C4                   04  add	sp,*4
07950                                           !BCC_EOS
07951                                           ! 1698           break;
07952 20F4           EB           22            jmp .1CC
07953                                           !BCC_EOS
07954                                           ! 1699         case 3:
07955                                           ! 1700           bios_printf(4, "r-echs");
07956                       000020F6            .1D5:
07957                                           ! Debug: list * char = .1D6+0 (used reg = )
07958 20F6           BB                   D785  mov	bx,#.1D6
07959 20F9           53                         push	bx
07960                                           ! Debug: list int = const 4 (used reg = )
07961 20FA           B8                   0004  mov	ax,*4
07962 20FD           50                         push	ax
07963                                           ! Debug: func () void = bios_printf+0 (used reg = )
07964 20FE           E8         E838            call	_bios_printf
07965 2101           83C4                   04  add	sp,*4
07966                                           !BCC_EOS
07967                                           ! 1701           break;
07968 2104           EB           12            jmp .1CC
07969                                           !BCC_EOS
07970                                           ! 1702       }
07971                                           ! 1703       switch (translation) {
07972 2106           EB           10            jmp .1CC
07973                       00002108            .1CE:
07974 2108           2C                     00  sub	al,*0
07975 210A           74           BA            je 	.1CF
07976 210C           2C                     01  sub	al,*1
07977 210E           74           C6            je 	.1D1
07978 2110           2C                     01  sub	al,*1
07979 2112           74           D2            je 	.1D3
07980 2114           2C                     01  sub	al,*1
07981 2116           74           DE            je 	.1D5
07982                       00002118            .1CC:
07983                       FFFFFDD8            ..FFFE	=	-$228
07984 2118           8A86       FDDD            mov	al,-$223[bp]
07985 211C           E9         0161            br 	.1D9
07986                                           ! 1704         case 0:
07987                                           ! 1705           break;
07988                       0000211F            .1DA:
07989 211F           E9         0174            br 	.1D7
07990                                           !BCC_EOS
07991                                           ! 1706         case 1:
07992                                           ! 1707           spt = 63;
07993                       00002122            .1DB:
07994                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$224] (used reg = )
07995 2122           B8                   003F  mov	ax,*$3F
07996 2125           8986       FDDE            mov	-$222[bp],ax
07997                                           !BCC_EOS
07998                                           ! 1708           sectors_low /= 63;
07999                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08000 2129           B8                   003F  mov	ax,*$3F
08001 212C           31DB                       xor	bx,bx
08002 212E           53                         push	bx
08003 212F           50                         push	ax
08004 2130           8B86       FDE8            mov	ax,-$218[bp]
08005 2134           8B9E       FDEA            mov	bx,-$216[bp]
08006 2138           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08007 213C           E8         E000            call	ldivul
08008 213F           8986       FDE8            mov	-$218[bp],ax
08009 2143           899E       FDEA            mov	-$216[bp],bx
08010 2147           83C4                   04  add	sp,*4
08011                                           !BCC_EOS
08012                                           ! 1709           heads = sectors_low / 1024;
08013                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08014 214A           B8                   0400  mov	ax,#$400
08015 214D           31DB                       xor	bx,bx
08016 214F           53                         push	bx
08017 2150           50                         push	ax
08018 2151           8B86       FDE8            mov	ax,-$218[bp]
08019 2155           8B9E       FDEA            mov	bx,-$216[bp]
08020 2159           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08021 215D           E8         DFDF            call	ldivul
08022 2160           83C4                   04  add	sp,*4
08023                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$222] (used reg = )
08024 2163           8986       FDE0            mov	-$220[bp],ax
08025                                           !BCC_EOS
08026                                           ! 1710           if (heads>128) heads = 255;
08027                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08028 2167           8B86       FDE0            mov	ax,-$220[bp]
08029 216B           3D                   0080  cmp	ax,#$80
08030 216E           76           09            jbe 	.1DC
08031                       00002170            .1DD:
08032                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$222] (used reg = )
08033 2170           B8                   00FF  mov	ax,#$FF
08034 2173           8986       FDE0            mov	-$220[bp],ax
08035                                           !BCC_EOS
08036                                           ! 1711           else if (heads>64) heads = 128;
08037 2177           EB           3D            jmp .1DE
08038                       00002179            .1DC:
08039                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08040 2179           8B86       FDE0            mov	ax,-$220[bp]
08041 217D           3D                   0040  cmp	ax,*$40
08042 2180           76           09            jbe 	.1DF
08043                       00002182            .1E0:
08044                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08045 2182           B8                   0080  mov	ax,#$80
08046 2185           8986       FDE0            mov	-$220[bp],ax
08047                                           !BCC_EOS
08048                                           ! 1712           else if (heads>32) heads = 64;
08049 2189           EB           2B            jmp .1E1
08050                       0000218B            .1DF:
08051                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08052 218B           8B86       FDE0            mov	ax,-$220[bp]
08053 218F           3D                   0020  cmp	ax,*$20
08054 2192           76           09            jbe 	.1E2
08055                       00002194            .1E3:
08056                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08057 2194           B8                   0040  mov	ax,*$40
08058 2197           8986       FDE0            mov	-$220[bp],ax
08059                                           !BCC_EOS
08060                                           ! 1713           else if (heads>16) heads = 32;
08061 219B           EB           19            jmp .1E4
08062                       0000219D            .1E2:
08063                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08064 219D           8B86       FDE0            mov	ax,-$220[bp]
08065 21A1           3D                   0010  cmp	ax,*$10
08066 21A4           76           09            jbe 	.1E5
08067                       000021A6            .1E6:
08068                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08069 21A6           B8                   0020  mov	ax,*$20
08070 21A9           8986       FDE0            mov	-$220[bp],ax
08071                                           !BCC_EOS
08072                                           ! 1714           else heads=16;
08073 21AD           EB           07            jmp .1E7
08074                       000021AF            .1E5:
08075                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08076 21AF           B8                   0010  mov	ax,*$10
08077 21B2           8986       FDE0            mov	-$220[bp],ax
08078                                           !BCC_EOS
08079                                           ! 1715           cylinders = sectors_low / heads;
08080                       000021B6            .1E7:
08081                       000021B6            .1E4:
08082                       000021B6            .1E1:
08083                       000021B6            .1DE:
08084                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$222] (used reg = )
08085 21B6           8B86       FDE0            mov	ax,-$220[bp]
08086 21BA           31DB                       xor	bx,bx
08087                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08088 21BC           53                         push	bx
08089 21BD           50                         push	ax
08090 21BE           8B86       FDE8            mov	ax,-$218[bp]
08091 21C2           8B9E       FDEA            mov	bx,-$216[bp]
08092 21C6           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08093 21CA           E8         DF72            call	ldivul
08094 21CD           83C4                   04  add	sp,*4
08095                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08096 21D0           8986       FDE2            mov	-$21E[bp],ax
08097                                           !BCC_EOS
08098                                           ! 1716           break;
08099 21D4           E9         00BF            br 	.1D7
08100                                           !BCC_EOS
08101                                           ! 1717         case 3:
08102                                           ! 1718           if (heads==16) {
08103                       000021D7            .1E8:
08104                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08105 21D7           8B86       FDE0            mov	ax,-$220[bp]
08106 21DB           3D                   0010  cmp	ax,*$10
08107 21DE           75           72            jne 	.1E9
08108                       000021E0            .1EA:
08109                                           ! 1719             if(cylinders>61439) cylinders=61439;
08110                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08111 21E0           8B86       FDE2            mov	ax,-$21E[bp]
08112 21E4           31DB                       xor	bx,bx
08113                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08114 21E6           53                         push	bx
08115 21E7           50                         push	ax
08116 21E8           B8                   EFFF  mov	ax,#$EFFF
08117 21EB           31DB                       xor	bx,bx
08118 21ED           53                         push	bx
08119 21EE           50                         push	ax
08120 21EF           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08121 21F3           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08122 21F7           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08123 21FB           E8         DE9E            call	lcmpul
08124 21FE           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08125 2202           76           07            jbe 	.1EB
08126                       00002204            .1EC:
08127                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$220] (used reg = )
08128 2204           B8                   EFFF  mov	ax,#$EFFF
08129 2207           8986       FDE2            mov	-$21E[bp],ax
08130                                           !BCC_EOS
08131                                           ! 1720             heads=15;
08132                       0000220B            .1EB:
08133                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$222] (used reg = )
08134 220B           B8                   000F  mov	ax,*$F
08135 220E           8986       FDE0            mov	-$220[bp],ax
08136                                           !BCC_EOS
08137                                           ! 1721             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08138                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08139 2212           8B86       FDE2            mov	ax,-$21E[bp]
08140 2216           31DB                       xor	bx,bx
08141                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08142 2218           53                         push	bx
08143 2219           50                         push	ax
08144 221A           B8                   0010  mov	ax,*$10
08145 221D           31DB                       xor	bx,bx
08146 221F           53                         push	bx
08147 2220           50                         push	ax
08148 2221           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08149 2225           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08150 2229           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08151 222D           E8         DE8A            call	lmulul
08152 2230           83C4                   08  add	sp,*8
08153                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08154 2233           53                         push	bx
08155 2234           50                         push	ax
08156 2235           B8                   000F  mov	ax,*$F
08157 2238           31DB                       xor	bx,bx
08158 223A           53                         push	bx
08159 223B           50                         push	ax
08160 223C           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08161 2240           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08162 2244           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08163 2248           E8         DEF4            call	ldivul
08164 224B           83C4                   08  add	sp,*8
08165                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08166                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08167 224E           8986       FDE2            mov	-$21E[bp],ax
08168                                           !BCC_EOS
08169                                           ! 1722           }
08170                                           ! 1723         case 2:
08171                       00002252            .1E9:
08172                                           ! 1724           while(cylinders > 1024) {
08173                       00002252            .1ED:
08174 2252           EB           1F            jmp .1EF
08175                       00002254            .1F0:
08176                                           ! 1725             cylinders >>= 1;
08177                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$220] (used reg = )
08178 2254           8B86       FDE2            mov	ax,-$21E[bp]
08179 2258           D1E8                       shr	ax,*1
08180 225A           8986       FDE2            mov	-$21E[bp],ax
08181                                           !BCC_EOS
08182                                           ! 1726             heads <<= 1;
08183                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$222] (used reg = )
08184 225E           8B86       FDE0            mov	ax,-$220[bp]
08185 2262           D1E0                       shl	ax,*1
08186 2264           8986       FDE0            mov	-$220[bp],ax
08187                                           !BCC_EOS
08188                                           ! 1727             if (heads > 127) break;
08189                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$222] (used reg = )
08190 2268           8B86       FDE0            mov	ax,-$220[bp]
08191 226C           3D                   007F  cmp	ax,*$7F
08192 226F           76           02            jbe 	.1F1
08193                       00002271            .1F2:
08194 2271           EB           09            jmp .1EE
08195                                           !BCC_EOS
08196                                           ! 1728           }
08197                       00002273            .1F1:
08198                                           ! 1729           break;
08199                       00002273            .1EF:
08200                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08201 2273           8B86       FDE2            mov	ax,-$21E[bp]
08202 2277           3D                   0400  cmp	ax,#$400
08203 227A           77           D8            ja 	.1F0
08204                       0000227C            .1F3:
08205                       0000227C            .1EE:
08206 227C           EB           18            jmp .1D7
08207                                           !BCC_EOS
08208                                           ! 1730       }
08209                                           ! 1731       if (cylinders > 1024) cylinders=1024;
08210 227E           EB           16            jmp .1D7
08211                       00002280            .1D9:
08212 2280           2C                     00  sub	al,*0
08213 2282         0F84         FE99            beq 	.1DA
08214 2286           2C                     01  sub	al,*1
08215 2288         0F84         FE96            beq 	.1DB
08216 228C           2C                     01  sub	al,*1
08217 228E           74           C2            je 	.1ED
08218 2290           2C                     01  sub	al,*1
08219 2292         0F84         FF41            beq 	.1E8
08220                       00002296            .1D7:
08221                       FFFFFDD8            ..FFFD	=	-$228
08222                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08223 2296           8B86       FDE2            mov	ax,-$21E[bp]
08224 229A           3D                   0400  cmp	ax,#$400
08225 229D           76           07            jbe 	.1F4
08226                       0000229F            .1F5:
08227                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08228 229F           B8                   0400  mov	ax,#$400
08229 22A2           8986       FDE2            mov	-$21E[bp],ax
08230                                           !BCC_EOS
08231                                           ! 1732       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08232                       000022A6            .1F4:
08233                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
08234 22A6           FFB6       FDDE            push	-$222[bp]
08235                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
08236 22AA           FFB6       FDE0            push	-$220[bp]
08237                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
08238 22AE           FFB6       FDE2            push	-$21E[bp]
08239                                           ! Debug: list * char = .1F6+0 (used reg = )
08240 22B2           BB                   D775  mov	bx,#.1F6
08241 22B5           53                         push	bx
08242                                           ! Debug: list int = const 4 (used reg = )
08243 22B6           B8                   0004  mov	ax,*4
08244 22B9           50                         push	ax
08245                                           ! Debug: func () void = bios_printf+0 (used reg = )
08246 22BA           E8         E67C            call	_bios_printf
08247 22BD           83C4                   0A  add	sp,*$A
08248                                           !BCC_EOS
08249                                           ! 1733       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (heads);
08250                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08251 22C0           8A46         FD            mov	al,-3[bp]
08252 22C3           30E4                       xor	ah,ah
08253 22C5           B9                   001E  mov	cx,*$1E
08254 22C8           F7E9                       imul	cx
08255 22CA           89C3                       mov	bx,ax
08256                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08257                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
08258                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$14C] (used reg = )
08259 22CC           8B86       FDE0            mov	ax,-$220[bp]
08260 22D0           8987       014C            mov	$14C[bx],ax
08261                                           !BCC_EOS
08262                                           ! 1734       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (cy
08263                                           ! 1734 linders);
08264                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08265 22D4           8A46         FD            mov	al,-3[bp]
08266 22D7           30E4                       xor	ah,ah
08267 22D9           B9                   001E  mov	cx,*$1E
08268 22DC           F7E9                       imul	cx
08269 22DE           89C3                       mov	bx,ax
08270                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08271                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
08272                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$14E] (used reg = )
08273 22E0           8B86       FDE2            mov	ax,-$21E[bp]
08274 22E4           8987       014E            mov	$14E[bx],ax
08275                                           !BCC_EOS
08276                                           ! 1735       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (spt);
08277                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08278 22E8           8A46         FD            mov	al,-3[bp]
08279 22EB           30E4                       xor	ah,ah
08280 22ED           B9                   001E  mov	cx,*$1E
08281 22F0           F7E9                       imul	cx
08282 22F2           89C3                       mov	bx,ax
08283                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08284                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
08285                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$150] (used reg = )
08286 22F4           8B86       FDDE            mov	ax,-$222[bp]
08287 22F8           8987       0150            mov	$150[bx],ax
08288                                           !BCC_EOS
08289                                           ! 1736       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[hdcount])) = (device);
08290                                           ! Debug: ptradd unsigned char hdcount = [S+$228-3] to [8] unsigned char = const $233 (used reg = )
08291 22FC           8A46         FF            mov	al,-1[bp]
08292 22FF           30E4                       xor	ah,ah
08293 2301           89C3                       mov	bx,ax
08294                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08295                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
08296                                           ! Debug: eq unsigned char device = [S+$228-5] to unsigned char = [bx+$233] (used reg = )
08297 2303           8A46         FD            mov	al,-3[bp]
08298 2306           8887       0233            mov	$233[bx],al
08299                                           !BCC_EOS
08300                                           ! 1737       hdcount++;
08301                                           ! Debug: postinc unsigned char hdcount = [S+$228-3] (used reg = )
08302 230A           8A46         FF            mov	al,-1[bp]
08303 230D           40                         inc	ax
08304 230E           8846         FF            mov	-1[bp],al
08305                                           !BCC_EOS
08306                                           ! 1738     }
08307 2311           83C4                   12  add	sp,*$12
08308                                           ! 1739     if(type == 0x03) {
08309                       00002314            .1BB:
08310                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$216-6] (used reg = )
08311 2314           8A46         FC            mov	al,-4[bp]
08312 2317           3C                     03  cmp	al,*3
08313 2319         0F85         011F            bne 	.1F7
08314                       0000231D            .1F8:
08315                                           ! 1740       Bit8u type, removable, mode;
08316                                           !BCC_EOS
08317                                           ! 1741       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x05);
08318 231D           83C4                   FC  add	sp,*-4
08319                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08320 2320           8A46         FD            mov	al,-3[bp]
08321 2323           30E4                       xor	ah,ah
08322 2325           B9                   001E  mov	cx,*$1E
08323 2328           F7E9                       imul	cx
08324 232A           89C3                       mov	bx,ax
08325                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08326                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08327                                           ! Debug: eq int = const 5 to unsigned char = [bx+$143] (used reg = )
08328 232C           B0                     05  mov	al,*5
08329 232E           8887       0143            mov	$143[bx],al
08330                                           !BCC_EOS
08331                                           ! 1742       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
08332                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08333 2332           8A46         FD            mov	al,-3[bp]
08334 2335           30E4                       xor	ah,ah
08335 2337           B9                   001E  mov	cx,*$1E
08336 233A           F7E9                       imul	cx
08337 233C           89C3                       mov	bx,ax
08338                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08339                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08340                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
08341 233E           30C0                       xor	al,al
08342 2340           8887       0146            mov	$146[bx],al
08343                                           !BCC_EOS
08344                                           ! 1743       if (ata_cmd_data_io(0, device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08345                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08346 2344           8D9E       FDFC            lea	bx,-$204[bp]
08347 2348           53                         push	bx
08348                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08349 2349           E8         E30E            call	_get_SS
08350                                           ! Debug: list unsigned short = ax+0 (used reg = )
08351 234C           50                         push	ax
08352                                           ! Debug: list long = const 0 (used reg = )
08353 234D           31C0                       xor	ax,ax
08354 234F           31DB                       xor	bx,bx
08355 2351           53                         push	bx
08356 2352           50                         push	ax
08357                                           ! Debug: list long = const 0 (used reg = )
08358 2353           31C0                       xor	ax,ax
08359 2355           31DB                       xor	bx,bx
08360 2357           53                         push	bx
08361 2358           50                         push	ax
08362                                           ! Debug: list int = const 0 (used reg = )
08363 2359           31C0                       xor	ax,ax
08364 235B           50                         push	ax
08365                                           ! Debug: list int = const 0 (used reg = )
08366 235C           31C0                       xor	ax,ax
08367 235E           50                         push	ax
08368                                           ! Debug: list int = const 0 (used reg = )
08369 235F           31C0                       xor	ax,ax
08370 2361           50                         push	ax
08371                                           ! Debug: list int = const 1 (used reg = )
08372 2362           B8                   0001  mov	ax,*1
08373 2365           50                         push	ax
08374                                           ! Debug: list int = const $A1 (used reg = )
08375 2366           B8                   00A1  mov	ax,#$A1
08376 2369           50                         push	ax
08377                                           ! Debug: list unsigned char device = [S+$230-5] (used reg = )
08378 236A           8A46         FD            mov	al,-3[bp]
08379 236D           30E4                       xor	ah,ah
08380 236F           50                         push	ax
08381                                           ! Debug: list int = const 0 (used reg = )
08382 2370           31C0                       xor	ax,ax
08383 2372           50                         push	ax
08384                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
08385 2373           E8         060A            call	_ata_cmd_data_io
08386 2376           83C4                   1A  add	sp,*$1A
08387                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08388 2379           85C0                       test	ax,ax
08389 237B           74           0E            je  	.1F9
08390                       0000237D            .1FA:
08391                                           ! 1744         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08392                                           ! Debug: list * char = .1FB+0 (used reg = )
08393 237D           BB                   D74A  mov	bx,#.1FB
08394 2380           53                         push	bx
08395                                           ! Debug: list int = const 7 (used reg = )
08396 2381           B8                   0007  mov	ax,*7
08397 2384           50                         push	ax
08398                                           ! Debug: func () void = bios_printf+0 (used reg = )
08399 2385           E8         E5B1            call	_bios_printf
08400 2388           83C4                   04  add	sp,*4
08401                                           !BCC_EOS
08402                                           ! 1745       type = read_byte_SS(buffer+1) & 0x1f;
08403                       0000238B            .1F9:
08404                                           ! Debug: list * unsigned char buffer = S+$21A-$205 (used reg = )
08405 238B           8D9E       FDFD            lea	bx,-$203[bp]
08406 238F           53                         push	bx
08407                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08408 2390           E8         E28E            call	_read_byte_SS
08409 2393           44                         inc	sp
08410 2394           44                         inc	sp
08411                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08412 2395           24                     1F  and	al,*$1F
08413                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$217] (used reg = )
08414 2397           8886       FDEB            mov	-$215[bp],al
08415                                           !BCC_EOS
08416                                           ! 1746       removable = (read_byte_SS(buffer+0) & 0x80) ? 1 : 0;
08417                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08418 239B           8D9E       FDFC            lea	bx,-$204[bp]
08419 239F           53                         push	bx
08420                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08421 23A0           E8         E27E            call	_read_byte_SS
08422 23A3           44                         inc	sp
08423 23A4           44                         inc	sp
08424                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08425 23A5           24                     80  and	al,#$80
08426 23A7           84C0                       test	al,al
08427 23A9           74           04            je  	.1FC
08428                       000023AB            .1FD:
08429 23AB           B0                     01  mov	al,*1
08430 23AD           EB           02            jmp .1FE
08431                       000023AF            .1FC:
08432 23AF           30C0                       xor	al,al
08433                       000023B1            .1FE:
08434                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$218] (used reg = )
08435 23B1           8886       FDEA            mov	-$216[bp],al
08436                                           !BCC_EOS
08437                                           ! 1747       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
08438                                           ! Debug: list * unsigned char buffer = S+$21A-$1A6 (used reg = )
08439 23B5           8D9E       FE5C            lea	bx,-$1A4[bp]
08440 23B9           53                         push	bx
08441                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08442 23BA           E8         E264            call	_read_byte_SS
08443 23BD           44                         inc	sp
08444 23BE           44                         inc	sp
08445 23BF           84C0                       test	al,al
08446 23C1           74           04            je  	.1FF
08447                       000023C3            .200:
08448 23C3           B0                     01  mov	al,*1
08449 23C5           EB           02            jmp .201
08450                       000023C7            .1FF:
08451 23C7           30C0                       xor	al,al
08452                       000023C9            .201:
08453                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$219] (used reg = )
08454 23C9           8886       FDE9            mov	-$217[bp],al
08455                                           !BCC_EOS
08456                                           ! 1748       blksize = 2048;
08457                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$20E] (used reg = )
08458 23CD           B8                   0800  mov	ax,#$800
08459 23D0           8986       FDF4            mov	-$20C[bp],ax
08460                                           !BCC_EOS
08461                                           ! 1749       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (type);
08462                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08463 23D4           8A46         FD            mov	al,-3[bp]
08464 23D7           30E4                       xor	ah,ah
08465 23D9           B9                   001E  mov	cx,*$1E
08466 23DC           F7E9                       imul	cx
08467 23DE           89C3                       mov	bx,ax
08468                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08469                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08470                                           ! Debug: eq unsigned char type = [S+$21A-$217] to unsigned char = [bx+$143] (used reg = )
08471 23E0           8A86       FDEB            mov	al,-$215[bp]
08472 23E4           8887       0143            mov	$143[bx],al
08473                                           !BCC_EOS
08474                                           ! 1750       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
08475                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08476 23E8           8A46         FD            mov	al,-3[bp]
08477 23EB           30E4                       xor	ah,ah
08478 23ED           B9                   001E  mov	cx,*$1E
08479 23F0           F7E9                       imul	cx
08480 23F2           89C3                       mov	bx,ax
08481                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
08483                                           ! Debug: eq unsigned char removable = [S+$21A-$218] to unsigned char = [bx+$144] (used reg = )
08484 23F4           8A86       FDEA            mov	al,-$216[bp]
08485 23F8           8887       0144            mov	$144[bx],al
08486                                           !BCC_EOS
08487                                           ! 1751       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
08488                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08489 23FC           8A46         FD            mov	al,-3[bp]
08490 23FF           30E4                       xor	ah,ah
08491 2401           B9                   001E  mov	cx,*$1E
08492 2404           F7E9                       imul	cx
08493 2406           89C3                       mov	bx,ax
08494                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08495                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08496                                           ! Debug: eq unsigned char mode = [S+$21A-$219] to unsigned char = [bx+$146] (used reg = )
08497 2408           8A86       FDE9            mov	al,-$217[bp]
08498 240C           8887       0146            mov	$146[bx],al
08499                                           !BCC_EOS
08500                                           ! 1752       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
08501                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08502 2410           8A46         FD            mov	al,-3[bp]
08503 2413           30E4                       xor	ah,ah
08504 2415           B9                   001E  mov	cx,*$1E
08505 2418           F7E9                       imul	cx
08506 241A           89C3                       mov	bx,ax
08507                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08508                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
08509                                           ! Debug: eq unsigned short blksize = [S+$21A-$20E] to unsigned short = [bx+$148] (used reg = )
08510 241C           8B86       FDF4            mov	ax,-$20C[bp]
08511 2420           8987       0148            mov	$148[bx],ax
08512                                           !BCC_EOS
08513                                           ! 1753       *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[cdcount])) = (device);
08514                                           ! Debug: ptradd unsigned char cdcount = [S+$21A-4] to [8] unsigned char = const $23C (used reg = )
08515 2424           8A46         FE            mov	al,-2[bp]
08516 2427           30E4                       xor	ah,ah
08517 2429           89C3                       mov	bx,ax
08518                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
08519                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
08520                                           ! Debug: eq unsigned char device = [S+$21A-5] to unsigned char = [bx+$23C] (used reg = )
08521 242B           8A46         FD            mov	al,-3[bp]
08522 242E           8887       023C            mov	$23C[bx],al
08523                                           !BCC_EOS
08524                                           ! 1754       cdcount++;
08525                                           ! Debug: postinc unsigned char cdcount = [S+$21A-4] (used reg = )
08526 2432           8A46         FE            mov	al,-2[bp]
08527 2435           40                         inc	ax
08528 2436           8846         FE            mov	-2[bp],al
08529                                           !BCC_EOS
08530                                           ! 1755     }
08531 2439           83C4                   04  add	sp,*4
08532                                           ! 1756     {
08533                       0000243C            .1F7:
08534                                           ! 1757       Bit32u sizeinmb;
08535                                           !BCC_EOS
08536                                           ! 1758       Bit16u ataversion;
08537                                           !BCC_EOS
08538                                           ! 1759       Bit8u c, i, lshift, rshift, version, model[41];
08539                                           !BCC_EOS
08540                                           ! 1760       switch (type) {
08541 243C           83C4                   CC  add	sp,*-$34
08542 243F           8A46         FC            mov	al,-4[bp]
08543 2442           E9         0213            br 	.204
08544                                           ! 1761         case 0x02:
08545                                           ! 1762           switch (blksize) {
08546                       00002445            .205:
08547 2445           8B86       FDF4            mov	ax,-$20C[bp]
08548 2449           EB           2A            jmp .208
08549                                           ! 1763             case 1024:
08550                                           ! 1764               lshift = 22;
08551                       0000244B            .209:
08552                                           ! Debug: eq int = const $16 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08553 244B           B0                     16  mov	al,*$16
08554 244D           8886       FDE3            mov	-$21D[bp],al
08555                                           !BCC_EOS
08556                                           ! 1765               rshift = 10;
08557                                           ! Debug: eq int = const $A to unsigned char rshift = [S+$24A-$220] (used reg = )
08558 2451           B0                     0A  mov	al,*$A
08559 2453           8886       FDE2            mov	-$21E[bp],al
08560                                           !BCC_EOS
08561                                           ! 1766               break;
08562 2457           EB           28            jmp .206
08563                                           !BCC_EOS
08564                                           ! 1767             case 4096:
08565                                           ! 1768               lshift = 24;
08566                       00002459            .20A:
08567                                           ! Debug: eq int = const $18 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08568 2459           B0                     18  mov	al,*$18
08569 245B           8886       FDE3            mov	-$21D[bp],al
08570                                           !BCC_EOS
08571                                           ! 1769               rshift = 8;
08572                                           ! Debug: eq int = const 8 to unsigned char rshift = [S+$24A-$220] (used reg = )
08573 245F           B0                     08  mov	al,*8
08574 2461           8886       FDE2            mov	-$21E[bp],al
08575                                           !BCC_EOS
08576                                           ! 1770               break;
08577 2465           EB           1A            jmp .206
08578                                           !BCC_EOS
08579                                           ! 1771             default:
08580                                           ! 1772               lshift = 21;
08581                       00002467            .20B:
08582                                           ! Debug: eq int = const $15 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08583 2467           B0                     15  mov	al,*$15
08584 2469           8886       FDE3            mov	-$21D[bp],al
08585                                           !BCC_EOS
08586                                           ! 1773               rshift = 11;
08587                                           ! Debug: eq int = const $B to unsigned char rshift = [S+$24A-$220] (used reg = )
08588 246D           B0                     0B  mov	al,*$B
08589 246F           8886       FDE2            mov	-$21E[bp],al
08590                                           !BCC_EOS
08591                                           ! 1774           }
08592                                           ! 1775           sizeinmb = (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) << lshift)
08593 2473           EB           0C            jmp .206
08594                       00002475            .208:
08595 2475           2D                   0400  sub	ax,#$400
08596 2478           74           D1            je 	.209
08597 247A           2D                   0C00  sub	ax,#$C00
08598 247D           74           DA            je 	.20A
08599 247F           EB           E6            jmp	.20B
08600                       00002481            .206:
08601                                           ! 1776             | (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) >> rshift);
08602                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
08603 2481           8A46         FD            mov	al,-3[bp]
08604 2484           30E4                       xor	ah,ah
08605 2486           B9                   001E  mov	cx,*$1E
08606 2489           F7E9                       imul	cx
08607 248B           89C3                       mov	bx,ax
08608                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08609                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
08610                                           ! Debug: sr unsigned char rshift = [S+$24A-$220] to unsigned long = [bx+$158] (used reg = )
08611 248D           8A86       FDE2            mov	al,-$21E[bp]
08612 2491           50                         push	ax
08613 2492           8B87       0158            mov	ax,$158[bx]
08614 2496           8B9F       015A            mov	bx,$15A[bx]
08615 249A           8A8E       FDB6            mov	cl,0+..FFFC[bp]
08616 249E           30ED                       xor	ch,ch
08617 24A0           89CF                       mov	di,cx
08618 24A2           E8         DC55            call	lsrul
08619 24A5           44                         inc	sp
08620 24A6           44                         inc	sp
08621 24A7           53                         push	bx
08622 24A8           50                         push	ax
08623                                           ! Debug: ptradd unsigned char device = [S+$24E-5] to [8] struct  = const $142 (used reg = )
08624 24A9           8A46         FD            mov	al,-3[bp]
08625 24AC           30E4                       xor	ah,ah
08626 24AE           B9                   001E  mov	cx,*$1E
08627 24B1           F7E9                       imul	cx
08628 24B3           89C3                       mov	bx,ax
08629                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08630                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
08631                                           ! Debug: sl unsigned char lshift = [S+$24E-$21F] to unsigned long = [bx+$15C] (used reg = )
08632 24B5           8A86       FDE3            mov	al,-$21D[bp]
08633 24B9           50                         push	ax
08634 24BA           8B87       015C            mov	ax,$15C[bx]
08635 24BE           8B9F       015E            mov	bx,$15E[bx]
08636 24C2           8A8E       FDB2            mov	cl,-4+..FFFC[bp]
08637 24C6           30ED                       xor	ch,ch
08638 24C8           89CF                       mov	di,cx
08639 24CA           E8         DC4B            call	lslul
08640 24CD           44                         inc	sp
08641 24CE           44                         inc	sp
08642                                           ! Debug: or unsigned long (temp) = [S+$24E-$24E] to unsigned long = bx+0 (used reg = )
08643 24CF           8DBE       FDB4            lea	di,-2+..FFFC[bp]
08644 24D3           E8         DC02            call	lorul
08645 24D6           83C4                   04  add	sp,*4
08646                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
08647 24D9           8986       FDE8            mov	-$218[bp],ax
08648 24DD           899E       FDEA            mov	-$216[bp],bx
08649                                           !BCC_EOS
08650                                           ! 1777         case 0x03:
08651                                           ! 1778           ataversion=((Bit16u)(read_byte_SS(buffer+161))<<8)|read_byte_SS(buffer+160);
08652                       000024E1            .20C:
08653                                           ! Debug: list * unsigned char buffer = S+$24A-$166 (used reg = )
08654 24E1           8D9E       FE9C            lea	bx,-$164[bp]
08655 24E5           53                         push	bx
08656                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08657 24E6           E8         E138            call	_read_byte_SS
08658 24E9           44                         inc	sp
08659 24EA           44                         inc	sp
08660 24EB           50                         push	ax
08661                                           ! Debug: list * unsigned char buffer = S+$24C-$165 (used reg = )
08662 24EC           8D9E       FE9D            lea	bx,-$163[bp]
08663 24F0           53                         push	bx
08664                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08665 24F1           E8         E12D            call	_read_byte_SS
08666 24F4           44                         inc	sp
08667 24F5           44                         inc	sp
08668                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
08669 24F6           30E4                       xor	ah,ah
08670                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
08671 24F8           88C4                       mov	ah,al
08672 24FA           30C0                       xor	al,al
08673                                           ! Debug: or unsigned char (temp) = [S+$24C-$24C] to unsigned int = ax+0 (used reg = )
08674 24FC           0A86       FDB6            or	al,0+..FFFC[bp]
08675 2500           44                         inc	sp
08676 2501           44                         inc	sp
08677                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08678 2502           8986       FDE6            mov	-$21A[bp],ax
08679                                           !BCC_EOS
08680                                           ! 1779           for(version=15;version>0;version--) {
08681                                           ! Debug: eq int = const $F to unsigned char version = [S+$24A-$221] (used reg = )
08682 2506           B0                     0F  mov	al,*$F
08683 2508           8886       FDE1            mov	-$21F[bp],al
08684                                           !BCC_EOS
08685                                           !BCC_EOS
08686 250C           EB           22            jmp .20F
08687                       0000250E            .210:
08688                                           ! 1780             if((ataversion&(1<<version))!=0)
08689                                           ! Debug: sl unsigned char version = [S+$24A-$221] to int = const 1 (used reg = )
08690 250E           8A86       FDE1            mov	al,-$21F[bp]
08691 2512           30E4                       xor	ah,ah
08692 2514           89C3                       mov	bx,ax
08693 2516           B8                   0001  mov	ax,*1
08694 2519           89D9                       mov	cx,bx
08695 251B           D3E0                       shl	ax,cl
08696                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08697                                           ! Debug: expression subtree swapping
08698 251D           2386       FDE6            and	ax,-$21A[bp]
08699                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
08700 2521           85C0                       test	ax,ax
08701 2523           74           02            je  	.211
08702                       00002525            .212:
08703                                           ! 1781             break;
08704 2525           EB           11            jmp .20D
08705                                           !BCC_EOS
08706                                           ! 1782 
08707                                           ! 1782           }
08708                       00002527            .211:
08709                                           ! 1783           for(i=0;i<20;i++) {
08710                       00002527            .20E:
08711                                           ! Debug: postdec unsigned char version = [S+$24A-$221] (used reg = )
08712 2527           8A86       FDE1            mov	al,-$21F[bp]
08713 252B           48                         dec	ax
08714 252C           8886       FDE1            mov	-$21F[bp],al
08715                       00002530            .20F:
08716                                           ! Debug: gt int = const 0 to unsigned char version = [S+$24A-$221] (used reg = )
08717 2530           8A86       FDE1            mov	al,-$21F[bp]
08718 2534           84C0                       test	al,al
08719 2536           75           D6            jne	.210
08720                       00002538            .213:
08721                       00002538            .20D:
08722                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08723 2538           30C0                       xor	al,al
08724 253A           8886       FDE4            mov	-$21C[bp],al
08725                                           !BCC_EOS
08726                                           !BCC_EOS
08727 253E           EB           69            jmp .216
08728                       00002540            .217:
08729                                           ! 1784             _write_byte_SS(read_byte_SS(buffer+(i*2)+54+1), model+(i*2));
08730                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08731 2540           8A86       FDE4            mov	al,-$21C[bp]
08732 2544           30E4                       xor	ah,ah
08733 2546           D1E0                       shl	ax,*1
08734                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08735 2548           89EB                       mov	bx,bp
08736 254A           01C3                       add	bx,ax
08737                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08738                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08739 254C           81C3                 FDB8  add	bx,#-$248
08740 2550           53                         push	bx
08741                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08742 2551           8A86       FDE4            mov	al,-$21C[bp]
08743 2555           30E4                       xor	ah,ah
08744 2557           D1E0                       shl	ax,*1
08745                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08746 2559           89EB                       mov	bx,bp
08747 255B           01C3                       add	bx,ax
08748                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08749                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1CE (used reg = )
08750                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CD (used reg = )
08751                                           ! Debug: list * unsigned char = bx-$1CD (used reg = )
08752 255D           81C3                 FE33  add	bx,#-$1CD
08753 2561           53                         push	bx
08754                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08755 2562           E8         E0BC            call	_read_byte_SS
08756 2565           44                         inc	sp
08757 2566           44                         inc	sp
08758                                           ! Debug: list unsigned char = al+0 (used reg = )
08759 2567           30E4                       xor	ah,ah
08760 2569           50                         push	ax
08761                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08762 256A           E8         E0CA            call	__write_byte_SS
08763 256D           83C4                   04  add	sp,*4
08764                                           !BCC_EOS
08765                                           ! 1785             _write_byte_SS(read_byte_SS(buffer+(i*2)+54), model+(i*2)+1);
08766                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08767 2570           8A86       FDE4            mov	al,-$21C[bp]
08768 2574           30E4                       xor	ah,ah
08769 2576           D1E0                       shl	ax,*1
08770                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08771 2578           89EB                       mov	bx,bp
08772 257A           01C3                       add	bx,ax
08773                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$248 (used reg = )
08774                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$247 (used reg = )
08775                                           ! Debug: list * unsigned char = bx-$247 (used reg = )
08776 257C           81C3                 FDB9  add	bx,#-$247
08777 2580           53                         push	bx
08778                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08779 2581           8A86       FDE4            mov	al,-$21C[bp]
08780 2585           30E4                       xor	ah,ah
08781 2587           D1E0                       shl	ax,*1
08782                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08783 2589           89EB                       mov	bx,bp
08784 258B           01C3                       add	bx,ax
08785                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08786                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CE (used reg = )
08787                                           ! Debug: list * unsigned char = bx-$1CE (used reg = )
08788 258D           81C3                 FE32  add	bx,#-$1CE
08789 2591           53                         push	bx
08790                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08791 2592           E8         E08C            call	_read_byte_SS
08792 2595           44                         inc	sp
08793 2596           44                         inc	sp
08794                                           ! Debug: list unsigned char = al+0 (used reg = )
08795 2597           30E4                       xor	ah,ah
08796 2599           50                         push	ax
08797                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08798 259A           E8         E09A            call	__write_byte_SS
08799 259D           83C4                   04  add	sp,*4
08800                                           !BCC_EOS
08801                                           ! 1786           }
08802                                           ! 1787           _write_byte_SS(0x00, model+40);
08803                       000025A0            .215:
08804                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
08805 25A0           8A86       FDE4            mov	al,-$21C[bp]
08806 25A4           40                         inc	ax
08807 25A5           8886       FDE4            mov	-$21C[bp],al
08808                       000025A9            .216:
08809                                           ! Debug: lt int = const $14 to unsigned char i = [S+$24A-$21E] (used reg = )
08810 25A9           8A86       FDE4            mov	al,-$21C[bp]
08811 25AD           3C                     14  cmp	al,*$14
08812 25AF           72           8F            jb 	.217
08813                       000025B1            .218:
08814                       000025B1            .214:
08815                                           ! Debug: list * unsigned char model = S+$24A-$222 (used reg = )
08816 25B1           8D9E       FDE0            lea	bx,-$220[bp]
08817 25B5           53                         push	bx
08818                                           ! Debug: list int = const 0 (used reg = )
08819 25B6           31C0                       xor	ax,ax
08820 25B8           50                         push	ax
08821                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08822 25B9           E8         E07B            call	__write_byte_SS
08823 25BC           83C4                   04  add	sp,*4
08824                                           !BCC_EOS
08825                                           ! 1788           for(i=39;i>0;i--){
08826                                           ! Debug: eq int = const $27 to unsigned char i = [S+$24A-$21E] (used reg = )
08827 25BF           B0                     27  mov	al,*$27
08828 25C1           8886       FDE4            mov	-$21C[bp],al
08829                                           !BCC_EOS
08830                                           !BCC_EOS
08831 25C5           EB           3D            jmp .21B
08832                       000025C7            .21C:
08833                                           ! 1789             if(read_byte_SS(model+i)==0x20)
08834                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08835 25C7           8A86       FDE4            mov	al,-$21C[bp]
08836 25CB           30E4                       xor	ah,ah
08837 25CD           89EB                       mov	bx,bp
08838 25CF           01C3                       add	bx,ax
08839                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08840                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08841 25D1           81C3                 FDB8  add	bx,#-$248
08842 25D5           53                         push	bx
08843                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08844 25D6           E8         E048            call	_read_byte_SS
08845 25D9           44                         inc	sp
08846 25DA           44                         inc	sp
08847                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
08848 25DB           3C                     20  cmp	al,*$20
08849 25DD           75           1A            jne 	.21D
08850                       000025DF            .21E:
08851                                           ! 1790               _write_byte_SS(0x00, model+i);
08852                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08853 25DF           8A86       FDE4            mov	al,-$21C[bp]
08854 25E3           30E4                       xor	ah,ah
08855 25E5           89EB                       mov	bx,bp
08856 25E7           01C3                       add	bx,ax
08857                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08858                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08859 25E9           81C3                 FDB8  add	bx,#-$248
08860 25ED           53                         push	bx
08861                                           ! Debug: list int = const 0 (used reg = )
08862 25EE           31C0                       xor	ax,ax
08863 25F0           50                         push	ax
08864                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08865 25F1           E8         E043            call	__write_byte_SS
08866 25F4           83C4                   04  add	sp,*4
08867                                           !BCC_EOS
08868                                           ! 1791             else break;
08869 25F7           EB           02            jmp .21F
08870                       000025F9            .21D:
08871 25F9           EB           11            jmp .219
08872                                           !BCC_EOS
08873                                           ! 1792           }
08874                       000025FB            .21F:
08875                                           ! 1793           if (i>36) {
08876                       000025FB            .21A:
08877                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08878 25FB           8A86       FDE4            mov	al,-$21C[bp]
08879 25FF           48                         dec	ax
08880 2600           8886       FDE4            mov	-$21C[bp],al
08881                       00002604            .21B:
08882                                           ! Debug: gt int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08883 2604           8A86       FDE4            mov	al,-$21C[bp]
08884 2608           84C0                       test	al,al
08885 260A           75           BB            jne	.21C
08886                       0000260C            .220:
08887                       0000260C            .219:
08888                                           ! Debug: gt int = const $24 to unsigned char i = [S+$24A-$21E] (used reg = )
08889 260C           8A86       FDE4            mov	al,-$21C[bp]
08890 2610           3C                     24  cmp	al,*$24
08891 2612           76           40            jbe 	.221
08892                       00002614            .222:
08893                                           ! 1794             _write_byte_SS(0x00, model+36);
08894                                           ! Debug: list * unsigned char model = S+$24A-$226 (used reg = )
08895 2614           8D9E       FDDC            lea	bx,-$224[bp]
08896 2618           53                         push	bx
08897                                           ! Debug: list int = const 0 (used reg = )
08898 2619           31C0                       xor	ax,ax
08899 261B           50                         push	ax
08900                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08901 261C           E8         E018            call	__write_byte_SS
08902 261F           83C4                   04  add	sp,*4
08903                                           !BCC_EOS
08904                                           ! 1795             for(i=35;i>32;i--){
08905                                           ! Debug: eq int = const $23 to unsigned char i = [S+$24A-$21E] (used reg = )
08906 2622           B0                     23  mov	al,*$23
08907 2624           8886       FDE4            mov	-$21C[bp],al
08908                                           !BCC_EOS
08909                                           !BCC_EOS
08910 2628           EB           22            jmp .225
08911                       0000262A            .226:
08912                                           ! 1796               _write_byte_SS(0x2E, model+i);
08913                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08914 262A           8A86       FDE4            mov	al,-$21C[bp]
08915 262E           30E4                       xor	ah,ah
08916 2630           89EB                       mov	bx,bp
08917 2632           01C3                       add	bx,ax
08918                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08919                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08920 2634           81C3                 FDB8  add	bx,#-$248
08921 2638           53                         push	bx
08922                                           ! Debug: list int = const $2E (used reg = )
08923 2639           B8                   002E  mov	ax,*$2E
08924 263C           50                         push	ax
08925                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08926 263D           E8         DFF7            call	__write_byte_SS
08927 2640           83C4                   04  add	sp,*4
08928                                           !BCC_EOS
08929                                           ! 1797             }
08930                                           ! 1798           }
08931                       00002643            .224:
08932                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08933 2643           8A86       FDE4            mov	al,-$21C[bp]
08934 2647           48                         dec	ax
08935 2648           8886       FDE4            mov	-$21C[bp],al
08936                       0000264C            .225:
08937                                           ! Debug: gt int = const $20 to unsigned char i = [S+$24A-$21E] (used reg = )
08938 264C           8A86       FDE4            mov	al,-$21C[bp]
08939 2650           3C                     20  cmp	al,*$20
08940 2652           77           D6            ja 	.226
08941                       00002654            .227:
08942                       00002654            .223:
08943                                           ! 1799           break;
08944                       00002654            .221:
08945 2654           EB           0E            jmp .202
08946                                           !BCC_EOS
08947                                           ! 1800       }
08948                                           ! 1801       switch (type) {
08949 2656           EB           0C            jmp .202
08950                       00002658            .204:
08951 2658           2C                     02  sub	al,*2
08952 265A         0F84         FDE7            beq 	.205
08953 265E           2C                     01  sub	al,*1
08954 2660         0F84         FE7D            beq 	.20C
08955                       00002664            .202:
08956                       FFFFFDB6            ..FFFC	=	-$24A
08957 2664           8A46         FC            mov	al,-4[bp]
08958 2667           E9         018E            br 	.22A
08959                                           ! 1802         case 0x02:
08960                                           ! 1803           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
08961                       0000266A            .22B:
08962 266A           8A86       FDF2            mov	al,-$20E[bp]
08963 266E           84C0                       test	al,al
08964 2670           74           05            je  	.22F
08965                       00002672            .230:
08966 2672           BB                   D738  mov	bx,#.22D
08967 2675           EB           03            jmp .231
08968                       00002677            .22F:
08969 2677           BB                   D731  mov	bx,#.22E
08970                       0000267A            .231:
08971                                           ! Debug: list * char = bx+0 (used reg = )
08972 267A           53                         push	bx
08973                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
08974 267B           8A86       FDF3            mov	al,-$20D[bp]
08975 267F           30E4                       xor	ah,ah
08976 2681           50                         push	ax
08977                                           ! Debug: list * char = .22C+0 (used reg = )
08978 2682           BB                   D73F  mov	bx,#.22C
08979 2685           53                         push	bx
08980                                           ! Debug: list int = const 2 (used reg = )
08981 2686           B8                   0002  mov	ax,*2
08982 2689           50                         push	ax
08983                                           ! Debug: func () void = bios_printf+0 (used reg = )
08984 268A           E8         E2AC            call	_bios_printf
08985 268D           83C4                   08  add	sp,*8
08986                                           !BCC_EOS
08987                                           ! 1804           i=0;
08988                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08989 2690           30C0                       xor	al,al
08990 2692           8886       FDE4            mov	-$21C[bp],al
08991                                           !BCC_EOS
08992                                           ! 1805           while(c=read_byte_SS(model+i++))
08993                                           ! 1806             bios_printf(2, "%c",c);
08994 2696           EB           15            jmp .233
08995                       00002698            .234:
08996                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
08997 2698           8A86       FDE5            mov	al,-$21B[bp]
08998 269C           30E4                       xor	ah,ah
08999 269E           50                         push	ax
09000                                           ! Debug: list * char = .235+0 (used reg = )
09001 269F           BB                   D72E  mov	bx,#.235
09002 26A2           53                         push	bx
09003                                           ! Debug: list int = const 2 (used reg = )
09004 26A3           B8                   0002  mov	ax,*2
09005 26A6           50                         push	ax
09006                                           ! Debug: func () void = bios_printf+0 (used reg = )
09007 26A7           E8         E28F            call	_bios_printf
09008 26AA           83C4                   06  add	sp,*6
09009                                           !BCC_EOS
09010                                           ! 1807           if (sizeinmb < (1UL<<16))
09011                       000026AD            .233:
09012                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09013 26AD           8A86       FDE4            mov	al,-$21C[bp]
09014 26B1           40                         inc	ax
09015 26B2           8886       FDE4            mov	-$21C[bp],al
09016                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09017 26B6           48                         dec	ax
09018 26B7           30E4                       xor	ah,ah
09019 26B9           89EB                       mov	bx,bp
09020 26BB           01C3                       add	bx,ax
09021                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09022                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09023 26BD           81C3                 FDB8  add	bx,#-$248
09024 26C1           53                         push	bx
09025                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09026 26C2           E8         DF5C            call	_read_byte_SS
09027 26C5           44                         inc	sp
09028 26C6           44                         inc	sp
09029                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09030 26C7           8886       FDE5            mov	-$21B[bp],al
09031 26CB           84C0                       test	al,al
09032 26CD           75           C9            jne	.234
09033                       000026CF            .236:
09034                       000026CF            .232:
09035                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09036 26CF           31C0                       xor	ax,ax
09037 26D1           BB                   0001  mov	bx,*1
09038 26D4           8DBE       FDE8            lea	di,-$218[bp]
09039 26D8           E8         D9C1            call	lcmpul
09040 26DB           76           1B            jbe 	.237
09041                       000026DD            .238:
09042                                           ! 1808             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09043                                           ! Debug: list unsigned short sizeinmb = [S+$24A-$21A] (used reg = )
09044 26DD           FFB6       FDE8            push	-$218[bp]
09045                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09046 26E1           8A86       FDE1            mov	al,-$21F[bp]
09047 26E5           30E4                       xor	ah,ah
09048 26E7           50                         push	ax
09049                                           ! Debug: list * char = .239+0 (used reg = )
09050 26E8           BB                   D70E  mov	bx,#.239
09051 26EB           53                         push	bx
09052                                           ! Debug: list int = const 2 (used reg = )
09053 26EC           B8                   0002  mov	ax,*2
09054 26EF           50                         push	ax
09055                                           ! Debug: func () void = bios_printf+0 (used reg = )
09056 26F0           E8         E246            call	_bios_printf
09057 26F3           83C4                   08  add	sp,*8
09058                                           !BCC_EOS
09059                                           ! 1809           else
09060                                           ! 1810             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09061 26F6           EB           2C            jmp .23A
09062                       000026F8            .237:
09063                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09064 26F8           8B86       FDE8            mov	ax,-$218[bp]
09065 26FC           8B9E       FDEA            mov	bx,-$216[bp]
09066 2700           88E0                       mov	al,ah
09067 2702           88DC                       mov	ah,bl
09068 2704           88FB                       mov	bl,bh
09069 2706           28FF                       sub	bh,bh
09070 2708           BF                   0002  mov	di,*2
09071 270B           E8         D9EC            call	lsrul
09072                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09073                                           ! Debug: list unsigned short = ax+0 (used reg = )
09074 270E           50                         push	ax
09075                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09076 270F           8A86       FDE1            mov	al,-$21F[bp]
09077 2713           30E4                       xor	ah,ah
09078 2715           50                         push	ax
09079                                           ! Debug: list * char = .23B+0 (used reg = )
09080 2716           BB                   D6EE  mov	bx,#.23B
09081 2719           53                         push	bx
09082                                           ! Debug: list int = const 2 (used reg = )
09083 271A           B8                   0002  mov	ax,*2
09084 271D           50                         push	ax
09085                                           ! Debug: func () void = bios_printf+0 (used reg = )
09086 271E           E8         E218            call	_bios_printf
09087 2721           83C4                   08  add	sp,*8
09088                                           !BCC_EOS
09089                                           ! 1811           break;
09090                       00002724            .23A:
09091 2724           E9         00E1            br 	.228
09092                                           !BCC_EOS
09093                                           ! 1812         case 0x03:
09094                                           ! 1813           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09095                       00002727            .23C:
09096 2727           8A86       FDF2            mov	al,-$20E[bp]
09097 272B           84C0                       test	al,al
09098 272D           74           05            je  	.240
09099                       0000272F            .241:
09100 272F           BB                   D6DC  mov	bx,#.23E
09101 2732           EB           03            jmp .242
09102                       00002734            .240:
09103 2734           BB                   D6D5  mov	bx,#.23F
09104                       00002737            .242:
09105                                           ! Debug: list * char = bx+0 (used reg = )
09106 2737           53                         push	bx
09107                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09108 2738           8A86       FDF3            mov	al,-$20D[bp]
09109 273C           30E4                       xor	ah,ah
09110 273E           50                         push	ax
09111                                           ! Debug: list * char = .23D+0 (used reg = )
09112 273F           BB                   D6E3  mov	bx,#.23D
09113 2742           53                         push	bx
09114                                           ! Debug: list int = const 2 (used reg = )
09115 2743           B8                   0002  mov	ax,*2
09116 2746           50                         push	ax
09117                                           ! Debug: func () void = bios_printf+0 (used reg = )
09118 2747           E8         E1EF            call	_bios_printf
09119 274A           83C4                   08  add	sp,*8
09120                                           !BCC_EOS
09121                                           ! 1814           i=0; while(c=read_byte_SS(model+i++)) bios_printf(2, "%c",c);
09122                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09123 274D           30C0                       xor	al,al
09124 274F           8886       FDE4            mov	-$21C[bp],al
09125                                           !BCC_EOS
09126 2753           EB           15            jmp .244
09127                       00002755            .245:
09128                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09129 2755           8A86       FDE5            mov	al,-$21B[bp]
09130 2759           30E4                       xor	ah,ah
09131 275B           50                         push	ax
09132                                           ! Debug: list * char = .246+0 (used reg = )
09133 275C           BB                   D6D2  mov	bx,#.246
09134 275F           53                         push	bx
09135                                           ! Debug: list int = const 2 (used reg = )
09136 2760           B8                   0002  mov	ax,*2
09137 2763           50                         push	ax
09138                                           ! Debug: func () void = bios_printf+0 (used reg = )
09139 2764           E8         E1D2            call	_bios_printf
09140 2767           83C4                   06  add	sp,*6
09141                                           !BCC_EOS
09142                                           ! 1815           if(*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device))==0x05)
09143                       0000276A            .244:
09144                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09145 276A           8A86       FDE4            mov	al,-$21C[bp]
09146 276E           40                         inc	ax
09147 276F           8886       FDE4            mov	-$21C[bp],al
09148                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09149 2773           48                         dec	ax
09150 2774           30E4                       xor	ah,ah
09151 2776           89EB                       mov	bx,bp
09152 2778           01C3                       add	bx,ax
09153                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09154                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09155 277A           81C3                 FDB8  add	bx,#-$248
09156 277E           53                         push	bx
09157                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09158 277F           E8         DE9F            call	_read_byte_SS
09159 2782           44                         inc	sp
09160 2783           44                         inc	sp
09161                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09162 2784           8886       FDE5            mov	-$21B[bp],al
09163 2788           84C0                       test	al,al
09164 278A           75           C9            jne	.245
09165                       0000278C            .247:
09166                       0000278C            .243:
09167                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
09168 278C           8A46         FD            mov	al,-3[bp]
09169 278F           30E4                       xor	ah,ah
09170 2791           B9                   001E  mov	cx,*$1E
09171 2794           F7E9                       imul	cx
09172 2796           89C3                       mov	bx,ax
09173                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09174                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
09175                                           ! Debug: logeq int = const 5 to unsigned char = [bx+$143] (used reg = )
09176 2798           8A87       0143            mov	al,$143[bx]
09177 279C           3C                     05  cmp	al,*5
09178 279E           75           17            jne 	.248
09179                       000027A0            .249:
09180                                           ! 1816             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09181                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09182 27A0           8A86       FDE1            mov	al,-$21F[bp]
09183 27A4           30E4                       xor	ah,ah
09184 27A6           50                         push	ax
09185                                           ! Debug: list * char = .24A+0 (used reg = )
09186 27A7           BB                   D6B8  mov	bx,#.24A
09187 27AA           53                         push	bx
09188                                           ! Debug: list int = const 2 (used reg = )
09189 27AB           B8                   0002  mov	ax,*2
09190 27AE           50                         push	ax
09191                                           ! Debug: func () void = bios_printf+0 (used reg = )
09192 27AF           E8         E187            call	_bios_printf
09193 27B2           83C4                   06  add	sp,*6
09194                                           !BCC_EOS
09195                                           ! 1817           else
09196                                           ! 1818             bios_printf(2, " ATAPI-%d Device\n",version);
09197 27B5           EB           15            jmp .24B
09198                       000027B7            .248:
09199                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09200 27B7           8A86       FDE1            mov	al,-$21F[bp]
09201 27BB           30E4                       xor	ah,ah
09202 27BD           50                         push	ax
09203                                           ! Debug: list * char = .24C+0 (used reg = )
09204 27BE           BB                   D6A6  mov	bx,#.24C
09205 27C1           53                         push	bx
09206                                           ! Debug: list int = const 2 (used reg = )
09207 27C2           B8                   0002  mov	ax,*2
09208 27C5           50                         push	ax
09209                                           ! Debug: func () void = bios_printf+0 (used reg = )
09210 27C6           E8         E170            call	_bios_printf
09211 27C9           83C4                   06  add	sp,*6
09212                                           !BCC_EOS
09213                                           ! 1819           break;
09214                       000027CC            .24B:
09215 27CC           EB           3A            jmp .228
09216                                           !BCC_EOS
09217                                           ! 1820         case 0x01:
09218                                           ! 1821           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09219                       000027CE            .24D:
09220 27CE           8A86       FDF2            mov	al,-$20E[bp]
09221 27D2           84C0                       test	al,al
09222 27D4           74           05            je  	.251
09223                       000027D6            .252:
09224 27D6           BB                   D685  mov	bx,#.24F
09225 27D9           EB           03            jmp .253
09226                       000027DB            .251:
09227 27DB           BB                   D67E  mov	bx,#.250
09228                       000027DE            .253:
09229                                           ! Debug: list * char = bx+0 (used reg = )
09230 27DE           53                         push	bx
09231                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09232 27DF           8A86       FDF3            mov	al,-$20D[bp]
09233 27E3           30E4                       xor	ah,ah
09234 27E5           50                         push	ax
09235                                           ! Debug: list * char = .24E+0 (used reg = )
09236 27E6           BB                   D68C  mov	bx,#.24E
09237 27E9           53                         push	bx
09238                                           ! Debug: list int = const 2 (used reg = )
09239 27EA           B8                   0002  mov	ax,*2
09240 27ED           50                         push	ax
09241                                           ! Debug: func () void = bios_printf+0 (used reg = )
09242 27EE           E8         E148            call	_bios_printf
09243 27F1           83C4                   08  add	sp,*8
09244                                           !BCC_EOS
09245                                           ! 1822           break;
09246 27F4           EB           12            jmp .228
09247                                           !BCC_EOS
09248                                           ! 1823       }
09249                                           ! 1824     }
09250 27F6           EB           10            jmp .228
09251                       000027F8            .22A:
09252 27F8           2C                     01  sub	al,*1
09253 27FA           74           D2            je 	.24D
09254 27FC           2C                     01  sub	al,*1
09255 27FE         0F84         FE68            beq 	.22B
09256 2802           2C                     01  sub	al,*1
09257 2804         0F84         FF1F            beq 	.23C
09258                       00002808            .228:
09259                       FFFFFDB6            ..FFFB	=	-$24A
09260 2808           83C4                   34  add	sp,*$34
09261                                           ! 1825   }
09262 280B           83C4                   0E  add	sp,*$E
09263                                           ! 1826   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (hdcount);
09264                       0000280E            .1A0:
09265                                           ! Debug: postinc unsigned char device = [S+$208-5] (used reg = )
09266 280E           8A46         FD            mov	al,-3[bp]
09267 2811           40                         inc	ax
09268 2812           8846         FD            mov	-3[bp],al
09269                       00002815            .1A1:
09270                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-5] (used reg = )
09271 2815           8A46         FD            mov	al,-3[bp]
09272 2818           3C                     08  cmp	al,*8
09273 281A         0F82         F3E8            blo 	.1A2
09274                       0000281E            .254:
09275                       0000281E            .19F:
09276                                           ! Debug: eq unsigned char hdcount = [S+$208-3] to unsigned char = [+$232] (used reg = )
09277 281E           8A46         FF            mov	al,-1[bp]
09278 2821           A2         0232            mov	[$232],al
09279                                           !BCC_EOS
09280                                           ! 1827   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (cdcount);
09281                                           ! Debug: eq unsigned char cdcount = [S+$208-4] to unsigned char = [+$23B] (used reg = )
09282 2824           8A46         FE            mov	al,-2[bp]
09283 2827           A2         023B            mov	[$23B],al
09284                                           !BCC_EOS
09285                                           ! 1828   _write_byte(hdcount, 0x75, 0x40);
09286                                           ! Debug: list int = const $40 (used reg = )
09287 282A           B8                   0040  mov	ax,*$40
09288 282D           50                         push	ax
09289                                           ! Debug: list int = const $75 (used reg = )
09290 282E           B8                   0075  mov	ax,*$75
09291 2831           50                         push	ax
09292                                           ! Debug: list unsigned char hdcount = [S+$20C-3] (used reg = )
09293 2832           8A46         FF            mov	al,-1[bp]
09294 2835           30E4                       xor	ah,ah
09295 2837           50                         push	ax
09296                                           ! Debug: func () void = _write_byte+0 (used reg = )
09297 2838           E8         DDC0            call	__write_byte
09298 283B           83C4                   06  add	sp,*6
09299                                           !BCC_EOS
09300                                           ! 1829   bios_printf(2, "\n");
09301                                           ! Debug: list * char = .255+0 (used reg = )
09302 283E           BB                   D67C  mov	bx,#.255
09303 2841           53                         push	bx
09304                                           ! Debug: list int = const 2 (used reg = )
09305 2842           B8                   0002  mov	ax,*2
09306 2845           50                         push	ax
09307                                           ! Debug: func () void = bios_printf+0 (used reg = )
09308 2846           E8         E0F0            call	_bios_printf
09309 2849           83C4                   04  add	sp,*4
09310                                           !BCC_EOS
09311                                           ! 1830   set_DS(old_ds);
09312                                           ! Debug: list unsigned short old_ds = [S+$208-$208] (used reg = )
09313 284C           FFB6       FDFA            push	-$206[bp]
09314                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
09315 2850           E8         DE0A            call	_set_DS
09316 2853           44                         inc	sp
09317 2854           44                         inc	sp
09318                                           !BCC_EOS
09319                                           ! 1831 }
09320 2855           89EC                       mov	sp,bp
09321 2857           5D                         pop	bp
09322 2858           C3                         ret
09323                                           ! 1832 void ata_reset(device)
09324                                           ! Register BX used in function ata_detect
09325                                           ! 1833 Bit16u device;
09326                                           export	_ata_reset
09327                       00002859            _ata_reset:
09328                                           !BCC_EOS
09329                                           ! 1834 {
09330                                           ! 1835   Bit16u iobase1, iobase2;
09331                                           !BCC_EOS
09332                                           ! 1836   Bit8u channel, slave, sn, sc;
09333                                           !BCC_EOS
09334                                           ! 1837   Bit8u type;
09335                                           !BCC_EOS
09336                                           ! 1838   Bit16u max;
09337                                           !BCC_EOS
09338                                           ! 1839   channel = device / 2;
09339 2859           55                         push	bp
09340 285A           89E5                       mov	bp,sp
09341 285C           83C4                   F4  add	sp,*-$C
09342                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09343 285F           8B46         04            mov	ax,4[bp]
09344 2862           D1E8                       shr	ax,*1
09345                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-7] (used reg = )
09346 2864           8846         FB            mov	-5[bp],al
09347                                           !BCC_EOS
09348                                           ! 1840   slave = device % 2;
09349                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09350 2867           8B46         04            mov	ax,4[bp]
09351 286A           24                     01  and	al,*1
09352                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-8] (used reg = )
09353 286C           8846         FA            mov	-6[bp],al
09354                                           !BCC_EOS
09355                                           ! 1841   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].i
09356                                           ! 1841 obase1));
09357                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09358 286F           8A46         FB            mov	al,-5[bp]
09359 2872           30E4                       xor	ah,ah
09360 2874           B1                     03  mov	cl,*3
09361 2876           D3E0                       shl	ax,cl
09362 2878           89C3                       mov	bx,ax
09363                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09364                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09365                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09366 287A           8B9F       0124            mov	bx,$124[bx]
09367 287E           895E         FE            mov	-2[bp],bx
09368                                           !BCC_EOS
09369                                           ! 1842   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09370                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09371 2881           8A46         FB            mov	al,-5[bp]
09372 2884           30E4                       xor	ah,ah
09373 2886           B1                     03  mov	cl,*3
09374 2888           D3E0                       shl	ax,cl
09375 288A           89C3                       mov	bx,ax
09376                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09377                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09378                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09379 288C           8B9F       0126            mov	bx,$126[bx]
09380 2890           895E         FC            mov	-4[bp],bx
09381                                           !BCC_EOS
09382                                           ! 1843   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09383                                           ! Debug: list int = const $E (used reg = )
09384 2893           B8                   000E  mov	ax,*$E
09385 2896           50                         push	ax
09386                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09387 2897           8B46         FC            mov	ax,-4[bp]
09388                                           ! Debug: list unsigned int = ax+6 (used reg = )
09389 289A           05                   0006  add	ax,*6
09390 289D           50                         push	ax
09391                                           ! Debug: func () void = outb+0 (used reg = )
09392 289E           E8         DC9E            call	_outb
09393 28A1           83C4                   04  add	sp,*4
09394                                           !BCC_EOS
09395                                           ! 1844   await_ide(1, iobase1, 20);
09396                                           ! Debug: list int = const $14 (used reg = )
09397 28A4           B8                   0014  mov	ax,*$14
09398 28A7           50                         push	ax
09399                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09400 28A8           FF76         FE            push	-2[bp]
09401                                           ! Debug: list int = const 1 (used reg = )
09402 28AB           B8                   0001  mov	ax,*1
09403 28AE           50                         push	ax
09404                                           ! Debug: func () int = await_ide+0 (used reg = )
09405 28AF           E8         F178            call	_await_ide
09406 28B2           83C4                   06  add	sp,*6
09407                                           !BCC_EOS
09408                                           ! 1845   outb(iobase2+6, 0x08 | 0x02);
09409                                           ! Debug: list int = const $A (used reg = )
09410 28B5           B8                   000A  mov	ax,*$A
09411 28B8           50                         push	ax
09412                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09413 28B9           8B46         FC            mov	ax,-4[bp]
09414                                           ! Debug: list unsigned int = ax+6 (used reg = )
09415 28BC           05                   0006  add	ax,*6
09416 28BF           50                         push	ax
09417                                           ! Debug: func () void = outb+0 (used reg = )
09418 28C0           E8         DC7C            call	_outb
09419 28C3           83C4                   04  add	sp,*4
09420                                           !BCC_EOS
09421                                           ! 1846   type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
09422                                           ! Debug: ptradd unsigned short device = [S+$E+2] to [8] struct  = const $142 (used reg = )
09423 28C6           8B46         04            mov	ax,4[bp]
09424 28C9           B9                   001E  mov	cx,*$1E
09425 28CC           F7E9                       imul	cx
09426 28CE           89C3                       mov	bx,ax
09427                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09428                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
09429                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$E-$B] (used reg = )
09430 28D0           8A87       0142            mov	al,$142[bx]
09431 28D4           8846         F7            mov	-9[bp],al
09432                                           !BCC_EOS
09433                                           ! 1847   if (type != 0x00) {
09434                                           ! Debug: ne int = const 0 to unsigned char type = [S+$E-$B] (used reg = )
09435 28D7           8A46         F7            mov	al,-9[bp]
09436 28DA           84C0                       test	al,al
09437 28DC         0F84         0084            beq 	.256
09438                       000028E0            .257:
09439                                           ! 1848     outb(iobase1+6, slave?0xb0:0xa0);
09440 28E0           8A46         FA            mov	al,-6[bp]
09441 28E3           84C0                       test	al,al
09442 28E5           74           04            je  	.258
09443                       000028E7            .259:
09444 28E7           B0                     B0  mov	al,#$B0
09445 28E9           EB           02            jmp .25A
09446                       000028EB            .258:
09447 28EB           B0                     A0  mov	al,#$A0
09448                       000028ED            .25A:
09449                                           ! Debug: list char = al+0 (used reg = )
09450 28ED           30E4                       xor	ah,ah
09451 28EF           50                         push	ax
09452                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
09453 28F0           8B46         FE            mov	ax,-2[bp]
09454                                           ! Debug: list unsigned int = ax+6 (used reg = )
09455 28F3           05                   0006  add	ax,*6
09456 28F6           50                         push	ax
09457                                           ! Debug: func () void = outb+0 (used reg = )
09458 28F7           E8         DC45            call	_outb
09459 28FA           83C4                   04  add	sp,*4
09460                                           !BCC_EOS
09461                                           ! 1849     sc = inb(iobase1+2);
09462                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$E-4] (used reg = )
09463 28FD           8B46         FE            mov	ax,-2[bp]
09464                                           ! Debug: list unsigned int = ax+2 (used reg = )
09465 2900           40                         inc	ax
09466 2901           40                         inc	ax
09467 2902           50                         push	ax
09468                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09469 2903           E8         DC23            call	_inb
09470 2906           44                         inc	sp
09471 2907           44                         inc	sp
09472                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$E-$A] (used reg = )
09473 2908           8846         F8            mov	-8[bp],al
09474                                           !BCC_EOS
09475                                           ! 1850     sn = inb(iobase1+3);
09476                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$E-4] (used reg = )
09477 290B           8B46         FE            mov	ax,-2[bp]
09478                                           ! Debug: list unsigned int = ax+3 (used reg = )
09479 290E           05                   0003  add	ax,*3
09480 2911           50                         push	ax
09481                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09482 2912           E8         DC14            call	_inb
09483 2915           44                         inc	sp
09484 2916           44                         inc	sp
09485                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$E-9] (used reg = )
09486 2917           8846         F9            mov	-7[bp],al
09487                                           !BCC_EOS
09488                                           ! 1851     if ( (sc==0x01) && (sn==0x01) ) {
09489                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$E-$A] (used reg = )
09490 291A           8A46         F8            mov	al,-8[bp]
09491 291D           3C                     01  cmp	al,*1
09492 291F           75           32            jne 	.25B
09493                       00002921            .25D:
09494                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$E-9] (used reg = )
09495 2921           8A46         F9            mov	al,-7[bp]
09496 2924           3C                     01  cmp	al,*1
09497 2926           75           2B            jne 	.25B
09498                       00002928            .25C:
09499                                           ! 1852       if (type == 0x02)
09500                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$E-$B] (used reg = )
09501 2928           8A46         F7            mov	al,-9[bp]
09502 292B           3C                     02  cmp	al,*2
09503 292D           75           13            jne 	.25E
09504                       0000292F            .25F:
09505                                           ! 1853         await_ide(5, iobase1, 32000u);
09506                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09507 292F           B8                   7D00  mov	ax,#$7D00
09508 2932           50                         push	ax
09509                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09510 2933           FF76         FE            push	-2[bp]
09511                                           ! Debug: list int = const 5 (used reg = )
09512 2936           B8                   0005  mov	ax,*5
09513 2939           50                         push	ax
09514                                           ! Debug: func () int = await_ide+0 (used reg = )
09515 293A           E8         F0ED            call	_await_ide
09516 293D           83C4                   06  add	sp,*6
09517                                           !BCC_EOS
09518                                           ! 1854       else
09519                                           ! 1855         await_ide(2, iobase1, 32000u);
09520 2940           EB           11            jmp .260
09521                       00002942            .25E:
09522                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09523 2942           B8                   7D00  mov	ax,#$7D00
09524 2945           50                         push	ax
09525                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09526 2946           FF76         FE            push	-2[bp]
09527                                           ! Debug: list int = const 2 (used reg = )
09528 2949           B8                   0002  mov	ax,*2
09529 294C           50                         push	ax
09530                                           ! Debug: func () int = await_ide+0 (used reg = )
09531 294D           E8         F0DA            call	_await_ide
09532 2950           83C4                   06  add	sp,*6
09533                                           !BCC_EOS
09534                                           ! 1856     }
09535                       00002953            .260:
09536                                           ! 1857     await_ide(2, iobase1, 32000u);
09537                       00002953            .25B:
09538                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09539 2953           B8                   7D00  mov	ax,#$7D00
09540 2956           50                         push	ax
09541                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09542 2957           FF76         FE            push	-2[bp]
09543                                           ! Debug: list int = const 2 (used reg = )
09544 295A           B8                   0002  mov	ax,*2
09545 295D           50                         push	ax
09546                                           ! Debug: func () int = await_ide+0 (used reg = )
09547 295E           E8         F0C9            call	_await_ide
09548 2961           83C4                   06  add	sp,*6
09549                                           !BCC_EOS
09550                                           ! 1858   }
09551                                           ! 1859   outb(iobase2+6, 0x08);
09552                       00002964            .256:
09553                                           ! Debug: list int = const 8 (used reg = )
09554 2964           B8                   0008  mov	ax,*8
09555 2967           50                         push	ax
09556                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09557 2968           8B46         FC            mov	ax,-4[bp]
09558                                           ! Debug: list unsigned int = ax+6 (used reg = )
09559 296B           05                   0006  add	ax,*6
09560 296E           50                         push	ax
09561                                           ! Debug: func () void = outb+0 (used reg = )
09562 296F           E8         DBCD            call	_outb
09563 2972           83C4                   04  add	sp,*4
09564                                           !BCC_EOS
09565                                           ! 1860 }
09566 2975           89EC                       mov	sp,bp
09567 2977           5D                         pop	bp
09568 2978           C3                         ret
09569                                           ! 1861 Bit16u ata_cmd_non_data()
09570                                           ! Register BX used in function ata_reset
09571                                           ! 1862 {return 0;}
09572                                           export	_ata_cmd_non_data
09573                       00002979            _ata_cmd_non_data:
09574 2979           55                         push	bp
09575 297A           89E5                       mov	bp,sp
09576 297C           31C0                       xor	ax,ax
09577 297E           5D                         pop	bp
09578 297F           C3                         ret
09579                                           !BCC_EOS
09580                                           ! 1863 Bit16u ata_cmd_data_io(ioflag, device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
09581                                           ! 1864 Bit16u ioflag, device, command, count, cylinder, head, sector, segment, offset;
09582                                           export	_ata_cmd_data_io
09583                       00002980            _ata_cmd_data_io:
09584                                           !BCC_EOS
09585                                           ! 1865 Bit32u lba_low, lba_high;
09586                                           !BCC_EOS
09587                                           ! 1866 {
09588                                           ! 1867   Bit16u iobase1, iobase2, blksize;
09589                                           !BCC_EOS
09590                                           ! 1868   Bit8u channel, slave;
09591                                           !BCC_EOS
09592                                           ! 1869   Bit8u status, current, mode;
09593                                           !BCC_EOS
09594                                           ! 1870   channel = device / 2;
09595 2980           55                         push	bp
09596 2981           89E5                       mov	bp,sp
09597 2983           83C4                   F4  add	sp,*-$C
09598                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09599 2986           8B46         06            mov	ax,6[bp]
09600 2989           D1E8                       shr	ax,*1
09601                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-9] (used reg = )
09602 298B           8846         F9            mov	-7[bp],al
09603                                           !BCC_EOS
09604                                           ! 1871   slave = device % 2;
09605                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09606 298E           8B46         06            mov	ax,6[bp]
09607 2991           24                     01  and	al,*1
09608                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-$A] (used reg = )
09609 2993           8846         F8            mov	-8[bp],al
09610                                           !BCC_EOS
09611                                           ! 1872   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09612                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09613 2996           8A46         F9            mov	al,-7[bp]
09614 2999           30E4                       xor	ah,ah
09615 299B           B1                     03  mov	cl,*3
09616 299D           D3E0                       shl	ax,cl
09617 299F           89C3                       mov	bx,ax
09618                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09619                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09620                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09621 29A1           8B9F       0124            mov	bx,$124[bx]
09622 29A5           895E         FE            mov	-2[bp],bx
09623                                           !BCC_EOS
09624                                           ! 1873   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09625                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09626 29A8           8A46         F9            mov	al,-7[bp]
09627 29AB           30E4                       xor	ah,ah
09628 29AD           B1                     03  mov	cl,*3
09629 29AF           D3E0                       shl	ax,cl
09630 29B1           89C3                       mov	bx,ax
09631                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09632                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09633                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09634 29B3           8B9F       0126            mov	bx,$126[bx]
09635 29B7           895E         FC            mov	-4[bp],bx
09636                                           !BCC_EOS
09637                                           ! 1874   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
09638                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09639 29BA           8B46         06            mov	ax,6[bp]
09640 29BD           B9                   001E  mov	cx,*$1E
09641 29C0           F7E9                       imul	cx
09642 29C2           89C3                       mov	bx,ax
09643                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09644                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
09645                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$E-$D] (used reg = )
09646 29C4           8A87       0146            mov	al,$146[bx]
09647 29C8           8846         F5            mov	-$B[bp],al
09648                                           !BCC_EOS
09649                                           ! 1875   if ((command == 0xEC) ||
09650                                           ! 1876       (command == 0xA1)) {
09651                                           ! Debug: logeq int = const $EC to unsigned short command = [S+$E+6] (used reg = )
09652 29CB           8B46         08            mov	ax,8[bp]
09653 29CE           3D                   00EC  cmp	ax,#$EC
09654 29D1           74           08            je  	.262
09655                       000029D3            .263:
09656                                           ! Debug: logeq int = const $A1 to unsigned short command = [S+$E+6] (used reg = )
09657 29D3           8B46         08            mov	ax,8[bp]
09658 29D6           3D                   00A1  cmp	ax,#$A1
09659 29D9           75           08            jne 	.261
09660                       000029DB            .262:
09661                                           ! 1877     blksize = 0x200;
09662                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$E-8] (used reg = )
09663 29DB           B8                   0200  mov	ax,#$200
09664 29DE           8946         FA            mov	-6[bp],ax
09665                                           !BCC_EOS
09666                                           ! 1878   } else {
09667 29E1           EB           11            jmp .264
09668                       000029E3            .261:
09669                                           ! 1879     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
09670                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09671 29E3           8B46         06            mov	ax,6[bp]
09672 29E6           B9                   001E  mov	cx,*$1E
09673 29E9           F7E9                       imul	cx
09674 29EB           89C3                       mov	bx,ax
09675                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09676                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
09677                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$E-8] (used reg = )
09678 29ED           8B9F       0148            mov	bx,$148[bx]
09679 29F1           895E         FA            mov	-6[bp],bx
09680                                           !BCC_EOS
09681                                           ! 1880   }
09682                                           ! 1881   if (mode == 0x01) blksize>>=2;
09683                       000029F4            .264:
09684                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$E-$D] (used reg = )
09685 29F4           8A46         F5            mov	al,-$B[bp]
09686 29F7           3C                     01  cmp	al,*1
09687 29F9           75           0C            jne 	.265
09688                       000029FB            .266:
09689                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$E-8] (used reg = )
09690 29FB           8B46         FA            mov	ax,-6[bp]
09691 29FE           D1E8                       shr	ax,*1
09692 2A00           D1E8                       shr	ax,*1
09693 2A02           8946         FA            mov	-6[bp],ax
09694                                           !BCC_EOS
09695                                           ! 1882   else blksize>>=1;
09696 2A05           EB           08            jmp .267
09697                       00002A07            .265:
09698                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$E-8] (used reg = )
09699 2A07           8B46         FA            mov	ax,-6[bp]
09700 2A0A           D1E8                       shr	ax,*1
09701 2A0C           8946         FA            mov	-6[bp],ax
09702                                           !BCC_EOS
09703                                           ! 1883   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
09704                       00002A0F            .267:
09705                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
09706 2A0F           31C0                       xor	ax,ax
09707 2A11           A3         0254            mov	[$254],ax
09708                                           !BCC_EOS
09709                                           ! 1884   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
09710                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
09711 2A14           31C0                       xor	ax,ax
09712 2A16           31DB                       xor	bx,bx
09713 2A18           A3         0256            mov	[$256],ax
09714 2A1B           891E       0258            mov	[$258],bx
09715                                           !BCC_EOS
09716                                           ! 1885   current = 0;
09717                                           ! Debug: eq int = const 0 to unsigned char current = [S+$E-$C] (used reg = )
09718 2A1F           30C0                       xor	al,al
09719 2A21           8846         F6            mov	-$A[bp],al
09720                                           !BCC_EOS
09721                                           ! 1886   status = inb(iobase1 + 7);
09722                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
09723 2A24           8B46         FE            mov	ax,-2[bp]
09724                                           ! Debug: list unsigned int = ax+7 (used reg = )
09725 2A27           05                   0007  add	ax,*7
09726 2A2A           50                         push	ax
09727                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09728 2A2B           E8         DAFB            call	_inb
09729 2A2E           44                         inc	sp
09730 2A2F           44                         inc	sp
09731                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
09732 2A30           8846         F7            mov	-9[bp],al
09733                                           !BCC_EOS
09734                                           ! 1887   if (status & 0x80) return 1;
09735                                           ! Debug: and int = const $80 to unsigned char status = [S+$E-$B] (used reg = )
09736 2A33           8A46         F7            mov	al,-9[bp]
09737 2A36           24                     80  and	al,#$80
09738 2A38           84C0                       test	al,al
09739 2A3A           74           07            je  	.268
09740                       00002A3C            .269:
09741 2A3C           B8                   0001  mov	ax,*1
09742 2A3F           89EC                       mov	sp,bp
09743 2A41           5D                         pop	bp
09744 2A42           C3                         ret
09745                                           !BCC_EOS
09746                                           ! 1888   outb(iobase2 + 6, 0x08 | 0x02);
09747                       00002A43            .268:
09748                                           ! Debug: list int = const $A (used reg = )
09749 2A43           B8                   000A  mov	ax,*$A
09750 2A46           50                         push	ax
09751                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09752 2A47           8B46         FC            mov	ax,-4[bp]
09753                                           ! Debug: list unsigned int = ax+6 (used reg = )
09754 2A4A           05                   0006  add	ax,*6
09755 2A4D           50                         push	ax
09756                                           ! Debug: func () void = outb+0 (used reg = )
09757 2A4E           E8         DAEE            call	_outb
09758 2A51           83C4                   04  add	sp,*4
09759                                           !BCC_EOS
09760                                           ! 1889   if (sector == 0) {
09761                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$E+$E] (used reg = )
09762 2A54           8B46         10            mov	ax,$10[bp]
09763 2A57           85C0                       test	ax,ax
09764 2A59         0F85         00F5            bne 	.26A
09765                       00002A5D            .26B:
09766                                           ! 1890     if (*(((Bit8u *)&count)+1) >= 1 || lba_high || (lba_low >= ((1UL << 28) - count))) {
09767                                           ! Debug: ge int = const 1 to unsigned char count = [S+$E+9] (used reg = )
09768 2A5D           8A46         0B            mov	al,$B[bp]
09769 2A60           3C                     01  cmp	al,*1
09770 2A62           72           04            jb 	.270
09771 2A64           B0                     01  mov	al,*1
09772 2A66           EB           02            jmp	.271
09773                       00002A68            .270:
09774 2A68           30C0                       xor	al,al
09775                       00002A6A            .271:
09776                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
09777 2A6A           30E4                       xor	ah,ah
09778 2A6C           99                         cwd
09779 2A6D           89D3                       mov	bx,dx
09780 2A6F           E8         D673            call	ltstl
09781 2A72           75           2A            jne 	.26D
09782                       00002A74            .26F:
09783 2A74           8B46         16            mov	ax,$16[bp]
09784 2A77           8B5E         18            mov	bx,$18[bp]
09785 2A7A           E8         D668            call	ltstl
09786 2A7D           75           1F            jne 	.26D
09787                       00002A7F            .26E:
09788                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$E+8] (used reg = )
09789 2A7F           8B46         0A            mov	ax,$A[bp]
09790 2A82           31DB                       xor	bx,bx
09791                                           ! Debug: sub unsigned long = bx+0 to unsigned long = const $10000000 (used reg = )
09792 2A84           53                         push	bx
09793 2A85           50                         push	ax
09794 2A86           31C0                       xor	ax,ax
09795 2A88           BB                   1000  mov	bx,#$1000
09796 2A8B           8D7E         F0            lea	di,-$10[bp]
09797 2A8E           E8         D621            call	lsubul
09798 2A91           83C4                   04  add	sp,*4
09799                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$E+$10] (used reg = )
09800 2A94           8D7E         12            lea	di,$12[bp]
09801 2A97           E8         D602            call	lcmpul
09802 2A9A         0F87         0086            bhi 	.26C
09803                       00002A9E            .26D:
09804                                           ! 1891       outb(iobase1 + 1, 0x00);
09805                                           ! Debug: list int = const 0 (used reg = )
09806 2A9E           31C0                       xor	ax,ax
09807 2AA0           50                         push	ax
09808                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09809 2AA1           8B46         FE            mov	ax,-2[bp]
09810                                           ! Debug: list unsigned int = ax+1 (used reg = )
09811 2AA4           40                         inc	ax
09812 2AA5           50                         push	ax
09813                                           ! Debug: func () void = outb+0 (used reg = )
09814 2AA6           E8         DA96            call	_outb
09815 2AA9           83C4                   04  add	sp,*4
09816                                           !BCC_EOS
09817                                           ! 1892       outb(iobase1 + 2, *(((Bit8u *)&count)+1));
09818                                           ! Debug: list unsigned char count = [S+$E+9] (used reg = )
09819 2AAC           8A46         0B            mov	al,$B[bp]
09820 2AAF           30E4                       xor	ah,ah
09821 2AB1           50                         push	ax
09822                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09823 2AB2           8B46         FE            mov	ax,-2[bp]
09824                                           ! Debug: list unsigned int = ax+2 (used reg = )
09825 2AB5           40                         inc	ax
09826 2AB6           40                         inc	ax
09827 2AB7           50                         push	ax
09828                                           ! Debug: func () void = outb+0 (used reg = )
09829 2AB8           E8         DA84            call	_outb
09830 2ABB           83C4                   04  add	sp,*4
09831                                           !BCC_EOS
09832                                           ! 1893       outb(iobase1 + 3, *(((Bit8u *)&*(((Bit16u *)&lba_low)+1))+1));
09833                                           ! Debug: list unsigned char lba_low = [S+$E+$13] (used reg = )
09834 2ABE           8A46         15            mov	al,$15[bp]
09835 2AC1           30E4                       xor	ah,ah
09836 2AC3           50                         push	ax
09837                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09838 2AC4           8B46         FE            mov	ax,-2[bp]
09839                                           ! Debug: list unsigned int = ax+3 (used reg = )
09840 2AC7           05                   0003  add	ax,*3
09841 2ACA           50                         push	ax
09842                                           ! Debug: func () void = outb+0 (used reg = )
09843 2ACB           E8         DA71            call	_outb
09844 2ACE           83C4                   04  add	sp,*4
09845                                           !BCC_EOS
09846                                           ! 1894       outb(iobase1 + 4, *((Bit8u *)&lba_high));
09847                                           ! Debug: list unsigned char lba_high = [S+$E+$14] (used reg = )
09848 2AD1           8A46         16            mov	al,$16[bp]
09849 2AD4           30E4                       xor	ah,ah
09850 2AD6           50                         push	ax
09851                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09852 2AD7           8B46         FE            mov	ax,-2[bp]
09853                                           ! Debug: list unsigned int = ax+4 (used reg = )
09854 2ADA           05                   0004  add	ax,*4
09855 2ADD           50                         push	ax
09856                                           ! Debug: func () void = outb+0 (used reg = )
09857 2ADE           E8         DA5E            call	_outb
09858 2AE1           83C4                   04  add	sp,*4
09859                                           !BCC_EOS
09860                                           ! 1895       outb(iobase1 + 5, *(((Bit8u *)&*((Bit16u *)&lba_high))+1));
09861                                           ! 1895 
09862                                           ! Debug: list unsigned char lba_high = [S+$E+$15] (used reg = )
09863 2AE4           8A46         17            mov	al,$17[bp]
09864 2AE7           30E4                       xor	ah,ah
09865 2AE9           50                         push	ax
09866                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09867 2AEA           8B46         FE            mov	ax,-2[bp]
09868                                           ! Debug: list unsigned int = ax+5 (used reg = )
09869 2AED           05                   0005  add	ax,*5
09870 2AF0           50                         push	ax
09871                                           ! Debug: func () void = outb+0 (used reg = )
09872 2AF1           E8         DA4B            call	_outb
09873 2AF4           83C4                   04  add	sp,*4
09874                                           !BCC_EOS
09875                                           ! 1896       command |= 0x04;
09876                                           ! Debug: orab int = const 4 to unsigned short command = [S+$E+6] (used reg = )
09877 2AF7           8B46         08            mov	ax,8[bp]
09878 2AFA           0C                     04  or	al,*4
09879 2AFC           8946         08            mov	8[bp],ax
09880                                           !BCC_EOS
09881                                           ! 1897       count &= (1 << 8) - 1;
09882                                           ! Debug: andab int = const $FF to unsigned short count = [S+$E+8] (used reg = )
09883 2AFF           8A46         0A            mov	al,$A[bp]
09884 2B02           30E4                       xor	ah,ah
09885 2B04           8946         0A            mov	$A[bp],ax
09886                                           !BCC_EOS
09887                                           ! 1898       lba_low &= (1UL << 24) - 1;
09888                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$E+$10] (used reg = )
09889 2B07           B8                   FFFF  mov	ax,#$FFFF
09890 2B0A           BB                   00FF  mov	bx,#$FF
09891 2B0D           53                         push	bx
09892 2B0E           50                         push	ax
09893 2B0F           8B46         12            mov	ax,$12[bp]
09894 2B12           8B5E         14            mov	bx,$14[bp]
09895 2B15           8D7E         F0            lea	di,-$10[bp]
09896 2B18           E8         D571            call	landul
09897 2B1B           8946         12            mov	$12[bp],ax
09898 2B1E           895E         14            mov	$14[bp],bx
09899 2B21           83C4                   04  add	sp,*4
09900                                           !BCC_EOS
09901                                           ! 1899     }
09902                                           ! 1900     sector = (Bit16u) *((Bit8u *)&lba_low);
09903                       00002B24            .26C:
09904                                           ! Debug: cast unsigned short = const 0 to unsigned char lba_low = [S+$E+$10] (used reg = )
09905 2B24           8A46         12            mov	al,$12[bp]
09906 2B27           30E4                       xor	ah,ah
09907                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$E+$E] (used reg = )
09908 2B29           8946         10            mov	$10[bp],ax
09909                                           !BCC_EOS
09910                                           ! 1901     lba_low >>= 8;
09911                                           ! Debug: srab int = const 8 to unsigned long lba_low = [S+$E+$10] (used reg = )
09912 2B2C           8B46         12            mov	ax,$12[bp]
09913 2B2F           8B5E         14            mov	bx,$14[bp]
09914 2B32           88E0                       mov	al,ah
09915 2B34           88DC                       mov	ah,bl
09916 2B36           88FB                       mov	bl,bh
09917 2B38           28FF                       sub	bh,bh
09918 2B3A           8946         12            mov	$12[bp],ax
09919 2B3D           895E         14            mov	$14[bp],bx
09920                                           !BCC_EOS
09921                                           ! 1902     cylinder = *((Bit16u *)&lba_low);
09922                                           ! Debug: eq unsigned short lba_low = [S+$E+$10] to unsigned short cylinder = [S+$E+$A] (used reg = )
09923 2B40           8B46         12            mov	ax,$12[bp]
09924 2B43           8946         0C            mov	$C[bp],ax
09925                                           !BCC_EOS
09926                                           ! 1903     head = (*(((Bit16u *)&lba_low)+1) & 0x000f) | 0x40;
09927                                           ! Debug: and int = const $F to unsigned short lba_low = [S+$E+$12] (used reg = )
09928 2B46           8A46         14            mov	al,$14[bp]
09929 2B49           24                     0F  and	al,*$F
09930                                           ! Debug: or int = const $40 to unsigned char = al+0 (used reg = )
09931 2B4B           0C                     40  or	al,*$40
09932                                           ! Debug: eq unsigned char = al+0 to unsigned short head = [S+$E+$C] (used reg = )
09933 2B4D           30E4                       xor	ah,ah
09934 2B4F           8946         0E            mov	$E[bp],ax
09935                                           !BCC_EOS
09936                                           ! 1904   }
09937                                           ! 1905   outb(iobase1 + 1, 0x00);
09938                       00002B52            .26A:
09939                                           ! Debug: list int = const 0 (used reg = )
09940 2B52           31C0                       xor	ax,ax
09941 2B54           50                         push	ax
09942                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09943 2B55           8B46         FE            mov	ax,-2[bp]
09944                                           ! Debug: list unsigned int = ax+1 (used reg = )
09945 2B58           40                         inc	ax
09946 2B59           50                         push	ax
09947                                           ! Debug: func () void = outb+0 (used reg = )
09948 2B5A           E8         D9E2            call	_outb
09949 2B5D           83C4                   04  add	sp,*4
09950                                           !BCC_EOS
09951                                           ! 1906   outb(iobase1 + 2, count);
09952                                           ! Debug: list unsigned short count = [S+$E+8] (used reg = )
09953 2B60           FF76         0A            push	$A[bp]
09954                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09955 2B63           8B46         FE            mov	ax,-2[bp]
09956                                           ! Debug: list unsigned int = ax+2 (used reg = )
09957 2B66           40                         inc	ax
09958 2B67           40                         inc	ax
09959 2B68           50                         push	ax
09960                                           ! Debug: func () void = outb+0 (used reg = )
09961 2B69           E8         D9D3            call	_outb
09962 2B6C           83C4                   04  add	sp,*4
09963                                           !BCC_EOS
09964                                           ! 1907   outb(iobase1 + 3, sector);
09965                                           ! Debug: list unsigned short sector = [S+$E+$E] (used reg = )
09966 2B6F           FF76         10            push	$10[bp]
09967                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09968 2B72           8B46         FE            mov	ax,-2[bp]
09969                                           ! Debug: list unsigned int = ax+3 (used reg = )
09970 2B75           05                   0003  add	ax,*3
09971 2B78           50                         push	ax
09972                                           ! Debug: func () void = outb+0 (used reg = )
09973 2B79           E8         D9C3            call	_outb
09974 2B7C           83C4                   04  add	sp,*4
09975                                           !BCC_EOS
09976                                           ! 1908   outb(iobase1 + 4, *((Bit8u *)&cylinder));
09977                                           ! Debug: list unsigned char cylinder = [S+$E+$A] (used reg = )
09978 2B7F           8A46         0C            mov	al,$C[bp]
09979 2B82           30E4                       xor	ah,ah
09980 2B84           50                         push	ax
09981                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09982 2B85           8B46         FE            mov	ax,-2[bp]
09983                                           ! Debug: list unsigned int = ax+4 (used reg = )
09984 2B88           05                   0004  add	ax,*4
09985 2B8B           50                         push	ax
09986                                           ! Debug: func () void = outb+0 (used reg = )
09987 2B8C           E8         D9B0            call	_outb
09988 2B8F           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1909   outb(iobase1 + 5, *(((Bit8u *)&cylinder)+1));
09991                                           ! Debug: list unsigned char cylinder = [S+$E+$B] (used reg = )
09992 2B92           8A46         0D            mov	al,$D[bp]
09993 2B95           30E4                       xor	ah,ah
09994 2B97           50                         push	ax
09995                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09996 2B98           8B46         FE            mov	ax,-2[bp]
09997                                           ! Debug: list unsigned int = ax+5 (used reg = )
09998 2B9B           05                   0005  add	ax,*5
09999 2B9E           50                         push	ax
10000                                           ! Debug: func () void = outb+0 (used reg = )
10001 2B9F           E8         D99D            call	_outb
10002 2BA2           83C4                   04  add	sp,*4
10003                                           !BCC_EOS
10004                                           ! 1910   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10005 2BA5           8A46         F8            mov	al,-8[bp]
10006 2BA8           84C0                       test	al,al
10007 2BAA           74           04            je  	.273
10008                       00002BAC            .274:
10009 2BAC           B0                     B0  mov	al,#$B0
10010 2BAE           EB           02            jmp .275
10011                       00002BB0            .273:
10012 2BB0           B0                     A0  mov	al,#$A0
10013                       00002BB2            .275:
10014                                           ! Debug: or unsigned char head = [S+$E+$C] to char = al+0 (used reg = )
10015 2BB2           0A46         0E            or	al,$E[bp]
10016                                           ! Debug: list unsigned char = al+0 (used reg = )
10017 2BB5           30E4                       xor	ah,ah
10018 2BB7           50                         push	ax
10019                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
10020 2BB8           8B46         FE            mov	ax,-2[bp]
10021                                           ! Debug: list unsigned int = ax+6 (used reg = )
10022 2BBB           05                   0006  add	ax,*6
10023 2BBE           50                         push	ax
10024                                           ! Debug: func () void = outb+0 (used reg = )
10025 2BBF           E8         D97D            call	_outb
10026 2BC2           83C4                   04  add	sp,*4
10027                                           !BCC_EOS
10028                                           ! 1911   outb(iobase1 + 7, command);
10029                                           ! Debug: list unsigned short command = [S+$E+6] (used reg = )
10030 2BC5           FF76         08            push	8[bp]
10031                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-4] (used reg = )
10032 2BC8           8B46         FE            mov	ax,-2[bp]
10033                                           ! Debug: list unsigned int = ax+7 (used reg = )
10034 2BCB           05                   0007  add	ax,*7
10035 2BCE           50                         push	ax
10036                                           ! Debug: func () void = outb+0 (used reg = )
10037 2BCF           E8         D96D            call	_outb
10038 2BD2           83C4                   04  add	sp,*4
10039                                           !BCC_EOS
10040                                           ! 1912   await_ide(3, iobase1, 32000u);
10041                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10042 2BD5           B8                   7D00  mov	ax,#$7D00
10043 2BD8           50                         push	ax
10044                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10045 2BD9           FF76         FE            push	-2[bp]
10046                                           ! Debug: list int = const 3 (used reg = )
10047 2BDC           B8                   0003  mov	ax,*3
10048 2BDF           50                         push	ax
10049                                           ! Debug: func () int = await_ide+0 (used reg = )
10050 2BE0           E8         EE47            call	_await_ide
10051 2BE3           83C4                   06  add	sp,*6
10052                                           !BCC_EOS
10053                                           ! 1913   status = inb(iobase1 + 7);
10054                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10055 2BE6           8B46         FE            mov	ax,-2[bp]
10056                                           ! Debug: list unsigned int = ax+7 (used reg = )
10057 2BE9           05                   0007  add	ax,*7
10058 2BEC           50                         push	ax
10059                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10060 2BED           E8         D939            call	_inb
10061 2BF0           44                         inc	sp
10062 2BF1           44                         inc	sp
10063                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10064 2BF2           8846         F7            mov	-9[bp],al
10065                                           !BCC_EOS
10066                                           ! 1914   if (status & 0x01) {
10067                                           ! Debug: and int = const 1 to unsigned char status = [S+$E-$B] (used reg = )
10068 2BF5           8A46         F7            mov	al,-9[bp]
10069 2BF8           24                     01  and	al,*1
10070 2BFA           84C0                       test	al,al
10071 2BFC           74           09            je  	.276
10072                       00002BFE            .277:
10073                                           ! 1915     ;
10074                                           !BCC_EOS
10075                                           ! 1916     return 2;
10076 2BFE           B8                   0002  mov	ax,*2
10077 2C01           89EC                       mov	sp,bp
10078 2C03           5D                         pop	bp
10079 2C04           C3                         ret
10080                                           !BCC_EOS
10081                                           ! 1917   } else if ( !(status & 0x08) ) {
10082 2C05           EB           10            jmp .278
10083                       00002C07            .276:
10084                                           ! Debug: and int = const 8 to unsigned char status = [S+$E-$B] (used reg = )
10085 2C07           8A46         F7            mov	al,-9[bp]
10086 2C0A           24                     08  and	al,*8
10087 2C0C           84C0                       test	al,al
10088 2C0E           75           07            jne 	.279
10089                       00002C10            .27A:
10090                                           ! 1918     ;
10091                                           !BCC_EOS
10092                                           ! 1919     return 3;
10093 2C10           B8                   0003  mov	ax,*3
10094 2C13           89EC                       mov	sp,bp
10095 2C15           5D                         pop	bp
10096 2C16           C3                         ret
10097                                           !BCC_EOS
10098                                           ! 1920   }
10099                                           ! 1921 #asm
10100                       00002C17            .279:
10101                       00002C17            .278:
10102                                           !BCC_EOS
10103                                           !BCC_ASM
10104                       00000016            _ata_cmd_data_io.count	set	$16
10105                       0000000A            .ata_cmd_data_io.count	set	$A
10106                       00000026            _ata_cmd_data_io.segment	set	$26
10107                       0000001A            .ata_cmd_data_io.segment	set	$1A
10108                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10109                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10110                       00000005            _ata_cmd_data_io.channel	set	5
10111                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10112                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10113                       00000012            .ata_cmd_data_io.lba_low	set	$12
10114                       00000022            _ata_cmd_data_io.lba_high	set	$22
10115                       00000016            .ata_cmd_data_io.lba_high	set	$16
10116                       0000001C            _ata_cmd_data_io.sector	set	$1C
10117                       00000010            .ata_cmd_data_io.sector	set	$10
10118                       00000006            _ata_cmd_data_io.blksize	set	6
10119                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10120                       0000001A            _ata_cmd_data_io.head	set	$1A
10121                       0000000E            .ata_cmd_data_io.head	set	$E
10122                       00000010            _ata_cmd_data_io.ioflag	set	$10
10123                       00000004            .ata_cmd_data_io.ioflag	set	4
10124                       00000018            _ata_cmd_data_io.cylinder	set	$18
10125                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10126                       00000012            _ata_cmd_data_io.device	set	$12
10127                       00000006            .ata_cmd_data_io.device	set	6
10128                       00000003            _ata_cmd_data_io.status	set	3
10129                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10130                       00000002            _ata_cmd_data_io.current	set	2
10131                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10132                       00000014            _ata_cmd_data_io.command	set	$14
10133                       00000008            .ata_cmd_data_io.command	set	8
10134                       00000001            _ata_cmd_data_io.mode	set	1
10135                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10136                       00000008            _ata_cmd_data_io.iobase2	set	8
10137                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10138                       00000028            _ata_cmd_data_io.offset	set	$28
10139                       0000001C            .ata_cmd_data_io.offset	set	$1C
10140                       00000004            _ata_cmd_data_io.slave	set	4
10141                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10142 2C17           FB                                 sti ;; enable higher priority interrupts
10143                                           ! 1923 endasm
10144                                           !BCC_ENDASM
10145                                           !BCC_EOS
10146                                           ! 1924   while (1) {
10147                       00002C18            .27D:
10148                                           ! 1925     if(ioflag == 0)
10149                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10150 2C18           8B46         04            mov	ax,4[bp]
10151 2C1B           85C0                       test	ax,ax
10152 2C1D           75           36            jne 	.27E
10153                       00002C1F            .27F:
10154                                           ! 1926     {
10155                                           ! 1927 #asm
10156                                           !BCC_EOS
10157                                           !BCC_ASM
10158                       00000016            _ata_cmd_data_io.count	set	$16
10159                       0000000A            .ata_cmd_data_io.count	set	$A
10160                       00000026            _ata_cmd_data_io.segment	set	$26
10161                       0000001A            .ata_cmd_data_io.segment	set	$1A
10162                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10163                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10164                       00000005            _ata_cmd_data_io.channel	set	5
10165                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10166                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10167                       00000012            .ata_cmd_data_io.lba_low	set	$12
10168                       00000022            _ata_cmd_data_io.lba_high	set	$22
10169                       00000016            .ata_cmd_data_io.lba_high	set	$16
10170                       0000001C            _ata_cmd_data_io.sector	set	$1C
10171                       00000010            .ata_cmd_data_io.sector	set	$10
10172                       00000006            _ata_cmd_data_io.blksize	set	6
10173                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10174                       0000001A            _ata_cmd_data_io.head	set	$1A
10175                       0000000E            .ata_cmd_data_io.head	set	$E
10176                       00000010            _ata_cmd_data_io.ioflag	set	$10
10177                       00000004            .ata_cmd_data_io.ioflag	set	4
10178                       00000018            _ata_cmd_data_io.cylinder	set	$18
10179                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10180                       00000012            _ata_cmd_data_io.device	set	$12
10181                       00000006            .ata_cmd_data_io.device	set	6
10182                       00000003            _ata_cmd_data_io.status	set	3
10183                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10184                       00000002            _ata_cmd_data_io.current	set	2
10185                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10186                       00000014            _ata_cmd_data_io.command	set	$14
10187                       00000008            .ata_cmd_data_io.command	set	8
10188                       00000001            _ata_cmd_data_io.mode	set	1
10189                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10190                       00000008            _ata_cmd_data_io.iobase2	set	8
10191                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10192                       00000028            _ata_cmd_data_io.offset	set	$28
10193                       0000001C            .ata_cmd_data_io.offset	set	$1C
10194                       00000004            _ata_cmd_data_io.slave	set	4
10195                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10196 2C1F           55                                 push bp
10197 2C20           89E5                               mov bp, sp
10198 2C22           8B7E         2A                    mov di, _ata_cmd_data_io.offset + 2[bp]
10199 2C25           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10200 2C28           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10201                                                   ;; adjust if there will be an overrun. 2K max sector size
10202 2C2B           81FF                 F800          cmp di, #0xf800 ;;
10203 2C2F           76           07                    jbe ata_in_no_adjust
10204                       00002C31            ata_in_adjust:
10205 2C31           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10206 2C35           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10207                       00002C38            ata_in_no_adjust:
10208 2C38           8EC0                               mov es, ax ;; segment in es
10209 2C3A           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data read port
10210 2C3D           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10211 2C40           80FC                   01          cmp ah, #0x01
10212 2C43           74           04                    je ata_in_32
10213                       00002C45            ata_in_16:
10214 2C45           F3                                 rep
10215 2C46           6D                                   insw ;; CX words transferred from port(DX) to ES:[DI]
10216 2C47           EB           03                    jmp ata_in_done
10217                       00002C49            ata_in_32:
10218 2C49           F3                                 rep
10219 2C4A     66    6D                                   insd ;; CX dwords transferred from port(DX) to ES:[DI]
10220                       00002C4C            ata_in_done:
10221 2C4C           897E         2A                    mov _ata_cmd_data_io.offset + 2[bp], di
10222 2C4F           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10223 2C52           5D                                 pop bp
10224                                           ! 1956 endasm
10225                                           !BCC_ENDASM
10226                                           !BCC_EOS
10227                                           ! 1957     }
10228                                           ! 1958     else
10229                                           ! 1959     {
10230 2C53           EB           36            jmp .280
10231                       00002C55            .27E:
10232                                           ! 1960 #asm
10233                                           !BCC_EOS
10234                                           !BCC_ASM
10235                       00000016            _ata_cmd_data_io.count	set	$16
10236                       0000000A            .ata_cmd_data_io.count	set	$A
10237                       00000026            _ata_cmd_data_io.segment	set	$26
10238                       0000001A            .ata_cmd_data_io.segment	set	$1A
10239                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10240                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10241                       00000005            _ata_cmd_data_io.channel	set	5
10242                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10243                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10244                       00000012            .ata_cmd_data_io.lba_low	set	$12
10245                       00000022            _ata_cmd_data_io.lba_high	set	$22
10246                       00000016            .ata_cmd_data_io.lba_high	set	$16
10247                       0000001C            _ata_cmd_data_io.sector	set	$1C
10248                       00000010            .ata_cmd_data_io.sector	set	$10
10249                       00000006            _ata_cmd_data_io.blksize	set	6
10250                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10251                       0000001A            _ata_cmd_data_io.head	set	$1A
10252                       0000000E            .ata_cmd_data_io.head	set	$E
10253                       00000010            _ata_cmd_data_io.ioflag	set	$10
10254                       00000004            .ata_cmd_data_io.ioflag	set	4
10255                       00000018            _ata_cmd_data_io.cylinder	set	$18
10256                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10257                       00000012            _ata_cmd_data_io.device	set	$12
10258                       00000006            .ata_cmd_data_io.device	set	6
10259                       00000003            _ata_cmd_data_io.status	set	3
10260                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10261                       00000002            _ata_cmd_data_io.current	set	2
10262                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10263                       00000014            _ata_cmd_data_io.command	set	$14
10264                       00000008            .ata_cmd_data_io.command	set	8
10265                       00000001            _ata_cmd_data_io.mode	set	1
10266                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10267                       00000008            _ata_cmd_data_io.iobase2	set	8
10268                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10269                       00000028            _ata_cmd_data_io.offset	set	$28
10270                       0000001C            .ata_cmd_data_io.offset	set	$1C
10271                       00000004            _ata_cmd_data_io.slave	set	4
10272                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10273 2C55           55                                 push bp
10274 2C56           89E5                               mov bp, sp
10275 2C58           8B76         2A                    mov si, _ata_cmd_data_io.offset + 2[bp]
10276 2C5B           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10277 2C5E           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10278                                                   ;; adjust if there will be an overrun. 2K max sector size
10279 2C61           81FE                 F800          cmp si, #0xf800 ;;
10280 2C65           76           07                    jbe ata_out_no_adjust
10281                       00002C67            ata_out_adjust:
10282 2C67           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
10283 2C6B           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10284                       00002C6E            ata_out_no_adjust:
10285 2C6E           8EC0                               mov es, ax ;; segment in es
10286 2C70           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data write port
10287 2C73           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10288 2C76           80FC                   01          cmp ah, #0x01
10289 2C79           74           05                    je ata_out_32
10290                       00002C7B            ata_out_16:
10291 2C7B           26                                 seg ES
10292 2C7C           F3                                 rep
10293 2C7D           6F                                   outsw ;; CX words transferred from port(DX) to ES:[SI]
10294 2C7E           EB           04                    jmp ata_out_done
10295                       00002C80            ata_out_32:
10296 2C80           26                                 seg ES
10297 2C81           F3                                 rep
10298 2C82     66    6F                                   outsd ;; CX dwords transferred from port(DX) to ES:[SI]
10299                       00002C84            ata_out_done:
10300 2C84           8976         2A                    mov _ata_cmd_data_io.offset + 2[bp], si
10301 2C87           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10302 2C8A           5D                                 pop bp
10303                                           ! 1991 endasm
10304                                           !BCC_ENDASM
10305                                           !BCC_EOS
10306                                           ! 1992     }
10307                                           ! 1993     current++;
10308                       00002C8B            .280:
10309                                           ! Debug: postinc unsigned char current = [S+$E-$C] (used reg = )
10310 2C8B           8A46         F6            mov	al,-$A[bp]
10311 2C8E           40                         inc	ax
10312 2C8F           8846         F6            mov	-$A[bp],al
10313                                           !BCC_EOS
10314                                           ! 1994     *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (current);
10315                                           ! Debug: eq unsigned char current = [S+$E-$C] to unsigned short = [+$254] (used reg = )
10316 2C92           8A46         F6            mov	al,-$A[bp]
10317 2C95           30E4                       xor	ah,ah
10318 2C97           A3         0254            mov	[$254],ax
10319                                           !BCC_EOS
10320                                           ! 1995     count--;
10321                                           ! Debug: postdec unsigned short count = [S+$E+8] (used reg = )
10322 2C9A           8B46         0A            mov	ax,$A[bp]
10323 2C9D           48                         dec	ax
10324 2C9E           8946         0A            mov	$A[bp],ax
10325                                           !BCC_EOS
10326                                           ! 1996     if(ioflag == 0) await_ide(2, iobase1, 32000u);
10327                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10328 2CA1           8B46         04            mov	ax,4[bp]
10329 2CA4           85C0                       test	ax,ax
10330 2CA6           75           11            jne 	.281
10331                       00002CA8            .282:
10332                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10333 2CA8           B8                   7D00  mov	ax,#$7D00
10334 2CAB           50                         push	ax
10335                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10336 2CAC           FF76         FE            push	-2[bp]
10337                                           ! Debug: list int = const 2 (used reg = )
10338 2CAF           B8                   0002  mov	ax,*2
10339 2CB2           50                         push	ax
10340                                           ! Debug: func () int = await_ide+0 (used reg = )
10341 2CB3           E8         ED74            call	_await_ide
10342 2CB6           83C4                   06  add	sp,*6
10343                                           !BCC_EOS
10344                                           ! 1997     status = inb(iobase1 + 7);
10345                       00002CB9            .281:
10346                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10347 2CB9           8B46         FE            mov	ax,-2[bp]
10348                                           ! Debug: list unsigned int = ax+7 (used reg = )
10349 2CBC           05                   0007  add	ax,*7
10350 2CBF           50                         push	ax
10351                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10352 2CC0           E8         D866            call	_inb
10353 2CC3           44                         inc	sp
10354 2CC4           44                         inc	sp
10355                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10356 2CC5           8846         F7            mov	-9[bp],al
10357                                           !BCC_EOS
10358                                           ! 1998     if(ioflag == 0)
10359                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10360 2CC8           8B46         04            mov	ax,4[bp]
10361 2CCB           85C0                       test	ax,ax
10362 2CCD           75           2F            jne 	.283
10363                       00002CCF            .284:
10364                                           ! 1999     {
10365                                           ! 2000       if (count == 0) {
10366                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10367 2CCF           8B46         0A            mov	ax,$A[bp]
10368 2CD2           85C0                       test	ax,ax
10369 2CD4           75           14            jne 	.285
10370                       00002CD6            .286:
10371                                           ! 2001         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10372                                           ! 2002             != 0x40 ) {
10373                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10374 2CD6           8A46         F7            mov	al,-9[bp]
10375 2CD9           24                     C9  and	al,#$C9
10376                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10377 2CDB           3C                     40  cmp	al,*$40
10378 2CDD           74           07            je  	.287
10379                       00002CDF            .288:
10380                                           ! 2003           ;
10381                                           !BCC_EOS
10382                                           ! 2004           return 4;
10383 2CDF           B8                   0004  mov	ax,*4
10384 2CE2           89EC                       mov	sp,bp
10385 2CE4           5D                         pop	bp
10386 2CE5           C3                         ret
10387                                           !BCC_EOS
10388                                           ! 2005         }
10389                                           ! 2006         break;
10390                       00002CE6            .287:
10391 2CE6           EB           46            jmp .27B
10392                                           !BCC_EOS
10393                                           ! 2007       }
10394                                           ! 2008       else {
10395 2CE8           EB           12            jmp .289
10396                       00002CEA            .285:
10397                                           ! 2009         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10398                                           ! 2010             != (0x40 | 0x08) ) {
10399                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10400 2CEA           8A46         F7            mov	al,-9[bp]
10401 2CED           24                     C9  and	al,#$C9
10402                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10403 2CEF           3C                     48  cmp	al,*$48
10404 2CF1           74           07            je  	.28A
10405                       00002CF3            .28B:
10406                                           ! 2011           ;
10407                                           !BCC_EOS
10408                                           ! 2012           return 5;
10409 2CF3           B8                   0005  mov	ax,*5
10410 2CF6           89EC                       mov	sp,bp
10411 2CF8           5D                         pop	bp
10412 2CF9           C3                         ret
10413                                           !BCC_EOS
10414                                           ! 2013         }
10415                                           ! 2014         continue;
10416                       00002CFA            .28A:
10417 2CFA           EB           2F            jmp .27C
10418                                           !BCC_EOS
10419                                           ! 2015       }
10420                                           ! 2016     }
10421                       00002CFC            .289:
10422                                           ! 2017     else
10423                                           ! 2018     {
10424 2CFC           EB           2D            jmp .28C
10425                       00002CFE            .283:
10426                                           ! 2019       if (count == 0) {
10427                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10428 2CFE           8B46         0A            mov	ax,$A[bp]
10429 2D01           85C0                       test	ax,ax
10430 2D03           75           14            jne 	.28D
10431                       00002D05            .28E:
10432                                           ! 2020         if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
10433                                           ! 2021             != 0x40 ) {
10434                                           ! Debug: and int = const $E9 to unsigned char status = [S+$E-$B] (used reg = )
10435 2D05           8A46         F7            mov	al,-9[bp]
10436 2D08           24                     E9  and	al,#$E9
10437                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10438 2D0A           3C                     40  cmp	al,*$40
10439 2D0C           74           07            je  	.28F
10440                       00002D0E            .290:
10441                                           ! 2022           ;
10442                                           !BCC_EOS
10443                                           ! 2023           return 6;
10444 2D0E           B8                   0006  mov	ax,*6
10445 2D11           89EC                       mov	sp,bp
10446 2D13           5D                         pop	bp
10447 2D14           C3                         ret
10448                                           !BCC_EOS
10449                                           ! 2024         }
10450                                           ! 2025         break;
10451                       00002D15            .28F:
10452 2D15           EB           17            jmp .27B
10453                                           !BCC_EOS
10454                                           ! 2026       }
10455                                           ! 2027       else {
10456 2D17           EB           12            jmp .291
10457                       00002D19            .28D:
10458                                           ! 2028         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10459                                           ! 2029             != (0x40 | 0x08) ) {
10460                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10461 2D19           8A46         F7            mov	al,-9[bp]
10462 2D1C           24                     C9  and	al,#$C9
10463                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10464 2D1E           3C                     48  cmp	al,*$48
10465 2D20           74           07            je  	.292
10466                       00002D22            .293:
10467                                           ! 2030           ;
10468                                           !BCC_EOS
10469                                           ! 2031           return 7;
10470 2D22           B8                   0007  mov	ax,*7
10471 2D25           89EC                       mov	sp,bp
10472 2D27           5D                         pop	bp
10473 2D28           C3                         ret
10474                                           !BCC_EOS
10475                                           ! 2032         }
10476                                           ! 2033         continue;
10477                       00002D29            .292:
10478 2D29           EB           00            jmp .27C
10479                                           !BCC_EOS
10480                                           ! 2034       }
10481                                           ! 2035     }
10482                       00002D2B            .291:
10483                                           ! 2036   }
10484                       00002D2B            .28C:
10485                                           ! 2037   outb(iobase2+6, 0x08);
10486                       00002D2B            .27C:
10487 2D2B           E9         FEEA            br 	.27D
10488                       00002D2E            .294:
10489                       00002D2E            .27B:
10490                                           ! Debug: list int = const 8 (used reg = )
10491 2D2E           B8                   0008  mov	ax,*8
10492 2D31           50                         push	ax
10493                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
10494 2D32           8B46         FC            mov	ax,-4[bp]
10495                                           ! Debug: list unsigned int = ax+6 (used reg = )
10496 2D35           05                   0006  add	ax,*6
10497 2D38           50                         push	ax
10498                                           ! Debug: func () void = outb+0 (used reg = )
10499 2D39           E8         D803            call	_outb
10500 2D3C           83C4                   04  add	sp,*4
10501                                           !BCC_EOS
10502                                           ! 2038   return 0;
10503 2D3F           31C0                       xor	ax,ax
10504 2D41           89EC                       mov	sp,bp
10505 2D43           5D                         pop	bp
10506 2D44           C3                         ret
10507                                           !BCC_EOS
10508                                           ! 2039 }
10509                                           ! 2040 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
10510                                           ! Register BX used in function ata_cmd_data_io
10511                                           ! 2041 Bit8u cmdlen,inout;
10512                                           export	_ata_cmd_packet
10513                       00002D45            _ata_cmd_packet:
10514                                           !BCC_EOS
10515                                           ! 2042 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
10516                                           !BCC_EOS
10517                                           ! 2043 Bit16u header;
10518                                           !BCC_EOS
10519                                           ! 2044 Bit32u length;
10520                                           !BCC_EOS
10521                                           ! 2045 {
10522                                           ! 2046   Bit16u ebda_seg=get_ebda_seg(), old_ds;
10523 2D45           55                         push	bp
10524 2D46           89E5                       mov	bp,sp
10525 2D48           4C                         dec	sp
10526 2D49           4C                         dec	sp
10527                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
10528 2D4A           E8         D91A            call	_get_ebda_seg
10529                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10530 2D4D           8946         FE            mov	-2[bp],ax
10531                                           !BCC_EOS
10532                                           ! 2047   Bit16u iobase1, iobase2;
10533                                           !BCC_EOS
10534                                           ! 2048   Bit16u lcount, lbefore, lafter, count;
10535                                           !BCC_EOS
10536                                           ! 2049   Bit8u channel, slave;
10537                                           !BCC_EOS
10538                                           ! 2050   Bit8u status, mode, lm
10539                                           ! 2050 ode;
10540                                           !BCC_EOS
10541                                           ! 2051   Bit32u total, transfer;
10542                                           !BCC_EOS
10543                                           ! 2052   channel = device / 2;
10544 2D50           83C4                   E4  add	sp,*-$1C
10545                                           ! Debug: div int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10546 2D53           8B46         04            mov	ax,4[bp]
10547 2D56           D1E8                       shr	ax,*1
10548                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$20-$13] (used reg = )
10549 2D58           8846         EF            mov	-$11[bp],al
10550                                           !BCC_EOS
10551                                           ! 2053   slave = device % 2;
10552                                           ! Debug: mod int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10553 2D5B           8B46         04            mov	ax,4[bp]
10554 2D5E           24                     01  and	al,*1
10555                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$20-$14] (used reg = )
10556 2D60           8846         EE            mov	-$12[bp],al
10557                                           !BCC_EOS
10558                                           ! 2054   if (inout == 0x02) {
10559                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$20+$10] (used reg = )
10560 2D63           8A46         12            mov	al,$12[bp]
10561 2D66           3C                     02  cmp	al,*2
10562 2D68           75           15            jne 	.295
10563                       00002D6A            .296:
10564                                           ! 2055     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
10565                                           ! Debug: list * char = .297+0 (used reg = )
10566 2D6A           BB                   D650  mov	bx,#.297
10567 2D6D           53                         push	bx
10568                                           ! Debug: list int = const 4 (used reg = )
10569 2D6E           B8                   0004  mov	ax,*4
10570 2D71           50                         push	ax
10571                                           ! Debug: func () void = bios_printf+0 (used reg = )
10572 2D72           E8         DBC4            call	_bios_printf
10573 2D75           83C4                   04  add	sp,*4
10574                                           !BCC_EOS
10575                                           ! 2056     return 1;
10576 2D78           B8                   0001  mov	ax,*1
10577 2D7B           89EC                       mov	sp,bp
10578 2D7D           5D                         pop	bp
10579 2D7E           C3                         ret
10580                                           !BCC_EOS
10581                                           ! 2057   }
10582                                           ! 2058   if (header & 1) {
10583                       00002D7F            .295:
10584                                           ! Debug: and int = const 1 to unsigned short header = [S+$20+$A] (used reg = )
10585 2D7F           8A46         0C            mov	al,$C[bp]
10586 2D82           24                     01  and	al,*1
10587 2D84           84C0                       test	al,al
10588 2D86           74           07            je  	.298
10589                       00002D88            .299:
10590                                           ! 2059     ;
10591                                           !BCC_EOS
10592                                           ! 2060     return 1;
10593 2D88           B8                   0001  mov	ax,*1
10594 2D8B           89EC                       mov	sp,bp
10595 2D8D           5D                         pop	bp
10596 2D8E           C3                         ret
10597                                           !BCC_EOS
10598                                           ! 2061   }
10599                                           ! 2062   old_ds = set_DS(ebda_seg);
10600                       00002D8F            .298:
10601                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
10602 2D8F           FF76         FE            push	-2[bp]
10603                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10604 2D92           E8         D8C8            call	_set_DS
10605 2D95           44                         inc	sp
10606 2D96           44                         inc	sp
10607                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$20-6] (used reg = )
10608 2D97           8946         FC            mov	-4[bp],ax
10609                                           !BCC_EOS
10610                                           ! 2063   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
10611                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10612 2D9A           8A46         EF            mov	al,-$11[bp]
10613 2D9D           30E4                       xor	ah,ah
10614 2D9F           B1                     03  mov	cl,*3
10615 2DA1           D3E0                       shl	ax,cl
10616 2DA3           89C3                       mov	bx,ax
10617                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10618                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
10619                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$20-8] (used reg = )
10620 2DA5           8B9F       0124            mov	bx,$124[bx]
10621 2DA9           895E         FA            mov	-6[bp],bx
10622                                           !BCC_EOS
10623                                           ! 2064   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
10624                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10625 2DAC           8A46         EF            mov	al,-$11[bp]
10626 2DAF           30E4                       xor	ah,ah
10627 2DB1           B1                     03  mov	cl,*3
10628 2DB3           D3E0                       shl	ax,cl
10629 2DB5           89C3                       mov	bx,ax
10630                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10631                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
10632                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$20-$A] (used reg = )
10633 2DB7           8B9F       0126            mov	bx,$126[bx]
10634 2DBB           895E         F8            mov	-8[bp],bx
10635                                           !BCC_EOS
10636                                           ! 2065   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
10637                                           ! Debug: ptradd unsigned short device = [S+$20+2] to [8] struct  = const $142 (used reg = )
10638 2DBE           8B46         04            mov	ax,4[bp]
10639 2DC1           B9                   001E  mov	cx,*$1E
10640 2DC4           F7E9                       imul	cx
10641 2DC6           89C3                       mov	bx,ax
10642                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10643                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
10644                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$20-$16] (used reg = )
10645 2DC8           8A87       0146            mov	al,$146[bx]
10646 2DCC           8846         EC            mov	-$14[bp],al
10647                                           !BCC_EOS
10648                                           ! 2066   transfer= 0L;
10649                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$20-$20] (used reg = )
10650 2DCF           31C0                       xor	ax,ax
10651 2DD1           31DB                       xor	bx,bx
10652 2DD3           8946         E2            mov	-$1E[bp],ax
10653 2DD6           895E         E4            mov	-$1C[bp],bx
10654                                           !BCC_EOS
10655                                           ! 2067   if (cmdlen < 12) cmdlen=12;
10656                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10657 2DD9           8A46         06            mov	al,6[bp]
10658 2DDC           3C                     0C  cmp	al,*$C
10659 2DDE           73           05            jae 	.29A
10660                       00002DE0            .29B:
10661                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10662 2DE0           B0                     0C  mov	al,*$C
10663 2DE2           8846         06            mov	6[bp],al
10664                                           !BCC_EOS
10665                                           ! 2068   if (cmdlen > 12) cmdlen=16;
10666                       00002DE5            .29A:
10667                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10668 2DE5           8A46         06            mov	al,6[bp]
10669 2DE8           3C                     0C  cmp	al,*$C
10670 2DEA           76           05            jbe 	.29C
10671                       00002DEC            .29D:
10672                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$20+4] (used reg = )
10673 2DEC           B0                     10  mov	al,*$10
10674 2DEE           8846         06            mov	6[bp],al
10675                                           !BCC_EOS
10676                                           ! 2069   cmdlen>>=1;
10677                       00002DF1            .29C:
10678                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$20+4] (used reg = )
10679 2DF1           8A46         06            mov	al,6[bp]
10680 2DF4           30E4                       xor	ah,ah
10681 2DF6           D1E8                       shr	ax,*1
10682 2DF8           8846         06            mov	6[bp],al
10683                                           !BCC_EOS
10684                                           ! 2070   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
10685                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
10686 2DFB           31C0                       xor	ax,ax
10687 2DFD           A3         0254            mov	[$254],ax
10688                                           !BCC_EOS
10689                                           ! 2071   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
10690                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
10691 2E00           31C0                       xor	ax,ax
10692 2E02           31DB                       xor	bx,bx
10693 2E04           A3         0256            mov	[$256],ax
10694 2E07           891E       0258            mov	[$258],bx
10695                                           !BCC_EOS
10696                                           ! 2072   set_DS(old_ds);
10697                                           ! Debug: list unsigned short old_ds = [S+$20-6] (used reg = )
10698 2E0B           FF76         FC            push	-4[bp]
10699                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10700 2E0E           E8         D84C            call	_set_DS
10701 2E11           44                         inc	sp
10702 2E12           44                         inc	sp
10703                                           !BCC_EOS
10704                                           ! 2073   status = inb(iobase1 + 7);
10705                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10706 2E13           8B46         FA            mov	ax,-6[bp]
10707                                           ! Debug: list unsigned int = ax+7 (used reg = )
10708 2E16           05                   0007  add	ax,*7
10709 2E19           50                         push	ax
10710                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10711 2E1A           E8         D70C            call	_inb
10712 2E1D           44                         inc	sp
10713 2E1E           44                         inc	sp
10714                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10715 2E1F           8846         ED            mov	-$13[bp],al
10716                                           !BCC_EOS
10717                                           ! 2074   if (status & 0x80) return 2;
10718                                           ! Debug: and int = const $80 to unsigned char status = [S+$20-$15] (used reg = )
10719 2E22           8A46         ED            mov	al,-$13[bp]
10720 2E25           24                     80  and	al,#$80
10721 2E27           84C0                       test	al,al
10722 2E29           74           07            je  	.29E
10723                       00002E2B            .29F:
10724 2E2B           B8                   0002  mov	ax,*2
10725 2E2E           89EC                       mov	sp,bp
10726 2E30           5D                         pop	bp
10727 2E31           C3                         ret
10728                                           !BCC_EOS
10729                                           ! 2075   outb(iobase2 + 6, 0x08 | 0x02);
10730                       00002E32            .29E:
10731                                           ! Debug: list int = const $A (used reg = )
10732 2E32           B8                   000A  mov	ax,*$A
10733 2E35           50                         push	ax
10734                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
10735 2E36           8B46         F8            mov	ax,-8[bp]
10736                                           ! Debug: list unsigned int = ax+6 (used reg = )
10737 2E39           05                   0006  add	ax,*6
10738 2E3C           50                         push	ax
10739                                           ! Debug: func () void = outb+0 (used reg = )
10740 2E3D           E8         D6FF            call	_outb
10741 2E40           83C4                   04  add	sp,*4
10742                                           !BCC_EOS
10743                                           ! 2076   outb(iobase1 + 1, 0x00);
10744                                           ! Debug: list int = const 0 (used reg = )
10745 2E43           31C0                       xor	ax,ax
10746 2E45           50                         push	ax
10747                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$22-8] (used reg = )
10748 2E46           8B46         FA            mov	ax,-6[bp]
10749                                           ! Debug: list unsigned int = ax+1 (used reg = )
10750 2E49           40                         inc	ax
10751 2E4A           50                         push	ax
10752                                           ! Debug: func () void = outb+0 (used reg = )
10753 2E4B           E8         D6F1            call	_outb
10754 2E4E           83C4                   04  add	sp,*4
10755                                           !BCC_EOS
10756                                           ! 2077   outb(iobase1 + 2, 0x00);
10757                                           ! Debug: list int = const 0 (used reg = )
10758 2E51           31C0                       xor	ax,ax
10759 2E53           50                         push	ax
10760                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-8] (used reg = )
10761 2E54           8B46         FA            mov	ax,-6[bp]
10762                                           ! Debug: list unsigned int = ax+2 (used reg = )
10763 2E57           40                         inc	ax
10764 2E58           40                         inc	ax
10765 2E59           50                         push	ax
10766                                           ! Debug: func () void = outb+0 (used reg = )
10767 2E5A           E8         D6E2            call	_outb
10768 2E5D           83C4                   04  add	sp,*4
10769                                           !BCC_EOS
10770                                           ! 2078   outb(iobase1 + 3, 0x00);
10771                                           ! Debug: list int = const 0 (used reg = )
10772 2E60           31C0                       xor	ax,ax
10773 2E62           50                         push	ax
10774                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$22-8] (used reg = )
10775 2E63           8B46         FA            mov	ax,-6[bp]
10776                                           ! Debug: list unsigned int = ax+3 (used reg = )
10777 2E66           05                   0003  add	ax,*3
10778 2E69           50                         push	ax
10779                                           ! Debug: func () void = outb+0 (used reg = )
10780 2E6A           E8         D6D2            call	_outb
10781 2E6D           83C4                   04  add	sp,*4
10782                                           !BCC_EOS
10783                                           ! 2079   outb(iobase1 + 4, 0xfff0 & 0x00ff);
10784                                           ! Debug: list unsigned int = const $F0 (used reg = )
10785 2E70           B8                   00F0  mov	ax,#$F0
10786 2E73           50                         push	ax
10787                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-8] (used reg = )
10788 2E74           8B46         FA            mov	ax,-6[bp]
10789                                           ! Debug: list unsigned int = ax+4 (used reg = )
10790 2E77           05                   0004  add	ax,*4
10791 2E7A           50                         push	ax
10792                                           ! Debug: func () void = outb+0 (used reg = )
10793 2E7B           E8         D6C1            call	_outb
10794 2E7E           83C4                   04  add	sp,*4
10795                                           !BCC_EOS
10796                                           ! 2080   outb(iobase1 + 5, 0xfff0 >> 8);
10797                                           ! Debug: list unsigned int = const $FF (used reg = )
10798 2E81           B8                   00FF  mov	ax,#$FF
10799 2E84           50                         push	ax
10800                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$22-8] (used reg = )
10801 2E85           8B46         FA            mov	ax,-6[bp]
10802                                           ! Debug: list unsigned int = ax+5 (used reg = )
10803 2E88           05                   0005  add	ax,*5
10804 2E8B           50                         push	ax
10805                                           ! Debug: func () void = outb+0 (used reg = )
10806 2E8C           E8         D6B0            call	_outb
10807 2E8F           83C4                   04  add	sp,*4
10808                                           !BCC_EOS
10809                                           ! 2081   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
10810 2E92           8A46         EE            mov	al,-$12[bp]
10811 2E95           84C0                       test	al,al
10812 2E97           74           04            je  	.2A0
10813                       00002E99            .2A1:
10814 2E99           B0                     B0  mov	al,#$B0
10815 2E9B           EB           02            jmp .2A2
10816                       00002E9D            .2A0:
10817 2E9D           B0                     A0  mov	al,#$A0
10818                       00002E9F            .2A2:
10819                                           ! Debug: list char = al+0 (used reg = )
10820 2E9F           30E4                       xor	ah,ah
10821 2EA1           50                         push	ax
10822                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$22-8] (used reg = )
10823 2EA2           8B46         FA            mov	ax,-6[bp]
10824                                           ! Debug: list unsigned int = ax+6 (used reg = )
10825 2EA5           05                   0006  add	ax,*6
10826 2EA8           50                         push	ax
10827                                           ! Debug: func () void = outb+0 (used reg = )
10828 2EA9           E8         D693            call	_outb
10829 2EAC           83C4                   04  add	sp,*4
10830                                           !BCC_EOS
10831                                           ! 2082   outb(iobase1 + 7, 0xA0);
10832                                           ! Debug: list int = const $A0 (used reg = )
10833 2EAF           B8                   00A0  mov	ax,#$A0
10834 2EB2           50                         push	ax
10835                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-8] (used reg = )
10836 2EB3           8B46         FA            mov	ax,-6[bp]
10837                                           ! Debug: list unsigned int = ax+7 (used reg = )
10838 2EB6           05                   0007  add	ax,*7
10839 2EB9           50                         push	ax
10840                                           ! Debug: func () void = outb+0 (used reg = )
10841 2EBA           E8         D682            call	_outb
10842 2EBD           83C4                   04  add	sp,*4
10843                                           !BCC_EOS
10844                                           ! 2083   await_ide(3, iobase1, 32000u);
10845                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10846 2EC0           B8                   7D00  mov	ax,#$7D00
10847 2EC3           50                         push	ax
10848                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10849 2EC4           FF76         FA            push	-6[bp]
10850                                           ! Debug: list int = const 3 (used reg = )
10851 2EC7           B8                   0003  mov	ax,*3
10852 2ECA           50                         push	ax
10853                                           ! Debug: func () int = await_ide+0 (used reg = )
10854 2ECB           E8         EB5C            call	_await_ide
10855 2ECE           83C4                   06  add	sp,*6
10856                                           !BCC_EOS
10857                                           ! 2084   status = inb(iobase1 + 7);
10858                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10859 2ED1           8B46         FA            mov	ax,-6[bp]
10860                                           ! Debug: list unsigned int = ax+7 (used reg = )
10861 2ED4           05                   0007  add	ax,*7
10862 2ED7           50                         push	ax
10863                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10864 2ED8           E8         D64E            call	_inb
10865 2EDB           44                         inc	sp
10866 2EDC           44                         inc	sp
10867                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10868 2EDD           8846         ED            mov	-$13[bp],al
10869                                           !BCC_EOS
10870                                           ! 2085   if (status & 0x01) {
10871                                           ! Debug: and int = const 1 to unsigned char status = [S+$20-$15] (used reg = )
10872 2EE0           8A46         ED            mov	al,-$13[bp]
10873 2EE3           24                     01  and	al,*1
10874 2EE5           84C0                       test	al,al
10875 2EE7           74           09            je  	.2A3
10876                       00002EE9            .2A4:
10877                                           ! 2086     ;
10878                                           !BCC_EOS
10879                                           ! 2087     return 3;
10880 2EE9           B8                   0003  mov	ax,*3
10881 2EEC           89EC                       mov	sp,bp
10882 2EEE           5D                         pop	bp
10883 2EEF           C3                         ret
10884                                           !BCC_EOS
10885                                           ! 2088   } else if ( !(status & 0x08) ) {
10886 2EF0           EB           10            jmp .2A5
10887                       00002EF2            .2A3:
10888                                           ! Debug: and int = const 8 to unsigned char status = [S+$20-$15] (used reg = )
10889 2EF2           8A46         ED            mov	al,-$13[bp]
10890 2EF5           24                     08  and	al,*8
10891 2EF7           84C0                       test	al,al
10892 2EF9           75           07            jne 	.2A6
10893                       00002EFB            .2A7:
10894                                           ! 2089     ;
10895                                           !BCC_EOS
10896                                           ! 2090     return 4;
10897 2EFB           B8                   0004  mov	ax,*4
10898 2EFE           89EC                       mov	sp,bp
10899 2F00           5D                         pop	bp
10900 2F01           C3                         ret
10901                                           !BCC_EOS
10902                                           ! 2091   }
10903                                           ! 2092   cmdseg += (cmdoff / 16);
10904                       00002F02            .2A6:
10905                       00002F02            .2A5:
10906                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10907 2F02           8B46         0A            mov	ax,$A[bp]
10908 2F05           B1                     04  mov	cl,*4
10909 2F07           D3E8                       shr	ax,cl
10910                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$20+6] (used reg = )
10911 2F09           0346         08            add	ax,8[bp]
10912 2F0C           8946         08            mov	8[bp],ax
10913                                           !BCC_EOS
10914                                           ! 2093   cmdoff %= 16;
10915                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10916 2F0F           8B46         0A            mov	ax,$A[bp]
10917 2F12           24                     0F  and	al,*$F
10918 2F14           30E4                       xor	ah,ah
10919 2F16           8946         0A            mov	$A[bp],ax
10920                                           !BCC_EOS
10921                                           ! 2094 #asm
10922                                           !BCC_EOS
10923                                           !BCC_ASM
10924                       00000028            _ata_cmd_packet.cmdoff	set	$28
10925                       0000000A            .ata_cmd_packet.cmdoff	set	$A
10926                       0000002A            _ata_cmd_packet.header	set	$2A
10927                       0000000C            .ata_cmd_packet.header	set	$C
10928                       0000000E            _ata_cmd_packet.count	set	$E
10929                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
10930                       00000010            _ata_cmd_packet.lafter	set	$10
10931                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
10932                       00000018            _ata_cmd_packet.iobase1	set	$18
10933                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
10934                       0000000D            _ata_cmd_packet.channel	set	$D
10935                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
10936                       00000026            _ata_cmd_packet.cmdseg	set	$26
10937                       00000008            .ata_cmd_packet.cmdseg	set	8
10938                       00000024            _ata_cmd_packet.cmdlen	set	$24
10939                       00000006            .ata_cmd_packet.cmdlen	set	6
10940                       00000009            _ata_cmd_packet.lmode	set	9
10941                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
10942                       00000022            _ata_cmd_packet.device	set	$22
10943                       00000004            .ata_cmd_packet.device	set	4
10944                       0000001C            _ata_cmd_packet.ebda_seg	set	$1C
10945                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
10946                       00000014            _ata_cmd_packet.lcount	set	$14
10947                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
10948                       00000004            _ata_cmd_packet.total	set	4
10949                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
10950                       0000000B            _ata_cmd_packet.status	set	$B
10951                       FFFFFFED            .ata_cmd_packet.status	set	-$13
10952                       0000000A            _ata_cmd_packet.mode	set	$A
10953                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
10954                       00000034            _ata_cmd_packet.bufoff	set	$34
10955                       00000016            .ata_cmd_packet.bufoff	set	$16
10956                       00000000            _ata_cmd_packet.transfer	set	0
10957                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
10958                       00000016            _ata_cmd_packet.iobase2	set	$16
10959                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
10960                       00000012            _ata_cmd_packet.lbefore	set	$12
10961                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
10962                       00000032            _ata_cmd_packet.bufseg	set	$32
10963                       00000014            .ata_cmd_packet.bufseg	set	$14
10964                       0000000C            _ata_cmd_packet.slave	set	$C
10965                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
10966                       00000030            _ata_cmd_packet.inout	set	$30
10967                       00000012            .ata_cmd_packet.inout	set	$12
10968                       0000001A            _ata_cmd_packet.old_ds	set	$1A
10969                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
10970                       0000002C            _ata_cmd_packet.length	set	$2C
10971                       0000000E            .ata_cmd_packet.length	set	$E
10972 2F19           FB                               sti ;; enable higher priority interrupts
10973 2F1A           55                               push bp
10974 2F1B           89E5                             mov bp, sp
10975 2F1D           8B76         2A                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
10976 2F20           8B46         28                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
10977 2F23           8B4E         26                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
10978 2F26           8EC0                             mov es, ax ;; segment in es
10979 2F28           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
10980 2F2B           26                               seg ES
10981 2F2C           F3                               rep
10982 2F2D           6F                                 outsw ;; CX words transferred from port(DX) to ES:[SI]
10983 2F2E           5D                               pop bp
10984                                           ! 2107 endasm
10985                                           !BCC_ENDASM
10986                                           !BCC_EOS
10987                                           ! 2108   if (inout == 0x00) {
10988                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$20+$10] (used reg = )
10989 2F2F           8A46         12            mov	al,$12[bp]
10990 2F32           84C0                       test	al,al
10991 2F34           75           23            jne 	.2A8
10992                       00002F36            .2A9:
10993                                           ! 2109     await_ide(2, iobase1, 32000u);
10994                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10995 2F36           B8                   7D00  mov	ax,#$7D00
10996 2F39           50                         push	ax
10997                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10998 2F3A           FF76         FA            push	-6[bp]
10999                                           ! Debug: list int = const 2 (used reg = )
11000 2F3D           B8                   0002  mov	ax,*2
11001 2F40           50                         push	ax
11002                                           ! Debug: func () int = await_ide+0 (used reg = )
11003 2F41           E8         EAE6            call	_await_ide
11004 2F44           83C4                   06  add	sp,*6
11005                                           !BCC_EOS
11006                                           ! 2110     status = inb(iobase1 + 7);
11007                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
11008 2F47           8B46         FA            mov	ax,-6[bp]
11009                                           ! Debug: list unsigned int = ax+7 (used reg = )
11010 2F4A           05                   0007  add	ax,*7
11011 2F4D           50                         push	ax
11012                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11013 2F4E           E8         D5D8            call	_inb
11014 2F51           44                         inc	sp
11015 2F52           44                         inc	sp
11016                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
11017 2F53           8846         ED            mov	-$13[bp],al
11018                                           !BCC_EOS
11019                                           ! 2111   }
11020                                           ! 2112   else {
11021 2F56           E9         026F            br 	.2AA
11022                       00002F59            .2A8:
11023                                           ! 2113     Bit16u loops = 0;
11024 2F59           4C                         dec	sp
11025 2F5A           4C                         dec	sp
11026                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$22-$22] (used reg = )
11027 2F5B           31C0                       xor	ax,ax
11028 2F5D           8946         E0            mov	-$20[bp],ax
11029                                           !BCC_EOS
11030                                           ! 2114     Bit8u sc;
11031                                           !BCC_EOS
11032                                           ! 2115     while (1) {
11033 2F60           4C                         dec	sp
11034 2F61           4C                         dec	sp
11035                       00002F62            .2AD:
11036                                           ! 2116       if (loops == 0) {
11037                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$24-$22] (used reg = )
11038 2F62           8B46         E0            mov	ax,-$20[bp]
11039 2F65           85C0                       test	ax,ax
11040 2F67           75           22            jne 	.2AE
11041                       00002F69            .2AF:
11042                                           ! 2117         status = inb(iobase2 + 6);
11043                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$24-$A] (used reg = )
11044 2F69           8B46         F8            mov	ax,-8[bp]
11045                                           ! Debug: list unsigned int = ax+6 (used reg = )
11046 2F6C           05                   0006  add	ax,*6
11047 2F6F           50                         push	ax
11048                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11049 2F70           E8         D5B6            call	_inb
11050 2F73           44                         inc	sp
11051 2F74           44                         inc	sp
11052                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11053 2F75           8846         ED            mov	-$13[bp],al
11054                                           !BCC_EOS
11055                                           ! 2118         await_ide(3, iobase1, 32000u);
11056                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11057 2F78           B8                   7D00  mov	ax,#$7D00
11058 2F7B           50                         push	ax
11059                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11060 2F7C           FF76         FA            push	-6[bp]
11061                                           ! Debug: list int = const 3 (used reg = )
11062 2F7F           B8                   0003  mov	ax,*3
11063 2F82           50                         push	ax
11064                                           ! Debug: func () int = await_ide+0 (used reg = )
11065 2F83           E8         EAA4            call	_await_ide
11066 2F86           83C4                   06  add	sp,*6
11067                                           !BCC_EOS
11068                                           ! 2119       }
11069                                           ! 2120       else
11070                                           ! 2121         await_ide(2, iobase1, 32000u);
11071 2F89           EB           11            jmp .2B0
11072                       00002F8B            .2AE:
11073                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11074 2F8B           B8                   7D00  mov	ax,#$7D00
11075 2F8E           50                         push	ax
11076                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11077 2F8F           FF76         FA            push	-6[bp]
11078                                           ! Debug: list int = const 2 (used reg = )
11079 2F92           B8                   0002  mov	ax,*2
11080 2F95           50                         push	ax
11081                                           ! Debug: func () int = await_ide+0 (used reg = )
11082 2F96           E8         EA91            call	_await_ide
11083 2F99           83C4                   06  add	sp,*6
11084                                           !BCC_EOS
11085                                           ! 2122       loops++;
11086                       00002F9C            .2B0:
11087                                           ! Debug: postinc unsigned short loops = [S+$24-$22] (used reg = )
11088 2F9C           8B46         E0            mov	ax,-$20[bp]
11089 2F9F           40                         inc	ax
11090 2FA0           8946         E0            mov	-$20[bp],ax
11091                                           !BCC_EOS
11092                                           ! 2123       status = inb(iobase1 + 7);
11093                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$24-8] (used reg = )
11094 2FA3           8B46         FA            mov	ax,-6[bp]
11095                                           ! Debug: list unsigned int = ax+7 (used reg = )
11096 2FA6           05                   0007  add	ax,*7
11097 2FA9           50                         push	ax
11098                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11099 2FAA           E8         D57C            call	_inb
11100 2FAD           44                         inc	sp
11101 2FAE           44                         inc	sp
11102                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11103 2FAF           8846         ED            mov	-$13[bp],al
11104                                           !BCC_EOS
11105                                           ! 2124       sc = inb(iob
11106                                           ! 2124 ase1 + 2);
11107                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11108 2FB2           8B46         FA            mov	ax,-6[bp]
11109                                           ! Debug: list unsigned int = ax+2 (used reg = )
11110 2FB5           40                         inc	ax
11111 2FB6           40                         inc	ax
11112 2FB7           50                         push	ax
11113                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11114 2FB8           E8         D56E            call	_inb
11115 2FBB           44                         inc	sp
11116 2FBC           44                         inc	sp
11117                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$24-$23] (used reg = )
11118 2FBD           8846         DF            mov	-$21[bp],al
11119                                           !BCC_EOS
11120                                           ! 2125       if(((inb(iobase1 + 2)&0x7)==0x3) &&
11121                                           ! 2126          ((status & (0x40 | 0x01)) == 0x40)) break;
11122                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11123 2FC0           8B46         FA            mov	ax,-6[bp]
11124                                           ! Debug: list unsigned int = ax+2 (used reg = )
11125 2FC3           40                         inc	ax
11126 2FC4           40                         inc	ax
11127 2FC5           50                         push	ax
11128                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11129 2FC6           E8         D560            call	_inb
11130 2FC9           44                         inc	sp
11131 2FCA           44                         inc	sp
11132                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
11133 2FCB           24                     07  and	al,*7
11134                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
11135 2FCD           3C                     03  cmp	al,*3
11136 2FCF           75           0C            jne 	.2B1
11137                       00002FD1            .2B3:
11138                                           ! Debug: and int = const $41 to unsigned char status = [S+$24-$15] (used reg = )
11139 2FD1           8A46         ED            mov	al,-$13[bp]
11140 2FD4           24                     41  and	al,*$41
11141                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
11142 2FD6           3C                     40  cmp	al,*$40
11143 2FD8           75           03            jne 	.2B1
11144                       00002FDA            .2B2:
11145 2FDA           E9         01E8            br 	.2AB
11146                                           !BCC_EOS
11147                                           ! 2127       if (status & 0x01) {
11148                       00002FDD            .2B1:
11149                                           ! Debug: and int = const 1 to unsigned char status = [S+$24-$15] (used reg = )
11150 2FDD           8A46         ED            mov	al,-$13[bp]
11151 2FE0           24                     01  and	al,*1
11152 2FE2           84C0                       test	al,al
11153 2FE4           74           07            je  	.2B4
11154                       00002FE6            .2B5:
11155                                           ! 2128         ;
11156                                           !BCC_EOS
11157                                           ! 2129         return 3;
11158 2FE6           B8                   0003  mov	ax,*3
11159 2FE9           89EC                       mov	sp,bp
11160 2FEB           5D                         pop	bp
11161 2FEC           C3                         ret
11162                                           !BCC_EOS
11163                                           ! 2130       }
11164                                           ! 2131       bufseg += (bufoff / 16);
11165                       00002FED            .2B4:
11166                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11167 2FED           8B46         16            mov	ax,$16[bp]
11168 2FF0           B1                     04  mov	cl,*4
11169 2FF2           D3E8                       shr	ax,cl
11170                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$24+$12] (used reg = )
11171 2FF4           0346         14            add	ax,$14[bp]
11172 2FF7           8946         14            mov	$14[bp],ax
11173                                           !BCC_EOS
11174                                           ! 2132       bufoff %= 16;
11175                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11176 2FFA           8B46         16            mov	ax,$16[bp]
11177 2FFD           24                     0F  and	al,*$F
11178 2FFF           30E4                       xor	ah,ah
11179 3001           8946         16            mov	$16[bp],ax
11180                                           !BCC_EOS
11181                                           ! 2133       *((Bit8u *)&lcount) = inb(iobase1 + 4);
11182                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$24-8] (used reg = )
11183 3004           8B46         FA            mov	ax,-6[bp]
11184                                           ! Debug: list unsigned int = ax+4 (used reg = )
11185 3007           05                   0004  add	ax,*4
11186 300A           50                         push	ax
11187                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11188 300B           E8         D51B            call	_inb
11189 300E           44                         inc	sp
11190 300F           44                         inc	sp
11191                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$C] (used reg = )
11192 3010           8846         F6            mov	-$A[bp],al
11193                                           !BCC_EOS
11194                                           ! 2134       *(((Bit8u *)&lcount)+1) = inb(iobase1 + 5);
11195                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-8] (used reg = )
11196 3013           8B46         FA            mov	ax,-6[bp]
11197                                           ! Debug: list unsigned int = ax+5 (used reg = )
11198 3016           05                   0005  add	ax,*5
11199 3019           50                         push	ax
11200                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11201 301A           E8         D50C            call	_inb
11202 301D           44                         inc	sp
11203 301E           44                         inc	sp
11204                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$B] (used reg = )
11205 301F           8846         F7            mov	-9[bp],al
11206                                           !BCC_EOS
11207                                           ! 2135       if(header>lcount) {
11208                                           ! Debug: gt unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11209 3022           8B46         0C            mov	ax,$C[bp]
11210 3025           3B46         F6            cmp	ax,-$A[bp]
11211 3028           76           16            jbe 	.2B6
11212                       0000302A            .2B7:
11213                                           ! 2136          lbefore=lcount;
11214                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short lbefore = [S+$24-$E] (used reg = )
11215 302A           8B46         F6            mov	ax,-$A[bp]
11216 302D           8946         F4            mov	-$C[bp],ax
11217                                           !BCC_EOS
11218                                           ! 2137          header-=lcount;
11219                                           ! Debug: subab unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11220 3030           8B46         0C            mov	ax,$C[bp]
11221 3033           2B46         F6            sub	ax,-$A[bp]
11222 3036           8946         0C            mov	$C[bp],ax
11223                                           !BCC_EOS
11224                                           ! 2138          lcount=0;
11225                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11226 3039           31C0                       xor	ax,ax
11227 303B           8946         F6            mov	-$A[bp],ax
11228                                           !BCC_EOS
11229                                           ! 2139       }
11230                                           ! 2140       else {
11231 303E           EB           14            jmp .2B8
11232                       00003040            .2B6:
11233                                           ! 2141         lbefore=header;
11234                                           ! Debug: eq unsigned short header = [S+$24+$A] to unsigned short lbefore = [S+$24-$E] (used reg = )
11235 3040           8B46         0C            mov	ax,$C[bp]
11236 3043           8946         F4            mov	-$C[bp],ax
11237                                           !BCC_EOS
11238                                           ! 2142         header=0;
11239                                           ! Debug: eq int = const 0 to unsigned short header = [S+$24+$A] (used reg = )
11240 3046           31C0                       xor	ax,ax
11241 3048           8946         0C            mov	$C[bp],ax
11242                                           !BCC_EOS
11243                                           ! 2143         lcount-=lbefore;
11244                                           ! Debug: subab unsigned short lbefore = [S+$24-$E] to unsigned short lcount = [S+$24-$C] (used reg = )
11245 304B           8B46         F6            mov	ax,-$A[bp]
11246 304E           2B46         F4            sub	ax,-$C[bp]
11247 3051           8946         F6            mov	-$A[bp],ax
11248                                           !BCC_EOS
11249                                           ! 2144       }
11250                                           ! 2145       if(lcount>length) {
11251                       00003054            .2B8:
11252                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11253 3054           8B46         F6            mov	ax,-$A[bp]
11254 3057           31DB                       xor	bx,bx
11255                                           ! Debug: gt unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11256 3059           8D7E         0E            lea	di,$E[bp]
11257 305C           E8         D03D            call	lcmpul
11258 305F           76           20            jbe 	.2B9
11259                       00003061            .2BA:
11260                                           ! 2146         lafter=lcount-length;
11261                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11262 3061           8B46         F6            mov	ax,-$A[bp]
11263 3064           31DB                       xor	bx,bx
11264                                           ! Debug: sub unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11265 3066           8D7E         0E            lea	di,$E[bp]
11266 3069           E8         D046            call	lsubul
11267                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$24-$10] (used reg = )
11268 306C           8946         F2            mov	-$E[bp],ax
11269                                           !BCC_EOS
11270                                           ! 2147         lcount=length;
11271                                           ! Debug: eq unsigned long length = [S+$24+$C] to unsigned short lcount = [S+$24-$C] (used reg = )
11272 306F           8B46         0E            mov	ax,$E[bp]
11273 3072           8946         F6            mov	-$A[bp],ax
11274                                           !BCC_EOS
11275                                           ! 2148         length=0;
11276                                           ! Debug: eq int = const 0 to unsigned long length = [S+$24+$C] (used reg = )
11277 3075           31C0                       xor	ax,ax
11278 3077           31DB                       xor	bx,bx
11279 3079           8946         0E            mov	$E[bp],ax
11280 307C           895E         10            mov	$10[bp],bx
11281                                           !BCC_EOS
11282                                           ! 2149       }
11283                                           ! 2150       else {
11284 307F           EB           21            jmp .2BB
11285                       00003081            .2B9:
11286                                           ! 2151         lafter=0;
11287                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11288 3081           31C0                       xor	ax,ax
11289 3083           8946         F2            mov	-$E[bp],ax
11290                                           !BCC_EOS
11291                                           ! 2152         length-=lcount;
11292                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11293 3086           8B46         F6            mov	ax,-$A[bp]
11294 3089           31DB                       xor	bx,bx
11295                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$24+$C] (used reg = )
11296 308B           53                         push	bx
11297 308C           50                         push	ax
11298 308D           8B46         0E            mov	ax,$E[bp]
11299 3090           8B5E         10            mov	bx,$10[bp]
11300 3093           8D7E         DA            lea	di,-$26[bp]
11301 3096           E8         D019            call	lsubul
11302 3099           8946         0E            mov	$E[bp],ax
11303 309C           895E         10            mov	$10[bp],bx
11304 309F           83C4                   04  add	sp,*4
11305                                           !BCC_EOS
11306                                           ! 2153       }
11307                                           ! 2154       count = lcount;
11308                       000030A2            .2BB:
11309                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short count = [S+$24-$12] (used reg = )
11310 30A2           8B46         F6            mov	ax,-$A[bp]
11311 30A5           8946         F0            mov	-$10[bp],ax
11312                                           !BCC_EOS
11313                                           ! 2155       ;
11314                                           !BCC_EOS
11315                                           ! 2156       ;
11316                                           !BCC_EOS
11317                                           ! 2157       lmode = mode;
11318                                           ! Debug: eq unsigned char mode = [S+$24-$16] to unsigned char lmode = [S+$24-$17] (used reg = )
11319 30A8           8A46         EC            mov	al,-$14[bp]
11320 30AB           8846         EB            mov	-$15[bp],al
11321                                           !BCC_EOS
11322                                           ! 2158       if (lbefore & 0x03) lmode=0x00;
11323                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$24-$E] (used reg = )
11324 30AE           8A46         F4            mov	al,-$C[bp]
11325 30B1           24                     03  and	al,*3
11326 30B3           84C0                       test	al,al
11327 30B5           74           05            je  	.2BC
11328                       000030B7            .2BD:
11329                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11330 30B7           30C0                       xor	al,al
11331 30B9           8846         EB            mov	-$15[bp],al
11332                                           !BCC_EOS
11333                                           ! 2159       if (lcount & 0x03) lmode=0x00;
11334                       000030BC            .2BC:
11335                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$24-$C] (used reg = )
11336 30BC           8A46         F6            mov	al,-$A[bp]
11337 30BF           24                     03  and	al,*3
11338 30C1           84C0                       test	al,al
11339 30C3           74           05            je  	.2BE
11340                       000030C5            .2BF:
11341                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11342 30C5           30C0                       xor	al,al
11343 30C7           8846         EB            mov	-$15[bp],al
11344                                           !BCC_EOS
11345                                           ! 2160       if (lafter & 0x03) lmode=0x00;
11346                       000030CA            .2BE:
11347                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$24-$10] (used reg = )
11348 30CA           8A46         F2            mov	al,-$E[bp]
11349 30CD           24                     03  and	al,*3
11350 30CF           84C0                       test	al,al
11351 30D1           74           05            je  	.2C0
11352                       000030D3            .2C1:
11353                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11354 30D3           30C0                       xor	al,al
11355 30D5           8846         EB            mov	-$15[bp],al
11356                                           !BCC_EOS
11357                                           ! 2161       if (lcount & 0x01) {
11358                       000030D8            .2C0:
11359                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11360 30D8           8A46         F6            mov	al,-$A[bp]
11361 30DB           24                     01  and	al,*1
11362 30DD           84C0                       test	al,al
11363 30DF           74           1E            je  	.2C2
11364                       000030E1            .2C3:
11365                                           ! 2162         lcount+=1;
11366                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11367 30E1           8B46         F6            mov	ax,-$A[bp]
11368 30E4           40                         inc	ax
11369 30E5           8946         F6            mov	-$A[bp],ax
11370                                           !BCC_EOS
11371                                           ! 2163         if ((lafter > 0) && (lafter & 0x01)) {
11372                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11373 30E8           8B46         F2            mov	ax,-$E[bp]
11374 30EB           85C0                       test	ax,ax
11375 30ED           74           10            je  	.2C4
11376                       000030EF            .2C6:
11377                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11378 30EF           8A46         F2            mov	al,-$E[bp]
11379 30F2           24                     01  and	al,*1
11380 30F4           84C0                       test	al,al
11381 30F6           74           07            je  	.2C4
11382                       000030F8            .2C5:
11383                                           ! 2164           lafter-=1;
11384                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11385 30F8           8B46         F2            mov	ax,-$E[bp]
11386 30FB           48                         dec	ax
11387 30FC           8946         F2            mov	-$E[bp],ax
11388                                           !BCC_EOS
11389                                           ! 2165         }
11390                                           ! 2166       }
11391                       000030FF            .2C4:
11392                                           ! 2167       if (lmode == 0x01) {
11393                       000030FF            .2C2:
11394                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$24-$17] (used reg = )
11395 30FF           8A46         EB            mov	al,-$15[bp]
11396 3102           3C                     01  cmp	al,*1
11397 3104           75           20            jne 	.2C7
11398                       00003106            .2C8:
11399                                           ! 2168         lcount>>=2; lbefore>>=2; lafter>>=2;
11400                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$24-$C] (used reg = )
11401 3106           8B46         F6            mov	ax,-$A[bp]
11402 3109           D1E8                       shr	ax,*1
11403 310B           D1E8                       shr	ax,*1
11404 310D           8946         F6            mov	-$A[bp],ax
11405                                           !BCC_EOS
11406                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$24-$E] (used reg = )
11407 3110           8B46         F4            mov	ax,-$C[bp]
11408 3113           D1E8                       shr	ax,*1
11409 3115           D1E8                       shr	ax,*1
11410 3117           8946         F4            mov	-$C[bp],ax
11411                                           !BCC_EOS
11412                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$24-$10] (used reg = )
11413 311A           8B46         F2            mov	ax,-$E[bp]
11414 311D           D1E8                       shr	ax,*1
11415 311F           D1E8                       shr	ax,*1
11416 3121           8946         F2            mov	-$E[bp],ax
11417                                           !BCC_EOS
11418                                           ! 2169       }
11419                                           ! 2170       else {
11420 3124           EB           18            jmp .2C9
11421                       00003126            .2C7:
11422                                           ! 2171         lcount>>=1; lbefore>>=1; lafter>>=1;
11423                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11424 3126           8B46         F6            mov	ax,-$A[bp]
11425 3129           D1E8                       shr	ax,*1
11426 312B           8946         F6            mov	-$A[bp],ax
11427                                           !BCC_EOS
11428                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$24-$E] (used reg = )
11429 312E           8B46         F4            mov	ax,-$C[bp]
11430 3131           D1E8                       shr	ax,*1
11431 3133           8946         F4            mov	-$C[bp],ax
11432                                           !BCC_EOS
11433                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11434 3136           8B46         F2            mov	ax,-$E[bp]
11435 3139           D1E8                       shr	ax,*1
11436 313B           8946         F2            mov	-$E[bp],ax
11437                                           !BCC_EOS
11438                                           ! 2172       }
11439                                           ! 2173        ;
11440                       0000313E            .2C9:
11441                                           !BCC_EOS
11442                                           ! 2174 #asm
11443                                           !BCC_EOS
11444                                           !BCC_ASM
11445                       0000002C            _ata_cmd_packet.cmdoff	set	$2C
11446                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11447                       0000002E            _ata_cmd_packet.header	set	$2E
11448                       0000000C            .ata_cmd_packet.header	set	$C
11449                       00000012            _ata_cmd_packet.count	set	$12
11450                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
11451                       00000014            _ata_cmd_packet.lafter	set	$14
11452                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
11453                       0000001C            _ata_cmd_packet.iobase1	set	$1C
11454                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
11455                       00000011            _ata_cmd_packet.channel	set	$11
11456                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
11457                       0000002A            _ata_cmd_packet.cmdseg	set	$2A
11458                       00000008            .ata_cmd_packet.cmdseg	set	8
11459                       00000028            _ata_cmd_packet.cmdlen	set	$28
11460                       00000006            .ata_cmd_packet.cmdlen	set	6
11461                       0000000D            _ata_cmd_packet.lmode	set	$D
11462                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11463                       00000026            _ata_cmd_packet.device	set	$26
11464                       00000004            .ata_cmd_packet.device	set	4
11465                       00000002            _ata_cmd_packet.loops	set	2
11466                       FFFFFFE0            .ata_cmd_packet.loops	set	-$20
11467                       00000020            _ata_cmd_packet.ebda_seg	set	$20
11468                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11469                       00000018            _ata_cmd_packet.lcount	set	$18
11470                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11471                       00000008            _ata_cmd_packet.total	set	8
11472                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11473                       0000000F            _ata_cmd_packet.status	set	$F
11474                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11475                       0000000E            _ata_cmd_packet.mode	set	$E
11476                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11477                       00000038            _ata_cmd_packet.bufoff	set	$38
11478                       00000016            .ata_cmd_packet.bufoff	set	$16
11479                       00000004            _ata_cmd_packet.transfer	set	4
11480                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11481                       00000001            _ata_cmd_packet.sc	set	1
11482                       FFFFFFDF            .ata_cmd_packet.sc	set	-$21
11483                       0000001A            _ata_cmd_packet.iobase2	set	$1A
11484                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11485                       00000016            _ata_cmd_packet.lbefore	set	$16
11486                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11487                       00000036            _ata_cmd_packet.bufseg	set	$36
11488                       00000014            .ata_cmd_packet.bufseg	set	$14
11489                       00000010            _ata_cmd_packet.slave	set	$10
11490                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11491                       00000034            _ata_cmd_packet.inout	set	$34
11492                       00000012            .ata_cmd_packet.inout	set	$12
11493                       0000001E            _ata_cmd_packet.old_ds	set	$1E
11494                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11495                       00000030            _ata_cmd_packet.length	set	$30
11496                       0000000E            .ata_cmd_packet.length	set	$E
11497 313E           55                                 push bp
11498 313F           89E5                               mov bp, sp
11499 3141           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
11500 3144           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
11501 3147           E3           15                    jcxz ata_packet_no_before
11502 3149           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11503 314C           80FC                   01          cmp ah, #0x01
11504 314F           74           05                    je ata_packet_in_before_32
11505                       00003151            ata_packet_in_before_16:
11506 3151           ED                                 in ax, dx
11507 3152           E2           FD                    loop ata_packet_in_before_16
11508 3154           EB           08                    jmp ata_packet_no_before
11509                       00003156            ata_packet_in_before_32:
11510 3156     66    50                                 push eax
11511                       00003158            ata_packet_in_before_32_loop:
11512 3158     66    ED                                 in eax, dx
11513 315A           E2           FC                    loop ata_packet_in_before_32_loop
11514 315C     66    58                                 pop eax
11515                       0000315E            ata_packet_no_before:
11516 315E           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
11517 3161           E3           17                    jcxz ata_packet_after
11518 3163           8B7E         3A                    mov di, _ata_cmd_packet.bufoff + 2[bp]
11519 3166           8B46         38                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
11520 3169           8EC0                               mov es, ax
11521 316B           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11522 316E           80FC                   01          cmp ah, #0x01
11523 3171           74           04                    je ata_packet_in_32
11524                       00003173            ata_packet_in_16:
11525 3173           F3                                 rep
11526 3174           6D                                   insw ;; CX words transferred to port(DX) to ES:[DI]
11527 3175           EB           03                    jmp ata_packet_after
11528                       00003177            ata_packet_in_32:
11529 3177           F3                                 rep
11530 3178     66    6D                                   insd ;; CX dwords transferred to port(DX) to ES:[DI]
11531                       0000317A            ata_packet_after:
11532 317A           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
11533 317D           E3           15                    jcxz ata_packet_done
11534 317F           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11535 3182           80FC                   01          cmp ah, #0x01
11536 3185           74           05                    je ata_packet_in_after_32
11537                       00003187            ata_packet_in_after_16:
11538 3187           ED                                 in ax, dx
11539 3188           E2           FD                    loop ata_packet_in_after_16
11540 318A           EB           08                    jmp ata_packet_done
11541                       0000318C            ata_packet_in_after_32:
11542 318C     66    50                                 push eax
11543                       0000318E            ata_packet_in_after_32_loop:
11544 318E     66    ED                                 in eax, dx
11545 3190           E2           FC                    loop ata_packet_in_after_32_loop
11546 3192     66    58                                 pop eax
11547                       00003194            ata_packet_done:
11548 3194           5D                                 pop bp
11549                                           ! 2227 endasm
11550                                           !BCC_ENDASM
11551                                           !BCC_EOS
11552                                           ! 2228       bufoff += count;
11553                                           ! Debug: addab unsigned short count = [S+$24-$12] to unsigned short bufoff = [S+$24+$14] (used reg = )
11554 3195           8B46         16            mov	ax,$16[bp]
11555 3198           0346         F0            add	ax,-$10[bp]
11556 319B           8946         16            mov	$16[bp],ax
11557                                           !BCC_EOS
11558                                           ! 2229       transfer += count;
11559                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$24-$12] (used reg = )
11560 319E           8B46         F0            mov	ax,-$10[bp]
11561 31A1           31DB                       xor	bx,bx
11562                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$24-$20] (used reg = )
11563 31A3           8D7E         E2            lea	di,-$1E[bp]
11564 31A6           E8         CEEB            call	laddul
11565 31A9           8946         E2            mov	-$1E[bp],ax
11566 31AC           895E         E4            mov	-$1C[bp],bx
11567                                           !BCC_EOS
11568                                           ! 2230       _write_dword(transfer, &((ebda_data_t *) 0)->ata.trsfbytes, ebda_seg);
11569                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11570 31AF           FF76         FE            push	-2[bp]
11571                                           ! Debug: list * unsigned long = const $256 (used reg = )
11572 31B2           B8                   0256  mov	ax,#$256
11573 31B5           50                         push	ax
11574                                           ! Debug: list unsigned long transfer = [S+$28-$20] (used reg = )
11575 31B6           FF76         E4            push	-$1C[bp]
11576 31B9           FF76         E2            push	-$1E[bp]
11577                                           ! Debug: func () void = _write_dword+0 (used reg = )
11578 31BC           E8         CEA8            call	__write_dword
11579 31BF           83C4                   08  add	sp,*8
11580                                           !BCC_EOS
11581                                           ! 2231     }
11582                                           ! 2232   }
11583                       000031C2            .2AC:
11584 31C2           E9         FD9D            br 	.2AD
11585                       000031C5            .2CA:
11586                       000031C5            .2AB:
11587 31C5           83C4                   04  add	sp,*4
11588                                           ! 2233   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11589                       000031C8            .2AA:
11590                                           ! 2234          != 0x40 ) {
11591                                           ! Debug: and int = const $E9 to unsigned char status = [S+$20-$15] (used reg = )
11592 31C8           8A46         ED            mov	al,-$13[bp]
11593 31CB           24                     E9  and	al,#$E9
11594                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11595 31CD           3C                     40  cmp	al,*$40
11596 31CF           74           07            je  	.2CB
11597                       000031D1            .2CC:
11598                                           ! 2235     ;
11599                                           !BCC_EOS
11600                                           ! 2236     return 4;
11601 31D1           B8                   0004  mov	ax,*4
11602 31D4           89EC                       mov	sp,bp
11603 31D6           5D                         pop	bp
11604 31D7           C3                         ret
11605                                           !BCC_EOS
11606                                           ! 2237   }
11607                                           ! 2238   outb(iobase2+6, 0x08);
11608                       000031D8            .2CB:
11609                                           ! Debug: list int = const 8 (used reg = )
11610 31D8           B8                   0008  mov	ax,*8
11611 31DB           50                         push	ax
11612                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
11613 31DC           8B46         F8            mov	ax,-8[bp]
11614                                           ! Debug: list unsigned int = ax+6 (used reg = )
11615 31DF           05                   0006  add	ax,*6
11616 31E2           50                         push	ax
11617                                           ! Debug: func () void = outb+0 (used reg = )
11618 31E3           E8         D359            call	_outb
11619 31E6           83C4                   04  add	sp,*4
11620                                           !BCC_EOS
11621                                           ! 2239   return 0;
11622 31E9           31C0                       xor	ax,ax
11623 31EB           89EC                       mov	sp,bp
11624 31ED           5D                         pop	bp
11625 31EE           C3                         ret
11626                                           !BCC_EOS
11627                                           ! 2240 }
11628                                           ! 2241   Bit16u
11629                                           ! Register BX used in function ata_cmd_packet
11630                                           ! 2242 atapi_get_sense(device, seg, asc, ascq)
11631                                           ! 2243   Bit16u device;
11632                                           export	_atapi_get_sense
11633                       000031EF            _atapi_get_sense:
11634                                           !BCC_EOS
11635                                           ! 2244 {
11636                                           ! 2245   Bit8u atacmd[12];
11637                                           !BCC_EOS
11638                                           ! 2246   Bit8u buffer[18];
11639                                           !BCC_EOS
11640                                           ! 2247   Bit8u i;
11641                                           !BCC_EOS
11642                                           ! 2248   _memsetb(0,atacmd,get_SS(),12);
11643 31EF           55                         push	bp
11644 31F0           89E5                       mov	bp,sp
11645 31F2           83C4                   E0  add	sp,*-$20
11646                                           ! Debug: list int = const $C (used reg = )
11647 31F5           B8                   000C  mov	ax,*$C
11648 31F8           50                         push	ax
11649                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11650 31F9           E8         D45E            call	_get_SS
11651                                           ! Debug: list unsigned short = ax+0 (used reg = )
11652 31FC           50                         push	ax
11653                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
11654 31FD           8D5E         F4            lea	bx,-$C[bp]
11655 3200           53                         push	bx
11656                                           ! Debug: list int = const 0 (used reg = )
11657 3201           31C0                       xor	ax,ax
11658 3203           50                         push	ax
11659                                           ! Debug: func () void = _memsetb+0 (used reg = )
11660 3204           E8         CDF9            call	__memsetb
11661 3207           83C4                   08  add	sp,*8
11662                                           !BCC_EOS
11663                                           ! 2249   atacmd[0]=0x03;
11664                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
11665 320A           B0                     03  mov	al,*3
11666 320C           8846         F4            mov	-$C[bp],al
11667                                           !BCC_EOS
11668                                           ! 2250   atacmd[4]=sizeof(buffer);
11669                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
11670 320F           B0                     12  mov	al,*$12
11671 3211           8846         F8            mov	-8[bp],al
11672                                           !BCC_EOS
11673                                           ! 2251   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
11674                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
11675 3214           8D5E         E2            lea	bx,-$1E[bp]
11676 3217           53                         push	bx
11677                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11678 3218           E8         D43F            call	_get_SS
11679                                           ! Debug: list unsigned short = ax+0 (used reg = )
11680 321B           50                         push	ax
11681                                           ! Debug: list int = const 1 (used reg = )
11682 321C           B8                   0001  mov	ax,*1
11683 321F           50                         push	ax
11684                                           ! Debug: list long = const $12 (used reg = )
11685 3220           B8                   0012  mov	ax,*$12
11686 3223           31DB                       xor	bx,bx
11687 3225           53                         push	bx
11688 3226           50                         push	ax
11689                                           ! Debug: list int = const 0 (used reg = )
11690 3227           31C0                       xor	ax,ax
11691 3229           50                         push	ax
11692                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
11693 322A           8D5E         F4            lea	bx,-$C[bp]
11694 322D           53                         push	bx
11695                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11696 322E           E8         D429            call	_get_SS
11697                                           ! Debug: list unsigned short = ax+0 (used reg = )
11698 3231           50                         push	ax
11699                                           ! Debug: list int = const $C (used reg = )
11700 3232           B8                   000C  mov	ax,*$C
11701 3235           50                         push	ax
11702                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
11703 3236           FF76         04            push	4[bp]
11704                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11705 3239           E8         FB09            call	_ata_cmd_packet
11706 323C           83C4                   14  add	sp,*$14
11707                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
11708 323F           85C0                       test	ax,ax
11709 3241           74           07            je  	.2CD
11710                       00003243            .2CE:
11711                                           ! 2252     return 0x0002;
11712 3243           B8                   0002  mov	ax,*2
11713 3246           89EC                       mov	sp,bp
11714 3248           5D                         pop	bp
11715 3249           C3                         ret
11716                                           !BCC_EOS
11717                                           ! 2253   _write_byte(buffer[12], asc, seg);
11718                       0000324A            .2CD:
11719                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11720 324A           FF76         06            push	6[bp]
11721                                           ! Debug: list int asc = [S+$24+6] (used reg = )
11722 324D           FF76         08            push	8[bp]
11723                                           ! Debug: list unsigned char buffer = [S+$26-$14] (used reg = )
11724 3250           8A46         EE            mov	al,-$12[bp]
11725 3253           30E4                       xor	ah,ah
11726 3255           50                         push	ax
11727                                           ! Debug: func () void = _write_byte+0 (used reg = )
11728 3256           E8         D3A2            call	__write_byte
11729 3259           83C4                   06  add	sp,*6
11730                                           !BCC_EOS
11731                                           ! 2254   _write_byte(buffer[13], ascq, seg);
11732                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11733 325C           FF76         06            push	6[bp]
11734                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
11735 325F           FF76         0A            push	$A[bp]
11736                                           ! Debug: list unsigned char buffer = [S+$26-$13] (used reg = )
11737 3262           8A46         EF            mov	al,-$11[bp]
11738 3265           30E4                       xor	ah,ah
11739 3267           50                         push	ax
11740                                           ! Debug: func () void = _write_byte+0 (used reg = )
11741 3268           E8         D390            call	__write_byte
11742 326B           83C4                   06  add	sp,*6
11743                                           !BCC_EOS
11744                                           ! 2255   return 0;
11745 326E           31C0                       xor	ax,ax
11746 3270           89EC                       mov	sp,bp
11747 3272           5D                         pop	bp
11748 3273           C3                         ret
11749                                           !BCC_EOS
11750                                           ! 2256 }
11751                                           ! 2257   Bit16u
11752                                           ! Register BX used in function atapi_get_sense
11753                                           ! 2258 atapi_is_ready(device)
11754                                           ! 2259   Bit16u device;
11755                                           export	_atapi_is_ready
11756                       00003274            _atapi_is_ready:
11757                                           !BCC_EOS
11758                                           ! 2260 {
11759                                           ! 2261   Bit8u packet[12];
11760                                           !BCC_EOS
11761                                           ! 2262   Bit8u buf[8];
11762                                           !BCC_EOS
11763                                           ! 2263   Bit32u block_len;
11764                                           !BCC_EOS
11765                                           ! 2264   Bit32u sectors;
11766                                           !BCC_EOS
11767                                           ! 2265   Bit32u timeout;
11768                                           !BCC_EOS
11769                                           ! 2266   Bit32u time;
11770                                           !BCC_EOS
11771                                           ! 2267   Bit8u asc, ascq;
11772                                           !BCC_EOS
11773                                           ! 2268   Bit8u in_progress;
11774                                           !BCC_EOS
11775                                           ! 2269   Bit16u ebda_seg = get_ebda_seg();
11776 3274           55                         push	bp
11777 3275           89E5                       mov	bp,sp
11778 3277           83C4                   D6  add	sp,*-$2A
11779                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
11780 327A           E8         D3EA            call	_get_ebda_seg
11781                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11782 327D           8946         D6            mov	-$2A[bp],ax
11783                                           !BCC_EOS
11784                                           ! 2270   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03) {
11785                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11786 3280           FF76         D6            push	-$2A[bp]
11787                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
11788 3283           8B46         04            mov	ax,4[bp]
11789 3286           B9                   001E  mov	cx,*$1E
11790 3289           F7E9                       imul	cx
11791 328B           89C3                       mov	bx,ax
11792                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
11793                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
11794 328D           81C3                 0142  add	bx,#$142
11795 3291           53                         push	bx
11796                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
11797 3292           E8         D34A            call	__read_byte
11798 3295           83C4                   04  add	sp,*4
11799                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
11800 3298           3C                     03  cmp	al,*3
11801 329A           74           15            je  	.2CF
11802                       0000329C            .2D0:
11803                                           ! 2271     bios_printf(2, "not implemented for non-ATAPI device\n");
11804                                           ! Debug: list * char = .2D1+0 (used reg = )
11805 329C           BB                   D62A  mov	bx,#.2D1
11806 329F           53                         push	bx
11807                                           ! Debug: list int = const 2 (used reg = )
11808 32A0           B8                   0002  mov	ax,*2
11809 32A3           50                         push	ax
11810                                           ! Debug: func () void = bios_printf+0 (used reg = )
11811 32A4           E8         D692            call	_bios_printf
11812 32A7           83C4                   04  add	sp,*4
11813                                           !BCC_EOS
11814                                           ! 2272     return -1;
11815 32AA           B8                   FFFF  mov	ax,#$FFFF
11816 32AD           89EC                       mov	sp,bp
11817 32AF           5D                         pop	bp
11818 32B0           C3                         ret
11819                                           !BCC_EOS
11820                                           ! 2273   }
11821                                           ! 2274   ;
11822                       000032B1            .2CF:
11823                                           !BCC_EOS
11824                                           ! 2275   _memsetb(0,packet,get_SS(),sizeof packet);
11825                                           ! Debug: list int = const $C (used reg = )
11826 32B1           B8                   000C  mov	ax,*$C
11827 32B4           50                         push	ax
11828                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11829 32B5           E8         D3A2            call	_get_SS
11830                                           ! Debug: list unsigned short = ax+0 (used reg = )
11831 32B8           50                         push	ax
11832                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
11833 32B9           8D5E         F4            lea	bx,-$C[bp]
11834 32BC           53                         push	bx
11835                                           ! Debug: list int = const 0 (used reg = )
11836 32BD           31C0                       xor	ax,ax
11837 32BF           50                         push	ax
11838                                           ! Debug: func () void = _memsetb+0 (used reg = )
11839 32C0           E8         CD3D            call	__memsetb
11840 32C3           83C4                   08  add	sp,*8
11841                                           !BCC_EOS
11842                                           ! 2276   packet[0] = 0x25;
11843                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
11844 32C6           B0                     25  mov	al,*$25
11845 32C8           8846         F4            mov	-$C[bp],al
11846                                           !BCC_EOS
11847                                           ! 2277   timeout = 5000;
11848                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
11849 32CB           B8                   1388  mov	ax,#$1388
11850 32CE           31DB                       xor	bx,bx
11851 32D0           8946         E0            mov	-$20[bp],ax
11852 32D3           895E         E2            mov	-$1E[bp],bx
11853                                           !BCC_EOS
11854                                           ! 2278   time = 0;
11855                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
11856 32D6           31C0                       xor	ax,ax
11857 32D8           31DB                       xor	bx,bx
11858 32DA           8946         DC            mov	-$24[bp],ax
11859 32DD           895E         DE            mov	-$22[bp],bx
11860                                           !BCC_EOS
11861                                           ! 2279   in_progress = 0;
11862                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11863 32E0           30C0                       xor	al,al
11864 32E2           8846         D9            mov	-$27[bp],al
11865                                           !BCC_EOS
11866                                           ! 2280   while (time < timeout) {
11867 32E5           E9         00AB            br 	.2D3
11868                       000032E8            .2D4:
11869                                           ! 2281     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
11870                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
11871 32E8           8D5E         EC            lea	bx,-$14[bp]
11872 32EB           53                         push	bx
11873                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11874 32EC           E8         D36B            call	_get_SS
11875                                           ! Debug: list unsigned short = ax+0 (used reg = )
11876 32EF           50                         push	ax
11877                                           ! Debug: list int = const 1 (used reg = )
11878 32F0           B8                   0001  mov	ax,*1
11879 32F3           50                         push	ax
11880                                           ! Debug: list long = const 8 (used reg = )
11881 32F4           B8                   0008  mov	ax,*8
11882 32F7           31DB                       xor	bx,bx
11883 32F9           53                         push	bx
11884 32FA           50                         push	ax
11885                                           ! Debug: list int = const 0 (used reg = )
11886 32FB           31C0                       xor	ax,ax
11887 32FD           50                         push	ax
11888                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
11889 32FE           8D5E         F4            lea	bx,-$C[bp]
11890 3301           53                         push	bx
11891                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11892 3302           E8         D355            call	_get_SS
11893                                           ! Debug: list unsigned short = ax+0 (used reg = )
11894 3305           50                         push	ax
11895                                           ! Debug: list int = const $C (used reg = )
11896 3306           B8                   000C  mov	ax,*$C
11897 3309           50                         push	ax
11898                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
11899 330A           FF76         04            push	4[bp]
11900                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11901 330D           E8         FA35            call	_ata_cmd_packet
11902 3310           83C4                   14  add	sp,*$14
11903                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11904 3313           85C0                       test	ax,ax
11905 3315           75           06            jne 	.2D5
11906                       00003317            .2D6:
11907                                           ! 2282       goto ok;
11908 3317           83C4                   00  add	sp,#..FFFA+$2C
11909 331A           E9         008D            br 	.FFFA
11910                                           !BCC_EOS
11911                                           ! 2283     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
11912                       0000331D            .2D5:
11913                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
11914 331D           8D5E         DA            lea	bx,-$26[bp]
11915 3320           53                         push	bx
11916                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
11917 3321           8D5E         DB            lea	bx,-$25[bp]
11918 3324           53                         push	bx
11919                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11920 3325           E8         D332            call	_get_SS
11921                                           ! Debug: list unsigned short = ax+0 (used reg = )
11922 3328           50                         push	ax
11923                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
11924 3329           FF76         04            push	4[bp]
11925                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
11926 332C           E8         FEC0            call	_atapi_get_sense
11927 332F           83C4                   08  add	sp,*8
11928                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11929 3332           85C0                       test	ax,ax
11930 3334           75           41            jne 	.2D7
11931                       00003336            .2D8:
11932                                           ! 2284       
11933                                           ! 2284 if (asc == 0x3a) {
11934                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
11935 3336           8A46         DB            mov	al,-$25[bp]
11936 3339           3C                     3A  cmp	al,*$3A
11937 333B           75           07            jne 	.2D9
11938                       0000333D            .2DA:
11939                                           ! 2285         ;
11940                                           !BCC_EOS
11941                                           ! 2286         return -1;
11942 333D           B8                   FFFF  mov	ax,#$FFFF
11943 3340           89EC                       mov	sp,bp
11944 3342           5D                         pop	bp
11945 3343           C3                         ret
11946                                           !BCC_EOS
11947                                           ! 2287       }
11948                                           ! 2288       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
11949                       00003344            .2D9:
11950                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
11951 3344           8A46         DB            mov	al,-$25[bp]
11952 3347           3C                     04  cmp	al,*4
11953 3349           75           2C            jne 	.2DB
11954                       0000334B            .2DE:
11955                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
11956 334B           8A46         DA            mov	al,-$26[bp]
11957 334E           3C                     01  cmp	al,*1
11958 3350           75           25            jne 	.2DB
11959                       00003352            .2DD:
11960 3352           8A46         D9            mov	al,-$27[bp]
11961 3355           84C0                       test	al,al
11962 3357           75           1E            jne 	.2DB
11963                       00003359            .2DC:
11964                                           ! 2289         bios_printf(2, "Waiting for device to detect medium... ");
11965                                           ! Debug: list * char = .2DF+0 (used reg = )
11966 3359           BB                   D602  mov	bx,#.2DF
11967 335C           53                         push	bx
11968                                           ! Debug: list int = const 2 (used reg = )
11969 335D           B8                   0002  mov	ax,*2
11970 3360           50                         push	ax
11971                                           ! Debug: func () void = bios_printf+0 (used reg = )
11972 3361           E8         D5D5            call	_bios_printf
11973 3364           83C4                   04  add	sp,*4
11974                                           !BCC_EOS
11975                                           ! 2290         timeout = 30000;
11976                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
11977 3367           B8                   7530  mov	ax,#$7530
11978 336A           31DB                       xor	bx,bx
11979 336C           8946         E0            mov	-$20[bp],ax
11980 336F           895E         E2            mov	-$1E[bp],bx
11981                                           !BCC_EOS
11982                                           ! 2291         in_progress = 1;
11983                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11984 3372           B0                     01  mov	al,*1
11985 3374           8846         D9            mov	-$27[bp],al
11986                                           !BCC_EOS
11987                                           ! 2292       }
11988                                           ! 2293     }
11989                       00003377            .2DB:
11990                                           ! 2294     time += 100;
11991                       00003377            .2D7:
11992                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
11993 3377           B8                   0064  mov	ax,*$64
11994 337A           31DB                       xor	bx,bx
11995 337C           53                         push	bx
11996 337D           50                         push	ax
11997 337E           8B46         DC            mov	ax,-$24[bp]
11998 3381           8B5E         DE            mov	bx,-$22[bp]
11999 3384           8D7E         D2            lea	di,-$2E[bp]
12000 3387           E8         CD0A            call	laddul
12001 338A           8946         DC            mov	-$24[bp],ax
12002 338D           895E         DE            mov	-$22[bp],bx
12003 3390           83C4                   04  add	sp,*4
12004                                           !BCC_EOS
12005                                           ! 2295   }
12006                                           ! 2296   ;
12007                       00003393            .2D3:
12008                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
12009 3393           8B46         E0            mov	ax,-$20[bp]
12010 3396           8B5E         E2            mov	bx,-$1E[bp]
12011 3399           8D7E         DC            lea	di,-$24[bp]
12012 339C           E8         CCFD            call	lcmpul
12013 339F         0F87         FF45            bhi 	.2D4
12014                       000033A3            .2E0:
12015                       000033A3            .2D2:
12016                                           !BCC_EOS
12017                                           ! 2297   return -1;
12018 33A3           B8                   FFFF  mov	ax,#$FFFF
12019 33A6           89EC                       mov	sp,bp
12020 33A8           5D                         pop	bp
12021 33A9           C3                         ret
12022                                           !BCC_EOS
12023                                           ! 2298 ok:
12024                       000033AA            .FFFA:
12025                       FFFFFFD4            ..FFFA	=	-$2C
12026                                           ! 2299   *(((Bit8u *)&*(((Bit16u *)&block_len)+1))+1) = buf[4];
12027                                           ! Debug: eq unsigned char buf = [S+$2C-$12] to unsigned char block_len = [S+$2C-$17] (used reg = )
12028 33AA           8A46         F0            mov	al,-$10[bp]
12029 33AD           8846         EB            mov	-$15[bp],al
12030                                           !BCC_EOS
12031                                           ! 2300   *((Bit8u *)&*(((Bit16u *)&block_len)+1)) = buf[5];
12032                                           ! Debug: eq unsigned char buf = [S+$2C-$11] to unsigned char block_len = [S+$2C-$18] (used reg = )
12033 33B0           8A46         F1            mov	al,-$F[bp]
12034 33B3           8846         EA            mov	-$16[bp],al
12035                                           !BCC_EOS
12036                                           ! 2301   *(((Bit8u *)&*((Bit16u *)&block_len))+1) = buf[6];
12037                                           ! Debug: eq unsigned char buf = [S+$2C-$10] to unsigned char block_len = [S+$2C-$19] (used reg = )
12038 33B6           8A46         F2            mov	al,-$E[bp]
12039 33B9           8846         E9            mov	-$17[bp],al
12040                                           !BCC_EOS
12041                                           ! 2302   *((Bit8u *)&block_len) = buf[7];
12042                                           ! Debug: eq unsigned char buf = [S+$2C-$F] to unsigned char block_len = [S+$2C-$1A] (used reg = )
12043 33BC           8A46         F3            mov	al,-$D[bp]
12044 33BF           8846         E8            mov	-$18[bp],al
12045                                           !BCC_EOS
12046                                           ! 2303   ;
12047                                           !BCC_EOS
12048                                           ! 2304   if (block_len!= 2048 && block_len!= 512)
12049                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12050                                           ! Debug: expression subtree swapping
12051 33C2           B8                   0800  mov	ax,#$800
12052 33C5           31DB                       xor	bx,bx
12053 33C7           53                         push	bx
12054 33C8           50                         push	ax
12055 33C9           8B46         E8            mov	ax,-$18[bp]
12056 33CC           8B5E         EA            mov	bx,-$16[bp]
12057 33CF           8D7E         D2            lea	di,-$2E[bp]
12058 33D2           E8         CCC7            call	lcmpul
12059 33D5           8D66         D6            lea	sp,-$2A[bp]
12060 33D8           74           33            je  	.2E1
12061                       000033DA            .2E3:
12062                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12063                                           ! Debug: expression subtree swapping
12064 33DA           B8                   0200  mov	ax,#$200
12065 33DD           31DB                       xor	bx,bx
12066 33DF           53                         push	bx
12067 33E0           50                         push	ax
12068 33E1           8B46         E8            mov	ax,-$18[bp]
12069 33E4           8B5E         EA            mov	bx,-$16[bp]
12070 33E7           8D7E         D2            lea	di,-$2E[bp]
12071 33EA           E8         CCAF            call	lcmpul
12072 33ED           8D66         D6            lea	sp,-$2A[bp]
12073 33F0           74           1B            je  	.2E1
12074                       000033F2            .2E2:
12075                                           ! 2305   {
12076                                           ! 2306     bios_printf(2, "Unsupported sector size %u\n", block_len);
12077                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
12078 33F2           FF76         EA            push	-$16[bp]
12079 33F5           FF76         E8            push	-$18[bp]
12080                                           ! Debug: list * char = .2E4+0 (used reg = )
12081 33F8           BB                   D5E6  mov	bx,#.2E4
12082 33FB           53                         push	bx
12083                                           ! Debug: list int = const 2 (used reg = )
12084 33FC           B8                   0002  mov	ax,*2
12085 33FF           50                         push	ax
12086                                           ! Debug: func () void = bios_printf+0 (used reg = )
12087 3400           E8         D536            call	_bios_printf
12088 3403           83C4                   08  add	sp,*8
12089                                           !BCC_EOS
12090                                           ! 2307     return -1;
12091 3406           B8                   FFFF  mov	ax,#$FFFF
12092 3409           89EC                       mov	sp,bp
12093 340B           5D                         pop	bp
12094 340C           C3                         ret
12095                                           !BCC_EOS
12096                                           ! 2308   }
12097                                           ! 2309   _write_dword(block_len, &((ebda_data_t *) 0)->ata.devices[device].blksize, ebda_seg);
12098                       0000340D            .2E1:
12099                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12100 340D           FF76         D6            push	-$2A[bp]
12101                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12102 3410           8B46         04            mov	ax,4[bp]
12103 3413           B9                   001E  mov	cx,*$1E
12104 3416           F7E9                       imul	cx
12105 3418           89C3                       mov	bx,ax
12106                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
12107                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
12108 341A           81C3                 0148  add	bx,#$148
12109 341E           53                         push	bx
12110                                           ! Debug: list unsigned long block_len = [S+$30-$1A] (used reg = )
12111 341F           FF76         EA            push	-$16[bp]
12112 3422           FF76         E8            push	-$18[bp]
12113                                           ! Debug: func () void = _write_dword+0 (used reg = )
12114 3425           E8         CC3F            call	__write_dword
12115 3428           83C4                   08  add	sp,*8
12116                                           !BCC_EOS
12117                                           ! 2310   *(((Bit8u *)&*(((Bit16u *)&sectors)+1))+1) = buf[0];
12118                                           ! Debug: eq unsigned char buf = [S+$2C-$16] to unsigned char sectors = [S+$2C-$1B] (used reg = )
12119 342B           8A46         EC            mov	al,-$14[bp]
12120 342E           8846         E7            mov	-$19[bp],al
12121                                           !BCC_EOS
12122                                           ! 2311   *((Bit8u *)&*(((Bit16u *)&sectors)+1)) = buf[1];
12123                                           ! Debug: eq unsigned char buf = [S+$2C-$15] to unsigned char sectors = [S+$2C-$1C] (used reg = )
12124 3431           8A46         ED            mov	al,-$13[bp]
12125 3434           8846         E6            mov	-$1A[bp],al
12126                                           !BCC_EOS
12127                                           ! 2312   *(((Bit8u *)&*((Bit16u *)&sectors))+1) = buf[2];
12128                                           ! Debug: eq unsigned char buf = [S+$2C-$14] to unsigned char sectors = [S+$2C-$1D] (used reg = )
12129 3437           8A46         EE            mov	al,-$12[bp]
12130 343A           8846         E5            mov	-$1B[bp],al
12131                                           !BCC_EOS
12132                                           ! 2313   *((Bit8u *)&sectors) = buf[3];
12133                                           ! Debug: eq unsigned char buf = [S+$2C-$13] to unsigned char sectors = [S+$2C-$1E] (used reg = )
12134 343D           8A46         EF            mov	al,-$11[bp]
12135 3440           8846         E4            mov	-$1C[bp],al
12136                                           !BCC_EOS
12137                                           ! 2314   ;
12138                                           !BCC_EOS
12139                                           ! 2315   if (block_len == 2048)
12140                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12141                                           ! Debug: expression subtree swapping
12142 3443           B8                   0800  mov	ax,#$800
12143 3446           31DB                       xor	bx,bx
12144 3448           53                         push	bx
12145 3449           50                         push	ax
12146 344A           8B46         E8            mov	ax,-$18[bp]
12147 344D           8B5E         EA            mov	bx,-$16[bp]
12148 3450           8D7E         D2            lea	di,-$2E[bp]
12149 3453           E8         CC46            call	lcmpul
12150 3456           8D66         D6            lea	sp,-$2A[bp]
12151 3459           75           12            jne 	.2E5
12152                       0000345B            .2E6:
12153                                           ! 2316     sectors <<= 2;
12154                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12155 345B           8B46         E4            mov	ax,-$1C[bp]
12156 345E           8B5E         E6            mov	bx,-$1A[bp]
12157 3461           BF                   0002  mov	di,*2
12158 3464           E8         CCB1            call	lslul
12159 3467           8946         E4            mov	-$1C[bp],ax
12160 346A           895E         E6            mov	-$1A[bp],bx
12161                                           !BCC_EOS
12162                                           ! 2317   if (sectors != _read_dword(&((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg))
12163                       0000346D            .2E5:
12164                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12165 346D           FF76         D6            push	-$2A[bp]
12166                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12167 3470           8B46         04            mov	ax,4[bp]
12168 3473           B9                   001E  mov	cx,*$1E
12169 3476           F7E9                       imul	cx
12170 3478           89C3                       mov	bx,ax
12171                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12172                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12173 347A           81C3                 0158  add	bx,#$158
12174 347E           53                         push	bx
12175                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
12176 347F           E8         CBD4            call	__read_dword
12177 3482           89D3                       mov	bx,dx
12178 3484           83C4                   04  add	sp,*4
12179                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12180                                           ! Debug: expression subtree swapping
12181 3487           8D7E         E4            lea	di,-$1C[bp]
12182 348A           E8         CC0F            call	lcmpul
12183 348D           74           24            je  	.2E7
12184                       0000348F            .2E8:
12185                                           ! 2318     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
12186                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
12187 348F           8B46         E4            mov	ax,-$1C[bp]
12188 3492           8B5E         E6            mov	bx,-$1A[bp]
12189 3495           88E0                       mov	al,ah
12190 3497           88DC                       mov	ah,bl
12191 3499           88FB                       mov	bl,bh
12192 349B           28FF                       sub	bh,bh
12193 349D           BF                   0003  mov	di,*3
12194 34A0           E8         CC57            call	lsrul
12195                                           ! Debug: list unsigned long = bx+0 (used reg = )
12196 34A3           53                         push	bx
12197 34A4           50                         push	ax
12198                                           ! Debug: list * char = .2E9+0 (used reg = )
12199 34A5           BB                   D5D0  mov	bx,#.2E9
12200 34A8           53                         push	bx
12201                                           ! Debug: list int = const 2 (used reg = )
12202 34A9           B8                   0002  mov	ax,*2
12203 34AC           50                         push	ax
12204                                           ! Debug: func () void = bios_printf+0 (used reg = )
12205 34AD           E8         D489            call	_bios_printf
12206 34B0           83C4                   08  add	sp,*8
12207                                           !BCC_EOS
12208                                           ! 2319   _write_dword(sectors, &((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg);
12209                       000034B3            .2E7:
12210                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12211 34B3           FF76         D6            push	-$2A[bp]
12212                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12213 34B6           8B46         04            mov	ax,4[bp]
12214 34B9           B9                   001E  mov	cx,*$1E
12215 34BC           F7E9                       imul	cx
12216 34BE           89C3                       mov	bx,ax
12217                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12218                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12219 34C0           81C3                 0158  add	bx,#$158
12220 34C4           53                         push	bx
12221                                           ! Debug: list unsigned long sectors = [S+$30-$1E] (used reg = )
12222 34C5           FF76         E6            push	-$1A[bp]
12223 34C8           FF76         E4            push	-$1C[bp]
12224                                           ! Debug: func () void = _write_dword+0 (used reg = )
12225 34CB           E8         CB99            call	__write_dword
12226 34CE           83C4                   08  add	sp,*8
12227                                           !BCC_EOS
12228                                           ! 2320   return 0;
12229 34D1           31C0                       xor	ax,ax
12230 34D3           89EC                       mov	sp,bp
12231 34D5           5D                         pop	bp
12232 34D6           C3                         ret
12233                                           !BCC_EOS
12234                                           ! 2321 }
12235                                           ! 2322   Bit16u
12236                                           ! Register BX used in function atapi_is_ready
12237                                           ! 2323 atapi_is_cdrom(device)
12238                                           ! 2324   Bit8u device;
12239                                           export	_atapi_is_cdrom
12240                       000034D7            _atapi_is_cdrom:
12241                                           !BCC_EOS
12242                                           ! 2325 {
12243                                           ! 2326   Bit16u ebda_seg=get_ebda_seg();
12244 34D7           55                         push	bp
12245 34D8           89E5                       mov	bp,sp
12246 34DA           4C                         dec	sp
12247 34DB           4C                         dec	sp
12248                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12249 34DC           E8         D188            call	_get_ebda_seg
12250                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12251 34DF           8946         FE            mov	-2[bp],ax
12252                                           !BCC_EOS
12253                                           ! 2327   if (device >= (4*2))
12254                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
12255 34E2           8A46         04            mov	al,4[bp]
12256 34E5           3C                     08  cmp	al,*8
12257 34E7           72           06            jb  	.2EA
12258                       000034E9            .2EB:
12259                                           ! 2328     return 0;
12260 34E9           31C0                       xor	ax,ax
12261 34EB           89EC                       mov	sp,bp
12262 34ED           5D                         pop	bp
12263 34EE           C3                         ret
12264                                           !BCC_EOS
12265                                           ! 2329   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03)
12266                       000034EF            .2EA:
12267                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12268 34EF           FF76         FE            push	-2[bp]
12269                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12270 34F2           8A46         04            mov	al,4[bp]
12271 34F5           30E4                       xor	ah,ah
12272 34F7           B9                   001E  mov	cx,*$1E
12273 34FA           F7E9                       imul	cx
12274 34FC           89C3                       mov	bx,ax
12275                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
12276                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
12277 34FE           81C3                 0142  add	bx,#$142
12278 3502           53                         push	bx
12279                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12280 3503           E8         D0D9            call	__read_byte
12281 3506           83C4                   04  add	sp,*4
12282                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
12283 3509           3C                     03  cmp	al,*3
12284 350B           74           06            je  	.2EC
12285                       0000350D            .2ED:
12286                                           ! 2330     return 0;
12287 350D           31C0                       xor	ax,ax
12288 350F           89EC                       mov	sp,bp
12289 3511           5D                         pop	bp
12290 3512           C3                         ret
12291                                           !BCC_EOS
12292                                           ! 2331   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].device, ebda_seg) != 0x05)
12293                       00003513            .2EC:
12294                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12295 3513           FF76         FE            push	-2[bp]
12296                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12297 3516           8A46         04            mov	al,4[bp]
12298 3519           30E4                       xor	ah,ah
12299 351B           B9                   001E  mov	cx,*$1E
12300 351E           F7E9                       imul	cx
12301 3520           89C3                       mov	bx,ax
12302                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
12303                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
12304 3522           81C3                 0143  add	bx,#$143
12305 3526           53                         push	bx
12306                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12307 3527           E8         D0B5            call	__read_byte
12308 352A           83C4                   04  add	sp,*4
12309                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
12310 352D           3C                     05  cmp	al,*5
12311 352F           74           06            je  	.2EE
12312                       00003531            .2EF:
12313                                           ! 2332     return 0;
12314 3531           31C0                       xor	ax,ax
12315 3533           89EC                       mov	sp,bp
12316 3535           5D                         pop	bp
12317 3536           C3                         ret
12318                                           !BCC_EOS
12319                                           ! 2333   return 1;
12320                       00003537            .2EE:
12321 3537           B8                   0001  mov	ax,*1
12322 353A           89EC                       mov	sp,bp
12323 353C           5D                         pop	bp
12324 353D           C3                         ret
12325                                           !BCC_EOS
12326                                           ! 2334 }
12327                                           ! 2335   void
12328                                           ! Register BX used in function atapi_is_cdrom
12329                                           ! 2336 cdemu_init()
12330                                           ! 2337 {
12331                                           export	_cdemu_init
12332                       0000353E            _cdemu_init:
12333                                           ! 2338   Bit16u ebda_seg=get_ebda_seg();
12334 353E           55                         push	bp
12335 353F           89E5                       mov	bp,sp
12336 3541           4C                         dec	sp
12337 3542           4C                         dec	sp
12338                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12339 3543           E8         D121            call	_get_ebda_seg
12340                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12341 3546           8946         FE            mov	-2[bp],ax
12342                                           !BCC_EOS
12343                                           ! 2339   _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
12344                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12345 3549           FF76         FE            push	-2[bp]
12346                                           ! Debug: list * unsigned char = const $25A (used reg = )
12347 354C           B8                   025A  mov	ax,#$25A
12348 354F           50                         push	ax
12349                                           ! Debug: list int = const 0 (used reg = )
12350 3550           31C0                       xor	ax,ax
12351 3552           50                         push	ax
12352                                           ! Debug: func () void = _write_byte+0 (used reg = )
12353 3553           E8         D0A5            call	__write_byte
12354 3556           83C4                   06  add	sp,*6
12355                                           !BCC_EOS
12356                                           ! 2340 }
12357 3559           89EC                       mov	sp,bp
12358 355B           5D                         pop	bp
12359 355C           C3                         ret
12360                                           ! 2341   Bit8u
12361                                           ! 2342 cdemu_isactive()
12362                                           ! 2343 {
12363                                           export	_cdemu_isactive
12364                       0000355D            _cdemu_isactive:
12365                                           ! 2344   Bit16u ebda_seg=get_ebda_seg();
12366 355D           55                         push	bp
12367 355E           89E5                       mov	bp,sp
12368 3560           4C                         dec	sp
12369 3561           4C                         dec	sp
12370                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12371 3562           E8         D102            call	_get_ebda_seg
12372                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12373 3565           8946         FE            mov	-2[bp],ax
12374                                           !BCC_EOS
12375                                           ! 2345   return(_read_byte(&((ebda_data_t *) 0)->cdemu.active, ebda_seg));
12376                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12377 3568           FF76         FE            push	-2[bp]
12378                                           ! Debug: list * unsigned char = const $25A (used reg = )
12379 356B           B8                   025A  mov	ax,#$25A
12380 356E           50                         push	ax
12381                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12382 356F           E8         D06D            call	__read_byte
12383 3572           83C4                   04  add	sp,*4
12384                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12385 3575           89EC                       mov	sp,bp
12386 3577           5D                         pop	bp
12387 3578           C3                         ret
12388                                           !BCC_EOS
12389                                           ! 2346 }
12390                                           ! 2347   Bit8u
12391                                           ! 2348 cdemu_emulated_drive()
12392                                           ! 2349 {
12393                                           export	_cdemu_emulated_drive
12394                       00003579            _cdemu_emulated_drive:
12395                                           ! 2350   Bit16u ebda_seg=get_ebda_seg();
12396 3579           55                         push	bp
12397 357A           89E5                       mov	bp,sp
12398 357C           4C                         dec	sp
12399 357D           4C                         dec	sp
12400                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12401 357E           E8         D0E6            call	_get_ebda_seg
12402                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12403 3581           8946         FE            mov	-2[bp],ax
12404                                           !BCC_EOS
12405                                           ! 2351   return(_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
12406                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12407 3584           FF76         FE            push	-2[bp]
12408                                           ! Debug: list * unsigned char = const $25C (used reg = )
12409 3587           B8                   025C  mov	ax,#$25C
12410 358A           50                         push	ax
12411                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12412 358B           E8         D051            call	__read_byte
12413 358E           83C4                   04  add	sp,*4
12414                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12415 3591           89EC                       mov	sp,bp
12416 3593           5D                         pop	bp
12417 3594           C3                         ret
12418                                           !BCC_EOS
12419                                           ! 2352 }
12420                                           ! 2353 static char isotag[6]="CD001";
12421                                           
12422                       00003595            _isotag:
12423                       00003595            .2F0:
12424 3595                        43            .ascii	"CD001"
12425 359A                        00            .byte	0
12426                                           !BCC_EOS
12427                                           ! 2354 static char eltorito[24]="EL TORITO SPECIFICATION";
12428                       0000359B            _eltorito:
12429                       0000359B            .2F1:
12430 359B                        45            .ascii	"EL TORITO SPECIFICATION"
12431 35B2                        00            .byte	0
12432                                           !BCC_EOS
12433                                           ! 2355   Bit16u
12434                                           ! 2356 cdrom_boot()
12435                                           ! 2357 {
12436                                           
12437                                           export	_cdrom_boot
12438                       000035B3            _cdrom_boot:
12439                                           ! 2358   
12440                                           ! 2358 Bit16u ebda_seg=get_ebda_seg(), old_ds;
12441 35B3           55                         push	bp
12442 35B4           89E5                       mov	bp,sp
12443 35B6           4C                         dec	sp
12444 35B7           4C                         dec	sp
12445                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12446 35B8           E8         D0AC            call	_get_ebda_seg
12447                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12448 35BB           8946         FE            mov	-2[bp],ax
12449                                           !BCC_EOS
12450                                           ! 2359   Bit8u atacmd[12], buffer[2048];
12451                                           !BCC_EOS
12452                                           ! 2360   Bit32u lba;
12453                                           !BCC_EOS
12454                                           ! 2361   Bit16u boot_segment, nbsectors, i, error;
12455                                           !BCC_EOS
12456                                           ! 2362   Bit8u device;
12457                                           !BCC_EOS
12458                                           ! 2363   for (device=0; device<(4*2);device++) {
12459 35BE           81C4                 F7E4  add	sp,#-$81C
12460                                           ! Debug: eq int = const 0 to unsigned char device = [S+$820-$81F] (used reg = )
12461 35C2           30C0                       xor	al,al
12462 35C4           8886       F7E3            mov	-$81D[bp],al
12463                                           !BCC_EOS
12464                                           !BCC_EOS
12465 35C8           EB           1B            jmp .2F4
12466                       000035CA            .2F5:
12467                                           ! 2364     if (atapi_is_cdrom(device)) break;
12468                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12469 35CA           8A86       F7E3            mov	al,-$81D[bp]
12470 35CE           30E4                       xor	ah,ah
12471 35D0           50                         push	ax
12472                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
12473 35D1           E8         FF03            call	_atapi_is_cdrom
12474 35D4           44                         inc	sp
12475 35D5           44                         inc	sp
12476 35D6           85C0                       test	ax,ax
12477 35D8           74           02            je  	.2F6
12478                       000035DA            .2F7:
12479 35DA           EB           11            jmp .2F2
12480                                           !BCC_EOS
12481                                           ! 2365   }
12482                       000035DC            .2F6:
12483                                           ! 2366   if(device >= (4*2)) return 2;
12484                       000035DC            .2F3:
12485                                           ! Debug: postinc unsigned char device = [S+$820-$81F] (used reg = )
12486 35DC           8A86       F7E3            mov	al,-$81D[bp]
12487 35E0           40                         inc	ax
12488 35E1           8886       F7E3            mov	-$81D[bp],al
12489                       000035E5            .2F4:
12490                                           ! Debug: lt int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12491 35E5           8A86       F7E3            mov	al,-$81D[bp]
12492 35E9           3C                     08  cmp	al,*8
12493 35EB           72           DD            jb 	.2F5
12494                       000035ED            .2F8:
12495                       000035ED            .2F2:
12496                                           ! Debug: ge int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12497 35ED           8A86       F7E3            mov	al,-$81D[bp]
12498 35F1           3C                     08  cmp	al,*8
12499 35F3           72           07            jb  	.2F9
12500                       000035F5            .2FA:
12501 35F5           B8                   0002  mov	ax,*2
12502 35F8           89EC                       mov	sp,bp
12503 35FA           5D                         pop	bp
12504 35FB           C3                         ret
12505                                           !BCC_EOS
12506                                           ! 2367   if(error = atapi_is_ready(device) != 0)
12507                       000035FC            .2F9:
12508                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12509 35FC           8A86       F7E3            mov	al,-$81D[bp]
12510 3600           30E4                       xor	ah,ah
12511 3602           50                         push	ax
12512                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
12513 3603           E8         FC6E            call	_atapi_is_ready
12514 3606           44                         inc	sp
12515 3607           44                         inc	sp
12516                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12517 3608           85C0                       test	ax,ax
12518 360A           74           04            je 	.2FD
12519 360C           B0                     01  mov	al,*1
12520 360E           EB           02            jmp	.2FE
12521                       00003610            .2FD:
12522 3610           30C0                       xor	al,al
12523                       00003612            .2FE:
12524                                           ! Debug: eq char = al+0 to unsigned short error = [S+$820-$81E] (used reg = )
12525 3612           30E4                       xor	ah,ah
12526 3614           8986       F7E4            mov	-$81C[bp],ax
12527 3618           85C0                       test	ax,ax
12528 361A           74           12            je  	.2FB
12529                       0000361C            .2FC:
12530                                           ! 2368     bios_printf(4, "ata_is_ready returned %d\n",error);
12531                                           ! Debug: list unsigned short error = [S+$820-$81E] (used reg = )
12532 361C           FFB6       F7E4            push	-$81C[bp]
12533                                           ! Debug: list * char = .2FF+0 (used reg = )
12534 3620           BB                   D5B6  mov	bx,#.2FF
12535 3623           53                         push	bx
12536                                           ! Debug: list int = const 4 (used reg = )
12537 3624           B8                   0004  mov	ax,*4
12538 3627           50                         push	ax
12539                                           ! Debug: func () void = bios_printf+0 (used reg = )
12540 3628           E8         D30E            call	_bios_printf
12541 362B           83C4                   06  add	sp,*6
12542                                           !BCC_EOS
12543                                           ! 2369   _memsetb(0,atacmd,get_SS(),12);
12544                       0000362E            .2FB:
12545                                           ! Debug: list int = const $C (used reg = )
12546 362E           B8                   000C  mov	ax,*$C
12547 3631           50                         push	ax
12548                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12549 3632           E8         D025            call	_get_SS
12550                                           ! Debug: list unsigned short = ax+0 (used reg = )
12551 3635           50                         push	ax
12552                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12553 3636           8D5E         F0            lea	bx,-$10[bp]
12554 3639           53                         push	bx
12555                                           ! Debug: list int = const 0 (used reg = )
12556 363A           31C0                       xor	ax,ax
12557 363C           50                         push	ax
12558                                           ! Debug: func () void = _memsetb+0 (used reg = )
12559 363D           E8         C9C0            call	__memsetb
12560 3640           83C4                   08  add	sp,*8
12561                                           !BCC_EOS
12562                                           ! 2370   atacmd[0]=0x28;
12563                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12564 3643           B0                     28  mov	al,*$28
12565 3645           8846         F0            mov	-$10[bp],al
12566                                           !BCC_EOS
12567                                           ! 2371   atacmd[7]=(0x01 & 0xff00) >> 8;
12568                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12569 3648           30C0                       xor	al,al
12570 364A           8846         F7            mov	-9[bp],al
12571                                           !BCC_EOS
12572                                           ! 2372   atacmd[8]=(0x01 & 0x00ff);
12573                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12574 364D           B0                     01  mov	al,*1
12575 364F           8846         F8            mov	-8[bp],al
12576                                           !BCC_EOS
12577                                           ! 2373   atacmd[2]=(0x11 & 0xff000000) >> 24;
12578                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$820-$10] (used reg = )
12579 3652           30C0                       xor	al,al
12580 3654           8846         F2            mov	-$E[bp],al
12581                                           !BCC_EOS
12582                                           ! 2374   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
12583                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$820-$F] (used reg = )
12584 3657           30C0                       xor	al,al
12585 3659           8846         F3            mov	-$D[bp],al
12586                                           !BCC_EOS
12587                                           ! 2375   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
12588                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$E] (used reg = )
12589 365C           30C0                       xor	al,al
12590 365E           8846         F4            mov	-$C[bp],al
12591                                           !BCC_EOS
12592                                           ! 2376   atacmd[5]=(0x11 & 0x000000ff);
12593                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$820-$D] (used reg = )
12594 3661           B0                     11  mov	al,*$11
12595 3663           8846         F5            mov	-$B[bp],al
12596                                           !BCC_EOS
12597                                           ! 2377   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12598                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12599 3666           8D9E       F7F0            lea	bx,-$810[bp]
12600 366A           53                         push	bx
12601                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12602 366B           E8         CFEC            call	_get_SS
12603                                           ! Debug: list unsigned short = ax+0 (used reg = )
12604 366E           50                         push	ax
12605                                           ! Debug: list int = const 1 (used reg = )
12606 366F           B8                   0001  mov	ax,*1
12607 3672           50                         push	ax
12608                                           ! Debug: list long = const $800 (used reg = )
12609 3673           B8                   0800  mov	ax,#$800
12610 3676           31DB                       xor	bx,bx
12611 3678           53                         push	bx
12612 3679           50                         push	ax
12613                                           ! Debug: list int = const 0 (used reg = )
12614 367A           31C0                       xor	ax,ax
12615 367C           50                         push	ax
12616                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12617 367D           8D5E         F0            lea	bx,-$10[bp]
12618 3680           53                         push	bx
12619                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12620 3681           E8         CFD6            call	_get_SS
12621                                           ! Debug: list unsigned short = ax+0 (used reg = )
12622 3684           50                         push	ax
12623                                           ! Debug: list int = const $C (used reg = )
12624 3685           B8                   000C  mov	ax,*$C
12625 3688           50                         push	ax
12626                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12627 3689           8A86       F7E3            mov	al,-$81D[bp]
12628 368D           30E4                       xor	ah,ah
12629 368F           50                         push	ax
12630                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12631 3690           E8         F6B2            call	_ata_cmd_packet
12632 3693           83C4                   14  add	sp,*$14
12633                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12634 3696           8986       F7E4            mov	-$81C[bp],ax
12635                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12636 369A           85C0                       test	ax,ax
12637 369C           74           07            je  	.300
12638                       0000369E            .301:
12639                                           ! 2378     return 3;
12640 369E           B8                   0003  mov	ax,*3
12641 36A1           89EC                       mov	sp,bp
12642 36A3           5D                         pop	bp
12643 36A4           C3                         ret
12644                                           !BCC_EOS
12645                                           ! 2379   if(buffer[0]!=0) return 4;
12646                       000036A5            .300:
12647                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$812] (used reg = )
12648 36A5           8A86       F7F0            mov	al,-$810[bp]
12649 36A9           84C0                       test	al,al
12650 36AB           74           07            je  	.302
12651                       000036AD            .303:
12652 36AD           B8                   0004  mov	ax,*4
12653 36B0           89EC                       mov	sp,bp
12654 36B2           5D                         pop	bp
12655 36B3           C3                         ret
12656                                           !BCC_EOS
12657                                           ! 2380   for(i=0;i<5;i++){
12658                       000036B4            .302:
12659                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12660 36B4           31C0                       xor	ax,ax
12661 36B6           8986       F7E6            mov	-$81A[bp],ax
12662                                           !BCC_EOS
12663                                           !BCC_EOS
12664 36BA           EB           3B            jmp .306
12665                       000036BC            .307:
12666                                           ! 2381     if(buffer[1+i]!=_read_byte(&isotag[i], 0xf000)) return 5;
12667                                           ! Debug: list unsigned int = const $F000 (used reg = )
12668 36BC           B8                   F000  mov	ax,#$F000
12669 36BF           50                         push	ax
12670                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [6] char = isotag+0 (used reg = )
12671 36C0           8B9E       F7E6            mov	bx,-$81A[bp]
12672                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
12673                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
12674 36C4           81C3                 3595  add	bx,#_isotag
12675 36C8           53                         push	bx
12676                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12677 36C9           E8         CF13            call	__read_byte
12678 36CC           83C4                   04  add	sp,*4
12679 36CF           50                         push	ax
12680                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 1 (used reg = )
12681                                           ! Debug: expression subtree swapping
12682 36D0           8B86       F7E6            mov	ax,-$81A[bp]
12683                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12684 36D4           40                         inc	ax
12685 36D5           89EB                       mov	bx,bp
12686 36D7           01C3                       add	bx,ax
12687                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12688 36D9           8A87       F7F0            mov	al,-$810[bx]
12689 36DD           3A86       F7E0            cmp	al,-$820[bp]
12690 36E1           8DA6       F7E2            lea	sp,-$81E[bp]
12691 36E5           74           07            je  	.308
12692                       000036E7            .309:
12693 36E7           B8                   0005  mov	ax,*5
12694 36EA           89EC                       mov	sp,bp
12695 36EC           5D                         pop	bp
12696 36ED           C3                         ret
12697                                           !BCC_EOS
12698                                           ! 2382   }
12699                       000036EE            .308:
12700                                           ! 2383   for(i=0;i<23;i++)
12701                       000036EE            .305:
12702                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12703 36EE           8B86       F7E6            mov	ax,-$81A[bp]
12704 36F2           40                         inc	ax
12705 36F3           8986       F7E6            mov	-$81A[bp],ax
12706                       000036F7            .306:
12707                                           ! Debug: lt int = const 5 to unsigned short i = [S+$820-$81C] (used reg = )
12708 36F7           8B86       F7E6            mov	ax,-$81A[bp]
12709 36FB           3D                   0005  cmp	ax,*5
12710 36FE           72           BC            jb 	.307
12711                       00003700            .30A:
12712                       00003700            .304:
12713                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12714 3700           31C0                       xor	ax,ax
12715 3702           8986       F7E6            mov	-$81A[bp],ax
12716                                           !BCC_EOS
12717                                           !BCC_EOS
12718                                           ! 2384     if(buffer[7+i]!=_read_byte(&eltorito[i], 0xf000)) return 6;
12719 3706           EB           3D            jmp .30D
12720                       00003708            .30E:
12721                                           ! Debug: list unsigned int = const $F000 (used reg = )
12722 3708           B8                   F000  mov	ax,#$F000
12723 370B           50                         push	ax
12724                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [$18] char = eltorito+0 (used reg = )
12725 370C           8B9E       F7E6            mov	bx,-$81A[bp]
12726                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
12727                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
12728 3710           81C3                 359B  add	bx,#_eltorito
12729 3714           53                         push	bx
12730                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12731 3715           E8         CEC7            call	__read_byte
12732 3718           83C4                   04  add	sp,*4
12733 371B           50                         push	ax
12734                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 7 (used reg = )
12735                                           ! Debug: expression subtree swapping
12736 371C           8B86       F7E6            mov	ax,-$81A[bp]
12737                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12738 3720           05                   0007  add	ax,*7
12739 3723           89EB                       mov	bx,bp
12740 3725           01C3                       add	bx,ax
12741                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12742 3727           8A87       F7F0            mov	al,-$810[bx]
12743 372B           3A86       F7E0            cmp	al,-$820[bp]
12744 372F           8DA6       F7E2            lea	sp,-$81E[bp]
12745 3733           74           07            je  	.30F
12746                       00003735            .310:
12747 3735           B8                   0006  mov	ax,*6
12748 3738           89EC                       mov	sp,bp
12749 373A           5D                         pop	bp
12750 373B           C3                         ret
12751                                           !BCC_EOS
12752                                           ! 2385   lba=*((Bit32u *)&buffer[0x47]);
12753                       0000373C            .30F:
12754                       0000373C            .30C:
12755                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12756 373C           8B86       F7E6            mov	ax,-$81A[bp]
12757 3740           40                         inc	ax
12758 3741           8986       F7E6            mov	-$81A[bp],ax
12759                       00003745            .30D:
12760                                           ! Debug: lt int = const $17 to unsigned short i = [S+$820-$81C] (used reg = )
12761 3745           8B86       F7E6            mov	ax,-$81A[bp]
12762 3749           3D                   0017  cmp	ax,*$17
12763 374C           72           BA            jb 	.30E
12764                       0000374E            .311:
12765                       0000374E            .30B:
12766                                           ! Debug: eq unsigned long buffer = [S+$820-$7CB] to unsigned long lba = [S+$820-$816] (used reg = )
12767 374E           8B86       F837            mov	ax,-$7C9[bp]
12768 3752           8B9E       F839            mov	bx,-$7C7[bp]
12769 3756           8986       F7EC            mov	-$814[bp],ax
12770 375A           899E       F7EE            mov	-$812[bp],bx
12771                                           !BCC_EOS
12772                                           ! 2386   _memsetb(0,atacmd,get_SS(),12);
12773                                           ! Debug: list int = const $C (used reg = )
12774 375E           B8                   000C  mov	ax,*$C
12775 3761           50                         push	ax
12776                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12777 3762           E8         CEF5            call	_get_SS
12778                                           ! Debug: list unsigned short = ax+0 (used reg = )
12779 3765           50                         push	ax
12780                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12781 3766           8D5E         F0            lea	bx,-$10[bp]
12782 3769           53                         push	bx
12783                                           ! Debug: list int = const 0 (used reg = )
12784 376A           31C0                       xor	ax,ax
12785 376C           50                         push	ax
12786                                           ! Debug: func () void = _memsetb+0 (used reg = )
12787 376D           E8         C890            call	__memsetb
12788 3770           83C4                   08  add	sp,*8
12789                                           !BCC_EOS
12790                                           ! 2387   atacmd[0]=0x28;
12791                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12792 3773           B0                     28  mov	al,*$28
12793 3775           8846         F0            mov	-$10[bp],al
12794                                           !BCC_EOS
12795                                           ! 2388   atacmd[7]=(0x01 & 0xff00) >> 8;
12796                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12797 3778           30C0                       xor	al,al
12798 377A           8846         F7            mov	-9[bp],al
12799                                           !BCC_EOS
12800                                           ! 2389   atacmd[8]=(0x01 & 0x00ff);
12801                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12802 377D           B0                     01  mov	al,*1
12803 377F           8846         F8            mov	-8[bp],al
12804                                           !BCC_EOS
12805                                           ! 2390   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
12806                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
12807 3782           8A86       F7EF            mov	al,-$811[bp]
12808 3786           8846         F2            mov	-$E[bp],al
12809                                           !BCC_EOS
12810                                           ! 2391   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
12811                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
12812 3789           8A86       F7EE            mov	al,-$812[bp]
12813 378D           8846         F3            mov	-$D[bp],al
12814                                           !BCC_EOS
12815                                           ! 2392   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
12816                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
12817 3790           8A86       F7ED            mov	al,-$813[bp]
12818 3794           8846         F4            mov	-$C[bp],al
12819                                           !BCC_EOS
12820                                           ! 2393   atacmd[5]=*((Bit8u *)&lba);
12821                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
12822 3797           8A86       F7EC            mov	al,-$814[bp]
12823 379B           8846         F5            mov	-$B[bp],al
12824                                           !BCC_EOS
12825                                           ! 2394   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12826                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12827 379E           8D9E       F7F0            lea	bx,-$810[bp]
12828 37A2           53                         push	bx
12829                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12830 37A3           E8         CEB4            call	_get_SS
12831                                           ! Debug: list unsigned short = ax+0 (used reg = )
12832 37A6           50                         push	ax
12833                                           ! Debug: list int = const 1 (used reg = )
12834 37A7           B8                   0001  mov	ax,*1
12835 37AA           50                         push	ax
12836                                           ! Debug: list long = const $800 (used reg = )
12837 37AB           B8                   0800  mov	ax,#$800
12838 37AE           31DB                       xor	bx,bx
12839 37B0           53                         push	bx
12840 37B1           50                         push	ax
12841                                           ! Debug: list int = const 0 (used reg = )
12842 37B2           31C0                       xor	ax,ax
12843 37B4           50                         push	ax
12844                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12845 37B5           8D5E         F0            lea	bx,-$10[bp]
12846 37B8           53                         push	bx
12847                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12848 37B9           E8         CE9E            call	_get_SS
12849                                           ! Debug: list unsigned short = ax+0 (used reg = )
12850 37BC           50                         push	ax
12851                                           ! Debug: list int = const $C (used reg = )
12852 37BD           B8                   000C  mov	ax,*$C
12853 37C0           50                         push	ax
12854                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12855 37C1           8A86       F7E3            mov	al,-$81D[bp]
12856 37C5           30E4                       xor	ah,ah
12857 37C7           50                         push	ax
12858                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12859 37C8           E8         F57A            call	_ata_cmd_packet
12860 37CB           83C4                   14  add	sp,*$14
12861                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12862 37CE           8986       F7E4            mov	-$81C[bp],ax
12863                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12864 37D2           85C0                       test	ax,ax
12865 37D4           74           07            je  	.312
12866                       000037D6            .313:
12867                                           ! 2395     return 7;
12868 37D6           B8                   0007  mov	ax,*7
12869 37D9           89EC                       mov	sp,bp
12870 37DB           5D                         pop	bp
12871 37DC           C3                         ret
12872                                           !BCC_EOS
12873                                           ! 2396   if(buffer[0x00]!=0x01)return 8;
12874                       000037DD            .312:
12875                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$820-$812] (used reg = )
12876 37DD           8A86       F7F0            mov	al,-$810[bp]
12877 37E1           3C                     01  cmp	al,*1
12878 37E3           74           07            je  	.314
12879                       000037E5            .315:
12880 37E5           B8                   0008  mov	ax,*8
12881 37E8           89EC                       mov	sp,bp
12882 37EA           5D                         pop	bp
12883 37EB           C3                         ret
12884                                           !BCC_EOS
12885                                           ! 2397   if(buffer[0x01]!=0x00)return 9;
12886                       000037EC            .314:
12887                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$811] (used reg = )
12888 37EC           8A86       F7F1            mov	al,-$80F[bp]
12889 37F0           84C0                       test	al,al
12890 37F2           74           07            je  	.316
12891                       000037F4            .317:
12892 37F4           B8                   0009  mov	ax,*9
12893 37F7           89EC                       mov	sp,bp
12894 37F9           5D                         pop	bp
12895 37FA           C3                         ret
12896                                           !BCC_EOS
12897                                           ! 2398   if(buffer[0x1E]!=0x55)return 10;
12898                       000037FB            .316:
12899                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$820-$7F4] (used reg = )
12900 37FB           8A86       F80E            mov	al,-$7F2[bp]
12901 37FF           3C                     55  cmp	al,*$55
12902 3801           74           07            je  	.318
12903                       00003803            .319:
12904 3803           B8                   000A  mov	ax,*$A
12905 3806           89EC                       mov	sp,bp
12906 3808           5D                         pop	bp
12907 3809           C3                         ret
12908                                           !BCC_EOS
12909                                           ! 2399   if(buffer[0x1F]!=0xAA)return 10;
12910                       0000380A            .318:
12911                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$820-$7F3] (used reg = )
12912 380A           8A86       F80F            mov	al,-$7F1[bp]
12913 380E           3C                     AA  cmp	al,#$AA
12914 3810           74           07            je  	.31A
12915                       00003812            .31B:
12916 3812           B8                   000A  mov	ax,*$A
12917 3815           89EC                       mov	sp,bp
12918 3817           5D                         pop	bp
12919 3818           C3                         ret
12920                                           !BCC_EOS
12921                                           ! 2400   if(buffer[0x20]!=0x88)return 11;
12922                       00003819            .31A:
12923                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$820-$7F2] (used reg = )
12924 3819           8A86       F810            mov	al,-$7F0[bp]
12925 381D           3C                     88  cmp	al,#$88
12926 381F           74           07            je  	.31C
12927                       00003821            .31D:
12928 3821           B8                   000B  mov	ax,*$B
12929 3824           89EC                       mov	sp,bp
12930 3826           5D                         pop	bp
12931 3827           C3                         ret
12932                                           !BCC_EOS
12933                                           ! 2401   old_ds = set_DS(ebda_seg);
12934                       00003828            .31C:
12935                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
12936 3828           FF76         FE            push	-2[bp]
12937                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
12938 382B           E8         CE2F            call	_set_DS
12939 382E           44                         inc	sp
12940 382F           44                         inc	sp
12941                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$820-6] (used reg = )
12942 3830           8946         FC            mov	-4[bp],ax
12943                                           !BCC_EOS
12944                                           ! 2402   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media)) = (buffer[0x21]);
12945                                           ! Debug: eq unsigned char buffer = [S+$820-$7F1] to unsigned char = [+$25B] (used reg = )
12946 3833           8A86       F811            mov	al,-$7EF[bp]
12947 3837           A2         025B            mov	[$25B],al
12948                                           !BCC_EOS
12949                                           ! 2403   if(buffer[0x21]==0){
12950                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$820-$7F1] (used reg = )
12951 383A           8A86       F811            mov	al,-$7EF[bp]
12952 383E           84C0                       test	al,al
12953 3840           75           07            jne 	.31E
12954                       00003842            .31F:
12955                                           ! 2404     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0xE0);
12956                                           ! Debug: eq int = const $E0 to unsigned char = [+$25C] (used reg = )
12957 3842           B0                     E0  mov	al,#$E0
12958 3844           A2         025C            mov	[$25C],al
12959                                           !BCC_EOS
12960                                           ! 2405   }
12961                                           ! 2406   else if(buffer[0x21]<4)
12962 3847           EB           14            jmp .320
12963                       00003849            .31E:
12964                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$820-$7F1] (used reg = )
12965 3849           8A86       F811            mov	al,-$7EF[bp]
12966 384D           3C                     04  cmp	al,*4
12967 384F           73           07            jae 	.321
12968                       00003851            .322:
12969                                           ! 2407     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x00);
12970                                           ! Debug: eq int = const 0 to unsigned char = [+$25C] (used reg = )
12971 3851           30C0                       xor	al,al
12972 3853           A2         025C            mov	[$25C],al
12973                                           !BCC_EOS
12974                                           ! 2408   else
12975                                           ! 2409     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x80);
12976 3856           EB           05            jmp .323
12977                       00003858            .321:
12978                                           ! Debug: eq int = const $80 to unsigned char = [+$25C] (used reg = )
12979 3858           B0                     80  mov	al,#$80
12980 385A           A2         025C            mov	[$25C],al
12981                                           !BCC_EOS
12982                                           ! 2410   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) = (device/2);
12983                       0000385D            .323:
12984                       0000385D            .320:
12985                                           ! Debug: div int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
12986 385D           8A86       F7E3            mov	al,-$81D[bp]
12987 3861           30E4                       xor	ah,ah
12988 3863           D1E8                       shr	ax,*1
12989                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$25D] (used reg = )
12990 3865           A2         025D            mov	[$25D],al
12991                                           !BCC_EOS
12992                                           ! 2411   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_
12993                                           ! 2411 spec)) = (device%2);
12994                                           ! Debug: mod int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
12995 3868           8A86       F7E3            mov	al,-$81D[bp]
12996 386C           30E4                       xor	ah,ah
12997 386E           24                     01  and	al,*1
12998                                           ! Debug: eq unsigned char = al+0 to unsigned char = [+$25E] (used reg = )
12999 3870           A2         025E            mov	[$25E],al
13000                                           !BCC_EOS
13001                                           ! 2412   boot_segment=*((Bit16u *)&buffer[0x22]);
13002                                           ! Debug: eq unsigned short buffer = [S+$820-$7F0] to unsigned short boot_segment = [S+$820-$818] (used reg = )
13003 3873           8B86       F812            mov	ax,-$7EE[bp]
13004 3877           8986       F7EA            mov	-$816[bp],ax
13005                                           !BCC_EOS
13006                                           ! 2413   if(boot_segment==0x0000)boot_segment=0x07C0;
13007                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13008 387B           8B86       F7EA            mov	ax,-$816[bp]
13009 387F           85C0                       test	ax,ax
13010 3881           75           07            jne 	.324
13011                       00003883            .325:
13012                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13013 3883           B8                   07C0  mov	ax,#$7C0
13014 3886           8986       F7EA            mov	-$816[bp],ax
13015                                           !BCC_EOS
13016                                           ! 2414   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.load_segment)) = (boot_segment);
13017                       0000388A            .324:
13018                                           ! Debug: eq unsigned short boot_segment = [S+$820-$818] to unsigned short = [+$266] (used reg = )
13019 388A           8B86       F7EA            mov	ax,-$816[bp]
13020 388E           A3         0266            mov	[$266],ax
13021                                           !BCC_EOS
13022                                           ! 2415   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.buffer_segment)) = (0x0000);
13023                                           ! Debug: eq int = const 0 to unsigned short = [+$264] (used reg = )
13024 3891           31C0                       xor	ax,ax
13025 3893           A3         0264            mov	[$264],ax
13026                                           !BCC_EOS
13027                                           ! 2416   nbsectors=*((Bit16u *)&buffer[0x26]);
13028                                           ! Debug: eq unsigned short buffer = [S+$820-$7EC] to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13029 3896           8B86       F816            mov	ax,-$7EA[bp]
13030 389A           8986       F7E8            mov	-$818[bp],ax
13031                                           !BCC_EOS
13032                                           ! 2417   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.sector_count)) = (nbsectors);
13033                                           ! Debug: eq unsigned short nbsectors = [S+$820-$81A] to unsigned short = [+$268] (used reg = )
13034 389E           8B86       F7E8            mov	ax,-$818[bp]
13035 38A2           A3         0268            mov	[$268],ax
13036                                           !BCC_EOS
13037                                           ! 2418   lba=*((Bit32u *)&buffer[0x28]);
13038                                           ! Debug: eq unsigned long buffer = [S+$820-$7EA] to unsigned long lba = [S+$820-$816] (used reg = )
13039 38A5           8B86       F818            mov	ax,-$7E8[bp]
13040 38A9           8B9E       F81A            mov	bx,-$7E6[bp]
13041 38AD           8986       F7EC            mov	-$814[bp],ax
13042 38B1           899E       F7EE            mov	-$812[bp],bx
13043                                           !BCC_EOS
13044                                           ! 2419   *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba)) = (lba);
13045                                           ! Debug: eq unsigned long lba = [S+$820-$816] to unsigned long = [+$260] (used reg = )
13046 38B5           8B86       F7EC            mov	ax,-$814[bp]
13047 38B9           8B9E       F7EE            mov	bx,-$812[bp]
13048 38BD           A3         0260            mov	[$260],ax
13049 38C0           891E       0262            mov	[$262],bx
13050                                           !BCC_EOS
13051                                           ! 2420   _memsetb(0,atacmd,get_SS(),12);
13052                                           ! Debug: list int = const $C (used reg = )
13053 38C4           B8                   000C  mov	ax,*$C
13054 38C7           50                         push	ax
13055                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13056 38C8           E8         CD8F            call	_get_SS
13057                                           ! Debug: list unsigned short = ax+0 (used reg = )
13058 38CB           50                         push	ax
13059                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
13060 38CC           8D5E         F0            lea	bx,-$10[bp]
13061 38CF           53                         push	bx
13062                                           ! Debug: list int = const 0 (used reg = )
13063 38D0           31C0                       xor	ax,ax
13064 38D2           50                         push	ax
13065                                           ! Debug: func () void = _memsetb+0 (used reg = )
13066 38D3           E8         C72A            call	__memsetb
13067 38D6           83C4                   08  add	sp,*8
13068                                           !BCC_EOS
13069                                           ! 2421   atacmd[0]=0x28;
13070                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
13071 38D9           B0                     28  mov	al,*$28
13072 38DB           8846         F0            mov	-$10[bp],al
13073                                           !BCC_EOS
13074                                           ! 2422   i = 1+(nbsectors-1)/4;
13075                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13076 38DE           8B86       F7E8            mov	ax,-$818[bp]
13077                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13078 38E2           48                         dec	ax
13079 38E3           D1E8                       shr	ax,*1
13080 38E5           D1E8                       shr	ax,*1
13081                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13082                                           ! Debug: expression subtree swapping
13083                                           ! Debug: eq unsigned int = ax+1 to unsigned short i = [S+$820-$81C] (used reg = )
13084 38E7           40                         inc	ax
13085 38E8           8986       F7E6            mov	-$81A[bp],ax
13086                                           !BCC_EOS
13087                                           ! 2423   atacmd[7]=*(((Bit8u *)&i)+1);
13088                                           ! Debug: eq unsigned char i = [S+$820-$81B] to unsigned char atacmd = [S+$820-$B] (used reg = )
13089 38EC           8A86       F7E7            mov	al,-$819[bp]
13090 38F0           8846         F7            mov	-9[bp],al
13091                                           !BCC_EOS
13092                                           ! 2424   atacmd[8]=*((Bit8u *)&i);
13093                                           ! Debug: eq unsigned char i = [S+$820-$81C] to unsigned char atacmd = [S+$820-$A] (used reg = )
13094 38F3           8A86       F7E6            mov	al,-$81A[bp]
13095 38F7           8846         F8            mov	-8[bp],al
13096                                           !BCC_EOS
13097                                           ! 2425   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
13098                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
13099 38FA           8A86       F7EF            mov	al,-$811[bp]
13100 38FE           8846         F2            mov	-$E[bp],al
13101                                           !BCC_EOS
13102                                           ! 2426   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
13103                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
13104 3901           8A86       F7EE            mov	al,-$812[bp]
13105 3905           8846         F3            mov	-$D[bp],al
13106                                           !BCC_EOS
13107                                           ! 2427   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
13108                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
13109 3908           8A86       F7ED            mov	al,-$813[bp]
13110 390C           8846         F4            mov	-$C[bp],al
13111                                           !BCC_EOS
13112                                           ! 2428   atacmd[5]=*((Bit8u *)&lba);
13113                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
13114 390F           8A86       F7EC            mov	al,-$814[bp]
13115 3913           8846         F5            mov	-$B[bp],al
13116                                           !BCC_EOS
13117                                           ! 2429   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
13118                                           ! Debug: list int = const 0 (used reg = )
13119 3916           31C0                       xor	ax,ax
13120 3918           50                         push	ax
13121                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13122 3919           FFB6       F7EA            push	-$816[bp]
13123                                           ! Debug: list int = const 1 (used reg = )
13124 391D           B8                   0001  mov	ax,*1
13125 3920           50                         push	ax
13126                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$826-$81A] (used reg = )
13127 3921           8B86       F7E8            mov	ax,-$818[bp]
13128 3925           31DB                       xor	bx,bx
13129                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
13130 3927           53                         push	bx
13131 3928           50                         push	ax
13132 3929           B8                   0200  mov	ax,#$200
13133 392C           31DB                       xor	bx,bx
13134 392E           53                         push	bx
13135 392F           50                         push	ax
13136 3930           8B86       F7D8            mov	ax,-$828[bp]
13137 3934           8B9E       F7DA            mov	bx,-$826[bp]
13138 3938           8DBE       F7D4            lea	di,-$82C[bp]
13139 393C           E8         C77B            call	lmulul
13140 393F           83C4                   08  add	sp,*8
13141                                           ! Debug: list unsigned long = bx+0 (used reg = )
13142 3942           53                         push	bx
13143 3943           50                         push	ax
13144                                           ! Debug: list int = const 0 (used reg = )
13145 3944           31C0                       xor	ax,ax
13146 3946           50                         push	ax
13147                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
13148 3947           8D5E         F0            lea	bx,-$10[bp]
13149 394A           53                         push	bx
13150                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13151 394B           E8         CD0C            call	_get_SS
13152                                           ! Debug: list unsigned short = ax+0 (used reg = )
13153 394E           50                         push	ax
13154                                           ! Debug: list int = const $C (used reg = )
13155 394F           B8                   000C  mov	ax,*$C
13156 3952           50                         push	ax
13157                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
13158 3953           8A86       F7E3            mov	al,-$81D[bp]
13159 3957           30E4                       xor	ah,ah
13160 3959           50                         push	ax
13161                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13162 395A           E8         F3E8            call	_ata_cmd_packet
13163 395D           83C4                   14  add	sp,*$14
13164                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
13165 3960           8986       F7E4            mov	-$81C[bp],ax
13166                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13167 3964           85C0                       test	ax,ax
13168 3966           74           0F            je  	.326
13169                       00003968            .327:
13170                                           ! 2430   {
13171                                           ! 2431     set_DS(old_ds);
13172                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13173 3968           FF76         FC            push	-4[bp]
13174                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13175 396B           E8         CCEF            call	_set_DS
13176 396E           44                         inc	sp
13177 396F           44                         inc	sp
13178                                           !BCC_EOS
13179                                           ! 2432     return 12;
13180 3970           B8                   000C  mov	ax,*$C
13181 3973           89EC                       mov	sp,bp
13182 3975           5D                         pop	bp
13183 3976           C3                         ret
13184                                           !BCC_EOS
13185                                           ! 2433   }
13186                                           ! 2434   switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
13187                       00003977            .326:
13188 3977           A0         025B            mov	al,[$25B]
13189 397A           E9         009B            br 	.32A
13190                                           ! 2435     case 0x01:
13191                                           ! 2436       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (15);
13192                       0000397D            .32B:
13193                                           ! Debug: eq int = const $F to unsigned short = [+$26E] (used reg = )
13194 397D           B8                   000F  mov	ax,*$F
13195 3980           A3         026E            mov	[$26E],ax
13196                                           !BCC_EOS
13197                                           ! 2437       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13198                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13199 3983           B8                   0050  mov	ax,*$50
13200 3986           A3         026C            mov	[$26C],ax
13201                                           !BCC_EOS
13202                                           ! 2438       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13203                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13204 3989           B8                   0002  mov	ax,*2
13205 398C           A3         026A            mov	[$26A],ax
13206                                           !BCC_EOS
13207                                           ! 2439       break;
13208 398F           E9         009C            br 	.328
13209                                           !BCC_EOS
13210                                           ! 2440     case 0x02:
13211                                           ! 2441       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (18);
13212                       00003992            .32C:
13213                                           ! Debug: eq int = const $12 to unsigned short = [+$26E] (used reg = )
13214 3992           B8                   0012  mov	ax,*$12
13215 3995           A3         026E            mov	[$26E],ax
13216                                           !BCC_EOS
13217                                           ! 2442       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13218                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13219 3998           B8                   0050  mov	ax,*$50
13220 399B           A3         026C            mov	[$26C],ax
13221                                           !BCC_EOS
13222                                           ! 2443       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13223                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13224 399E           B8                   0002  mov	ax,*2
13225 39A1           A3         026A            mov	[$26A],ax
13226                                           !BCC_EOS
13227                                           ! 2444       break;
13228 39A4           E9         0087            br 	.328
13229                                           !BCC_EOS
13230                                           ! 2445     case 0x03:
13231                                           ! 2446       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (36);
13232                       000039A7            .32D:
13233                                           ! Debug: eq int = const $24 to unsigned short = [+$26E] (used reg = )
13234 39A7           B8                   0024  mov	ax,*$24
13235 39AA           A3         026E            mov	[$26E],ax
13236                                           !BCC_EOS
13237                                           ! 2447       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13238                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13239 39AD           B8                   0050  mov	ax,*$50
13240 39B0           A3         026C            mov	[$26C],ax
13241                                           !BCC_EOS
13242                                           ! 2448       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13243                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13244 39B3           B8                   0002  mov	ax,*2
13245 39B6           A3         026A            mov	[$26A],ax
13246                                           !BCC_EOS
13247                                           ! 2449       break;
13248 39B9           EB           73            jmp .328
13249                                           !BCC_EOS
13250                                           ! 2450     case 0x04:
13251                                           ! 2451       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (_read_byte(446+6, boot_segment)&0x3f);
13252                       000039BB            .32E:
13253                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13254 39BB           FFB6       F7EA            push	-$816[bp]
13255                                           ! Debug: list int = const $1C4 (used reg = )
13256 39BF           B8                   01C4  mov	ax,#$1C4
13257 39C2           50                         push	ax
13258                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13259 39C3           E8         CC19            call	__read_byte
13260 39C6           83C4                   04  add	sp,*4
13261                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
13262 39C9           24                     3F  and	al,*$3F
13263                                           ! Debug: eq unsigned char = al+0 to unsigned short = [+$26E] (used reg = )
13264 39CB           30E4                       xor	ah,ah
13265 39CD           A3         026E            mov	[$26E],ax
13266                                           !BCC_EOS
13267                                           ! 2452       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = ((_read_byte(446+6, boot_segment)<<2) + _read_byte(446+7, boot_segment) + 1);
13268                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13269 39D0           FFB6       F7EA            push	-$816[bp]
13270                                           ! Debug: list int = const $1C5 (used reg = )
13271 39D4           B8                   01C5  mov	ax,#$1C5
13272 39D7           50                         push	ax
13273                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13274 39D8           E8         CC04            call	__read_byte
13275 39DB           83C4                   04  add	sp,*4
13276 39DE           50                         push	ax
13277                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13278 39DF           FFB6       F7EA            push	-$816[bp]
13279                                           ! Debug: list int = const $1C4 (used reg = )
13280 39E3           B8                   01C4  mov	ax,#$1C4
13281 39E6           50                         push	ax
13282                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13283 39E7           E8         CBF5            call	__read_byte
13284 39EA           83C4                   04  add	sp,*4
13285                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
13286 39ED           30E4                       xor	ah,ah
13287 39EF           D1E0                       shl	ax,*1
13288 39F1           D1E0                       shl	ax,*1
13289                                           ! Debug: add unsigned char (temp) = [S+$822-$822] to unsigned int = ax+0 (used reg = )
13290 39F3           0286       F7E0            add	al,0+..FFF9[bp]
13291 39F7           80D4                   00  adc	ah,*0
13292 39FA           44                         inc	sp
13293 39FB           44                         inc	sp
13294                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
13295                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26C] (used reg = )
13296 39FC           40                         inc	ax
13297 39FD           A3         026C            mov	[$26C],ax
13298                                           !BCC_EOS
13299                                           ! 2453       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (_
13300                                           ! 2453 read_byte(446+5, boot_segment) + 1);
13301                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13302 3A00           FFB6       F7EA            push	-$816[bp]
13303                                           ! Debug: list int = const $1C3 (used reg = )
13304 3A04           B8                   01C3  mov	ax,#$1C3
13305 3A07           50                         push	ax
13306                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13307 3A08           E8         CBD4            call	__read_byte
13308 3A0B           83C4                   04  add	sp,*4
13309                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13310 3A0E           30E4                       xor	ah,ah
13311                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26A] (used reg = )
13312 3A10           40                         inc	ax
13313 3A11           A3         026A            mov	[$26A],ax
13314                                           !BCC_EOS
13315                                           ! 2454       break;
13316 3A14           EB           18            jmp .328
13317                                           !BCC_EOS
13318                                           ! 2455    }
13319                                           ! 2456   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0) {
13320 3A16           EB           16            jmp .328
13321                       00003A18            .32A:
13322 3A18           2C                     01  sub	al,*1
13323 3A1A         0F84         FF5F            beq 	.32B
13324 3A1E           2C                     01  sub	al,*1
13325 3A20         0F84         FF6E            beq 	.32C
13326 3A24           2C                     01  sub	al,*1
13327 3A26         0F84         FF7D            beq 	.32D
13328 3A2A           2C                     01  sub	al,*1
13329 3A2C           74           8D            je 	.32E
13330                       00003A2E            .328:
13331                       FFFFF7E0            ..FFF9	=	-$820
13332                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13333 3A2E           A0         025B            mov	al,[$25B]
13334 3A31           84C0                       test	al,al
13335 3A33           74           33            je  	.32F
13336                       00003A35            .330:
13337                                           ! 2457     if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))==0x00)
13338                                           ! Debug: logeq int = const 0 to unsigned char = [+$25C] (used reg = )
13339 3A35           A0         025C            mov	al,[$25C]
13340 3A38           84C0                       test	al,al
13341 3A3A           75           23            jne 	.331
13342                       00003A3C            .332:
13343                                           ! 2458       _write_byte(_read_byte(0x10, 0x40)|0x41, 0x10, 0x40);
13344                                           ! Debug: list int = const $40 (used reg = )
13345 3A3C           B8                   0040  mov	ax,*$40
13346 3A3F           50                         push	ax
13347                                           ! Debug: list int = const $10 (used reg = )
13348 3A40           B8                   0010  mov	ax,*$10
13349 3A43           50                         push	ax
13350                                           ! Debug: list int = const $40 (used reg = )
13351 3A44           B8                   0040  mov	ax,*$40
13352 3A47           50                         push	ax
13353                                           ! Debug: list int = const $10 (used reg = )
13354 3A48           B8                   0010  mov	ax,*$10
13355 3A4B           50                         push	ax
13356                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13357 3A4C           E8         CB90            call	__read_byte
13358 3A4F           83C4                   04  add	sp,*4
13359                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
13360 3A52           0C                     41  or	al,*$41
13361                                           ! Debug: list unsigned char = al+0 (used reg = )
13362 3A54           30E4                       xor	ah,ah
13363 3A56           50                         push	ax
13364                                           ! Debug: func () void = _write_byte+0 (used reg = )
13365 3A57           E8         CBA1            call	__write_byte
13366 3A5A           83C4                   06  add	sp,*6
13367                                           !BCC_EOS
13368                                           ! 2459     else
13369                                           ! 2460       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) + 1);
13370 3A5D           EB           09            jmp .333
13371                       00003A5F            .331:
13372                                           ! Debug: add int = const 1 to unsigned char = [+$232] (used reg = )
13373 3A5F           A0         0232            mov	al,[$232]
13374 3A62           30E4                       xor	ah,ah
13375                                           ! Debug: eq unsigned int = ax+1 to unsigned char = [+$232] (used reg = )
13376 3A64           40                         inc	ax
13377 3A65           A2         0232            mov	[$232],al
13378                                           !BCC_EOS
13379                                           ! 2461   }
13380                       00003A68            .333:
13381                                           ! 2462   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0)
13382                       00003A68            .32F:
13383                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13384 3A68           A0         025B            mov	al,[$25B]
13385 3A6B           84C0                       test	al,al
13386 3A6D           74           05            je  	.334
13387                       00003A6F            .335:
13388                                           ! 2463     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) = (0x01);
13389                                           ! Debug: eq int = const 1 to unsigned char = [+$25A] (used reg = )
13390 3A6F           B0                     01  mov	al,*1
13391 3A71           A2         025A            mov	[$25A],al
13392                                           !BCC_EOS
13393                                           ! 2464   i = (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))*0x100)+0;
13394                       00003A74            .334:
13395                                           ! Debug: mul int = const $100 to unsigned char = [+$25C] (used reg = )
13396 3A74           A0         025C            mov	al,[$25C]
13397 3A77           30E4                       xor	ah,ah
13398 3A79           B9                   0100  mov	cx,#$100
13399 3A7C           F7E9                       imul	cx
13400                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
13401                                           ! Debug: eq unsigned int = ax+0 to unsigned short i = [S+$820-$81C] (used reg = )
13402 3A7E           8986       F7E6            mov	-$81A[bp],ax
13403                                           !BCC_EOS
13404                                           ! 2465   set_DS(old_ds);
13405                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13406 3A82           FF76         FC            push	-4[bp]
13407                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13408 3A85           E8         CBD5            call	_set_DS
13409 3A88           44                         inc	sp
13410 3A89           44                         inc	sp
13411                                           !BCC_EOS
13412                                           ! 2466   return i;
13413 3A8A           8B86       F7E6            mov	ax,-$81A[bp]
13414 3A8E           89EC                       mov	sp,bp
13415 3A90           5D                         pop	bp
13416 3A91           C3                         ret
13417                                           !BCC_EOS
13418                                           ! 2467 }
13419                                           ! 2468 void int14_function(regs, ds, iret_addr)
13420                                           ! Register BX used in function cdrom_boot
13421                                           ! 2469   pusha_regs_t regs;
13422                                           export	_int14_function
13423                       00003A92            _int14_function:
13424                                           !BCC_EOS
13425                                           ! 2470   Bit16u ds;
13426                                           !BCC_EOS
13427                                           ! 2471   iret_addr_t iret_addr;
13428                                           !BCC_EOS
13429                                           ! 2472 {
13430                                           ! 2473   Bit16u addr,timer,val16;
13431                                           !BCC_EOS
13432                                           ! 2474   Bit8u counter;
13433                                           !BCC_EOS
13434                                           ! 2475 #asm
13435 3A92           55                         push	bp
13436 3A93           89E5                       mov	bp,sp
13437 3A95           83C4                   F8  add	sp,*-8
13438                                           !BCC_EOS
13439                                           !BCC_ASM
13440                       0000001C            _int14_function.ds	set	$1C
13441                       00000014            .int14_function.ds	set	$14
13442                       00000001            _int14_function.counter	set	1
13443                       FFFFFFF9            .int14_function.counter	set	-7
13444                       00000004            _int14_function.timer	set	4
13445                       FFFFFFFC            .int14_function.timer	set	-4
13446                       0000001E            _int14_function.iret_addr	set	$1E
13447                       00000016            .int14_function.iret_addr	set	$16
13448                       00000006            _int14_function.addr	set	6
13449                       FFFFFFFE            .int14_function.addr	set	-2
13450                       00000002            _int14_function.val16	set	2
13451                       FFFFFFFA            .int14_function.val16	set	-6
13452                       0000000C            _int14_function.regs	set	$C
13453                       00000004            .int14_function.regs	set	4
13454 3A98           FB                           sti
13455                                           ! 2477 endasm
13456                                           !BCC_ENDASM
13457                                           !BCC_EOS
13458                                           ! 2478   addr = *((Bit16u *)(0x400 + (regs.u.r16.dx << 1)));
13459                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
13460 3A99           8B46         0E            mov	ax,$E[bp]
13461 3A9C           D1E0                       shl	ax,*1
13462                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
13463                                           ! Debug: expression subtree swapping
13464                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$400 (used reg = )
13465 3A9E           89C3                       mov	bx,ax
13466                                           ! Debug: eq unsigned short = [bx+$400] to unsigned short addr = [S+$A-4] (used reg = )
13467 3AA0           8B9F       0400            mov	bx,$400[bx]
13468 3AA4           895E         FE            mov	-2[bp],bx
13469                                           !BCC_EOS
13470                                           ! 2479   counter = *((Bit8u *)(0x047C + regs.u.r16.dx));
13471                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $47C (used reg = )
13472                                           ! Debug: expression subtree swapping
13473 3AA7           8B46         0E            mov	ax,$E[bp]
13474                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$47C (used reg = )
13475 3AAA           89C3                       mov	bx,ax
13476                                           ! Debug: eq unsigned char = [bx+$47C] to unsigned char counter = [S+$A-9] (used reg = )
13477 3AAC           8A87       047C            mov	al,$47C[bx]
13478 3AB0           8846         F9            mov	-7[bp],al
13479                                           !BCC_EOS
13480                                           ! 2480   if ((regs.u.r16.dx < 4) && (addr > 0)) {
13481                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
13482 3AB3           8B46         0E            mov	ax,$E[bp]
13483 3AB6           3D                   0004  cmp	ax,*4
13484 3AB9         0F83         01F6            bhis	.336
13485                       00003ABD            .338:
13486                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
13487 3ABD           8B46         FE            mov	ax,-2[bp]
13488 3AC0           85C0                       test	ax,ax
13489 3AC2         0F84         01ED            beq 	.336
13490                       00003AC6            .337:
13491                                           ! 2481     switch (regs.u.r8.ah) {
13492 3AC6           8A46         13            mov	al,$13[bp]
13493 3AC9           E9         01CD            br 	.33B
13494                                           ! 2482       case 0:
13495                                           ! 2483         outb(addr+3, inb(addr+3) | 0x80);
13496                       00003ACC            .33C:
13497                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
13498 3ACC           8B46         FE            mov	ax,-2[bp]
13499                                           ! Debug: list unsigned int = ax+3 (used reg = )
13500 3ACF           05                   0003  add	ax,*3
13501 3AD2           50                         push	ax
13502                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13503 3AD3           E8         CA53            call	_inb
13504 3AD6           44                         inc	sp
13505 3AD7           44                         inc	sp
13506                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
13507 3AD8           0C                     80  or	al,#$80
13508                                           ! Debug: list unsigned char = al+0 (used reg = )
13509 3ADA           30E4                       xor	ah,ah
13510 3ADC           50                         push	ax
13511                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13512 3ADD           8B46         FE            mov	ax,-2[bp]
13513                                           ! Debug: list unsigned int = ax+3 (used reg = )
13514 3AE0           05                   0003  add	ax,*3
13515 3AE3           50                         push	ax
13516                                           ! Debug: func () void = outb+0 (used reg = )
13517 3AE4           E8         CA58            call	_outb
13518 3AE7           83C4                   04  add	sp,*4
13519                                           !BCC_EOS
13520                                           ! 2484         if (regs.u.r8.al & 0xE0 == 0) {
13521                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
13522 3AEA           8A46         12            mov	al,$12[bp]
13523 3AED           30C0                       xor	al,al
13524 3AEF           84C0                       test	al,al
13525 3AF1           74           1E            je  	.33D
13526                       00003AF3            .33E:
13527                                           ! 2485           outb(addr, 0x17);
13528                                           ! Debug: list int = const $17 (used reg = )
13529 3AF3           B8                   0017  mov	ax,*$17
13530 3AF6           50                         push	ax
13531                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13532 3AF7           FF76         FE            push	-2[bp]
13533                                           ! Debug: func () void = outb+0 (used reg = )
13534 3AFA           E8         CA42            call	_outb
13535 3AFD           83C4                   04  add	sp,*4
13536                                           !BCC_EOS
13537                                           ! 2486           outb(addr+1, 0x04);
13538                                           ! Debug: list int = const 4 (used reg = )
13539 3B00           B8                   0004  mov	ax,*4
13540 3B03           50                         push	ax
13541                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13542 3B04           8B46         FE            mov	ax,-2[bp]
13543                                           ! Debug: list unsigned int = ax+1 (used reg = )
13544 3B07           40                         inc	ax
13545 3B08           50                         push	ax
13546                                           ! Debug: func () void = outb+0 (used reg = )
13547 3B09           E8         CA33            call	_outb
13548 3B0C           83C4                   04  add	sp,*4
13549                                           !BCC_EOS
13550                                           ! 2487         } else {
13551 3B0F           EB           37            jmp .33F
13552                       00003B11            .33D:
13553                                           ! 2488           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
13554                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
13555 3B11           8A46         12            mov	al,$12[bp]
13556 3B14           24                     E0  and	al,#$E0
13557                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
13558 3B16           30E4                       xor	ah,ah
13559 3B18           B1                     05  mov	cl,*5
13560 3B1A           D3E8                       shr	ax,cl
13561                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
13562 3B1C           89C3                       mov	bx,ax
13563 3B1E           B8                   0600  mov	ax,#$600
13564 3B21           89D9                       mov	cx,bx
13565 3B23           D3F8                       sar	ax,cl
13566                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
13567 3B25           8946         FA            mov	-6[bp],ax
13568                                           !BCC_EOS
13569                                           ! 2489           outb(addr, val16 & 0xFF);
13570                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
13571 3B28           8A46         FA            mov	al,-6[bp]
13572                                           ! Debug: list unsigned char = al+0 (used reg = )
13573 3B2B           30E4                       xor	ah,ah
13574 3B2D           50                         push	ax
13575                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13576 3B2E           FF76         FE            push	-2[bp]
13577                                           ! Debug: func () void = outb+0 (used reg = )
13578 3B31           E8         CA0B            call	_outb
13579 3B34           83C4                   04  add	sp,*4
13580                                           !BCC_EOS
13581                                           ! 2490           outb(addr+1, *(((Bit8u *)&val16)+1));
13582                                           ! Debug: list unsigned char val16 = [S+$A-7] (used reg = )
13583 3B37           8A46         FB            mov	al,-5[bp]
13584 3B3A           30E4                       xor	ah,ah
13585 3B3C           50                         push	ax
13586                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13587 3B3D           8B46         FE            mov	ax,-2[bp]
13588                                           ! Debug: list unsigned int = ax+1 (used reg = )
13589 3B40           40                         inc	ax
13590 3B41           50                         push	ax
13591                                           ! Debug: func () void = outb+0 (used reg = )
13592 3B42           E8         C9FA            call	_outb
13593 3B45           83C4                   04  add	sp,*4
13594                                           !BCC_EOS
13595                                           ! 2491         }
13596                                           ! 2492         outb(addr+3, regs.u.r8.al & 0x1F);
13597                       00003B48            .33F:
13598                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
13599 3B48           8A46         12            mov	al,$12[bp]
13600 3B4B           24                     1F  and	al,*$1F
13601                                           ! Debug: list unsigned char = al+0 (used reg = )
13602 3B4D           30E4                       xor	ah,ah
13603 3B4F           50                         push	ax
13604                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13605 3B50           8B46         FE            mov	ax,-2[bp]
13606                                           ! Debug: list unsigned int = ax+3 (used reg = )
13607 3B53           05                   0003  add	ax,*3
13608 3B56           50                         push	ax
13609                                           ! Debug: func () void = outb+0 (used reg = )
13610 3B57           E8         C9E5            call	_outb
13611 3B5A           83C4                   04  add	sp,*4
13612                                           !BCC_EOS
13613                                           ! 2493         regs.u.r8.ah = inb(addr+5);
13614                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13615 3B5D           8B46         FE            mov	ax,-2[bp]
13616                                           ! Debug: list unsigned int = ax+5 (used reg = )
13617 3B60           05                   0005  add	ax,*5
13618 3B63           50                         push	ax
13619                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13620 3B64           E8         C9C2            call	_inb
13621 3B67           44                         inc	sp
13622 3B68           44                         inc	sp
13623                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13624 3B69           8846         13            mov	$13[bp],al
13625                                           !BCC_EOS
13626                                           ! 2494         regs.u.r8.al = inb(addr+6);
13627                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13628 3B6C           8B46         FE            mov	ax,-2[bp]
13629                                           ! Debug: list unsigned int = ax+6 (used reg = )
13630 3B6F           05                   0006  add	ax,*6
13631 3B72           50                         push	ax
13632                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13633 3B73           E8         C9B3            call	_inb
13634 3B76           44                         inc	sp
13635 3B77           44                         inc	sp
13636                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13637 3B78           8846         12            mov	$12[bp],al
13638                                           !BCC_EOS
13639                                           ! 2495         iret_addr.flags.u.r8.flagsl &= 0xfe;
13640                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13641 3B7B           8A46         1A            mov	al,$1A[bp]
13642 3B7E           24                     FE  and	al,#$FE
13643 3B80           8846         1A            mov	$1A[bp],al
13644                                           !BCC_EOS
13645                                           ! 2496         break;
13646 3B83           E9         012B            br 	.339
13647                                           !BCC_EOS
13648                                           ! 2497       case 1:
13649                                           ! 2498         timer = *((Bit16u *)(0x046C));
13650                       00003B86            .340:
13651                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13652 3B86           A1         046C            mov	ax,[$46C]
13653 3B89           8946         FC            mov	-4[bp],ax
13654                                           !BCC_EOS
13655                                           ! 2499         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
13656 3B8C           EB           1B            jmp .342
13657                       00003B8E            .343:
13658                                           ! 2500           val16 = *((Bit16u *)(0x046C));
13659                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13660 3B8E           A1         046C            mov	ax,[$46C]
13661 3B91           8946         FA            mov	-6[bp],ax
13662                                           !BCC_EOS
13663                                           ! 2501           if (val16 != timer) {
13664                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13665 3B94           8B46         FA            mov	ax,-6[bp]
13666 3B97           3B46         FC            cmp	ax,-4[bp]
13667 3B9A           74           0D            je  	.344
13668                       00003B9C            .345:
13669                                           ! 2502             timer = val16;
13670                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13671 3B9C           8B46         FA            mov	ax,-6[bp]
13672 3B9F           8946         FC            mov	-4[bp],ax
13673                                           !BCC_EOS
13674                                           ! 2503             counter--;
13675                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13676 3BA2           8A46         F9            mov	al,-7[bp]
13677 3BA5           48                         dec	ax
13678 3BA6           8846         F9            mov	-7[bp],al
13679                                           !BCC_EOS
13680                                           ! 2504           }
13681                                           ! 2505         }
13682                       00003BA9            .344:
13683                                           ! 2506         if (counter > 0) {
13684                       00003BA9            .342:
13685                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13686 3BA9           8B46         FE            mov	ax,-2[bp]
13687                                           ! Debug: list unsigned int = ax+5 (used reg = )
13688 3BAC           05                   0005  add	ax,*5
13689 3BAF           50                         push	ax
13690                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13691 3BB0           E8         C976            call	_inb
13692 3BB3           44                         inc	sp
13693 3BB4           44                         inc	sp
13694                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
13695 3BB5           24                     60  and	al,*$60
13696                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
13697 3BB7           3C                     60  cmp	al,*$60
13698 3BB9           74           07            je  	.346
13699                       00003BBB            .347:
13700 3BBB           8A46         F9            mov	al,-7[bp]
13701 3BBE           84C0                       test	al,al
13702 3BC0           75           CC            jne	.343
13703                       00003BC2            .346:
13704                       00003BC2            .341:
13705                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13706 3BC2           8A46         F9            mov	al,-7[bp]
13707 3BC5           84C0                       test	al,al
13708 3BC7           74           20            je  	.348
13709                       00003BC9            .349:
13710                                           ! 2507           outb(addr, regs.u.r8.al);
13711                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
13712 3BC9           8A46         12            mov	al,$12[bp]
13713 3BCC           30E4                       xor	ah,ah
13714 3BCE           50                         push	ax
13715                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13716 3BCF           FF76         FE            push	-2[bp]
13717                                           ! Debug: func () void = outb+0 (used reg = )
13718 3BD2           E8         C96A            call	_outb
13719 3BD5           83C4                   04  add	sp,*4
13720                                           !BCC_EOS
13721                                           ! 2508           regs.u.r8.ah = inb(addr+5);
13722                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13723 3BD8           8B46         FE            mov	ax,-2[bp]
13724                                           ! Debug: list unsigned int = ax+5 (used reg = )
13725 3BDB           05                   0005  add	ax,*5
13726 3BDE           50                         push	ax
13727                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13728 3BDF           E8         C947            call	_inb
13729 3BE2           44                         inc	sp
13730 3BE3           44                         inc	sp
13731                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13732 3BE4           8846         13            mov	$13[bp],al
13733                                           !BCC_EOS
13734                                           ! 2509         } else {
13735 3BE7           EB           05            jmp .34A
13736                       00003BE9            .348:
13737                                           ! 2510           regs.u.r8.ah = 0x80;
13738                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13739 3BE9           B0                     80  mov	al,#$80
13740 3BEB           8846         13            mov	$13[bp],al
13741                                           !BCC_EOS
13742                                           ! 2511         }
13743                                           ! 2512         iret_addr.flags.u.r8.flagsl &= 0xfe;
13744                       00003BEE            .34A:
13745                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13746 3BEE           8A46         1A            mov	al,$1A[bp]
13747 3BF1           24                     FE  and	al,#$FE
13748 3BF3           8846         1A            mov	$1A[bp],al
13749                                           !BCC_EOS
13750                                           ! 2513         break;
13751 3BF6           E9         00B8            br 	.339
13752                                           !BCC_EOS
13753                                           ! 2514       case 2:
13754                                           ! 2515         timer = *((Bit16u *)(0x046C));
13755                       00003BF9            .34B:
13756                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13757 3BF9           A1         046C            mov	ax,[$46C]
13758 3BFC           8946         FC            mov	-4[bp],ax
13759                                           !BCC_EOS
13760                                           ! 2516         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
13761 3BFF           EB           1B            jmp .34D
13762                       00003C01            .34E:
13763                                           ! 2517           val16 = *((Bit1
13764                                           ! 2517 6u *)(0x046C));
13765                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13766 3C01           A1         046C            mov	ax,[$46C]
13767 3C04           8946         FA            mov	-6[bp],ax
13768                                           !BCC_EOS
13769                                           ! 2518           if (val16 != timer) {
13770                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13771 3C07           8B46         FA            mov	ax,-6[bp]
13772 3C0A           3B46         FC            cmp	ax,-4[bp]
13773 3C0D           74           0D            je  	.34F
13774                       00003C0F            .350:
13775                                           ! 2519             timer = val16;
13776                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13777 3C0F           8B46         FA            mov	ax,-6[bp]
13778 3C12           8946         FC            mov	-4[bp],ax
13779                                           !BCC_EOS
13780                                           ! 2520             counter--;
13781                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13782 3C15           8A46         F9            mov	al,-7[bp]
13783 3C18           48                         dec	ax
13784 3C19           8846         F9            mov	-7[bp],al
13785                                           !BCC_EOS
13786                                           ! 2521           }
13787                                           ! 2522         }
13788                       00003C1C            .34F:
13789                                           ! 2523         if (counter > 0) {
13790                       00003C1C            .34D:
13791                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13792 3C1C           8B46         FE            mov	ax,-2[bp]
13793                                           ! Debug: list unsigned int = ax+5 (used reg = )
13794 3C1F           05                   0005  add	ax,*5
13795 3C22           50                         push	ax
13796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13797 3C23           E8         C903            call	_inb
13798 3C26           44                         inc	sp
13799 3C27           44                         inc	sp
13800                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
13801 3C28           24                     01  and	al,*1
13802                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
13803 3C2A           84C0                       test	al,al
13804 3C2C           75           07            jne 	.351
13805                       00003C2E            .352:
13806 3C2E           8A46         F9            mov	al,-7[bp]
13807 3C31           84C0                       test	al,al
13808 3C33           75           CC            jne	.34E
13809                       00003C35            .351:
13810                       00003C35            .34C:
13811                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13812 3C35           8A46         F9            mov	al,-7[bp]
13813 3C38           84C0                       test	al,al
13814 3C3A           74           1C            je  	.353
13815                       00003C3C            .354:
13816                                           ! 2524           regs.u.r8.ah = inb(addr+5);
13817                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13818 3C3C           8B46         FE            mov	ax,-2[bp]
13819                                           ! Debug: list unsigned int = ax+5 (used reg = )
13820 3C3F           05                   0005  add	ax,*5
13821 3C42           50                         push	ax
13822                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13823 3C43           E8         C8E3            call	_inb
13824 3C46           44                         inc	sp
13825 3C47           44                         inc	sp
13826                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13827 3C48           8846         13            mov	$13[bp],al
13828                                           !BCC_EOS
13829                                           ! 2525           regs.u.r8.al = inb(addr);
13830                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
13831 3C4B           FF76         FE            push	-2[bp]
13832                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13833 3C4E           E8         C8D8            call	_inb
13834 3C51           44                         inc	sp
13835 3C52           44                         inc	sp
13836                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13837 3C53           8846         12            mov	$12[bp],al
13838                                           !BCC_EOS
13839                                           ! 2526         } else {
13840 3C56           EB           05            jmp .355
13841                       00003C58            .353:
13842                                           ! 2527           regs.u.r8.ah = 0x80;
13843                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13844 3C58           B0                     80  mov	al,#$80
13845 3C5A           8846         13            mov	$13[bp],al
13846                                           !BCC_EOS
13847                                           ! 2528         }
13848                                           ! 2529         iret_addr.flags.u.r8.flagsl &= 0xfe;
13849                       00003C5D            .355:
13850                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13851 3C5D           8A46         1A            mov	al,$1A[bp]
13852 3C60           24                     FE  and	al,#$FE
13853 3C62           8846         1A            mov	$1A[bp],al
13854                                           !BCC_EOS
13855                                           ! 2530         break;
13856 3C65           EB           4A            jmp .339
13857                                           !BCC_EOS
13858                                           ! 2531       case 3:
13859                                           ! 2532         regs.u.r8.ah = inb(addr+5);
13860                       00003C67            .356:
13861                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13862 3C67           8B46         FE            mov	ax,-2[bp]
13863                                           ! Debug: list unsigned int = ax+5 (used reg = )
13864 3C6A           05                   0005  add	ax,*5
13865 3C6D           50                         push	ax
13866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13867 3C6E           E8         C8B8            call	_inb
13868 3C71           44                         inc	sp
13869 3C72           44                         inc	sp
13870                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13871 3C73           8846         13            mov	$13[bp],al
13872                                           !BCC_EOS
13873                                           ! 2533         regs.u.r8.al = inb(addr+6);
13874                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13875 3C76           8B46         FE            mov	ax,-2[bp]
13876                                           ! Debug: list unsigned int = ax+6 (used reg = )
13877 3C79           05                   0006  add	ax,*6
13878 3C7C           50                         push	ax
13879                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13880 3C7D           E8         C8A9            call	_inb
13881 3C80           44                         inc	sp
13882 3C81           44                         inc	sp
13883                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13884 3C82           8846         12            mov	$12[bp],al
13885                                           !BCC_EOS
13886                                           ! 2534         iret_addr.flags.u.r8.flagsl &= 0xfe;
13887                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13888 3C85           8A46         1A            mov	al,$1A[bp]
13889 3C88           24                     FE  and	al,#$FE
13890 3C8A           8846         1A            mov	$1A[bp],al
13891                                           !BCC_EOS
13892                                           ! 2535         break;
13893 3C8D           EB           22            jmp .339
13894                                           !BCC_EOS
13895                                           ! 2536       default:
13896                                           ! 2537         iret_addr.flags.u.r8.flagsl |= 0x01;
13897                       00003C8F            .357:
13898                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13899 3C8F           8A46         1A            mov	al,$1A[bp]
13900 3C92           0C                     01  or	al,*1
13901 3C94           8846         1A            mov	$1A[bp],al
13902                                           !BCC_EOS
13903                                           ! 2538       }
13904                                           ! 2539   } else {
13905 3C97           EB           18            jmp .339
13906                       00003C99            .33B:
13907 3C99           2C                     00  sub	al,*0
13908 3C9B         0F84         FE2D            beq 	.33C
13909 3C9F           2C                     01  sub	al,*1
13910 3CA1         0F84         FEE1            beq 	.340
13911 3CA5           2C                     01  sub	al,*1
13912 3CA7         0F84         FF4E            beq 	.34B
13913 3CAB           2C                     01  sub	al,*1
13914 3CAD           74           B8            je 	.356
13915 3CAF           EB           DE            jmp	.357
13916                       00003CB1            .339:
13917                       FFFFFFF6            ..FFF8	=	-$A
13918 3CB1           EB           08            jmp .358
13919                       00003CB3            .336:
13920                                           ! 2540     iret_addr.flags.u.r8.flagsl |= 0x01;
13921                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13922 3CB3           8A46         1A            mov	al,$1A[bp]
13923 3CB6           0C                     01  or	al,*1
13924 3CB8           8846         1A            mov	$1A[bp],al
13925                                           !BCC_EOS
13926                                           ! 2541   }
13927                                           ! 2542 }
13928                       00003CBB            .358:
13929 3CBB           89EC                       mov	sp,bp
13930 3CBD           5D                         pop	bp
13931 3CBE           C3                         ret
13932                                           ! 2543   void
13933                                           ! Register BX used in function int14_function
13934                                           ! 2544 int15_function(regs, ES, DS, FLAGS)
13935                                           ! 2545   pusha_regs_t regs;
13936                                           export	_int15_function
13937                       00003CBF            _int15_function:
13938                                           !BCC_EOS
13939                                           ! 2546   Bit16u ES, DS, FLAGS;
13940                                           !BCC_EOS
13941                                           ! 2547 {
13942                                           ! 2548   Bit16u ebda_seg=get_ebda_seg();
13943 3CBF           55                         push	bp
13944 3CC0           89E5                       mov	bp,sp
13945 3CC2           4C                         dec	sp
13946 3CC3           4C                         dec	sp
13947                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
13948 3CC4           E8         C9A0            call	_get_ebda_seg
13949                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13950 3CC7           8946         FE            mov	-2[bp],ax
13951                                           !BCC_EOS
13952                                           ! 2549   bx_bool prev_a20_enable;
13953                                           !BCC_EOS
13954                                           ! 2550   Bit16u base15_00;
13955                                           !BCC_EOS
13956                                           ! 2551   Bit8u base23_16;
13957                                           !BCC_EOS
13958                                           ! 2552   Bit16u ss;
13959                                           !BCC_EOS
13960                                           ! 2553   Bit16u BX,CX,DX;
13961                                           !BCC_EOS
13962                                           ! 2554   Bit16u bRegister;
13963                                           !BCC_EOS
13964                                           ! 2555   Bit8u irqDisable;
13965                                           !BCC_EOS
13966                                           ! 2556 ;
13967 3CCA           83C4                   EE  add	sp,*-$12
13968                                           !BCC_EOS
13969                                           ! 2557   switch (regs.u.r8.ah) {
13970 3CCD           8A46         13            mov	al,$13[bp]
13971 3CD0           E9         0482            br 	.35B
13972                                           ! 2558     case 0x24:
13973                                           ! 2559       switch (regs.u.r8.al) {
13974                       00003CD3            .35C:
13975 3CD3           8A46         12            mov	al,$12[bp]
13976 3CD6           EB           73            jmp .35F
13977                                           ! 2560         case 0x00:
13978                                           ! 2561         case 0x01:
13979                       00003CD8            .360:
13980                                           ! 2562           set_enable_a20(regs.u.r8.al);
13981                       00003CD8            .361:
13982                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
13983 3CD8           8A46         12            mov	al,$12[bp]
13984 3CDB           30E4                       xor	ah,ah
13985 3CDD           50                         push	ax
13986                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
13987 3CDE           E8         DA50            call	_set_enable_a20
13988 3CE1           44                         inc	sp
13989 3CE2           44                         inc	sp
13990                                           !BCC_EOS
13991                                           ! 2563           FLAGS &= 0xfffe;
13992                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
13993 3CE3           8B46         18            mov	ax,$18[bp]
13994 3CE6           24                     FE  and	al,#$FE
13995 3CE8           8946         18            mov	$18[bp],ax
13996                                           !BCC_EOS
13997                                           ! 2564           regs.u.r8.ah = 0;
13998                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
13999 3CEB           30C0                       xor	al,al
14000 3CED           8846         13            mov	$13[bp],al
14001                                           !BCC_EOS
14002                                           ! 2565           break;
14003 3CF0           EB           6B            jmp .35D
14004                                           !BCC_EOS
14005                                           ! 2566         case 0x02:
14006                                           ! 2567           regs.u.r8.al = (inb(0x0092) >> 1) & 0x01;
14007                       00003CF2            .362:
14008                                           ! Debug: list int = const $92 (used reg = )
14009 3CF2           B8                   0092  mov	ax,#$92
14010 3CF5           50                         push	ax
14011                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14012 3CF6           E8         C830            call	_inb
14013 3CF9           44                         inc	sp
14014 3CFA           44                         inc	sp
14015                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
14016 3CFB           30E4                       xor	ah,ah
14017 3CFD           D1E8                       shr	ax,*1
14018                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
14019 3CFF           24                     01  and	al,*1
14020                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14021 3D01           8846         12            mov	$12[bp],al
14022                                           !BCC_EOS
14023                                           ! 2568           FLAGS &= 0xfffe;
14024                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14025 3D04           8B46         18            mov	ax,$18[bp]
14026 3D07           24                     FE  and	al,#$FE
14027 3D09           8946         18            mov	$18[bp],ax
14028                                           !BCC_EOS
14029                                           ! 2569           regs.u.r8.ah = 0;
14030                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14031 3D0C           30C0                       xor	al,al
14032 3D0E           8846         13            mov	$13[bp],al
14033                                           !BCC_EOS
14034                                           ! 2570           break;
14035 3D11           EB           4A            jmp .35D
14036                                           !BCC_EOS
14037                                           ! 2571         case 0x03:
14038                                           ! 2572           FLAGS &= 0xfffe;
14039                       00003D13            .363:
14040                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14041 3D13           8B46         18            mov	ax,$18[bp]
14042 3D16           24                     FE  and	al,#$FE
14043 3D18           8946         18            mov	$18[bp],ax
14044                                           !BCC_EOS
14045                                           ! 2573           regs.u.r8.ah = 0;
14046                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14047 3D1B           30C0                       xor	al,al
14048 3D1D           8846         13            mov	$13[bp],al
14049                                           !BCC_EOS
14050                                           ! 2574           regs.u.r16.bx = 3;
14051                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
14052 3D20           B8                   0003  mov	ax,*3
14053 3D23           8946         0C            mov	$C[bp],ax
14054                                           !BCC_EOS
14055                                           ! 2575           break;
14056 3D26           EB           35            jmp .35D
14057                                           !BCC_EOS
14058                                           ! 2576         default:
14059                                           ! 2577           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
14060                       00003D28            .364:
14061                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14062 3D28           8A46         12            mov	al,$12[bp]
14063 3D2B           30E4                       xor	ah,ah
14064 3D2D           50                         push	ax
14065                                           ! Debug: list * char = .365+0 (used reg = )
14066 3D2E           BB                   D576  mov	bx,#.365
14067 3D31           53                         push	bx
14068                                           ! Debug: list int = const 4 (used reg = )
14069 3D32           B8                   0004  mov	ax,*4
14070 3D35           50                         push	ax
14071                                           ! Debug: func () void = bios_printf+0 (used reg = )
14072 3D36           E8         CC00            call	_bios_printf
14073 3D39           83C4                   06  add	sp,*6
14074                                           !BCC_EOS
14075                                           ! 2578           FLAGS |= 0x0001;
14076                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14077 3D3C           8B46         18            mov	ax,$18[bp]
14078 3D3F           0C                     01  or	al,*1
14079 3D41           8946         18            mov	$18[bp],ax
14080                                           !BCC_EOS
14081                                           ! 2579           regs.u.r8.ah = 0x86;
14082                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14083 3D44           B0                     86  mov	al,#$86
14084 3D46           8846         13            mov	$13[bp],al
14085                                           !BCC_EOS
14086                                           ! 2580       }
14087                                           ! 2581       break;
14088 3D49           EB           12            jmp .35D
14089                       00003D4B            .35F:
14090 3D4B           2C                     00  sub	al,*0
14091 3D4D           74           89            je 	.360
14092 3D4F           2C                     01  sub	al,*1
14093 3D51           74           85            je 	.361
14094 3D53           2C                     01  sub	al,*1
14095 3D55           74           9B            je 	.362
14096 3D57           2C                     01  sub	al,*1
14097 3D59           74           B8            je 	.363
14098 3D5B           EB           CB            jmp	.364
14099                       00003D5D            .35D:
14100 3D5D           E9         043F            br 	.359
14101                                           !BCC_EOS
14102                                           ! 2582     case 0x41:
14103                                           ! 2583       FLAGS |= 0x0001;
14104                       00003D60            .366:
14105                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14106 3D60           8B46         18            mov	ax,$18[bp]
14107 3D63           0C                     01  or	al,*1
14108 3D65           8946         18            mov	$18[bp],ax
14109                                           !BCC_EOS
14110                                           ! 2584       regs.u.r8.ah = 0x86;
14111                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14112 3D68           B0                     86  mov	al,#$86
14113 3D6A           8846         13            mov	$13[bp],al
14114                                           !BCC_EOS
14115                                           ! 2585       break;
14116 3D6D           E9         042F            br 	.359
14117                                           !BCC_EOS
14118                                           ! 2586     case 0x4f:
14119                                           ! 2587       FLAGS |= 0x0001;
14120                       00003D70            .367:
14121                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14122 3D70           8B46         18            mov	ax,$18[bp]
14123 3D73           0C                     01  or	al,*1
14124 3D75           8946         18            mov	$18[bp],ax
14125                                           !BCC_EOS
14126                                           ! 2588       break;
14127 3D78           E9         0424            br 	.359
14128                                           !BCC_EOS
14129                                           ! 2589     case 0x52:
14130                                           ! 2590       FLAGS &= 0xfffe;
14131                       00003D7B            .368:
14132                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14133 3D7B           8B46         18            mov	ax,$18[bp]
14134 3D7E           24                     FE  and	al,#$FE
14135 3D80           8946         18            mov	$18[bp],ax
14136                                           !BCC_EOS
14137                                           ! 2591       regs.u.r8.ah = 0;
14138                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14139 3D83           30C0                       xor	al,al
14140 3D85           8846         13            mov	$13[bp],al
14141                                           !BCC_EOS
14142                                           ! 2592       break;
14143 3D88           E9         0414            br 	.359
14144                                           !BCC_EOS
14145                                           ! 2593     case 0x83: {
14146                       00003D8B            .369:
14147                                           ! 2594       set_DS(0x40);
14148                                           ! Debug: list int = const $40 (used reg = )
14149 3D8B           B8                   0040  mov	ax,*$40
14150 3D8E           50                         push	ax
14151                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14152 3D8F           E8         C8CB            call	_set_DS
14153 3D92           44                         inc	sp
14154 3D93           44                         inc	sp
14155                                           !BCC_EOS
14156                                           ! 2595       if( regs.u.r8.al == 0 ) {
14157                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
14158 3D94           8A46         12            mov	al,$12[bp]
14159 3D97           84C0                       test	al,al
14160 3D99           75           7B            jne 	.36A
14161                       00003D9B            .36B:
14162                                           ! 2596         if( ( *((Bit8u *)(0xA0)) & 1 ) == 0 ) {
14163                                           ! Debug: and int = const 1 to unsigned char = [+$A0] (used reg = )
14164 3D9B           A0         00A0            mov	al,[$A0]
14165 3D9E           24                     01  and	al,*1
14166                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14167 3DA0           84C0                       test	al,al
14168 3DA2           75           63            jne 	.36C
14169                       00003DA4            .36D:
14170                                           ! 2597           *((Bit8u *)(0xA0)) = (1);
14171                                           ! Debug: eq int = const 1 to unsigned char = [+$A0] (used reg = )
14172 3DA4           B0                     01  mov	al,*1
14173 3DA6           A2         00A0            mov	[$A0],al
14174                                           !BCC_EOS
14175                                           ! 2598           *((Bit16u *)(0x98)) = (ES);
14176                                           ! Debug: eq unsigned short ES = [S+$16+$12] to unsigned short = [+$98] (used reg = )
14177 3DA9           8B46         14            mov	ax,$14[bp]
14178 3DAC           A3         0098            mov	[$98],ax
14179                                           !BCC_EOS
14180                                           ! 2599           *((Bit16u *)(0x9A)) = (regs.u.r16.bx);
14181                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short = [+$9A] (used reg = )
14182 3DAF           8B46         0C            mov	ax,$C[bp]
14183 3DB2           A3         009A            mov	[$9A],ax
14184                                           !BCC_EOS
14185                                           ! 2600           *((Bit16u *)(0x9C)) 
14186                                           ! 2600 = (regs.u.r16.dx);
14187                                           ! Debug: eq unsigned short regs = [S+$16+$C] to unsigned short = [+$9C] (used reg = )
14188 3DB5           8B46         0E            mov	ax,$E[bp]
14189 3DB8           A3         009C            mov	[$9C],ax
14190                                           !BCC_EOS
14191                                           ! 2601           *((Bit16u *)(0x9E)) = (regs.u.r16.cx);
14192                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short = [+$9E] (used reg = )
14193 3DBB           8B46         10            mov	ax,$10[bp]
14194 3DBE           A3         009E            mov	[$9E],ax
14195                                           !BCC_EOS
14196                                           ! 2602           FLAGS &= 0xfffe;
14197                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14198 3DC1           8B46         18            mov	ax,$18[bp]
14199 3DC4           24                     FE  and	al,#$FE
14200 3DC6           8946         18            mov	$18[bp],ax
14201                                           !BCC_EOS
14202                                           ! 2603           irqDisable = inb( 0x00a1 );
14203                                           ! Debug: list int = const $A1 (used reg = )
14204 3DC9           B8                   00A1  mov	ax,#$A1
14205 3DCC           50                         push	ax
14206                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14207 3DCD           E8         C759            call	_inb
14208 3DD0           44                         inc	sp
14209 3DD1           44                         inc	sp
14210                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
14211 3DD2           8846         ED            mov	-$13[bp],al
14212                                           !BCC_EOS
14213                                           ! 2604           outb( 0x00a1, irqDisable & 0xFE );
14214                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
14215 3DD5           8A46         ED            mov	al,-$13[bp]
14216 3DD8           24                     FE  and	al,#$FE
14217                                           ! Debug: list unsigned char = al+0 (used reg = )
14218 3DDA           30E4                       xor	ah,ah
14219 3DDC           50                         push	ax
14220                                           ! Debug: list int = const $A1 (used reg = )
14221 3DDD           B8                   00A1  mov	ax,#$A1
14222 3DE0           50                         push	ax
14223                                           ! Debug: func () void = outb+0 (used reg = )
14224 3DE1           E8         C75B            call	_outb
14225 3DE4           83C4                   04  add	sp,*4
14226                                           !BCC_EOS
14227                                           ! 2605           bRegister = inb_cmos( 0xB );
14228                                           ! Debug: list int = const $B (used reg = )
14229 3DE7           B8                   000B  mov	ax,*$B
14230 3DEA           50                         push	ax
14231                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14232 3DEB           E8         C780            call	_inb_cmos
14233 3DEE           44                         inc	sp
14234 3DEF           44                         inc	sp
14235                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14236 3DF0           30E4                       xor	ah,ah
14237 3DF2           8946         EE            mov	-$12[bp],ax
14238                                           !BCC_EOS
14239                                           ! 2606           outb_cmos( 0xB, bRegister | 0x40 );
14240                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
14241 3DF5           8B46         EE            mov	ax,-$12[bp]
14242 3DF8           0C                     40  or	al,*$40
14243                                           ! Debug: list unsigned int = ax+0 (used reg = )
14244 3DFA           50                         push	ax
14245                                           ! Debug: list int = const $B (used reg = )
14246 3DFB           B8                   000B  mov	ax,*$B
14247 3DFE           50                         push	ax
14248                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14249 3DFF           E8         C75D            call	_outb_cmos
14250 3E02           83C4                   04  add	sp,*4
14251                                           !BCC_EOS
14252                                           ! 2607         } else {
14253 3E05           EB           0D            jmp .36E
14254                       00003E07            .36C:
14255                                           ! 2608           ;
14256                                           !BCC_EOS
14257                                           ! 2609           FLAGS |= 0x0001;
14258                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14259 3E07           8B46         18            mov	ax,$18[bp]
14260 3E0A           0C                     01  or	al,*1
14261 3E0C           8946         18            mov	$18[bp],ax
14262                                           !BCC_EOS
14263                                           ! 2610           regs.u.r8.ah = 0x86;
14264                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14265 3E0F           B0                     86  mov	al,#$86
14266 3E11           8846         13            mov	$13[bp],al
14267                                           !BCC_EOS
14268                                           ! 2611         }
14269                                           ! 2612       } else if( regs.u.r8.al == 1 ) {
14270                       00003E14            .36E:
14271 3E14           EB           48            jmp .36F
14272                       00003E16            .36A:
14273                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
14274 3E16           8A46         12            mov	al,$12[bp]
14275 3E19           3C                     01  cmp	al,*1
14276 3E1B           75           2D            jne 	.370
14277                       00003E1D            .371:
14278                                           ! 2613         *((Bit8u *)(0xA0)) = (0);
14279                                           ! Debug: eq int = const 0 to unsigned char = [+$A0] (used reg = )
14280 3E1D           30C0                       xor	al,al
14281 3E1F           A2         00A0            mov	[$A0],al
14282                                           !BCC_EOS
14283                                           ! 2614         FLAGS &= 0xfffe;
14284                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14285 3E22           8B46         18            mov	ax,$18[bp]
14286 3E25           24                     FE  and	al,#$FE
14287 3E27           8946         18            mov	$18[bp],ax
14288                                           !BCC_EOS
14289                                           ! 2615         bRegister = inb_cmos( 0xB );
14290                                           ! Debug: list int = const $B (used reg = )
14291 3E2A           B8                   000B  mov	ax,*$B
14292 3E2D           50                         push	ax
14293                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14294 3E2E           E8         C73D            call	_inb_cmos
14295 3E31           44                         inc	sp
14296 3E32           44                         inc	sp
14297                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14298 3E33           30E4                       xor	ah,ah
14299 3E35           8946         EE            mov	-$12[bp],ax
14300                                           !BCC_EOS
14301                                           ! 2616         outb_cmos( 0xB, bRegister & ~0x40 );
14302                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
14303 3E38           8B46         EE            mov	ax,-$12[bp]
14304 3E3B           24                     BF  and	al,#$BF
14305                                           ! Debug: list unsigned int = ax+0 (used reg = )
14306 3E3D           50                         push	ax
14307                                           ! Debug: list int = const $B (used reg = )
14308 3E3E           B8                   000B  mov	ax,*$B
14309 3E41           50                         push	ax
14310                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14311 3E42           E8         C71A            call	_outb_cmos
14312 3E45           83C4                   04  add	sp,*4
14313                                           !BCC_EOS
14314                                           ! 2617       } else {
14315 3E48           EB           14            jmp .372
14316                       00003E4A            .370:
14317                                           ! 2618         ;
14318                                           !BCC_EOS
14319                                           ! 2619         FLAGS |= 0x0001;
14320                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14321 3E4A           8B46         18            mov	ax,$18[bp]
14322 3E4D           0C                     01  or	al,*1
14323 3E4F           8946         18            mov	$18[bp],ax
14324                                           !BCC_EOS
14325                                           ! 2620         regs.u.r8.ah = 0x86;
14326                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14327 3E52           B0                     86  mov	al,#$86
14328 3E54           8846         13            mov	$13[bp],al
14329                                           !BCC_EOS
14330                                           ! 2621         regs.u.r8.al--;
14331                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
14332 3E57           8A46         12            mov	al,$12[bp]
14333 3E5A           48                         dec	ax
14334 3E5B           8846         12            mov	$12[bp],al
14335                                           !BCC_EOS
14336                                           ! 2622       }
14337                                           ! 2623       break;
14338                       00003E5E            .372:
14339                       00003E5E            .36F:
14340 3E5E           E9         033E            br 	.359
14341                                           !BCC_EOS
14342                                           ! 2624     }
14343                                           ! 2625     case 0x87:
14344                                           ! 2626 #asm
14345                       00003E61            .373:
14346                                           !BCC_EOS
14347                                           !BCC_ASM
14348                       00000006            _int15_function.CX	set	6
14349                       FFFFFFF2            .int15_function.CX	set	-$E
14350                       0000002C            _int15_function.FLAGS	set	$2C
14351                       00000018            .int15_function.FLAGS	set	$18
14352                       00000001            _int15_function.irqDisable	set	1
14353                       FFFFFFED            .int15_function.irqDisable	set	-$13
14354                       0000002A            _int15_function.DS	set	$2A
14355                       00000016            .int15_function.DS	set	$16
14356                       00000004            _int15_function.DX	set	4
14357                       FFFFFFF0            .int15_function.DX	set	-$10
14358                       0000000D            _int15_function.base23_16	set	$D
14359                       FFFFFFF9            .int15_function.base23_16	set	-7
14360                       00000002            _int15_function.bRegister	set	2
14361                       FFFFFFEE            .int15_function.bRegister	set	-$12
14362                       00000028            _int15_function.ES	set	$28
14363                       00000014            .int15_function.ES	set	$14
14364                       00000012            _int15_function.ebda_seg	set	$12
14365                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14366                       0000000E            _int15_function.base15_00	set	$E
14367                       FFFFFFFA            .int15_function.base15_00	set	-6
14368                       0000000A            _int15_function.ss	set	$A
14369                       FFFFFFF6            .int15_function.ss	set	-$A
14370                       00000008            _int15_function.BX	set	8
14371                       FFFFFFF4            .int15_function.BX	set	-$C
14372                       00000018            _int15_function.regs	set	$18
14373                       00000004            .int15_function.regs	set	4
14374                       00000010            _int15_function.prev_a20_enable	set	$10
14375                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14376 3E61           FA                           cli
14377                                           ! 2628 endasm
14378                                           !BCC_ENDASM
14379                                           !BCC_EOS
14380                                           ! 2629       prev_a20_enable = set_enable_a20(1);
14381                                           ! Debug: list int = const 1 (used reg = )
14382 3E62           B8                   0001  mov	ax,*1
14383 3E65           50                         push	ax
14384                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14385 3E66           E8         D8C8            call	_set_enable_a20
14386 3E69           44                         inc	sp
14387 3E6A           44                         inc	sp
14388                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14389 3E6B           8946         FC            mov	-4[bp],ax
14390                                           !BCC_EOS
14391                                           ! 2630       base15_00 = (ES << 4) + regs.u.r16.si;
14392                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14393 3E6E           8B46         14            mov	ax,$14[bp]
14394 3E71           B1                     04  mov	cl,*4
14395 3E73           D3E0                       shl	ax,cl
14396                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
14397 3E75           0346         06            add	ax,6[bp]
14398                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14399 3E78           8946         FA            mov	-6[bp],ax
14400                                           !BCC_EOS
14401                                           ! 2631       base23_16 = ES >> 12;
14402                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
14403 3E7B           8B46         14            mov	ax,$14[bp]
14404 3E7E           88E0                       mov	al,ah
14405 3E80           30E4                       xor	ah,ah
14406 3E82           B1                     04  mov	cl,*4
14407 3E84           D3E8                       shr	ax,cl
14408                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14409 3E86           8846         F9            mov	-7[bp],al
14410                                           !BCC_EOS
14411                                           ! 2632       if (base15_00 < (ES<<4))
14412                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14413 3E89           8B46         14            mov	ax,$14[bp]
14414 3E8C           B1                     04  mov	cl,*4
14415 3E8E           D3E0                       shl	ax,cl
14416                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14417 3E90           3B46         FA            cmp	ax,-6[bp]
14418 3E93           76           07            jbe 	.374
14419                       00003E95            .375:
14420                                           ! 2633         base23_16++;
14421                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
14422 3E95           8A46         F9            mov	al,-7[bp]
14423 3E98           40                         inc	ax
14424 3E99           8846         F9            mov	-7[bp],al
14425                                           !BCC_EOS
14426                                           ! 2634       set_DS(ES);
14427                       00003E9C            .374:
14428                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14429 3E9C           FF76         14            push	$14[bp]
14430                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14431 3E9F           E8         C7BB            call	_set_DS
14432 3EA2           44                         inc	sp
14433 3EA3           44                         inc	sp
14434                                           !BCC_EOS
14435                                           ! 2635       *((Bit16u *)(regs.u.r16.si+0x08+0)) = (47);
14436                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14437 3EA4           8B46         06            mov	ax,6[bp]
14438                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
14439                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
14440 3EA7           89C3                       mov	bx,ax
14441                                           ! Debug: eq int = const $2F to unsigned short = [bx+8] (used reg = )
14442 3EA9           B8                   002F  mov	ax,*$2F
14443 3EAC           8947         08            mov	8[bx],ax
14444                                           !BCC_EOS
14445                                           ! 2636       *((Bit16u *)(regs.u.r16.si+0x08+2)) = (base15_00);
14446                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14447 3EAF           8B46         06            mov	ax,6[bp]
14448                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
14449                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
14450 3EB2           89C3                       mov	bx,ax
14451                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$A] (used reg = )
14452 3EB4           8B46         FA            mov	ax,-6[bp]
14453 3EB7           8947         0A            mov	$A[bx],ax
14454                                           !BCC_EOS
14455                                           ! 2637       *((Bit8u *)(regs.u.r16.si+0x08+4)) = (base23_16);
14456                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14457 3EBA           8B46         06            mov	ax,6[bp]
14458                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
14459                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$C (used reg = )
14460 3EBD           89C3                       mov	bx,ax
14461                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$C] (used reg = )
14462 3EBF           8A46         F9            mov	al,-7[bp]
14463 3EC2           8847         0C            mov	$C[bx],al
14464                                           !BCC_EOS
14465                                           ! 2638       *((Bit8u *)(regs.u.r16.si+0x08+5)) = (0x93);
14466                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14467 3EC5           8B46         06            mov	ax,6[bp]
14468                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
14469                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$D (used reg = )
14470 3EC8           89C3                       mov	bx,ax
14471                                           ! Debug: eq int = const $93 to unsigned char = [bx+$D] (used reg = )
14472 3ECA           B0                     93  mov	al,#$93
14473 3ECC           8847         0D            mov	$D[bx],al
14474                                           !BCC_EOS
14475                                           ! 2639       *((Bit16u *)(regs.u.r16.si+0x08+6)) = (0x0000);
14476                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14477 3ECF           8B46         06            mov	ax,6[bp]
14478                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
14479                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
14480 3ED2           89C3                       mov	bx,ax
14481                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
14482 3ED4           31C0                       xor	ax,ax
14483 3ED6           8947         0E            mov	$E[bx],ax
14484                                           !BCC_EOS
14485                                           ! 2640       *((Bit16u *)(regs.u.r16.si+0x20+0)) = (0xffff);
14486                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14487 3ED9           8B46         06            mov	ax,6[bp]
14488                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
14489                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$20 (used reg = )
14490 3EDC           89C3                       mov	bx,ax
14491                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$20] (used reg = )
14492 3EDE           B8                   FFFF  mov	ax,#$FFFF
14493 3EE1           8947         20            mov	$20[bx],ax
14494                                           !BCC_EOS
14495                                           ! 2641       *((Bit16u *)(regs.u.r16.si+0x20+2)) = (0x0000);
14496                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14497 3EE4           8B46         06            mov	ax,6[bp]
14498                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
14499                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
14500 3EE7           89C3                       mov	bx,ax
14501                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
14502 3EE9           31C0                       xor	ax,ax
14503 3EEB           8947         22            mov	$22[bx],ax
14504                                           !BCC_EOS
14505                                           ! 2642       *((Bit8u *)(regs.u.r16.si+0x20+4)) = (0x000f);
14506                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14507 3EEE           8B46         06            mov	ax,6[bp]
14508                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
14509                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
14510 3EF1           89C3                       mov	bx,ax
14511                                           ! Debug: eq int = const $F to unsigned char = [bx+$24] (used reg = )
14512 3EF3           B0                     0F  mov	al,*$F
14513 3EF5           8847         24            mov	$24[bx],al
14514                                           !BCC_EOS
14515                                           ! 2643       *((Bit8u *)(regs.u.r16.si+0x20+5)) = (0x9b);
14516                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14517 3EF8           8B46         06            mov	ax,6[bp]
14518                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
14519                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
14520 3EFB           89C3                       mov	bx,ax
14521                                           ! Debug: eq int = const $9B to unsigned char = [bx+$25] (used reg = )
14522 3EFD           B0                     9B  mov	al,#$9B
14523 3EFF           8847         25            mov	$25[bx],al
14524                                           !BCC_EOS
14525                                           ! 2644       *((Bit16u *)(regs.u.r16.si+0x20+6)) = (0x0000);
14526                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14527 3F02           8B46         06            mov	ax,6[bp]
14528                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
14529                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$26 (used reg = )
14530 3F05           89C3                       mov	bx,ax
14531                                           ! Debug: eq int = const 0 to unsigned short = [bx+$26] (used reg = )
14532 3F07           31C0                       xor	ax,ax
14533 3F09           8947         26            mov	$26[bx],ax
14534                                           !BCC_EOS
14535                                           ! 2645       ss = get_SS();
14536                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14537 3F0C           E8         C74B            call	_get_SS
14538                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
14539 3F0F           8946         F6            mov	-$A[bp],ax
14540                                           !BCC_EOS
14541                                           ! 2646       base15_00 = ss << 4;
14542                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
14543 3F12           8B46         F6            mov	ax,-$A[bp]
14544 3F15           B1                     04  mov	cl,*4
14545 3F17           D3E0                       shl	ax,cl
14546                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14547 3F19           8946         FA            mov	-6[bp],ax
14548                                           !BCC_EOS
14549                                           ! 2647       base23_16 = ss >> 12;
14550                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
14551 3F1C           8B46         F6            mov	ax,-$A[bp]
14552 3F1F           88E0                       mov	al,ah
14553 3F21           30E4                       xor	ah,ah
14554 3F23           B1                     04  mov	cl,*4
14555 3F25           D3E8                       shr	ax,cl
14556                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14557 3F27           8846         F9            mov	-7[bp],al
14558                                           !BCC_EOS
14559                                           ! 2648       *((Bit16u *)(regs.u.r16.si+0x28+0)) = (0xffff);
14560                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14561 3F2A           8B46         06            mov	ax,6[bp]
14562                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
14563                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$28 (used reg = )
14564 3F2D           89C3                       mov	bx,ax
14565                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$28] (used reg = )
14566 3F2F           B8                   FFFF  mov	ax,#$FFFF
14567 3F32           8947         28            mov	$28[bx],ax
14568                                           !BCC_EOS
14569                                           ! 2649       *((Bit16u *)(regs.u.r16.si+0x28+2)) = (base15_00);
14570                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14571 3F35           8B46         06            mov	ax,6[bp]
14572                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
14573                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2A (used reg = )
14574 3F38           89C3                       mov	bx,ax
14575                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$2A] (used reg = )
14576 3F3A           8B46         FA            mov	ax,-6[bp]
14577 3F3D           8947         2A            mov	$2A[bx],ax
14578                                           !BCC_EOS
14579                                           ! 2650       *((Bit8u *)(regs.u.r16.si+0x28+4)) = (base23_16);
14580                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14581 3F40           8B46         06            mov	ax,6[bp]
14582                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
14583                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
14584 3F43           89C3                       mov	bx,ax
14585                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$2C] (used reg = )
14586 3F45           8A46         F9            mov	al,-7[bp]
14587 3F48           8847         2C            mov	$2C[bx],al
14588                                           !BCC_EOS
14589                                           ! 2651       *((Bit8u *)(regs.u.r16.si+0x28+5)) = (0x93);
14590                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14591 3F4B           8B46         06            mov	ax,6[bp]
14592                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
14593                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
14594 3F4E           89C3                       mov	bx,ax
14595                                           ! Debug: eq int = const $93 to unsigned char = [bx+$2D] (used reg = )
14596 3F50           B0                     93  mov	al,#$93
14597 3F52           8847         2D            mov	$2D[bx],al
14598                                           !BCC_EOS
14599                                           ! 2652       *((Bit16u *)(regs.u.r16.si+0x28+6)) = (0x0000);
14600                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14601 3F55           8B46         06            mov	ax,6[bp]
14602                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
14603                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2E (used reg = )
14604 3F58           89C3                       mov	bx,ax
14605                                           ! Debug: eq int = const 0 to unsigned short = [bx+$2E] (used reg = )
14606 3F5A           31C0                       xor	ax,ax
14607 3F5C           8947         2E            mov	$2E[bx],ax
14608                                           !BCC_EOS
14609                                           ! 2653       CX = regs.u.r16.cx;
14610                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
14611 3F5F           8B46         10            mov	ax,$10[bp]
14612 3F62           8946         F2            mov	-$E[bp],ax
14613                                           !BCC_EOS
14614                                           ! 2654 #asm
14615                                           !BCC_EOS
14616                                           !BCC_ASM
14617                       00000006            _int15_function.CX	set	6
14618                       FFFFFFF2            .int15_function.CX	set	-$E
14619                       0000002C            _int15_function.FLAGS	set	$2C
14620                       00000018            .int15_function.FLAGS	set	$18
14621                       00000001            _int15_function.irqDisable	set	1
14622                       FFFFFFED            .int15_function.irqDisable	set	-$13
14623                       0000002A            _int15_function.DS	set	$2A
14624                       00000016            .int15_function.DS	set	$16
14625                       00000004            _int15_function.DX	set	4
14626                       FFFFFFF0            .int15_function.DX	set	-$10
14627                       0000000D            _int15_function.base23_16	set	$D
14628                       FFFFFFF9            .int15_function.base23_16	set	-7
14629                       00000002            _int15_function.bRegister	set	2
14630                       FFFFFFEE            .int15_function.bRegister	set	-$12
14631                       00000028            _int15_function.ES	set	$28
14632                       00000014            .int15_function.ES	set	$14
14633                       00000012            _int15_function.ebda_seg	set	$12
14634                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14635                       0000000E            _int15_function.base15_00	set	$E
14636                       FFFFFFFA            .int15_function.base15_00	set	-6
14637                       0000000A            _int15_function.ss	set	$A
14638                       FFFFFFF6            .int15_function.ss	set	-$A
14639                       00000008            _int15_function.BX	set	8
14640                       FFFFFFF4            .int15_function.BX	set	-$C
14641                       00000018            _int15_function.regs	set	$18
14642                       00000004            .int15_function.regs	set	4
14643                       00000010            _int15_function.prev_a20_enable	set	$10
14644                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14645 3F65           89E3                             mov bx, sp
14646 3F67           36                               SEG SS
14647 3F68           8B4F         06                    mov cx, _int15_function.CX [bx]
14648 3F6B     66    50                               push eax
14649 3F6D     66    31C0                             xor eax, eax
14650 3F70           8ED8                             mov ds, ax
14651 3F72           8C16       0469                  mov 0x0469, ss
14652 3F76           8926       0467                  mov 0x0467, sp
14653 3F7A           26                               SEG ES
14654 3F7B         0F0154         08                    lgdt [si + 0x08]
14655 3F7F           2E                               SEG CS
14656 3F80         0F011E       F8AB                    lidt [pmode_IDT_info]
14657                                                 ;; perhaps do something with IDT here
14658                                                 ;; set PE bit in CR0
14659 3F85         0F20C0                             mov eax, cr0
14660 3F88           0C                     01        or al, #0x01
14661 3F8A         0F22C0                             mov cr0, eax
14662                                                 ;; far jump to flush CPU queue after transition to protected mode
14663                                                 JMP_AP(0x0020, protected_mode)
 +a   3F8D                        EA              db 0xea
 +a   3F8E                      3F92              dw  protected_mode
 +a   3F90                      0020              dw 0x0020
14664                       00003F92            protected_mode:
14665                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14666 3F92           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
14667 3F95           8ED0                             mov ss, ax
14668 3F97           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
14669 3F9A           8ED8                             mov ds, ax
14670 3F9C           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
14671 3F9F           8EC0                             mov es, ax
14672 3FA1           31F6                             xor si, si
14673 3FA3           31FF                             xor di, di
14674 3FA5           FC                               cld
14675 3FA6           F3                               rep
14676 3FA7           A5                                 movsw ;; move CX words from DS:SI to ES:DI
14677                                                 ;; make sure DS and ES limits are 64KB
14678 3FA8           B8                   0028        mov ax, #0x28
14679 3FAB           8ED8                             mov ds, ax
14680 3FAD           8EC0                             mov es, ax
14681                                                 ;; reset PG bit in CR0 ???
14682 3FAF         0F20C0                             mov eax, cr0
14683 3FB2           24                     FE        and al, #0xFE
14684 3FB4         0F22C0                             mov cr0, eax
14685                                                 ;; far jump to flush CPU queue after transition to real mode
14686                                                 JMP_AP(0xf000, real_mode)
 +a   3FB7                        EA              db 0xea
 +a   3FB8                      3FBC              dw  real_mode
 +a   3FBA                      F000              dw 0xf000
14687                       00003FBC            real_mode:
14688                                                 ;; restore IDT to normal real-mode defaults
14689 3FBC           2E                               SEG CS
14690 3FBD         0F011E       F8B1                    lidt [rmode_IDT_info]
14691 3FC2           31C0                             xor ax, ax
14692 3FC4           8ED8                             mov ds, ax
14693 3FC6           8E16       0469                  mov ss, 0x0469
14694 3FCA           8B26       0467                  mov sp, 0x0467
14695 3FCE     66    58                               pop eax
14696                                           ! 2706 endasm
14697                                           !BCC_ENDASM
14698                                           !BCC_EOS
14699                                           ! 2707       set_enable_a20(prev_a20_enable);
14700                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14701 3FD0           FF76         FC            push	-4[bp]
14702                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14703 3FD3           E8         D75B            call	_set_enable_a20
14704 3FD6           44                         inc	sp
14705 3FD7           44                         inc	sp
14706                                           !BCC_EOS
14707                                           ! 2708 #asm
14708                                           !BCC_EOS
14709                                           !BCC_ASM
14710                       00000006            _int15_function.CX	set	6
14711                       FFFFFFF2            .int15_function.CX	set	-$E
14712                       0000002C            _int15_function.FLAGS	set	$2C
14713                       00000018            .int15_function.FLAGS	set	$18
14714                       00000001            _int15_function.irqDisable	set	1
14715                       FFFFFFED            .int15_function.irqDisable	set	-$13
14716                       0000002A            _int15_function.DS	set	$2A
14717                       00000016            .int15_function.DS	set	$16
14718                       00000004            _int15_function.DX	set	4
14719                       FFFFFFF0            .int15_function.DX	set	-$10
14720                       0000000D            _int15_function.base23_16	set	$D
14721                       FFFFFFF9            .int15_function.base23_16	set	-7
14722                       00000002            _int15_function.bRegister	set	2
14723                       FFFFFFEE            .int15_function.bRegister	set	-$12
14724                       00000028            _int15_function.ES	set	$28
14725                       00000014            .int15_function.ES	set	$14
14726                       00000012            _int15_function.ebda_seg	set	$12
14727                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14728                       0000000E            _int15_function.base15_00	set	$E
14729                       FFFFFFFA            .int15_function.base15_00	set	-6
14730                       0000000A            _int15_function.ss	set	$A
14731                       FFFFFFF6            .int15_function.ss	set	-$A
14732                       00000008            _int15_function.BX	set	8
14733                       FFFFFFF4            .int15_function.BX	set	-$C
14734                       00000018            _int15_function.regs	set	$18
14735                       00000004            .int15_function.regs	set	4
14736                       00000010            _int15_function.prev_a20_enable	set	$10
14737                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14738 3FD8           FB                           sti
14739                                           ! 2710 endasm
14740                                           !BCC_ENDASM
14741                                           !BCC_EOS
14742                                           ! 2711       regs.u.r8.ah = 0;
14743                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14744 3FD9           30C0                       xor	al,al
14745 3FDB           8846         13            mov	$13[bp],al
14746                                           !BCC_EOS
14747                                           ! 2712       FLAGS &= 0xfffe;
14748                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14749 3FDE           8B46         18            mov	ax,$18[bp]
14750 3FE1           24                     FE  and	al,#$FE
14751 3FE3           8946         18            mov	$18[bp],ax
14752                                           !BCC_EOS
14753                                           ! 2713       break;
14754 3FE6           E9         01B6            br 	.359
14755                                           !BCC_EOS
14756                                           ! 2714     case 0x88:
14757                                           ! 2715       regs.u.r8.al = inb_cmos(0x30);
14758                       00003FE9            .376:
14759                                           ! Debug: list int = const $30 (used reg = )
14760 3FE9           B8                   0030  mov	ax,*$30
14761 3FEC           50                         push	ax
14762                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14763 3FED           E8         C57E            call	_inb_cmos
14764 3FF0           44                         inc	sp
14765 3FF1           44                         inc	sp
14766                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14767 3FF2           8846         12            mov	$12[bp],al
14768                                           !BCC_EOS
14769                                           ! 2716       regs.u.r8.ah = inb_cmos(0x31);
14770                                           ! Debug: list int = const $31 (used reg = )
14771 3FF5           B8                   0031  mov	ax,*$31
14772 3FF8           50                         push	ax
14773                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14774 3FF9           E8         C572            call	_inb_cmos
14775 3FFC           44                         inc	sp
14776 3FFD           44                         inc	sp
14777                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
14778 3FFE           8846         13            mov	$13[bp],al
14779                                           !BCC_EOS
14780                                           ! 2717       if(regs.u.r16.ax > 0xffc0)
14781                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14782 4001           8B46         12            mov	ax,$12[bp]
14783 4004           3D                   FFC0  cmp	ax,#$FFC0
14784 4007           76           06            jbe 	.377
14785                       00004009            .378:
14786                                           ! 2718         regs.u.r16.ax = 0xffc0;
14787                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14788 4009           B8                   FFC0  mov	ax,#$FFC0
14789 400C           8946         12            mov	$12[bp],ax
14790                                           !BCC_EOS
14791                                           ! 2719       FLAGS &= 0xfffe;
14792                       0000400F            .377:
14793                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14794 400F           8B46         18            mov	ax,$18[bp]
14795 4012           24                     FE  and	al,#$FE
14796 4014           8946         18            mov	$18[bp],ax
14797                                           !BCC_EOS
14798                                           ! 2720       break;
14799 4017           E9         0185            br 	.359
14800                                           !BCC_EOS
14801                                           ! 2721   case 0x89:
14802                                           ! 2722 #asm
14803                       0000401A            .379:
14804                                           !BCC_EOS
14805                                           !BCC_ASM
14806                       00000006            _int15_function.CX	set	6
14807                       FFFFFFF2            .int15_function.CX	set	-$E
14808                       0000002C            _int15_function.FLAGS	set	$2C
14809                       00000018            .int15_function.FLAGS	set	$18
14810                       00000001            _int15_function.irqDisable	set	1
14811                       FFFFFFED            .int15_function.irqDisable	set	-$13
14812                       0000002A            _int15_function.DS	set	$2A
14813                       00000016            .int15_function.DS	set	$16
14814                       00000004            _int15_function.DX	set	4
14815                       FFFFFFF0            .int15_function.DX	set	-$10
14816                       0000000D            _int15_function.base23_16	set	$D
14817                       FFFFFFF9            .int15_function.base23_16	set	-7
14818                       00000002            _int15_function.bRegister	set	2
14819                       FFFFFFEE            .int15_function.bRegister	set	-$12
14820                       00000028            _int15_function.ES	set	$28
14821                       00000014            .int15_function.ES	set	$14
14822                       00000012            _int15_function.ebda_seg	set	$12
14823                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14824                       0000000E            _int15_function.base15_00	set	$E
14825                       FFFFFFFA            .int15_function.base15_00	set	-6
14826                       0000000A            _int15_function.ss	set	$A
14827                       FFFFFFF6            .int15_function.ss	set	-$A
14828                       00000008            _int15_function.BX	set	8
14829                       FFFFFFF4            .int15_function.BX	set	-$C
14830                       00000018            _int15_function.regs	set	$18
14831                       00000004            .int15_function.regs	set	4
14832                       00000010            _int15_function.prev_a20_enable	set	$10
14833                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14834 401A           FA                           cli
14835                                           ! 2724 endasm
14836                                           !BCC_ENDASM
14837                                           !BCC_EOS
14838                                           ! 2725       set_enable_a20(1);
14839                                           ! Debug: list int = const 1 (used reg = )
14840 401B           B8                   0001  mov	ax,*1
14841 401E           50                         push	ax
14842                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14843 401F           E8         D70F            call	_set_enable_a20
14844 4022           44                         inc	sp
14845 4023           44                         inc	sp
14846                                           !BCC_EOS
14847                                           ! 2726       set_DS(ES);
14848                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14849 4024           FF76         14            push	$14[bp]
14850                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14851 4027           E8         C633            call	_set_DS
14852 402A           44                         inc	sp
14853 402B           44                         inc	sp
14854                                           !BCC_EOS
14855                                           ! 2727       *((Bit16u *)(regs.u.r16.si+0x38+0)) = (0xffff);
14856                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14857 402C           8B46         06            mov	ax,6[bp]
14858                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
14859                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$38 (used reg = )
14860 402F           89C3                       mov	bx,ax
14861                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$38] (used reg = )
14862 4031           B8                   FFFF  mov	ax,#$FFFF
14863 4034           8947         38            mov	$38[bx],ax
14864                                           !BCC_EOS
14865                                           ! 2728       *((Bit16u *)(regs.u.r16.si+0x38+2)) = (0x0000);
14866                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14867 4037           8B46         06            mov	ax,6[bp]
14868                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
14869                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
14870 403A           89C3                       mov	bx,ax
14871                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
14872 403C           31C0                       xor	ax,ax
14873 403E           8947         3A            mov	$3A[bx],ax
14874                                           !BCC_EOS
14875                                           ! 2729       *((Bit8u *)(regs.u.r16.si+0x38+4)) = (0x000f);
14876                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14877 4041           8B46         06            mov	ax,6[bp]
14878                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
14879                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3C (used reg = )
14880 4044           89C3                       mov	bx,ax
14881                                           ! Debug: eq int = const $F to unsigned char = [bx+$3C] (used reg = )
14882 4046           B0                     0F  mov	al,*$F
14883 4048           8847         3C            mov	$3C[bx],al
14884                                           !BCC_EOS
14885                                           ! 2730       *((Bit8u *)(regs.u.r16.si+0x38+5)) = (0x9b);
14886                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14887 404B           8B46         06            mov	ax,6[bp]
14888                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
14889                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3D (used reg = )
14890 404E           89C3                       mov	bx,ax
14891                                           ! Debug: eq int = const $9B to unsigned char = [bx+$3D] (used reg = )
14892 4050           B0                     9B  mov	al,#$9B
14893 4052           8847         3D            mov	$3D[bx],al
14894                                           !BCC_EOS
14895                                           ! 2731       *((Bit16u *)(regs.u.r16.si+0x38+6)) = (0x0000);
14896                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14897 4055           8B46         06            mov	ax,6[bp]
14898                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
14899                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3E (used reg = )
14900 4058           89C3                       mov	bx,ax
14901                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3E] (used reg = )
14902 405A           31C0                       xor	ax,ax
14903 405C           8947         3E            mov	$3E[bx],ax
14904                                           !BCC_EOS
14905                                           ! 2732       BX = regs.u.r16.bx;
14906                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
14907 405F           8B46         0C            mov	ax,$C[bp]
14908 4062           8946         F4            mov	-$C[bp],ax
14909                                           !BCC_EOS
14910                                           ! 2733 #asm
14911                                           !BCC_EOS
14912                                           !BCC_ASM
14913                       00000006            _int15_function.CX	set	6
14914                       FFFFFFF2            .int15_function.CX	set	-$E
14915                       0000002C            _int15_function.FLAGS	set	$2C
14916                       00000018            .int15_function.FLAGS	set	$18
14917                       00000001            _int15_function.irqDisable	set	1
14918                       FFFFFFED            .int15_function.irqDisable	set	-$13
14919                       0000002A            _int15_function.DS	set	$2A
14920                       00000016            .int15_function.DS	set	$16
14921                       00000004            _int15_function.DX	set	4
14922                       FFFFFFF0            .int15_function.DX	set	-$10
14923                       0000000D            _int15_function.base23_16	set	$D
14924                       FFFFFFF9            .int15_function.base23_16	set	-7
14925                       00000002            _int15_function.bRegister	set	2
14926                       FFFFFFEE            .int15_function.bRegister	set	-$12
14927                       00000028            _int15_function.ES	set	$28
14928                       00000014            .int15_function.ES	set	$14
14929                       00000012            _int15_function.ebda_seg	set	$12
14930                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14931                       0000000E            _int15_function.base15_00	set	$E
14932                       FFFFFFFA            .int15_function.base15_00	set	-6
14933                       0000000A            _int15_function.ss	set	$A
14934                       FFFFFFF6            .int15_function.ss	set	-$A
14935                       00000008            _int15_function.BX	set	8
14936                       FFFFFFF4            .int15_function.BX	set	-$C
14937                       00000018            _int15_function.regs	set	$18
14938                       00000004            .int15_function.regs	set	4
14939                       00000010            _int15_function.prev_a20_enable	set	$10
14940                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14941 4065           89E3                             mov bx, sp
14942 4067           36                               SEG SS
14943 4068           8B5F         08                    mov bx, _int15_function.BX [bx]
14944 406B           B0                     11        mov al, #0x11 ; send initialisation commands
14945 406D           E6                     20        out 0x0020, al
14946 406F           E6                     A0        out 0x00a0, al
14947 4071           88F8                             mov al, bh
14948 4073           E6                     21        out 0x0021, al
14949 4075           88D8                             mov al, bl
14950 4077           E6                     A1        out 0x00a1, al
14951 4079           B0                     04        mov al, #0x04
14952 407B           E6                     21        out 0x0021, al
14953 407D           B0                     02        mov al, #0x02
14954 407F           E6                     A1        out 0x00a1, al
14955 4081           B0                     01        mov al, #0x01
14956 4083           E6                     21        out 0x0021, al
14957 4085           E6                     A1        out 0x00a1, al
14958 4087           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
14959 4089           E6                     21        out 0x0021, al
14960 408B           E6                     A1        out 0x00a1, al
14961 408D           26                               SEG ES
14962 408E         0F0154         08                    lgdt [si + 0x08]
14963 4092           26                               SEG ES
14964 4093         0F015C         10                    lidt [si + 0x10]
14965 4097         0F20C0                             mov eax, cr0
14966 409A           0C                     01        or al, #0x01
14967 409C         0F22C0                             mov cr0, eax
14968                                                 JMP_AP(0x0038, protmode_switch)
 +a   409F                        EA              db 0xea
 +a   40A0                      40A4              dw  protmode_switch
 +a   40A2                      0038              dw 0x0038
14969                       000040A4            protmode_switch:
14970                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14971 40A4           B8                   0028        mov ax, #0x28
14972 40A7           8ED0                             mov ss, ax
14973 40A9           B8                   0018        mov ax, #0x18
14974 40AC           8ED8                             mov ds, ax
14975 40AE           B8                   0020        mov ax, #0x20
14976 40B1           8EC0                             mov es, ax
14977 40B3           89EC                             mov sp,bp
14978 40B5           83C4                   04        add sp,#4 ; skip return address
14979 40B8           61                               popa ; restore regs
14980 40B9           58                               pop ax ; skip saved es
14981 40BA           58                               pop ax ; skip saved ds
14982 40BB           58                               pop ax ; skip saved flags
14983 40BC           59                               pop cx ; get return offset
14984 40BD           58                               pop ax ; skip return segment
14985 40BE           58                               pop ax ; skip flags
14986 40BF           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
14987 40C2           50                               push ax
14988 40C3           51                               push cx ; re-create modified ret address on stack
14989 40C4           CB                               retf
14990                                           ! 2783 endasm
14991                                           !BCC_ENDASM
14992                                           !BCC_EOS
14993                                           ! 2784       break;
14994 40C5           E9         00D7            br 	.359
14995                                           !BCC_EOS
14996                                           ! 2785     case 0xbf:
14997                                           ! 2786       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
14998                       000040C8            .37A:
14999                                           ! Debug: list * char = .37B+0 (used reg = )
15000 40C8           BB                   D547  mov	bx,#.37B
15001 40CB           53                         push	bx
15002                                           ! Debug: list int = const 4 (used reg = )
15003 40CC           B8                   0004  mov	ax,*4
15004 40CF           50                         push	ax
15005                                           ! Debug: func () void = bios_printf+0 (used reg = )
15006 40D0           E8         C866            call	_bios_printf
15007 40D3           83C4                   04  add	sp,*4
15008                                           !BCC_EOS
15009                                           ! 2787       FLAGS |= 0x0001;
15010                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15011 40D6           8B46         18            mov	ax,$18[bp]
15012 40D9           0C                     01  or	al,*1
15013 40DB           8946         18            mov	$18[bp],ax
15014                                           !BCC_EOS
15015                                           ! 2788       regs.u.r8.ah = 0x86;
15016                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15017 40DE           B0                     86  mov	al,#$86
15018 40E0           8846         13            mov	$13[bp],al
15019                                           !BCC_EOS
15020                                           ! 2789       break;
15021 40E3           E9         00B9            br 	.359
15022                                           !BCC_EOS
15023                                           ! 2790     case 0xC0:
15024                                           ! 2791       FLAGS &= 0xfffe;
15025                       000040E6            .37C:
15026                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15027 40E6           8B46         18            mov	ax,$18[bp]
15028 40E9           24                     FE  and	al,#$FE
15029 40EB           8946         18            mov	$18[bp],ax
15030                                           !BCC_EOS
15031                                           ! 2792       regs.u.r8.ah = 0;
15032                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15033 40EE           30C0                       xor	al,al
15034 40F0           8846         13            mov	$13[bp],al
15035                                           !BCC_EOS
15036                                           ! 2793       regs.u.r16.bx = 0xe6f5;
15037                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
15038 40F3           B8                   E6F5  mov	ax,#$E6F5
15039 40F6           8946         0C            mov	$C[bp],ax
15040                                           !BCC_EOS
15041                                           ! 2794       ES = 0xF000;
15042                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
15043 40F9           B8                   F000  mov	ax,#$F000
15044 40FC           8946         14            mov	$14[bp],ax
15045                                           !BCC_EOS
15046                                           ! 2795       break;
15047 40FF           E9         009D            br 	.359
15048                                           !BCC_EOS
15049                                           ! 2796     case 0xc1:
15050                                           ! 2797       ES = ebda_seg;
15051                       00004102            .37D:
15052                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
15053 4102           8B46         FE            mov	ax,-2[bp]
15054 4105           8946         14            mov	$14[bp],ax
15055                                           !BCC_EOS
15056                                           ! 2798       FLAGS &= 0xfffe;
15057                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15058 4108           8B46         18            mov	ax,$18[bp]
15059 410B           24                     FE  and	al,#$FE
15060 410D           8946         18            mov	$18[bp],ax
15061                                           !BCC_EOS
15062                                           ! 2799       break;
15063 4110           E9         008C            br 	.359
15064                                           !BCC_EOS
15065                                           ! 2800     case 0xd8:
15066                                           ! 2801       bios_printf(8, "EISA BIOS not present\n");
15067                       00004113            .37E:
15068                                           ! Debug: list * char = .37F+0 (used reg = )
15069 4113           BB                   D530  mov	bx,#.37F
15070 4116           53                         push	bx
15071                                           ! Debug: list int = const 8 (used reg = )
15072 4117           B8                   0008  mov	ax,*8
15073 411A           50                         push	ax
15074                                           ! Debug: func () void = bios_printf+0 (used reg = )
15075 411B           E8         C81B            call	_bios_printf
15076 411E           83C4                   04  add	sp,*4
15077                                           !BCC_EOS
15078                                           ! 2802       FLAGS |= 0x0001;
15079                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15080 4121           8B46         18            mov	ax,$18[bp]
15081 4124           0C                     01  or	al,*1
15082 4126           8946         18            mov	$18[bp],ax
15083                                           !BCC_EOS
15084                                           ! 2803       regs.u.r8.ah = 0x86;
15085                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15086 4129           B0                     86  mov	al,#$86
15087 412B           8846         13            mov	$13[bp],al
15088                                           !BCC_EOS
15089                                           ! 2804       break;
15090 412E           EB           6F            jmp .359
15091                                           !BCC_EOS
15092                                           ! 2805     default:
15093                                           ! 2806       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
15094                       00004130            .380:
15095                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
15096 4130           FF76         0C            push	$C[bp]
15097                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
15098 4133           FF76         12            push	$12[bp]
15099                                           ! Debug: list * char = .381+0 (used reg = )
15100 4136           BB                   D4F6  mov	bx,#.381
15101 4139           53                         push	bx
15102                                           ! Debug: list int = const 4 (used reg = )
15103 413A           B8                   0004  mov	ax,*4
15104 413D           50                         push	ax
15105                                           ! Debug: func () void = bios_printf+0 (used reg = )
15106 413E           E8         C7F8            call	_bios_printf
15107 4141           83C4                   08  add	sp,*8
15108                                           !BCC_EOS
15109                                           ! 2807       FLAGS |= 0x0001;
15110                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15111 4144           8B46         18            mov	ax,$18[bp]
15112 4147           0C                     01  or	al,*1
15113 4149           8946         18            mov	$18[bp],ax
15114                                           !BCC_EOS
15115                                           ! 2808       regs.u.r8.ah = 0x86;
15116                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15117 414C           B0                     86  mov	al,#$86
15118 414E           8846         13            mov	$13[bp],al
15119                                           !BCC_EOS
15120                                           ! 2809       break;
15121 4151           EB           4C            jmp .359
15122                                           !BCC_EOS
15123                                           ! 2810     }
15124                                           ! 2811 }
15125 4153           EB           4A            jmp .359
15126                       00004155            .35B:
15127 4155           2C                     24  sub	al,*$24
15128 4157         0F84         FB78            beq 	.35C
15129 415B           2C                     1D  sub	al,*$1D
15130 415D         0F84         FBFF            beq 	.366
15131 4161           2C                     0E  sub	al,*$E
15132 4163         0F84         FC09            beq 	.367
15133 4167           2C                     03  sub	al,*3
15134 4169         0F84         FC0E            beq 	.368
15135 416D           2C                     31  sub	al,*$31
15136 416F         0F84         FC18            beq 	.369
15137 4173           2C                     04  sub	al,*4
15138 4175         0F84         FCE8            beq 	.373
15139 4179           2C                     01  sub	al,*1
15140 417B         0F84         FE6A            beq 	.376
15141 417F           2C                     01  sub	al,*1
15142 4181         0F84         FE95            beq 	.379
15143 4185           2C                     36  sub	al,*$36
15144 4187         0F84         FF3D            beq 	.37A
15145 418B           2C                     01  sub	al,*1
15146 418D         0F84         FF55            beq 	.37C
15147 4191           2C                     01  sub	al,*1
15148 4193         0F84         FF6B            beq 	.37D
15149 4197           2C                     17  sub	al,*$17
15150 4199         0F84         FF76            beq 	.37E
15151 419D           EB           91            jmp	.380
15152                       0000419F            .359:
15153                       FFFFFFEA            ..FFF7	=	-$16
15154 419F           89EC                       mov	sp,bp
15155 41A1           5D                         pop	bp
15156 41A2           C3                         ret
15157                                           ! 2812   void
15158                                           ! Register BX used in function int15_function
15159                                           ! 2813 int15_function_mouse(regs, ES, DS, FLAGS)
15160                                           ! 2814   pusha_regs_t regs;
15161                                           export	_int15_function_mouse
15162                       000041A3            _int15_function_mouse:
15163                                           !BCC_EOS
15164                                           ! 2815   Bit16u ES, DS, FLAGS;
15165                                           !BCC_EOS
15166                                           ! 2816 {
15167                                           ! 2817   Bit16u ebda_seg=get_ebda_seg();
15168 41A3           55                         push	bp
15169 41A4           89E5                       mov	bp,sp
15170 41A6           4C                         dec	sp
15171 41A7           4C                         dec	sp
15172                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
15173 41A8           E8         C4BC            call	_get_ebda_seg
15174                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15175 41AB           8946         FE            mov	-2[bp],ax
15176                                           !BCC_EOS
15177                                           ! 2818   Bit8u mouse_flags_1, mouse_flags_2;
15178                                           !BCC_EOS
15179                                           ! 2819   Bit16u mouse_driver_seg;
15180                                           !BCC_EOS
15181                                           ! 2820   Bit16u mouse_driver_offset;
15182                                           !BCC_EOS
15183                                           ! 2821   Bit8u comm_byte, prev_command_byte;
15184                                           !BCC_EOS
15185                                           ! 2822   Bit8
15186                                           ! 2822 u ret, mouse_data1, mouse_data2, mouse_data3;
15187                                           !BCC_EOS
15188                                           ! 2823 ;
15189 41AE           83C4                   F4  add	sp,*-$C
15190                                           !BCC_EOS
15191                                           ! 2824   switch (regs.u.r8.ah) {
15192 41B1           8A46         13            mov	al,$13[bp]
15193 41B4           E9         066A            br 	.384
15194                                           ! 2825     case 0xC2:
15195                                           ! 2826       switch (regs.u.r8.al) {
15196                       000041B7            .385:
15197 41B7           8A46         12            mov	al,$12[bp]
15198 41BA           E9         0618            br 	.388
15199                                           ! 2827         case 0:
15200                                           ! 2828 ;
15201                       000041BD            .389:
15202                                           !BCC_EOS
15203                                           ! 2829           switch (regs.u.r8.bh) {
15204 41BD           8A46         0D            mov	al,$D[bp]
15205 41C0           E9         00E9            br 	.38C
15206                                           ! 2830             case 0:
15207                                           ! 2831 ;
15208                       000041C3            .38D:
15209                                           !BCC_EOS
15210                                           ! 2832               inhibit_mouse_int_and_events();
15211                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15212 41C3           E8         1029            call	_inhibit_mouse_int_and_events
15213                                           !BCC_EOS
15214                                           ! 2833               ret = send_to_mouse_ctrl(0xF5);
15215                                           ! Debug: list int = const $F5 (used reg = )
15216 41C6           B8                   00F5  mov	ax,#$F5
15217 41C9           50                         push	ax
15218                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15219 41CA           E8         1173            call	_send_to_mouse_ctrl
15220 41CD           44                         inc	sp
15221 41CE           44                         inc	sp
15222                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15223 41CF           8846         F5            mov	-$B[bp],al
15224                                           !BCC_EOS
15225                                           ! 2834               if (ret == 0) {
15226                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15227 41D2           8A46         F5            mov	al,-$B[bp]
15228 41D5           84C0                       test	al,al
15229 41D7           75           2B            jne 	.38E
15230                       000041D9            .38F:
15231                                           ! 2835                 ret = get_mouse_data(&mouse_data1);
15232                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15233 41D9           8D5E         F4            lea	bx,-$C[bp]
15234 41DC           53                         push	bx
15235                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15236 41DD           E8         11AA            call	_get_mouse_data
15237 41E0           44                         inc	sp
15238 41E1           44                         inc	sp
15239                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15240 41E2           8846         F5            mov	-$B[bp],al
15241                                           !BCC_EOS
15242                                           ! 2836                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
15243                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15244 41E5           8A46         F5            mov	al,-$B[bp]
15245 41E8           84C0                       test	al,al
15246 41EA           74           07            je  	.391
15247                       000041EC            .392:
15248                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15249 41EC           8A46         F4            mov	al,-$C[bp]
15250 41EF           3C                     FA  cmp	al,#$FA
15251 41F1           75           11            jne 	.390
15252                       000041F3            .391:
15253                                           ! 2837                   FLAGS &= 0xfffe;
15254                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15255 41F3           8B46         18            mov	ax,$18[bp]
15256 41F6           24                     FE  and	al,#$FE
15257 41F8           8946         18            mov	$18[bp],ax
15258                                           !BCC_EOS
15259                                           ! 2838                   regs.u.r8.ah = 0;
15260                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15261 41FB           30C0                       xor	al,al
15262 41FD           8846         13            mov	$13[bp],al
15263                                           !BCC_EOS
15264                                           ! 2839                   return;
15265 4200           89EC                       mov	sp,bp
15266 4202           5D                         pop	bp
15267 4203           C3                         ret
15268                                           !BCC_EOS
15269                                           ! 2840                 }
15270                                           ! 2841               }
15271                       00004204            .390:
15272                                           ! 2842               FLAGS |= 0x0001;
15273                       00004204            .38E:
15274                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15275 4204           8B46         18            mov	ax,$18[bp]
15276 4207           0C                     01  or	al,*1
15277 4209           8946         18            mov	$18[bp],ax
15278                                           !BCC_EOS
15279                                           ! 2843               regs.u.r8.ah = ret;
15280                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15281 420C           8A46         F5            mov	al,-$B[bp]
15282 420F           8846         13            mov	$13[bp],al
15283                                           !BCC_EOS
15284                                           ! 2844               return;
15285 4212           89EC                       mov	sp,bp
15286 4214           5D                         pop	bp
15287 4215           C3                         ret
15288                                           !BCC_EOS
15289                                           ! 2845               break;
15290 4216           E9         00A1            br 	.38A
15291                                           !BCC_EOS
15292                                           ! 2846             case 1:
15293                                           ! 2847 ;
15294                       00004219            .393:
15295                                           !BCC_EOS
15296                                           ! 2848               mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15297                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15298 4219           FF76         FE            push	-2[bp]
15299                                           ! Debug: list * unsigned char = const $27 (used reg = )
15300 421C           B8                   0027  mov	ax,*$27
15301 421F           50                         push	ax
15302                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15303 4220           E8         C3BC            call	__read_byte
15304 4223           83C4                   04  add	sp,*4
15305                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15306 4226           8846         FC            mov	-4[bp],al
15307                                           !BCC_EOS
15308                                           ! 2849               if ( (mouse_flags_2 & 0x80) == 0 ) {
15309                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15310 4229           8A46         FC            mov	al,-4[bp]
15311 422C           24                     80  and	al,#$80
15312                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15313 422E           84C0                       test	al,al
15314 4230           75           11            jne 	.394
15315                       00004232            .395:
15316                                           ! 2850                 ;
15317                                           !BCC_EOS
15318                                           ! 2851                 FLAGS |= 0x0001;
15319                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15320 4232           8B46         18            mov	ax,$18[bp]
15321 4235           0C                     01  or	al,*1
15322 4237           8946         18            mov	$18[bp],ax
15323                                           !BCC_EOS
15324                                           ! 2852                 regs.u.r8.ah = 5;
15325                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
15326 423A           B0                     05  mov	al,*5
15327 423C           8846         13            mov	$13[bp],al
15328                                           !BCC_EOS
15329                                           ! 2853                 return;
15330 423F           89EC                       mov	sp,bp
15331 4241           5D                         pop	bp
15332 4242           C3                         ret
15333                                           !BCC_EOS
15334                                           ! 2854               }
15335                                           ! 2855               inhibit_mouse_int_and_events();
15336                       00004243            .394:
15337                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15338 4243           E8         0FA9            call	_inhibit_mouse_int_and_events
15339                                           !BCC_EOS
15340                                           ! 2856               ret = send_to_mouse_ctrl(0xF4);
15341                                           ! Debug: list int = const $F4 (used reg = )
15342 4246           B8                   00F4  mov	ax,#$F4
15343 4249           50                         push	ax
15344                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15345 424A           E8         10F3            call	_send_to_mouse_ctrl
15346 424D           44                         inc	sp
15347 424E           44                         inc	sp
15348                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15349 424F           8846         F5            mov	-$B[bp],al
15350                                           !BCC_EOS
15351                                           ! 2857               if (ret == 0) {
15352                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15353 4252           8A46         F5            mov	al,-$B[bp]
15354 4255           84C0                       test	al,al
15355 4257           75           2E            jne 	.396
15356                       00004259            .397:
15357                                           ! 2858                 ret = get_mouse_data(&mouse_data1);
15358                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15359 4259           8D5E         F4            lea	bx,-$C[bp]
15360 425C           53                         push	bx
15361                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15362 425D           E8         112A            call	_get_mouse_data
15363 4260           44                         inc	sp
15364 4261           44                         inc	sp
15365                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15366 4262           8846         F5            mov	-$B[bp],al
15367                                           !BCC_EOS
15368                                           ! 2859                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
15369                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15370 4265           8A46         F5            mov	al,-$B[bp]
15371 4268           84C0                       test	al,al
15372 426A           75           1B            jne 	.398
15373                       0000426C            .39A:
15374                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15375 426C           8A46         F4            mov	al,-$C[bp]
15376 426F           3C                     FA  cmp	al,#$FA
15377 4271           75           14            jne 	.398
15378                       00004273            .399:
15379                                           ! 2860                   enable_mouse_int_and_events();
15380                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15381 4273           E8         1026            call	_enable_mouse_int_and_events
15382                                           !BCC_EOS
15383                                           ! 2861                   FLAGS &= 0xfffe;
15384                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15385 4276           8B46         18            mov	ax,$18[bp]
15386 4279           24                     FE  and	al,#$FE
15387 427B           8946         18            mov	$18[bp],ax
15388                                           !BCC_EOS
15389                                           ! 2862                   regs.u.r8.ah = 0;
15390                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15391 427E           30C0                       xor	al,al
15392 4280           8846         13            mov	$13[bp],al
15393                                           !BCC_EOS
15394                                           ! 2863                   return;
15395 4283           89EC                       mov	sp,bp
15396 4285           5D                         pop	bp
15397 4286           C3                         ret
15398                                           !BCC_EOS
15399                                           ! 2864                 }
15400                                           ! 2865               }
15401                       00004287            .398:
15402                                           ! 2866               FLAGS |= 0x0001;
15403                       00004287            .396:
15404                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15405 4287           8B46         18            mov	ax,$18[bp]
15406 428A           0C                     01  or	al,*1
15407 428C           8946         18            mov	$18[bp],ax
15408                                           !BCC_EOS
15409                                           ! 2867               regs.u.r8.ah = ret;
15410                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15411 428F           8A46         F5            mov	al,-$B[bp]
15412 4292           8846         13            mov	$13[bp],al
15413                                           !BCC_EOS
15414                                           ! 2868               return;
15415 4295           89EC                       mov	sp,bp
15416 4297           5D                         pop	bp
15417 4298           C3                         ret
15418                                           !BCC_EOS
15419                                           ! 2869             default:
15420                                           ! 2870               ;
15421                       00004299            .39B:
15422                                           !BCC_EOS
15423                                           ! 2871               FLAGS |= 0x0001;
15424                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15425 4299           8B46         18            mov	ax,$18[bp]
15426 429C           0C                     01  or	al,*1
15427 429E           8946         18            mov	$18[bp],ax
15428                                           !BCC_EOS
15429                                           ! 2872               regs.u.r8.ah = 1;
15430                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
15431 42A1           B0                     01  mov	al,*1
15432 42A3           8846         13            mov	$13[bp],al
15433                                           !BCC_EOS
15434                                           ! 2873               return;
15435 42A6           89EC                       mov	sp,bp
15436 42A8           5D                         pop	bp
15437 42A9           C3                         ret
15438                                           !BCC_EOS
15439                                           ! 2874           }
15440                                           ! 2875           break;
15441 42AA           EB           0E            jmp .38A
15442                       000042AC            .38C:
15443 42AC           2C                     00  sub	al,*0
15444 42AE         0F84         FF11            beq 	.38D
15445 42B2           2C                     01  sub	al,*1
15446 42B4         0F84         FF61            beq 	.393
15447 42B8           EB           DF            jmp	.39B
15448                       000042BA            .38A:
15449 42BA           E9         053D            br 	.386
15450                                           !BCC_EOS
15451                                           ! 2876         case 1:
15452                                           ! 2877         case 5:
15453                       000042BD            .39C:
15454                                           ! 2878 ;
15455                       000042BD            .39D:
15456                                           !BCC_EOS
15457                                           ! 2879           if (regs.u.r8.al == 5) {
15458                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
15459 42BD           8A46         12            mov	al,$12[bp]
15460 42C0           3C                     05  cmp	al,*5
15461 42C2           75           70            jne 	.39E
15462                       000042C4            .39F:
15463                                           ! 2880             if ((regs.u.r8.bh != 3) && (regs.u.r8.bh != 4)) {
15464                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
15465 42C4           8A46         0D            mov	al,$D[bp]
15466 42C7           3C                     03  cmp	al,*3
15467 42C9           74           18            je  	.3A0
15468                       000042CB            .3A2:
15469                                           ! Debug: ne int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15470 42CB           8A46         0D            mov	al,$D[bp]
15471 42CE           3C                     04  cmp	al,*4
15472 42D0           74           11            je  	.3A0
15473                       000042D2            .3A1:
15474                                           ! 2881               FLAGS |= 0x0001;
15475                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15476 42D2           8B46         18            mov	ax,$18[bp]
15477 42D5           0C                     01  or	al,*1
15478 42D7           8946         18            mov	$18[bp],ax
15479                                           !BCC_EOS
15480                                           ! 2882               regs.u.r8.ah = 0x02;
15481                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
15482 42DA           B0                     02  mov	al,*2
15483 42DC           8846         13            mov	$13[bp],al
15484                                           !BCC_EOS
15485                                           ! 2883               return;
15486 42DF           89EC                       mov	sp,bp
15487 42E1           5D                         pop	bp
15488 42E2           C3                         ret
15489                                           !BCC_EOS
15490                                           ! 2884             }
15491                                           ! 2885             mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15492                       000042E3            .3A0:
15493                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15494 42E3           FF76         FE            push	-2[bp]
15495                                           ! Debug: list * unsigned char = const $27 (used reg = )
15496 42E6           B8                   0027  mov	ax,*$27
15497 42E9           50                         push	ax
15498                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15499 42EA           E8         C2F2            call	__read_byte
15500 42ED           83C4                   04  add	sp,*4
15501                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15502 42F0           8846         FC            mov	-4[bp],al
15503                                           !BCC_EOS
15504                                           ! 2886             mouse_flags_2 = (mouse_flags_2 & 0xF8) | regs.u.r8.bh - 1;
15505                                           ! Debug: sub int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
15506 42F3           8A46         0D            mov	al,$D[bp]
15507 42F6           30E4                       xor	ah,ah
15508 42F8           48                         dec	ax
15509 42F9           50                         push	ax
15510                                           ! Debug: and int = const $F8 to unsigned char mouse_flags_2 = [S+$12-6] (used reg = )
15511 42FA           8A46         FC            mov	al,-4[bp]
15512 42FD           24                     F8  and	al,#$F8
15513                                           ! Debug: or unsigned int (temp) = [S+$12-$12] to unsigned char = al+0 (used reg = )
15514 42FF           30E4                       xor	ah,ah
15515 4301           0B46         F0            or	ax,0+..FFF6[bp]
15516 4304           44                         inc	sp
15517 4305           44                         inc	sp
15518                                           ! Debug: eq unsigned int = ax+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15519 4306           8846         FC            mov	-4[bp],al
15520                                           !BCC_EOS
15521                                           ! 2887             mouse_flags_1 = 0x00;
15522                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
15523 4309           30C0                       xor	al,al
15524 430B           8846         FD            mov	-3[bp],al
15525                                           !BCC_EOS
15526                                           ! 2888             _write_b
15527                                           ! 2888 yte(mouse_flags_1, &((ebda_data_t *) 0)->mouse_flag1, ebda_seg);
15528                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15529 430E           FF76         FE            push	-2[bp]
15530                                           ! Debug: list * unsigned char = const $26 (used reg = )
15531 4311           B8                   0026  mov	ax,*$26
15532 4314           50                         push	ax
15533                                           ! Debug: list unsigned char mouse_flags_1 = [S+$14-5] (used reg = )
15534 4315           8A46         FD            mov	al,-3[bp]
15535 4318           30E4                       xor	ah,ah
15536 431A           50                         push	ax
15537                                           ! Debug: func () void = _write_byte+0 (used reg = )
15538 431B           E8         C2DD            call	__write_byte
15539 431E           83C4                   06  add	sp,*6
15540                                           !BCC_EOS
15541                                           ! 2889             _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15542                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15543 4321           FF76         FE            push	-2[bp]
15544                                           ! Debug: list * unsigned char = const $27 (used reg = )
15545 4324           B8                   0027  mov	ax,*$27
15546 4327           50                         push	ax
15547                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
15548 4328           8A46         FC            mov	al,-4[bp]
15549 432B           30E4                       xor	ah,ah
15550 432D           50                         push	ax
15551                                           ! Debug: func () void = _write_byte+0 (used reg = )
15552 432E           E8         C2CA            call	__write_byte
15553 4331           83C4                   06  add	sp,*6
15554                                           !BCC_EOS
15555                                           ! 2890           }
15556                                           ! 2891           inhibit_mouse_int_and_events();
15557                       00004334            .39E:
15558                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15559 4334           E8         0EB8            call	_inhibit_mouse_int_and_events
15560                                           !BCC_EOS
15561                                           ! 2892           ret = send_to_mouse_ctrl(0xFF);
15562                                           ! Debug: list int = const $FF (used reg = )
15563 4337           B8                   00FF  mov	ax,#$FF
15564 433A           50                         push	ax
15565                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15566 433B           E8         1002            call	_send_to_mouse_ctrl
15567 433E           44                         inc	sp
15568 433F           44                         inc	sp
15569                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15570 4340           8846         F5            mov	-$B[bp],al
15571                                           !BCC_EOS
15572                                           ! 2893           if (ret == 0) {
15573                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15574 4343           8A46         F5            mov	al,-$B[bp]
15575 4346           84C0                       test	al,al
15576 4348         0F85         0087            bne 	.3A3
15577                       0000434C            .3A4:
15578                                           ! 2894             ret = get_mouse_data(&mouse_data3);
15579                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
15580 434C           8D5E         F2            lea	bx,-$E[bp]
15581 434F           53                         push	bx
15582                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15583 4350           E8         1037            call	_get_mouse_data
15584 4353           44                         inc	sp
15585 4354           44                         inc	sp
15586                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15587 4355           8846         F5            mov	-$B[bp],al
15588                                           !BCC_EOS
15589                                           ! 2895             if (mouse_data3 == 0xfe) {
15590                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15591 4358           8A46         F2            mov	al,-$E[bp]
15592 435B           3C                     FE  cmp	al,#$FE
15593 435D           75           0C            jne 	.3A5
15594                       0000435F            .3A6:
15595                                           ! 2896               FLAGS |= 0x0001;
15596                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15597 435F           8B46         18            mov	ax,$18[bp]
15598 4362           0C                     01  or	al,*1
15599 4364           8946         18            mov	$18[bp],ax
15600                                           !BCC_EOS
15601                                           ! 2897               return;
15602 4367           89EC                       mov	sp,bp
15603 4369           5D                         pop	bp
15604 436A           C3                         ret
15605                                           !BCC_EOS
15606                                           ! 2898             }
15607                                           ! 2899             if (mouse_data3 != 0xfa)
15608                       0000436B            .3A5:
15609                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15610 436B           8A46         F2            mov	al,-$E[bp]
15611 436E           3C                     FA  cmp	al,#$FA
15612 4370           74           14            je  	.3A7
15613                       00004372            .3A8:
15614                                           ! 2900               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
15615                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15616 4372           8A46         F2            mov	al,-$E[bp]
15617 4375           30E4                       xor	ah,ah
15618 4377           50                         push	ax
15619                                           ! Debug: list * char = .3A9+0 (used reg = )
15620 4378           BB                   D4CB  mov	bx,#.3A9
15621 437B           53                         push	bx
15622                                           ! Debug: list int = const 7 (used reg = )
15623 437C           B8                   0007  mov	ax,*7
15624 437F           50                         push	ax
15625                                           ! Debug: func () void = bios_printf+0 (used reg = )
15626 4380           E8         C5B6            call	_bios_printf
15627 4383           83C4                   06  add	sp,*6
15628                                           !BCC_EOS
15629                                           ! 2901             if ( ret == 0 ) {
15630                       00004386            .3A7:
15631                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15632 4386           8A46         F5            mov	al,-$B[bp]
15633 4389           84C0                       test	al,al
15634 438B           75           46            jne 	.3AA
15635                       0000438D            .3AB:
15636                                           ! 2902               ret = get_mouse_data(&mouse_data1);
15637                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15638 438D           8D5E         F4            lea	bx,-$C[bp]
15639 4390           53                         push	bx
15640                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15641 4391           E8         0FF6            call	_get_mouse_data
15642 4394           44                         inc	sp
15643 4395           44                         inc	sp
15644                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15645 4396           8846         F5            mov	-$B[bp],al
15646                                           !BCC_EOS
15647                                           ! 2903               if ( ret == 0 ) {
15648                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15649 4399           8A46         F5            mov	al,-$B[bp]
15650 439C           84C0                       test	al,al
15651 439E           75           33            jne 	.3AC
15652                       000043A0            .3AD:
15653                                           ! 2904                 ret = get_mouse_data(&mouse_data2);
15654                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15655 43A0           8D5E         F3            lea	bx,-$D[bp]
15656 43A3           53                         push	bx
15657                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15658 43A4           E8         0FE3            call	_get_mouse_data
15659 43A7           44                         inc	sp
15660 43A8           44                         inc	sp
15661                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15662 43A9           8846         F5            mov	-$B[bp],al
15663                                           !BCC_EOS
15664                                           ! 2905                 if ( ret == 0 ) {
15665                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15666 43AC           8A46         F5            mov	al,-$B[bp]
15667 43AF           84C0                       test	al,al
15668 43B1           75           20            jne 	.3AE
15669                       000043B3            .3AF:
15670                                           ! 2906                   enable_mouse_int_and_events();
15671                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15672 43B3           E8         0EE6            call	_enable_mouse_int_and_events
15673                                           !BCC_EOS
15674                                           ! 2907                   FLAGS &= 0xfffe;
15675                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15676 43B6           8B46         18            mov	ax,$18[bp]
15677 43B9           24                     FE  and	al,#$FE
15678 43BB           8946         18            mov	$18[bp],ax
15679                                           !BCC_EOS
15680                                           ! 2908                   regs.u.r8.ah = 0;
15681                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15682 43BE           30C0                       xor	al,al
15683 43C0           8846         13            mov	$13[bp],al
15684                                           !BCC_EOS
15685                                           ! 2909                   regs.u.r8.bl = mouse_data1;
15686                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
15687 43C3           8A46         F4            mov	al,-$C[bp]
15688 43C6           8846         0C            mov	$C[bp],al
15689                                           !BCC_EOS
15690                                           ! 2910                   regs.u.r8.bh = mouse_data2;
15691                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
15692 43C9           8A46         F3            mov	al,-$D[bp]
15693 43CC           8846         0D            mov	$D[bp],al
15694                                           !BCC_EOS
15695                                           ! 2911                   return;
15696 43CF           89EC                       mov	sp,bp
15697 43D1           5D                         pop	bp
15698 43D2           C3                         ret
15699                                           !BCC_EOS
15700                                           ! 2912                 }
15701                                           ! 2913               }
15702                       000043D3            .3AE:
15703                                           ! 2914             }
15704                       000043D3            .3AC:
15705                                           ! 2915           }
15706                       000043D3            .3AA:
15707                                           ! 2916           FLAGS |= 0x0001;
15708                       000043D3            .3A3:
15709                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15710 43D3           8B46         18            mov	ax,$18[bp]
15711 43D6           0C                     01  or	al,*1
15712 43D8           8946         18            mov	$18[bp],ax
15713                                           !BCC_EOS
15714                                           ! 2917           regs.u.r8.ah = ret;
15715                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15716 43DB           8A46         F5            mov	al,-$B[bp]
15717 43DE           8846         13            mov	$13[bp],al
15718                                           !BCC_EOS
15719                                           ! 2918           return;
15720 43E1           89EC                       mov	sp,bp
15721 43E3           5D                         pop	bp
15722 43E4           C3                         ret
15723                                           !BCC_EOS
15724                                           ! 2919         case 2:
15725                                           ! 2920 ;
15726                       000043E5            .3B0:
15727                                           !BCC_EOS
15728                                           ! 2921           switch (regs.u.r8.bh) {
15729 43E5           8A46         0D            mov	al,$D[bp]
15730 43E8           EB           38            jmp .3B3
15731                                           ! 2922             case 0: mouse_data1 = 10; break;
15732                       000043EA            .3B4:
15733                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15734 43EA           B0                     0A  mov	al,*$A
15735 43EC           8846         F4            mov	-$C[bp],al
15736                                           !BCC_EOS
15737 43EF           EB           54            jmp .3B1
15738                                           !BCC_EOS
15739                                           ! 2923             case 1: mouse_data1 = 20; break;
15740                       000043F1            .3B5:
15741                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15742 43F1           B0                     14  mov	al,*$14
15743 43F3           8846         F4            mov	-$C[bp],al
15744                                           !BCC_EOS
15745 43F6           EB           4D            jmp .3B1
15746                                           !BCC_EOS
15747                                           ! 2924             case 2: mouse_data1 = 40; break;
15748                       000043F8            .3B6:
15749                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15750 43F8           B0                     28  mov	al,*$28
15751 43FA           8846         F4            mov	-$C[bp],al
15752                                           !BCC_EOS
15753 43FD           EB           46            jmp .3B1
15754                                           !BCC_EOS
15755                                           ! 2925             case 3: mouse_data1 = 60; break;
15756                       000043FF            .3B7:
15757                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15758 43FF           B0                     3C  mov	al,*$3C
15759 4401           8846         F4            mov	-$C[bp],al
15760                                           !BCC_EOS
15761 4404           EB           3F            jmp .3B1
15762                                           !BCC_EOS
15763                                           ! 2926             case 4: mouse_data1 = 80; break;
15764                       00004406            .3B8:
15765                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15766 4406           B0                     50  mov	al,*$50
15767 4408           8846         F4            mov	-$C[bp],al
15768                                           !BCC_EOS
15769 440B           EB           38            jmp .3B1
15770                                           !BCC_EOS
15771                                           ! 2927             case 5: mouse_data1 = 100; break;
15772                       0000440D            .3B9:
15773                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15774 440D           B0                     64  mov	al,*$64
15775 440F           8846         F4            mov	-$C[bp],al
15776                                           !BCC_EOS
15777 4412           EB           31            jmp .3B1
15778                                           !BCC_EOS
15779                                           ! 2928             case 6: mouse_data1 = 200; break;
15780                       00004414            .3BA:
15781                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15782 4414           B0                     C8  mov	al,#$C8
15783 4416           8846         F4            mov	-$C[bp],al
15784                                           !BCC_EOS
15785 4419           EB           2A            jmp .3B1
15786                                           !BCC_EOS
15787                                           ! 2929             default: mouse_data1 = 0;
15788                       0000441B            .3BB:
15789                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15790 441B           30C0                       xor	al,al
15791 441D           8846         F4            mov	-$C[bp],al
15792                                           !BCC_EOS
15793                                           ! 2930           }
15794                                           ! 2931           if (mouse_data1 > 0) {
15795 4420           EB           23            jmp .3B1
15796                       00004422            .3B3:
15797 4422           2C                     00  sub	al,*0
15798 4424           72           F5            jb 	.3BB
15799 4426           3C                     06  cmp	al,*6
15800 4428           77           19            ja  	.3BC
15801 442A           30E4                       xor	ah,ah
15802 442C           D1E0                       shl	ax,*1
15803 442E           89C3                       mov	bx,ax
15804 4430           2E                         seg	cs
15805 4431           FFA7       4435            br	.3BD[bx]
15806                       00004435            .3BD:
15807 4435                      43EA            .word	.3B4
15808 4437                      43F1            .word	.3B5
15809 4439                      43F8            .word	.3B6
15810 443B                      43FF            .word	.3B7
15811 443D                      4406            .word	.3B8
15812 443F                      440D            .word	.3B9
15813 4441                      4414            .word	.3BA
15814                       00004443            .3BC:
15815 4443           EB           D6            jmp	.3BB
15816                       00004445            .3B1:
15817                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15818 4445           8A46         F4            mov	al,-$C[bp]
15819 4448           84C0                       test	al,al
15820 444A         0F84         0057            beq 	.3BE
15821                       0000444E            .3BF:
15822                                           ! 2932             ret = send_to_mouse_ctrl(0xF3);
15823                                           ! Debug: list int = const $F3 (used reg = )
15824 444E           B8                   00F3  mov	ax,#$F3
15825 4451           50                         push	ax
15826                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15827 4452           E8         0EEB            call	_send_to_mouse_ctrl
15828 4455           44                         inc	sp
15829 4456           44                         inc	sp
15830                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15831 4457           8846         F5            mov	-$B[bp],al
15832                                           !BCC_EOS
15833                                           ! 2933             if (ret == 0) {
15834                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15835 445A           8A46         F5            mov	al,-$B[bp]
15836 445D           84C0                       test	al,al
15837 445F           75           35            jne 	.3C0
15838                       00004461            .3C1:
15839                                           ! 2934               ret = get_mouse_data(&mouse_data2);
15840                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15841 4461           8D5E         F3            lea	bx,-$D[bp]
15842 4464           53                         push	bx
15843                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15844 4465           E8         0F22            call	_get_mouse_data
15845 4468           44                         inc	sp
15846 4469           44                         inc	sp
15847                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15848 446A           8846         F5            mov	-$B[bp],al
15849                                           !BCC_EOS
15850                                           ! 2935               ret = send_to_mouse_ctrl(mouse_data1);
15851                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15852 446D           8A46         F4            mov	al,-$C[bp]
15853 4470           30E4                       xor	ah,ah
15854 4472           50                         push	ax
15855                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15856 4473           E8         0ECA            call	_send_to_mouse_ctrl
15857 4476           44                         inc	sp
15858 4477           44                         inc	sp
15859                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15860 4478           8846         F5            mov	-$B[bp],al
15861                                           !BCC_EOS
15862                                           ! 2936               ret = get_mouse_data(&mouse_data2);
15863                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15864 447B           8D5E         F3            lea	bx,-$D[bp]
15865 447E           53                         push	bx
15866                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15867 447F           E8         0F08            call	_get_mouse_data
15868 4482           44                         inc	sp
15869 4483           44                         inc	sp
15870                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15871 4484           8846         F5            mov	-$B[bp],al
15872                                           !BCC_EOS
15873                                           ! 2937               FLAGS &= 0xfffe;
15874                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15875 4487           8B46         18            mov	ax,$18[bp]
15876 448A           24                     FE  and	al,#$FE
15877 448C           8946         18            mov	$18[bp],ax
15878                                           !BCC_EOS
15879                                           ! 2938               regs.u.r8.ah = 0;
15880                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15881 448F           30C0                       xor	al,al
15882 4491           8846         13            mov	$13[bp],al
15883                                           !BCC_EOS
15884                                           ! 2939             } else {
15885 4494           EB           0D            jmp .3C2
15886                       00004496            .3C0:
15887                                           ! 2940               FLAGS |= 0x0001;
15888                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15889 4496           8B46         18            mov	ax,$18[bp]
15890 4499           0C                     01  or	al,*1
15891 449B           8946         18            mov	$18[bp],ax
15892                                           !BCC_EOS
15893                                           ! 2941               regs.u.r8.ah = 0x86;
15894                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15895 449E           B0                     86  mov	al,#$86
15896 44A0           8846         13            mov	$13[bp],al
15897                                           !BCC_EOS
15898                                           ! 2942             }
15899                                           ! 2943           } else {
15900                       000044A3            .3C2:
15901 44A3           EB           0D            jmp .3C3
15902                       000044A5            .3BE:
15903                                           ! 2944             FLAGS |= 0x0001;
15904                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15905 44A5           8B46         18            mov	ax,$18[bp]
15906 44A8           0C                     01  or	al,*1
15907 44AA           8946         18            mov	$18[bp],ax
15908                                           !BCC_EOS
15909                                           ! 2945             reg
15910                                           ! 2945 s.u.r8.ah = 0x86;
15911                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15912 44AD           B0                     86  mov	al,#$86
15913 44AF           8846         13            mov	$13[bp],al
15914                                           !BCC_EOS
15915                                           ! 2946           }
15916                                           ! 2947           break;
15917                       000044B2            .3C3:
15918 44B2           E9         0345            br 	.386
15919                                           !BCC_EOS
15920                                           ! 2948         case 3:
15921                                           ! 2949 ;
15922                       000044B5            .3C4:
15923                                           !BCC_EOS
15924                                           ! 2950           comm_byte = inhibit_mouse_int_and_events();
15925                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15926 44B5           E8         0D37            call	_inhibit_mouse_int_and_events
15927                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
15928 44B8           8846         F7            mov	-9[bp],al
15929                                           !BCC_EOS
15930                                           ! 2951           if (regs.u.r8.bh < 4) {
15931                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15932 44BB           8A46         0D            mov	al,$D[bp]
15933 44BE           3C                     04  cmp	al,*4
15934 44C0         0F83         008F            bhis	.3C5
15935                       000044C4            .3C6:
15936                                           ! 2952             ret = send_to_mouse_ctrl(0xE8);
15937                                           ! Debug: list int = const $E8 (used reg = )
15938 44C4           B8                   00E8  mov	ax,#$E8
15939 44C7           50                         push	ax
15940                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15941 44C8           E8         0E75            call	_send_to_mouse_ctrl
15942 44CB           44                         inc	sp
15943 44CC           44                         inc	sp
15944                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15945 44CD           8846         F5            mov	-$B[bp],al
15946                                           !BCC_EOS
15947                                           ! 2953             if (ret == 0) {
15948                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15949 44D0           8A46         F5            mov	al,-$B[bp]
15950 44D3           84C0                       test	al,al
15951 44D5         0F85         006B            bne 	.3C7
15952                       000044D9            .3C8:
15953                                           ! 2954               ret = get_mouse_data(&mouse_data1);
15954                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15955 44D9           8D5E         F4            lea	bx,-$C[bp]
15956 44DC           53                         push	bx
15957                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15958 44DD           E8         0EAA            call	_get_mouse_data
15959 44E0           44                         inc	sp
15960 44E1           44                         inc	sp
15961                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15962 44E2           8846         F5            mov	-$B[bp],al
15963                                           !BCC_EOS
15964                                           ! 2955               if (mouse_data1 != 0xfa)
15965                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15966 44E5           8A46         F4            mov	al,-$C[bp]
15967 44E8           3C                     FA  cmp	al,#$FA
15968 44EA           74           14            je  	.3C9
15969                       000044EC            .3CA:
15970                                           ! 2956                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
15971                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15972 44EC           8A46         F4            mov	al,-$C[bp]
15973 44EF           30E4                       xor	ah,ah
15974 44F1           50                         push	ax
15975                                           ! Debug: list * char = .3CB+0 (used reg = )
15976 44F2           BB                   D49F  mov	bx,#.3CB
15977 44F5           53                         push	bx
15978                                           ! Debug: list int = const 7 (used reg = )
15979 44F6           B8                   0007  mov	ax,*7
15980 44F9           50                         push	ax
15981                                           ! Debug: func () void = bios_printf+0 (used reg = )
15982 44FA           E8         C43C            call	_bios_printf
15983 44FD           83C4                   06  add	sp,*6
15984                                           !BCC_EOS
15985                                           ! 2957               ret = send_to_mouse_ctrl(regs.u.r8.bh);
15986                       00004500            .3C9:
15987                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
15988 4500           8A46         0D            mov	al,$D[bp]
15989 4503           30E4                       xor	ah,ah
15990 4505           50                         push	ax
15991                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15992 4506           E8         0E37            call	_send_to_mouse_ctrl
15993 4509           44                         inc	sp
15994 450A           44                         inc	sp
15995                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15996 450B           8846         F5            mov	-$B[bp],al
15997                                           !BCC_EOS
15998                                           ! 2958               ret = get_mouse_data(&mouse_data1);
15999                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16000 450E           8D5E         F4            lea	bx,-$C[bp]
16001 4511           53                         push	bx
16002                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16003 4512           E8         0E75            call	_get_mouse_data
16004 4515           44                         inc	sp
16005 4516           44                         inc	sp
16006                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16007 4517           8846         F5            mov	-$B[bp],al
16008                                           !BCC_EOS
16009                                           ! 2959               if (mouse_data1 != 0xfa)
16010                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16011 451A           8A46         F4            mov	al,-$C[bp]
16012 451D           3C                     FA  cmp	al,#$FA
16013 451F           74           14            je  	.3CC
16014                       00004521            .3CD:
16015                                           ! 2960                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16016                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16017 4521           8A46         F4            mov	al,-$C[bp]
16018 4524           30E4                       xor	ah,ah
16019 4526           50                         push	ax
16020                                           ! Debug: list * char = .3CE+0 (used reg = )
16021 4527           BB                   D473  mov	bx,#.3CE
16022 452A           53                         push	bx
16023                                           ! Debug: list int = const 7 (used reg = )
16024 452B           B8                   0007  mov	ax,*7
16025 452E           50                         push	ax
16026                                           ! Debug: func () void = bios_printf+0 (used reg = )
16027 452F           E8         C407            call	_bios_printf
16028 4532           83C4                   06  add	sp,*6
16029                                           !BCC_EOS
16030                                           ! 2961               FLAGS &= 0xfffe;
16031                       00004535            .3CC:
16032                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16033 4535           8B46         18            mov	ax,$18[bp]
16034 4538           24                     FE  and	al,#$FE
16035 453A           8946         18            mov	$18[bp],ax
16036                                           !BCC_EOS
16037                                           ! 2962               regs.u.r8.ah = 0;
16038                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16039 453D           30C0                       xor	al,al
16040 453F           8846         13            mov	$13[bp],al
16041                                           !BCC_EOS
16042                                           ! 2963             } else {
16043 4542           EB           0D            jmp .3CF
16044                       00004544            .3C7:
16045                                           ! 2964               FLAGS |= 0x0001;
16046                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16047 4544           8B46         18            mov	ax,$18[bp]
16048 4547           0C                     01  or	al,*1
16049 4549           8946         18            mov	$18[bp],ax
16050                                           !BCC_EOS
16051                                           ! 2965               regs.u.r8.ah = 0x86;
16052                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16053 454C           B0                     86  mov	al,#$86
16054 454E           8846         13            mov	$13[bp],al
16055                                           !BCC_EOS
16056                                           ! 2966             }
16057                                           ! 2967           } else {
16058                       00004551            .3CF:
16059 4551           EB           0D            jmp .3D0
16060                       00004553            .3C5:
16061                                           ! 2968             FLAGS |= 0x0001;
16062                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16063 4553           8B46         18            mov	ax,$18[bp]
16064 4556           0C                     01  or	al,*1
16065 4558           8946         18            mov	$18[bp],ax
16066                                           !BCC_EOS
16067                                           ! 2969             regs.u.r8.ah = 0x86;
16068                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16069 455B           B0                     86  mov	al,#$86
16070 455D           8846         13            mov	$13[bp],al
16071                                           !BCC_EOS
16072                                           ! 2970           }
16073                                           ! 2971           set_kbd_command_byte(comm_byte);
16074                       00004560            .3D0:
16075                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16076 4560           8A46         F7            mov	al,-9[bp]
16077 4563           30E4                       xor	ah,ah
16078 4565           50                         push	ax
16079                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16080 4566           E8         0E58            call	_set_kbd_command_byte
16081 4569           44                         inc	sp
16082 456A           44                         inc	sp
16083                                           !BCC_EOS
16084                                           ! 2972           break;
16085 456B           E9         028C            br 	.386
16086                                           !BCC_EOS
16087                                           ! 2973         case 4:
16088                                           ! 2974 ;
16089                       0000456E            .3D1:
16090                                           !BCC_EOS
16091                                           ! 2975           inhibit_mouse_int_and_events();
16092                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16093 456E           E8         0C7E            call	_inhibit_mouse_int_and_events
16094                                           !BCC_EOS
16095                                           ! 2976           ret = send_to_mouse_ctrl(0xF2);
16096                                           ! Debug: list int = const $F2 (used reg = )
16097 4571           B8                   00F2  mov	ax,#$F2
16098 4574           50                         push	ax
16099                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16100 4575           E8         0DC8            call	_send_to_mouse_ctrl
16101 4578           44                         inc	sp
16102 4579           44                         inc	sp
16103                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16104 457A           8846         F5            mov	-$B[bp],al
16105                                           !BCC_EOS
16106                                           ! 2977           if (ret == 0) {
16107                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16108 457D           8A46         F5            mov	al,-$B[bp]
16109 4580           84C0                       test	al,al
16110 4582           75           2D            jne 	.3D2
16111                       00004584            .3D3:
16112                                           ! 2978             ret = get_mouse_data(&mouse_data1);
16113                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16114 4584           8D5E         F4            lea	bx,-$C[bp]
16115 4587           53                         push	bx
16116                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16117 4588           E8         0DFF            call	_get_mouse_data
16118 458B           44                         inc	sp
16119 458C           44                         inc	sp
16120                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16121 458D           8846         F5            mov	-$B[bp],al
16122                                           !BCC_EOS
16123                                           ! 2979             ret = get_mouse_data(&mouse_data2);
16124                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16125 4590           8D5E         F3            lea	bx,-$D[bp]
16126 4593           53                         push	bx
16127                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16128 4594           E8         0DF3            call	_get_mouse_data
16129 4597           44                         inc	sp
16130 4598           44                         inc	sp
16131                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16132 4599           8846         F5            mov	-$B[bp],al
16133                                           !BCC_EOS
16134                                           ! 2980             FLAGS &= 0xfffe;
16135                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16136 459C           8B46         18            mov	ax,$18[bp]
16137 459F           24                     FE  and	al,#$FE
16138 45A1           8946         18            mov	$18[bp],ax
16139                                           !BCC_EOS
16140                                           ! 2981             regs.u.r8.ah = 0;
16141                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16142 45A4           30C0                       xor	al,al
16143 45A6           8846         13            mov	$13[bp],al
16144                                           !BCC_EOS
16145                                           ! 2982             regs.u.r8.bh = mouse_data2;
16146                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16147 45A9           8A46         F3            mov	al,-$D[bp]
16148 45AC           8846         0D            mov	$D[bp],al
16149                                           !BCC_EOS
16150                                           ! 2983           } else {
16151 45AF           EB           0D            jmp .3D4
16152                       000045B1            .3D2:
16153                                           ! 2984             FLAGS |= 0x0001;
16154                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16155 45B1           8B46         18            mov	ax,$18[bp]
16156 45B4           0C                     01  or	al,*1
16157 45B6           8946         18            mov	$18[bp],ax
16158                                           !BCC_EOS
16159                                           ! 2985             regs.u.r8.ah = 0x86;
16160                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16161 45B9           B0                     86  mov	al,#$86
16162 45BB           8846         13            mov	$13[bp],al
16163                                           !BCC_EOS
16164                                           ! 2986           }
16165                                           ! 2987           break;
16166                       000045BE            .3D4:
16167 45BE           E9         0239            br 	.386
16168                                           !BCC_EOS
16169                                           ! 2988         case 6:
16170                                           ! 2989 ;
16171                       000045C1            .3D5:
16172                                           !BCC_EOS
16173                                           ! 2990           switch (regs.u.r8.bh) {
16174 45C1           8A46         0D            mov	al,$D[bp]
16175 45C4           E9         015E            br 	.3D8
16176                                           ! 2991             case 0:
16177                                           ! 2992               comm_byte = inhibit_mouse_int_and_events();
16178                       000045C7            .3D9:
16179                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16180 45C7           E8         0C25            call	_inhibit_mouse_int_and_events
16181                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16182 45CA           8846         F7            mov	-9[bp],al
16183                                           !BCC_EOS
16184                                           ! 2993               ret = send_to_mouse_ctrl(0xE9);
16185                                           ! Debug: list int = const $E9 (used reg = )
16186 45CD           B8                   00E9  mov	ax,#$E9
16187 45D0           50                         push	ax
16188                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16189 45D1           E8         0D6C            call	_send_to_mouse_ctrl
16190 45D4           44                         inc	sp
16191 45D5           44                         inc	sp
16192                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16193 45D6           8846         F5            mov	-$B[bp],al
16194                                           !BCC_EOS
16195                                           ! 2994               if (ret == 0) {
16196                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16197 45D9           8A46         F5            mov	al,-$B[bp]
16198 45DC           84C0                       test	al,al
16199 45DE         0F85         0099            bne 	.3DA
16200                       000045E2            .3DB:
16201                                           ! 2995                 ret = get_mouse_data(&mouse_data1);
16202                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16203 45E2           8D5E         F4            lea	bx,-$C[bp]
16204 45E5           53                         push	bx
16205                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16206 45E6           E8         0DA1            call	_get_mouse_data
16207 45E9           44                         inc	sp
16208 45EA           44                         inc	sp
16209                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16210 45EB           8846         F5            mov	-$B[bp],al
16211                                           !BCC_EOS
16212                                           ! 2996                 if (mouse_data1 != 0xfa)
16213                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16214 45EE           8A46         F4            mov	al,-$C[bp]
16215 45F1           3C                     FA  cmp	al,#$FA
16216 45F3           74           14            je  	.3DC
16217                       000045F5            .3DD:
16218                                           ! 2997                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16219                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16220 45F5           8A46         F4            mov	al,-$C[bp]
16221 45F8           30E4                       xor	ah,ah
16222 45FA           50                         push	ax
16223                                           ! Debug: list * char = .3DE+0 (used reg = )
16224 45FB           BB                   D447  mov	bx,#.3DE
16225 45FE           53                         push	bx
16226                                           ! Debug: list int = const 7 (used reg = )
16227 45FF           B8                   0007  mov	ax,*7
16228 4602           50                         push	ax
16229                                           ! Debug: func () void = bios_printf+0 (used reg = )
16230 4603           E8         C333            call	_bios_printf
16231 4606           83C4                   06  add	sp,*6
16232                                           !BCC_EOS
16233                                           ! 2998                 if (ret == 0) {
16234                       00004609            .3DC:
16235                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16236 4609           8A46         F5            mov	al,-$B[bp]
16237 460C           84C0                       test	al,al
16238 460E         0F85         0069            bne 	.3DF
16239                       00004612            .3E0:
16240                                           ! 2999                   ret = get_mouse_data(&mouse_data1);
16241                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16242 4612           8D5E         F4            lea	bx,-$C[bp]
16243 4615           53                         push	bx
16244                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16245 4616           E8         0D71            call	_get_mouse_data
16246 4619           44                         inc	sp
16247 461A           44                         inc	sp
16248                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16249 461B           8846         F5            mov	-$B[bp],al
16250                                           !BCC_EOS
16251                                           ! 3000                   if (ret == 0) {
16252                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16253 461E           8A46         F5            mov	al,-$B[bp]
16254 4621           84C0                       test	al,al
16255 4623         0F85         0054            bne 	.3E1
16256                       00004627            .3E2:
16257                                           ! 3001                     ret = get_mouse_data(&mouse_data2);
16258                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16259 4627           8D5E         F3            lea	bx,-$D[bp]
16260 462A           53                         push	bx
16261                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16262 462B           E8         0D5C            call	_get_mouse_data
16263 462E           44                         inc	sp
16264 462F           44                         inc	sp
16265                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16266 4630           8846         F5            mov	-$B[bp],al
16267                                           !BCC_EOS
16268                                           ! 3002                     if (r
16269                                           ! 3002 et == 0) {
16270                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16271 4633           8A46         F5            mov	al,-$B[bp]
16272 4636           84C0                       test	al,al
16273 4638           75           41            jne 	.3E3
16274                       0000463A            .3E4:
16275                                           ! 3003                       ret = get_mouse_data(&mouse_data3);
16276                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16277 463A           8D5E         F2            lea	bx,-$E[bp]
16278 463D           53                         push	bx
16279                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16280 463E           E8         0D49            call	_get_mouse_data
16281 4641           44                         inc	sp
16282 4642           44                         inc	sp
16283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16284 4643           8846         F5            mov	-$B[bp],al
16285                                           !BCC_EOS
16286                                           ! 3004                       if (ret == 0) {
16287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16288 4646           8A46         F5            mov	al,-$B[bp]
16289 4649           84C0                       test	al,al
16290 464B           75           2E            jne 	.3E5
16291                       0000464D            .3E6:
16292                                           ! 3005                         FLAGS &= 0xfffe;
16293                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16294 464D           8B46         18            mov	ax,$18[bp]
16295 4650           24                     FE  and	al,#$FE
16296 4652           8946         18            mov	$18[bp],ax
16297                                           !BCC_EOS
16298                                           ! 3006                         regs.u.r8.ah = 0;
16299                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16300 4655           30C0                       xor	al,al
16301 4657           8846         13            mov	$13[bp],al
16302                                           !BCC_EOS
16303                                           ! 3007                         regs.u.r8.bl = mouse_data1;
16304                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16305 465A           8A46         F4            mov	al,-$C[bp]
16306 465D           8846         0C            mov	$C[bp],al
16307                                           !BCC_EOS
16308                                           ! 3008                         regs.u.r8.cl = mouse_data2;
16309                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
16310 4660           8A46         F3            mov	al,-$D[bp]
16311 4663           8846         10            mov	$10[bp],al
16312                                           !BCC_EOS
16313                                           ! 3009                         regs.u.r8.dl = mouse_data3;
16314                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
16315 4666           8A46         F2            mov	al,-$E[bp]
16316 4669           8846         0E            mov	$E[bp],al
16317                                           !BCC_EOS
16318                                           ! 3010                         set_kbd_command_byte(comm_byte);
16319                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16320 466C           8A46         F7            mov	al,-9[bp]
16321 466F           30E4                       xor	ah,ah
16322 4671           50                         push	ax
16323                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16324 4672           E8         0D4C            call	_set_kbd_command_byte
16325 4675           44                         inc	sp
16326 4676           44                         inc	sp
16327                                           !BCC_EOS
16328                                           ! 3011                         return;
16329 4677           89EC                       mov	sp,bp
16330 4679           5D                         pop	bp
16331 467A           C3                         ret
16332                                           !BCC_EOS
16333                                           ! 3012                       }
16334                                           ! 3013                     }
16335                       0000467B            .3E5:
16336                                           ! 3014                   }
16337                       0000467B            .3E3:
16338                                           ! 3015                 }
16339                       0000467B            .3E1:
16340                                           ! 3016               }
16341                       0000467B            .3DF:
16342                                           ! 3017               FLAGS |= 0x0001;
16343                       0000467B            .3DA:
16344                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16345 467B           8B46         18            mov	ax,$18[bp]
16346 467E           0C                     01  or	al,*1
16347 4680           8946         18            mov	$18[bp],ax
16348                                           !BCC_EOS
16349                                           ! 3018               regs.u.r8.ah = ret;
16350                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16351 4683           8A46         F5            mov	al,-$B[bp]
16352 4686           8846         13            mov	$13[bp],al
16353                                           !BCC_EOS
16354                                           ! 3019               set_kbd_command_byte(comm_byte);
16355                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16356 4689           8A46         F7            mov	al,-9[bp]
16357 468C           30E4                       xor	ah,ah
16358 468E           50                         push	ax
16359                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16360 468F           E8         0D2F            call	_set_kbd_command_byte
16361 4692           44                         inc	sp
16362 4693           44                         inc	sp
16363                                           !BCC_EOS
16364                                           ! 3020               return;
16365 4694           89EC                       mov	sp,bp
16366 4696           5D                         pop	bp
16367 4697           C3                         ret
16368                                           !BCC_EOS
16369                                           ! 3021             case 1:
16370                                           ! 3022             case 2:
16371                       00004698            .3E7:
16372                                           ! 3023               comm_byte = inhibit_mouse_int_and_events();
16373                       00004698            .3E8:
16374                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16375 4698           E8         0B54            call	_inhibit_mouse_int_and_events
16376                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16377 469B           8846         F7            mov	-9[bp],al
16378                                           !BCC_EOS
16379                                           ! 3024               if (regs.u.r8.bh == 1) {
16380                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
16381 469E           8A46         0D            mov	al,$D[bp]
16382 46A1           3C                     01  cmp	al,*1
16383 46A3           75           0E            jne 	.3E9
16384                       000046A5            .3EA:
16385                                           ! 3025                 ret = send_to_mouse_ctrl(0xE6);
16386                                           ! Debug: list int = const $E6 (used reg = )
16387 46A5           B8                   00E6  mov	ax,#$E6
16388 46A8           50                         push	ax
16389                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16390 46A9           E8         0C94            call	_send_to_mouse_ctrl
16391 46AC           44                         inc	sp
16392 46AD           44                         inc	sp
16393                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16394 46AE           8846         F5            mov	-$B[bp],al
16395                                           !BCC_EOS
16396                                           ! 3026               } else {
16397 46B1           EB           0C            jmp .3EB
16398                       000046B3            .3E9:
16399                                           ! 3027                 ret = send_to_mouse_ctrl(0xE7);
16400                                           ! Debug: list int = const $E7 (used reg = )
16401 46B3           B8                   00E7  mov	ax,#$E7
16402 46B6           50                         push	ax
16403                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16404 46B7           E8         0C86            call	_send_to_mouse_ctrl
16405 46BA           44                         inc	sp
16406 46BB           44                         inc	sp
16407                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16408 46BC           8846         F5            mov	-$B[bp],al
16409                                           !BCC_EOS
16410                                           ! 3028               }
16411                                           ! 3029               if (ret == 0) {
16412                       000046BF            .3EB:
16413                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16414 46BF           8A46         F5            mov	al,-$B[bp]
16415 46C2           84C0                       test	al,al
16416 46C4           75           19            jne 	.3EC
16417                       000046C6            .3ED:
16418                                           ! 3030                 get_mouse_data(&mouse_data1);
16419                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16420 46C6           8D5E         F4            lea	bx,-$C[bp]
16421 46C9           53                         push	bx
16422                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16423 46CA           E8         0CBD            call	_get_mouse_data
16424 46CD           44                         inc	sp
16425 46CE           44                         inc	sp
16426                                           !BCC_EOS
16427                                           ! 3031                 ret = (mouse_data1 != 0xFA);
16428                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16429 46CF           8A46         F4            mov	al,-$C[bp]
16430 46D2           3C                     FA  cmp	al,#$FA
16431 46D4           74           04            je 	.3EE
16432 46D6           B0                     01  mov	al,*1
16433 46D8           EB           02            jmp	.3EF
16434                       000046DA            .3EE:
16435 46DA           30C0                       xor	al,al
16436                       000046DC            .3EF:
16437                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16438 46DC           8846         F5            mov	-$B[bp],al
16439                                           !BCC_EOS
16440                                           ! 3032               }
16441                                           ! 3033               if (ret == 0) {
16442                       000046DF            .3EC:
16443                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16444 46DF           8A46         F5            mov	al,-$B[bp]
16445 46E2           84C0                       test	al,al
16446 46E4           75           0F            jne 	.3F0
16447                       000046E6            .3F1:
16448                                           ! 3034                 FLAGS &= 0xfffe;
16449                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16450 46E6           8B46         18            mov	ax,$18[bp]
16451 46E9           24                     FE  and	al,#$FE
16452 46EB           8946         18            mov	$18[bp],ax
16453                                           !BCC_EOS
16454                                           ! 3035                 regs.u.r8.ah = 0;
16455                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16456 46EE           30C0                       xor	al,al
16457 46F0           8846         13            mov	$13[bp],al
16458                                           !BCC_EOS
16459                                           ! 3036               } else {
16460 46F3           EB           0D            jmp .3F2
16461                       000046F5            .3F0:
16462                                           ! 3037                 FLAGS |= 0x0001;
16463                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16464 46F5           8B46         18            mov	ax,$18[bp]
16465 46F8           0C                     01  or	al,*1
16466 46FA           8946         18            mov	$18[bp],ax
16467                                           !BCC_EOS
16468                                           ! 3038                 regs.u.r8.ah = 0x86;
16469                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16470 46FD           B0                     86  mov	al,#$86
16471 46FF           8846         13            mov	$13[bp],al
16472                                           !BCC_EOS
16473                                           ! 3039               }
16474                                           ! 3040               set_kbd_command_byte(comm_byte);
16475                       00004702            .3F2:
16476                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16477 4702           8A46         F7            mov	al,-9[bp]
16478 4705           30E4                       xor	ah,ah
16479 4707           50                         push	ax
16480                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16481 4708           E8         0CB6            call	_set_kbd_command_byte
16482 470B           44                         inc	sp
16483 470C           44                         inc	sp
16484                                           !BCC_EOS
16485                                           ! 3041               break;
16486 470D           EB           2A            jmp .3D6
16487                                           !BCC_EOS
16488                                           ! 3042             default:
16489                                           ! 3043               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
16490                       0000470F            .3F3:
16491                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16492 470F           8A46         0D            mov	al,$D[bp]
16493 4712           30E4                       xor	ah,ah
16494 4714           50                         push	ax
16495                                           ! Debug: list * char = .3F4+0 (used reg = )
16496 4715           BB                   D42D  mov	bx,#.3F4
16497 4718           53                         push	bx
16498                                           ! Debug: list int = const 7 (used reg = )
16499 4719           B8                   0007  mov	ax,*7
16500 471C           50                         push	ax
16501                                           ! Debug: func () void = bios_printf+0 (used reg = )
16502 471D           E8         C219            call	_bios_printf
16503 4720           83C4                   06  add	sp,*6
16504                                           !BCC_EOS
16505                                           ! 3044           }
16506                                           ! 3045           break;
16507 4723           EB           14            jmp .3D6
16508                       00004725            .3D8:
16509 4725           2C                     00  sub	al,*0
16510 4727         0F84         FE9C            beq 	.3D9
16511 472B           2C                     01  sub	al,*1
16512 472D         0F84         FF67            beq 	.3E7
16513 4731           2C                     01  sub	al,*1
16514 4733         0F84         FF61            beq 	.3E8
16515 4737           EB           D6            jmp	.3F3
16516                       00004739            .3D6:
16517 4739           E9         00BE            br 	.386
16518                                           !BCC_EOS
16519                                           ! 3046         case 7:
16520                                           ! 3047 ;
16521                       0000473C            .3F5:
16522                                           !BCC_EOS
16523                                           ! 3048           mouse_driver_seg = ES;
16524                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16525 473C           8B46         14            mov	ax,$14[bp]
16526 473F           8946         FA            mov	-6[bp],ax
16527                                           !BCC_EOS
16528                                           ! 3049           mouse_driver_offset = regs.u.r16.bx;
16529                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16530 4742           8B46         0C            mov	ax,$C[bp]
16531 4745           8946         F8            mov	-8[bp],ax
16532                                           !BCC_EOS
16533                                           ! 3050           _write_word(mouse_driver_offset, &((ebda_data_t *) 0)->mouse_driver_offset, ebda_seg);
16534                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16535 4748           FF76         FE            push	-2[bp]
16536                                           ! Debug: list * unsigned short = const $22 (used reg = )
16537 474B           B8                   0022  mov	ax,*$22
16538 474E           50                         push	ax
16539                                           ! Debug: list unsigned short mouse_driver_offset = [S+$14-$A] (used reg = )
16540 474F           FF76         F8            push	-8[bp]
16541                                           ! Debug: func () void = _write_word+0 (used reg = )
16542 4752           E8         BEB9            call	__write_word
16543 4755           83C4                   06  add	sp,*6
16544                                           !BCC_EOS
16545                                           ! 3051           _write_word(mouse_driver_seg, &((ebda_data_t *) 0)->mouse_driver_seg, ebda_seg);
16546                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16547 4758           FF76         FE            push	-2[bp]
16548                                           ! Debug: list * unsigned short = const $24 (used reg = )
16549 475B           B8                   0024  mov	ax,*$24
16550 475E           50                         push	ax
16551                                           ! Debug: list unsigned short mouse_driver_seg = [S+$14-8] (used reg = )
16552 475F           FF76         FA            push	-6[bp]
16553                                           ! Debug: func () void = _write_word+0 (used reg = )
16554 4762           E8         BEA9            call	__write_word
16555 4765           83C4                   06  add	sp,*6
16556                                           !BCC_EOS
16557                                           ! 3052           mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16558                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16559 4768           FF76         FE            push	-2[bp]
16560                                           ! Debug: list * unsigned char = const $27 (used reg = )
16561 476B           B8                   0027  mov	ax,*$27
16562 476E           50                         push	ax
16563                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
16564 476F           E8         BE6D            call	__read_byte
16565 4772           83C4                   04  add	sp,*4
16566                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16567 4775           8846         FC            mov	-4[bp],al
16568                                           !BCC_EOS
16569                                           ! 3053           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
16570                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16571 4778           8B46         F8            mov	ax,-8[bp]
16572 477B           85C0                       test	ax,ax
16573 477D           75           1D            jne 	.3F6
16574                       0000477F            .3F8:
16575                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16576 477F           8B46         FA            mov	ax,-6[bp]
16577 4782           85C0                       test	ax,ax
16578 4784           75           16            jne 	.3F6
16579                       00004786            .3F7:
16580                                           ! 3054             if ( (mouse_flags_2 & 0x80) != 0 ) {
16581                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16582 4786           8A46         FC            mov	al,-4[bp]
16583 4789           24                     80  and	al,#$80
16584                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
16585 478B           84C0                       test	al,al
16586 478D           74           0B            je  	.3F9
16587                       0000478F            .3FA:
16588                                           ! 3055               mouse_flags_2 &= ~0x80;
16589                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16590 478F           8A46         FC            mov	al,-4[bp]
16591 4792           24                     7F  and	al,*$7F
16592 4794           8846         FC            mov	-4[bp],al
16593                                           !BCC_EOS
16594                                           ! 3056               inhibit_mouse_
16595                                           ! 3056 int_and_events();
16596                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16597 4797           E8         0A55            call	_inhibit_mouse_int_and_events
16598                                           !BCC_EOS
16599                                           ! 3057             }
16600                                           ! 3058           }
16601                       0000479A            .3F9:
16602                                           ! 3059           else {
16603 479A           EB           08            jmp .3FB
16604                       0000479C            .3F6:
16605                                           ! 3060             mouse_flags_2 |= 0x80;
16606                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16607 479C           8A46         FC            mov	al,-4[bp]
16608 479F           0C                     80  or	al,#$80
16609 47A1           8846         FC            mov	-4[bp],al
16610                                           !BCC_EOS
16611                                           ! 3061           }
16612                                           ! 3062           _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16613                       000047A4            .3FB:
16614                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16615 47A4           FF76         FE            push	-2[bp]
16616                                           ! Debug: list * unsigned char = const $27 (used reg = )
16617 47A7           B8                   0027  mov	ax,*$27
16618 47AA           50                         push	ax
16619                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
16620 47AB           8A46         FC            mov	al,-4[bp]
16621 47AE           30E4                       xor	ah,ah
16622 47B0           50                         push	ax
16623                                           ! Debug: func () void = _write_byte+0 (used reg = )
16624 47B1           E8         BE47            call	__write_byte
16625 47B4           83C4                   06  add	sp,*6
16626                                           !BCC_EOS
16627                                           ! 3063           FLAGS &= 0xfffe;
16628                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16629 47B7           8B46         18            mov	ax,$18[bp]
16630 47BA           24                     FE  and	al,#$FE
16631 47BC           8946         18            mov	$18[bp],ax
16632                                           !BCC_EOS
16633                                           ! 3064           regs.u.r8.ah = 0;
16634                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16635 47BF           30C0                       xor	al,al
16636 47C1           8846         13            mov	$13[bp],al
16637                                           !BCC_EOS
16638                                           ! 3065           break;
16639 47C4           EB           34            jmp .386
16640                                           !BCC_EOS
16641                                           ! 3066         default:
16642                                           ! 3067 ;
16643                       000047C6            .3FC:
16644                                           !BCC_EOS
16645                                           ! 3068           regs.u.r8.ah = 1;
16646                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
16647 47C6           B0                     01  mov	al,*1
16648 47C8           8846         13            mov	$13[bp],al
16649                                           !BCC_EOS
16650                                           ! 3069           FLAGS |= 0x0001;
16651                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16652 47CB           8B46         18            mov	ax,$18[bp]
16653 47CE           0C                     01  or	al,*1
16654 47D0           8946         18            mov	$18[bp],ax
16655                                           !BCC_EOS
16656                                           ! 3070       }
16657                                           ! 3071       break;
16658 47D3           EB           25            jmp .386
16659                       000047D5            .388:
16660 47D5           2C                     00  sub	al,*0
16661 47D7           72           ED            jb 	.3FC
16662 47D9           3C                     07  cmp	al,*7
16663 47DB           77           1B            ja  	.3FD
16664 47DD           30E4                       xor	ah,ah
16665 47DF           D1E0                       shl	ax,*1
16666 47E1           89C3                       mov	bx,ax
16667 47E3           2E                         seg	cs
16668 47E4           FFA7       47E8            br	.3FE[bx]
16669                       000047E8            .3FE:
16670 47E8                      41BD            .word	.389
16671 47EA                      42BD            .word	.39C
16672 47EC                      43E5            .word	.3B0
16673 47EE                      44B5            .word	.3C4
16674 47F0                      456E            .word	.3D1
16675 47F2                      42BD            .word	.39D
16676 47F4                      45C1            .word	.3D5
16677 47F6                      473C            .word	.3F5
16678                       000047F8            .3FD:
16679 47F8           EB           CC            jmp	.3FC
16680                       000047FA            .386:
16681 47FA           EB           2D            jmp .382
16682                                           !BCC_EOS
16683                                           ! 3072     default:
16684                                           ! 3073       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
16685                       000047FC            .3FF:
16686                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
16687 47FC           FF76         0C            push	$C[bp]
16688                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
16689 47FF           FF76         12            push	$12[bp]
16690                                           ! Debug: list * char = .400+0 (used reg = )
16691 4802           BB                   D3F3  mov	bx,#.400
16692 4805           53                         push	bx
16693                                           ! Debug: list int = const 4 (used reg = )
16694 4806           B8                   0004  mov	ax,*4
16695 4809           50                         push	ax
16696                                           ! Debug: func () void = bios_printf+0 (used reg = )
16697 480A           E8         C12C            call	_bios_printf
16698 480D           83C4                   08  add	sp,*8
16699                                           !BCC_EOS
16700                                           ! 3074       FLAGS |= 0x0001;
16701                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16702 4810           8B46         18            mov	ax,$18[bp]
16703 4813           0C                     01  or	al,*1
16704 4815           8946         18            mov	$18[bp],ax
16705                                           !BCC_EOS
16706                                           ! 3075       regs.u.r8.ah = 0x86;
16707                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16708 4818           B0                     86  mov	al,#$86
16709 481A           8846         13            mov	$13[bp],al
16710                                           !BCC_EOS
16711                                           ! 3076       break;
16712 481D           EB           0A            jmp .382
16713                                           !BCC_EOS
16714                                           ! 3077   }
16715                                           ! 3078 }
16716 481F           EB           08            jmp .382
16717                       00004821            .384:
16718 4821           2C                     C2  sub	al,#$C2
16719 4823         0F84         F990            beq 	.385
16720 4827           EB           D3            jmp	.3FF
16721                       00004829            .382:
16722                       FFFFFFF0            ..FFF6	=	-$10
16723 4829           89EC                       mov	sp,bp
16724 482B           5D                         pop	bp
16725 482C           C3                         ret
16726                                           ! 3079 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
16727                                           ! Register BX used in function int15_function_mouse
16728                                           ! 3080      Bit16u ES;
16729                                           export	_set_e820_range
16730                       0000482D            _set_e820_range:
16731                                           !BCC_EOS
16732                                           ! 3081      Bit16u DI;
16733                                           !BCC_EOS
16734                                           ! 3082      Bit32u start;
16735                                           !BCC_EOS
16736                                           ! 3083      Bit32u end;
16737                                           !BCC_EOS
16738                                           ! 3084      Bit8u extra_start;
16739                                           !BCC_EOS
16740                                           ! 3085      Bit8u extra_end;
16741                                           !BCC_EOS
16742                                           ! 3086      Bit16u type;
16743                                           !BCC_EOS
16744                                           ! 3087 {
16745                                           ! 3088     Bit16u old_ds = set_DS(ES);
16746 482D           55                         push	bp
16747 482E           89E5                       mov	bp,sp
16748 4830           4C                         dec	sp
16749 4831           4C                         dec	sp
16750                                           ! Debug: list unsigned short ES = [S+4+2] (used reg = )
16751 4832           FF76         04            push	4[bp]
16752                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16753 4835           E8         BE25            call	_set_DS
16754 4838           44                         inc	sp
16755 4839           44                         inc	sp
16756                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+4-4] (used reg = )
16757 483A           8946         FE            mov	-2[bp],ax
16758                                           !BCC_EOS
16759                                           ! 3089     *((Bit32u *)(DI)) = (start);
16760 483D           8B5E         06            mov	bx,6[bp]
16761                                           ! Debug: eq unsigned long start = [S+4+6] to unsigned long = [bx+0] (used reg = )
16762 4840           8B46         08            mov	ax,8[bp]
16763 4843           8B76         0A            mov	si,$A[bp]
16764 4846           8907                       mov	[bx],ax
16765 4848           8977         02            mov	2[bx],si
16766                                           !BCC_EOS
16767                                           ! 3090     *((Bit16u *)(DI+4)) = (extra_start);
16768                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
16769 484B           8B46         06            mov	ax,6[bp]
16770                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+4 (used reg = )
16771 484E           89C3                       mov	bx,ax
16772                                           ! Debug: eq unsigned char extra_start = [S+4+$E] to unsigned short = [bx+4] (used reg = )
16773 4850           8A46         10            mov	al,$10[bp]
16774 4853           30E4                       xor	ah,ah
16775 4855           8947         04            mov	4[bx],ax
16776                                           !BCC_EOS
16777                                           ! 3091     *((Bit16u *)(DI+6)) = (0x00);
16778                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
16779 4858           8B46         06            mov	ax,6[bp]
16780                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+6 (used reg = )
16781 485B           89C3                       mov	bx,ax
16782                                           ! Debug: eq int = const 0 to unsigned short = [bx+6] (used reg = )
16783 485D           31C0                       xor	ax,ax
16784 485F           8947         06            mov	6[bx],ax
16785                                           !BCC_EOS
16786                                           ! 3092     end -= start;
16787                                           ! Debug: subab unsigned long start = [S+4+6] to unsigned long end = [S+4+$A] (used reg = )
16788 4862           8B46         0C            mov	ax,$C[bp]
16789 4865           8B5E         0E            mov	bx,$E[bp]
16790 4868           8D7E         08            lea	di,8[bp]
16791 486B           E8         B844            call	lsubul
16792 486E           8946         0C            mov	$C[bp],ax
16793 4871           895E         0E            mov	$E[bp],bx
16794                                           !BCC_EOS
16795                                           ! 3093     extra_end -= extra_start;
16796                                           ! Debug: subab unsigned char extra_start = [S+4+$E] to unsigned char extra_end = [S+4+$10] (used reg = )
16797 4874           8A46         12            mov	al,$12[bp]
16798 4877           30E4                       xor	ah,ah
16799 4879           2A46         10            sub	al,$10[bp]
16800 487C           80DC                   00  sbb	ah,*0
16801 487F           8846         12            mov	$12[bp],al
16802                                           !BCC_EOS
16803                                           ! 3094     *((Bit32u *)(DI+8)) = (end);
16804                                           ! Debug: add int = const 8 to unsigned short DI = [S+4+4] (used reg = )
16805 4882           8B46         06            mov	ax,6[bp]
16806                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+8 (used reg = )
16807 4885           89C3                       mov	bx,ax
16808                                           ! Debug: eq unsigned long end = [S+4+$A] to unsigned long = [bx+8] (used reg = )
16809 4887           8B46         0C            mov	ax,$C[bp]
16810 488A           8B76         0E            mov	si,$E[bp]
16811 488D           8947         08            mov	8[bx],ax
16812 4890           8977         0A            mov	$A[bx],si
16813                                           !BCC_EOS
16814                                           ! 3095     *((Bit16u *)(DI+12)) = (extra_end);
16815                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
16816 4893           8B46         06            mov	ax,6[bp]
16817                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
16818 4896           89C3                       mov	bx,ax
16819                                           ! Debug: eq unsigned char extra_end = [S+4+$10] to unsigned short = [bx+$C] (used reg = )
16820 4898           8A46         12            mov	al,$12[bp]
16821 489B           30E4                       xor	ah,ah
16822 489D           8947         0C            mov	$C[bx],ax
16823                                           !BCC_EOS
16824                                           ! 3096     *((Bit16u *)(DI+14)) = (0x0000);
16825                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
16826 48A0           8B46         06            mov	ax,6[bp]
16827                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
16828 48A3           89C3                       mov	bx,ax
16829                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
16830 48A5           31C0                       xor	ax,ax
16831 48A7           8947         0E            mov	$E[bx],ax
16832                                           !BCC_EOS
16833                                           ! 3097     *((Bit16u *)(DI+16)) = (type);
16834                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
16835 48AA           8B46         06            mov	ax,6[bp]
16836                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$10 (used reg = )
16837 48AD           89C3                       mov	bx,ax
16838                                           ! Debug: eq unsigned short type = [S+4+$12] to unsigned short = [bx+$10] (used reg = )
16839 48AF           8B46         14            mov	ax,$14[bp]
16840 48B2           8947         10            mov	$10[bx],ax
16841                                           !BCC_EOS
16842                                           ! 3098     *((Bit16u *)(DI+18)) = (0x0);
16843                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
16844 48B5           8B46         06            mov	ax,6[bp]
16845                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$12 (used reg = )
16846 48B8           89C3                       mov	bx,ax
16847                                           ! Debug: eq int = const 0 to unsigned short = [bx+$12] (used reg = )
16848 48BA           31C0                       xor	ax,ax
16849 48BC           8947         12            mov	$12[bx],ax
16850                                           !BCC_EOS
16851                                           ! 3099     set_DS(old_ds);
16852                                           ! Debug: list unsigned short old_ds = [S+4-4] (used reg = )
16853 48BF           FF76         FE            push	-2[bp]
16854                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16855 48C2           E8         BD98            call	_set_DS
16856 48C5           44                         inc	sp
16857 48C6           44                         inc	sp
16858                                           !BCC_EOS
16859                                           ! 3100 }
16860 48C7           89EC                       mov	sp,bp
16861 48C9           5D                         pop	bp
16862 48CA           C3                         ret
16863                                           ! 3101   void
16864                                           ! Register BX used in function set_e820_range
16865                                           ! 3102 int15_function32(regs, ES, DS, FLAGS)
16866                                           ! 3103   pushad_regs_t regs;
16867                                           export	_int15_function32
16868                       000048CB            _int15_function32:
16869                                           !BCC_EOS
16870                                           ! 3104   Bit16u ES, DS, FLAGS;
16871                                           !BCC_EOS
16872                                           ! 3105 {
16873                                           ! 3106   Bit32u extended_memory_size=0;
16874 48CB           55                         push	bp
16875 48CC           89E5                       mov	bp,sp
16876 48CE           83C4                   FC  add	sp,*-4
16877                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
16878 48D1           31C0                       xor	ax,ax
16879 48D3           31DB                       xor	bx,bx
16880 48D5           8946         FC            mov	-4[bp],ax
16881 48D8           895E         FE            mov	-2[bp],bx
16882                                           !BCC_EOS
16883                                           ! 3107   Bit32u extra_lowbits_memory_size=0;
16884 48DB           83C4                   FC  add	sp,*-4
16885                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
16886 48DE           31C0                       xor	ax,ax
16887 48E0           31DB                       xor	bx,bx
16888 48E2           8946         F8            mov	-8[bp],ax
16889 48E5           895E         FA            mov	-6[bp],bx
16890                                           !BCC_EOS
16891                                           ! 3108   Bit16u CX,DX;
16892                                           !BCC_EOS
16893                                           ! 3109   Bit8u extra_highbits_memory_size=0;
16894 48E8           83C4                   FB  add	sp,*-5
16895                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
16896 48EB           30C0                       xor	al,al
16897 48ED           8846         F3            mov	-$D[bp],al
16898                                           !BCC_EOS
16899                                           ! 3110 ;
16900 48F0           4C                         dec	sp
16901                                           !BCC_EOS
16902                                           ! 3111   switch (regs.u.r8.ah) {
16903 48F1           8A46         21            mov	al,$21[bp]
16904 48F4           E9         0487            br 	.403
16905                                           ! 3112     case 0x86:
16906                                           ! 3113       CX = regs.u.r16.cx;
16907                       000048F7            .404:
16908                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
16909 48F7           8B46         1C            mov	ax,$1C[bp]
16910 48FA           8946         F6            mov	-$A[bp],ax
16911                                           !BCC_EOS
16912                                           ! 3114       DX = regs.u.r16.dx;
16913                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
16914 48FD           8B46         18            mov	ax,$18[bp]
16915 4900           8946         F4            mov	-$C[bp],ax
16916                                           !BCC_EOS
16917                                           ! 3115 #asm
16918                                           !BCC_EOS
16919                                           !BCC_ASM
16920                       00000004            _int15_function32.CX	set	4
16921                       FFFFFFF6            .int15_function32.CX	set	-$A
16922                       00000001            _int15_function32.extra_highbits_memory_size	set	1
16923                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
16924                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
16925                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
16926                       0000000A            _int15_function32.extended_memory_size	set	$A
16927                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
16928                       00000036            _int15_function32.FLAGS	set	$36
16929                       00000028            .int15_function32.FLAGS	set	$28
16930                       00000034            _int15_function32.DS	set	$34
16931                       00000026            .int15_function32.DS	set	$26
16932                       00000002            _int15_function32.DX	set	2
16933                       FFFFFFF4            .int15_function32.DX	set	-$C
16934                       00000032            _int15_function32.ES	set	$32
16935                       00000024            .int15_function32.ES	set	$24
16936                       00000012            _int15_function32.regs	set	$12
16937                       00000004            .int15_function32.regs	set	4
16938 4903           FB                               sti
16939                                                 ;; Get the count in eax
16940 4904           89E3                             mov bx, sp
16941 4906           36                               SEG SS
16942 4907           8B47         04                    mov ax, _int15_function32.CX [bx]
16943 490A     66    C1E0                   10        shl eax, #16
16944 490E           36                               SEG SS
16945 490F           8B47         02                    mov ax, _int15_function32.DX [bx]
16946                                                 ;; convert to numbers of 15usec ticks
16947 4912     66    BB               0000000F        mov ebx, #15
16948 4918     66    31D2                             xor edx, edx
16949 491B     66    F7F3                             div eax, ebx
16950 491E     66    89C1                             mov ecx, eax
16951                                                 ;; wait for ecx number of refresh requests
16952 4921           E4                     61        in al, 0x0061
16953 4923           24                     10        and al,#0x10
16954 4925           88C4                             mov ah, al
16955 4927     66    09C9                             or ecx, ecx
16956 492A           74           0E                  je int1586_tick_end
16957                       0000492C            int1586_tick:
16958 492C           E4                     61        in al, 0x0061
16959 492E           24                     10        and al,#0x10
16960 4930           38E0                             cmp al, ah
16961 4932           74           F8                  je int1586_tick
16962 4934           88C4                             mov ah, al
16963 4936     66    49                               dec ecx
16964 4938           75           F2                  jnz int1586_tick
16965                       0000493A            int1586_tick_end:
16966                                           ! 3144 endasm
16967                                           !BCC_ENDASM
16968                                           !BCC_EOS
16969                                           ! 3145       break;
16970 493A           E9         044F            br 	.401
16971                                           !BCC_EOS
16972                                           ! 3146     case 0xe8:
16973                                           ! 3147         switch(regs.u.r8.al) {
16974                       0000493D            .405:
16975 493D           8A46         20            mov	al,$20[bp]
16976 4940           E9         0408            br 	.408
16977                                           ! 3148          case 0x20:
16978                                           ! 3149             if (regs.u.r32.edx == 0x534D4150) {
16979                       00004943            .409:
16980                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
16981                                           ! Debug: expression subtree swapping
16982 4943           B8                   4150  mov	ax,#$4150
16983 4946           BB                   534D  mov	bx,#$534D
16984 4949           53                         push	bx
16985 494A           50                         push	ax
16986 494B           8B46         18            mov	ax,$18[bp]
16987 494E           8B5E         1A            mov	bx,$1A[bp]
16988 4951           8D7E         EE            lea	di,-2+..FFF5[bp]
16989 4954           E8         B745            call	lcmpul
16990 4957           8D66         F2            lea	sp,2+..FFF5[bp]
16991 495A         0F85         038B            bne 	.40A
16992                       0000495E            .40B:
16993                                           ! 3150                 *((Bit8u *)&extended_memory_size) = inb_cmos(0x34);
16994                                           ! Debug: list int = const $34 (used reg = )
16995 495E           B8                   0034  mov	ax,*$34
16996 4961           50                         push	ax
16997                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16998 4962           E8         BC09            call	_inb_cmos
16999 4965           44                         inc	sp
17000 4966           44                         inc	sp
17001                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17002 4967           8846         FC            mov	-4[bp],al
17003                                           !BCC_EOS
17004                                           ! 3151                 *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x35);
17005                                           ! Debug: list int = const $35 (used reg = )
17006 496A           B8                   0035  mov	ax,*$35
17007 496D           50                         push	ax
17008                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17009 496E           E8         BBFD            call	_inb_cmos
17010 4971           44                         inc	sp
17011 4972           44                         inc	sp
17012                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17013 4973           8846         FD            mov	-3[bp],al
17014                                           !BCC_EOS
17015                                           ! 3152                 extended_memory_size *= 64;
17016                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17017 4976           B8                   0040  mov	ax,*$40
17018 4979           31DB                       xor	bx,bx
17019 497B           53                         push	bx
17020 497C           50                         push	ax
17021 497D           8B46         FC            mov	ax,-4[bp]
17022 4980           8B5E         FE            mov	bx,-2[bp]
17023 4983           8D7E         EE            lea	di,-2+..FFF5[bp]
17024 4986           E8         B731            call	lmulul
17025 4989           8946         FC            mov	-4[bp],ax
17026 498C           895E         FE            mov	-2[bp],bx
17027 498F           83C4                   04  add	sp,*4
17028                                           !BCC_EOS
17029                                           ! 3153                 if (extended_memory_size > 0x2fc000) {
17030                                           ! Debug: gt long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17031 4992           B8                   C000  mov	ax,#$C000
17032 4995           BB                   002F  mov	bx,*$2F
17033 4998           8D7E         FC            lea	di,-4[bp]
17034 499B           E8         B6FE            call	lcmpul
17035 499E           73           0C            jae 	.40C
17036                       000049A0            .40D:
17037                                           ! 3154                     extended_memory_size = 0x2fc000;
17038                                           ! Debug: eq long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17039 49A0           B8                   C000  mov	ax,#$C000
17040 49A3           BB                   002F  mov	bx,*$2F
17041 49A6           8946         FC            mov	-4[bp],ax
17042 49A9           895E         FE            mov	-2[bp],bx
17043                                           !BCC_EOS
17044                                           ! 3155                 }
17045                                           ! 3156                 extended_memory_size *= 1024;
17046                       000049AC            .40C:
17047                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17048 49AC           B8                   0400  mov	ax,#$400
17049 49AF           31DB                       xor	bx,bx
17050 49B1           53                         push	bx
17051 49B2           50                         push	ax
17052 49B3           8B46         FC            mov	ax,-4[bp]
17053 49B6           8B5E         FE            mov	bx,-2[bp]
17054 49B9           8D7E         EE            lea	di,-2+..FFF5[bp]
17055 49BC           E8         B6FB            call	lmulul
17056 49BF           8946         FC            mov	-4[bp],ax
17057 49C2           895E         FE            mov	-2[bp],bx
17058 49C5           83C4                   04  add	sp,*4
17059                                           !BCC_EOS
17060                                           ! 3157                 extended_memory_size += (16L * 1024 * 1024);
17061                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17062 49C8           31C0                       xor	ax,ax
17063 49CA           BB                   0100  mov	bx,#$100
17064 49CD           53                         push	bx
17065 49CE           50                         push	ax
17066 49CF           8B46         FC            mov	ax,-4[bp]
17067 49D2           8B5E         FE            mov	bx,-2[bp]
17068 49D5           8D7E         EE            lea	di,-2+..FFF5[bp]
17069 49D8           E8         B6B9            call	laddul
17070 49DB           8946         FC            mov	-4[bp],ax
17071 49DE           895E         FE            mov	-2[bp],bx
17072 49E1           83C4                   04  add	sp,*4
17073                                           !BCC_EOS
17074                                           ! 3158                 if (extended_memory_size <= (16L * 1024 * 1024)) {
17075                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17076 49E4           31C0                       xor	ax,ax
17077 49E6           BB                   0100  mov	bx,#$100
17078 49E9           8D7E         FC            lea	di,-4[bp]
17079 49EC           E8         B6AD            call	lcmpul
17080 49EF           72           50            jb  	.40E
17081                       000049F1            .40F:
17082                                           ! 3159                     *((Bit8u *)&extended_memory_size) = inb_cmos(0x30);
17083                                           ! Debug: list int = const $30 (used reg = )
17084 49F1           B8                   0030  mov	ax,*$30
17085 49F4           50                         push	ax
17086                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17087 49F5           E8         BB76            call	_inb_cmos
17088 49F8           44                         inc	sp
17089 49F9           44                         inc	sp
17090                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17091 49FA           8846         FC            mov	-4[bp],al
17092                                           !BCC_EOS
17093                                           ! 3160                     *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x31);
17094                                           ! Debug: list int = const $31 (used reg = )
17095 49FD           B8                   0031  mov	ax,*$31
17096 4A00           50                         push	ax
17097                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17098 4A01           E8         BB6A            call	_inb_cmos
17099 4A04           44                         inc	sp
17100 4A05           44                         inc	sp
17101                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17102 4A06           8846         FD            mov	-3[bp],al
17103                                           !BCC_EOS
17104                                           ! 3161                     extended_memory_size *= 1024;
17105                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17106 4A09           B8                   0400  mov	ax,#$400
17107 4A0C           31DB                       xor	bx,bx
17108 4A0E           53                         push	bx
17109 4A0F           50                         push	ax
17110 4A10           8B46         FC            mov	ax,-4[bp]
17111 4A13           8B5E         FE            mov	bx,-2[bp]
17112 4A16           8D7E         EE            lea	di,-2+..FFF5[bp]
17113 4A19           E8         B69E            call	lmulul
17114 4A1C           8946         FC            mov	-4[bp],ax
17115 4A1F           895E         FE            mov	-2[bp],bx
17116 4A22           83C4                   04  add	sp,*4
17117                                           !BCC_EOS
17118                                           ! 3162                     extended_memory_size += (1L * 1024 * 1024);
17119                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17120 4A25           31C0                       xor	ax,ax
17121 4A27           BB                   0010  mov	bx,*$10
17122 4A2A           53                         push	bx
17123 4A2B           50                         push	ax
17124 4A2C           8B46         FC            mov	ax,-4[bp]
17125 4A2F           8B5E         FE            mov	bx,-2[bp]
17126 4A32           8D7E         EE            lea	di,-2+..FFF5[bp]
17127 4A35           E8         B65C            call	laddul
17128 4A38           8946         FC            mov	-4[bp],ax
17129 4A3B           895E         FE            mov	-2[bp],bx
17130 4A3E           83C4                   04  add	sp,*4
17131                                           !BCC_EOS
17132                                           ! 3163                 }
17133                                           ! 3164                 *((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1)) = inb_cmos(0x5b);
17134                       00004A41            .40E:
17135                                           ! Debug: list int = const $5B (used reg = )
17136 4A41           B8                   005B  mov	ax,*$5B
17137 4A44           50                         push	ax
17138                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17139 4A45           E8         BB26            call	_inb_cmos
17140 4A48           44                         inc	sp
17141 4A49           44                         inc	sp
17142                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-8] (used reg = )
17143 4A4A           8846         FA            mov	-6[bp],al
17144                                           !BCC_EOS
17145                                           ! 3165                 *(((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1))+1) = inb_cmos(0x5c);
17146                                           ! Debug: list int = const $5C (used reg = )
17147 4A4D           B8                   005C  mov	ax,*$5C
17148 4A50           50                         push	ax
17149                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17150 4A51           E8         BB1A            call	_inb_cmos
17151 4A54           44                         inc	sp
17152 4A55           44                         inc	sp
17153                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-7] (used reg = )
17154 4A56           8846         FB            mov	-5[bp],al
17155                                           !BCC_EOS
17156                                           ! 3166                 *((Bit16u *)&extra_lowbits_memory_size) = 0;
17157                                           ! Debug: eq int = const 0 to unsigned short extra_lowbits_memory_size = [S+$10-$A] (used reg = )
17158 4A59           31C0                       xor	ax,ax
17159 4A5B           8946         F8            mov	-8[bp],ax
17160                                           !BCC_EOS
17161                                           ! 3167                 extra_highbits_memory_size = inb_cmos(0x5d);
17162                                           ! Debug: list int = const $5D (used reg = )
17163 4A5E           B8                   005D  mov	ax,*$5D
17164 4A61           50                         push	ax
17165                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17166 4A62           E8         BB09            call	_inb_cmos
17167 4A65           44                         inc	sp
17168 4A66           44                         inc	sp
17169                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17170 4A67           8846         F3            mov	-$D[bp],al
17171                                           !BCC_EOS
17172                                           ! 3168                 switch(regs.u.r16.bx)
17173 4A6A           8B46         14            mov	ax,$14[bp]
17174                                           ! 3169                 {
17175 4A6D           E9         0233            br 	.412
17176                                           ! 3170                     case 0:
17177                                           ! 3171                         set_e820_range(ES, regs.u.r16.di,
17178                       00004A70            .413:
17179                                           ! 3172                                        0x0000000L, 0x0009f000L, 0, 0, 1);
17180                                           ! Debug: list int = const 1 (used reg = )
17181 4A70           B8                   0001  mov	ax,*1
17182 4A73           50                         push	ax
17183                                           ! Debug: list int = const 0 (used reg = )
17184 4A74           31C0                       xor	ax,ax
17185 4A76           50                         push	ax
17186                                           ! Debug: list int = const 0 (used reg = )
17187 4A77           31C0                       xor	ax,ax
17188 4A79           50                         push	ax
17189                                           ! Debug: list long = const $9F000 (used reg = )
17190 4A7A           B8                   F000  mov	ax,#$F000
17191 4A7D           BB                   0009  mov	bx,*9
17192 4A80           53                         push	bx
17193 4A81           50                         push	ax
17194                                           ! Debug: list long = const 0 (used reg = )
17195 4A82           31C0                       xor	ax,ax
17196 4A84           31DB                       xor	bx,bx
17197 4A86           53                         push	bx
17198 4A87           50                         push	ax
17199                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17200 4A88           FF76         04            push	4[bp]
17201                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17202 4A8B           FF76         24            push	$24[bp]
17203                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17204 4A8E           E8         FD9C            call	_set_e820_range
17205 4A91           83C4                   12  add	sp,*$12
17206                                           !BCC_EOS
17207                                           ! 3173                         regs.u.r32.ebx = 1;
17208                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
17209 4A94           B8                   0001  mov	ax,*1
17210 4A97           31DB                       xor	bx,bx
17211 4A99           8946         14            mov	$14[bp],ax
17212 4A9C           895E         16            mov	$16[bp],bx
17213                                           !BCC_EOS
17214                                           ! 3174                         break;
17215 4A9F           E9         0226            br 	.410
17216                                           !BCC_EOS
17217                                           ! 3175                     case 1:
17218                                           ! 3176                         set_e820_range(ES, regs.u.r16.di,
17219                       00004AA2            .414:
17220                                           ! 3177                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
17221                                           ! Debug: list int = const 2 (used reg = )
17222 4AA2           B8                   0002  mov	ax,*2
17223 4AA5           50                         push	ax
17224                                           ! Debug: list int = const 0 (used reg = )
17225 4AA6           31C0                       xor	ax,ax
17226 4AA8           50                         push	ax
17227                                           ! Debug: list int = const 0 (used reg = )
17228 4AA9           31C0                       xor	ax,ax
17229 4AAB           50                         push	ax
17230                                           ! Debug: list long = const $A0000 (used reg = )
17231 4AAC           31C0                       xor	ax,ax
17232 4AAE           BB                   000A  mov	bx,*$A
17233 4AB1           53                         push	bx
17234 4AB2           50                         push	ax
17235                                           ! Debug: list long = const $9F000 (used reg = )
17236 4AB3           B8                   F000  mov	ax,#$F000
17237 4AB6           BB                   0009  mov	bx,*9
17238 4AB9           53                         push	bx
17239 4ABA           50                         push	ax
17240                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17241 4ABB           FF76         04            push	4[bp]
17242                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17243 4ABE           FF76         24            push	$24[bp]
17244                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17245 4AC1           E8         FD69            call	_set_e820_range
17246 4AC4           83C4                   12  add	sp,*$12
17247                                           !BCC_EOS
17248                                           ! 3178                         regs.u.r32.ebx = 2;
17249                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
17250 4AC7           B8                   0002  mov	ax,*2
17251 4ACA           31DB                       xor	bx,bx
17252 4ACC           8946         14            mov	$14[bp],ax
17253 4ACF           895E         16            mov	$16[bp],bx
17254                                           !BCC_EOS
17255                                           ! 3179                         break;
17256 4AD2           E9         01F3            br 	.410
17257                                           !BCC_EOS
17258                                           ! 3180                     case 2:
17259                                           ! 3181                         set_e820_range(ES, regs.u.r16.di,
17260                       00004AD5            .415:
17261                                           ! 3182                                        0x000e8000L, 0x00100000L, 0, 0, 2);
17262                                           ! Debug: list int = const 2 (used reg = )
17263 4AD5           B8                   0002  mov	ax,*2
17264 4AD8           50                         push	ax
17265                                           ! Debug: list int = const 0 (used reg = )
17266 4AD9           31C0                       xor	ax,ax
17267 4ADB           50                         push	ax
17268                                           ! Debug: list int = const 0 (used reg = )
17269 4ADC           31C0                       xor	ax,ax
17270 4ADE           50                         push	ax
17271                                           ! Debug: list long = const $100000 (used reg = )
17272 4ADF           31C0                       xor	ax,ax
17273 4AE1           BB                   0010  mov	bx,*$10
17274 4AE4           53                         push	bx
17275 4AE5           50                         push	ax
17276                                           ! Debug: list long = const $E8000 (used reg = )
17277 4AE6           B8                   8000  mov	ax,#$8000
17278 4AE9           BB                   000E  mov	bx,*$E
17279 4AEC           53                         push	bx
17280 4AED           50                         push	ax
17281                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17282 4AEE           FF76         04            push	4[bp]
17283                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17284 4AF1           FF76         24            push	$24[bp]
17285                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17286 4AF4           E8         FD36            call	_set_e820_range
17287 4AF7           83C4                   12  add	sp,*$12
17288                                           !BCC_EOS
17289                                           ! 3183                         if (extended_memory_size <= 0x100000)
17290                                           ! Debug: le long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17291 4AFA           31C0                       xor	ax,ax
17292 4AFC           BB                   0010  mov	bx,*$10
17293 4AFF           8D7E         FC            lea	di,-4[bp]
17294 4B02           E8         B597            call	lcmpul
17295 4B05           72           0D            jb  	.416
17296                       00004B07            .417:
17297                                           ! 3184      
17298                                           ! 3184                        regs.u.r32.ebx = 6;
17299                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17300 4B07           B8                   0006  mov	ax,*6
17301 4B0A           31DB                       xor	bx,bx
17302 4B0C           8946         14            mov	$14[bp],ax
17303 4B0F           895E         16            mov	$16[bp],bx
17304                                           !BCC_EOS
17305                                           ! 3185                         else
17306                                           ! 3186                             regs.u.r32.ebx = 3;
17307 4B12           EB           0B            jmp .418
17308                       00004B14            .416:
17309                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
17310 4B14           B8                   0003  mov	ax,*3
17311 4B17           31DB                       xor	bx,bx
17312 4B19           8946         14            mov	$14[bp],ax
17313 4B1C           895E         16            mov	$16[bp],bx
17314                                           !BCC_EOS
17315                                           ! 3187                         break;
17316                       00004B1F            .418:
17317 4B1F           E9         01A6            br 	.410
17318                                           !BCC_EOS
17319                                           ! 3188                     case 3:
17320                                           ! 3189                         set_e820_range(ES, regs.u.r16.di,
17321                       00004B22            .419:
17322                                           ! 3190                                        0x00100000L,
17323                                           ! 3191                                        extended_memory_size - 0x00010000L, 0, 0, 1);
17324                                           ! Debug: list int = const 1 (used reg = )
17325 4B22           B8                   0001  mov	ax,*1
17326 4B25           50                         push	ax
17327                                           ! Debug: list int = const 0 (used reg = )
17328 4B26           31C0                       xor	ax,ax
17329 4B28           50                         push	ax
17330                                           ! Debug: list int = const 0 (used reg = )
17331 4B29           31C0                       xor	ax,ax
17332 4B2B           50                         push	ax
17333                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17334 4B2C           31C0                       xor	ax,ax
17335 4B2E           BB                   0001  mov	bx,*1
17336 4B31           53                         push	bx
17337 4B32           50                         push	ax
17338 4B33           8B46         FC            mov	ax,-4[bp]
17339 4B36           8B5E         FE            mov	bx,-2[bp]
17340 4B39           8D7E         E8            lea	di,-8+..FFF5[bp]
17341 4B3C           E8         B573            call	lsubul
17342 4B3F           83C4                   04  add	sp,*4
17343                                           ! Debug: list unsigned long = bx+0 (used reg = )
17344 4B42           53                         push	bx
17345 4B43           50                         push	ax
17346                                           ! Debug: list long = const $100000 (used reg = )
17347 4B44           31C0                       xor	ax,ax
17348 4B46           BB                   0010  mov	bx,*$10
17349 4B49           53                         push	bx
17350 4B4A           50                         push	ax
17351                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17352 4B4B           FF76         04            push	4[bp]
17353                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17354 4B4E           FF76         24            push	$24[bp]
17355                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17356 4B51           E8         FCD9            call	_set_e820_range
17357 4B54           83C4                   12  add	sp,*$12
17358                                           !BCC_EOS
17359                                           ! 3192                         regs.u.r32.ebx = 5;
17360                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17361 4B57           B8                   0005  mov	ax,*5
17362 4B5A           31DB                       xor	bx,bx
17363 4B5C           8946         14            mov	$14[bp],ax
17364 4B5F           895E         16            mov	$16[bp],bx
17365                                           !BCC_EOS
17366                                           ! 3193                         break;
17367 4B62           E9         0163            br 	.410
17368                                           !BCC_EOS
17369                                           ! 3194                     case 4:
17370                                           ! 3195                         set_e820_range(ES, regs.u.r16.di,
17371                       00004B65            .41A:
17372                                           ! 3196                                        extended_memory_size - 0x00010000L - 0x00002000,
17373                                           ! 3197                                        extended_memory_size - 0x00010000L, 0, 0, 2);
17374                                           ! Debug: list int = const 2 (used reg = )
17375 4B65           B8                   0002  mov	ax,*2
17376 4B68           50                         push	ax
17377                                           ! Debug: list int = const 0 (used reg = )
17378 4B69           31C0                       xor	ax,ax
17379 4B6B           50                         push	ax
17380                                           ! Debug: list int = const 0 (used reg = )
17381 4B6C           31C0                       xor	ax,ax
17382 4B6E           50                         push	ax
17383                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17384 4B6F           31C0                       xor	ax,ax
17385 4B71           BB                   0001  mov	bx,*1
17386 4B74           53                         push	bx
17387 4B75           50                         push	ax
17388 4B76           8B46         FC            mov	ax,-4[bp]
17389 4B79           8B5E         FE            mov	bx,-2[bp]
17390 4B7C           8D7E         E8            lea	di,-8+..FFF5[bp]
17391 4B7F           E8         B530            call	lsubul
17392 4B82           83C4                   04  add	sp,*4
17393                                           ! Debug: list unsigned long = bx+0 (used reg = )
17394 4B85           53                         push	bx
17395 4B86           50                         push	ax
17396                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17397 4B87           31C0                       xor	ax,ax
17398 4B89           BB                   0001  mov	bx,*1
17399 4B8C           53                         push	bx
17400 4B8D           50                         push	ax
17401 4B8E           8B46         FC            mov	ax,-4[bp]
17402 4B91           8B5E         FE            mov	bx,-2[bp]
17403 4B94           8D7E         E4            lea	di,-$C+..FFF5[bp]
17404 4B97           E8         B518            call	lsubul
17405 4B9A           83C4                   04  add	sp,*4
17406                                           ! Debug: sub unsigned long = const $2000 to unsigned long = bx+0 (used reg = )
17407 4B9D           53                         push	bx
17408 4B9E           50                         push	ax
17409 4B9F           B8                   2000  mov	ax,#$2000
17410 4BA2           31DB                       xor	bx,bx
17411 4BA4           53                         push	bx
17412 4BA5           50                         push	ax
17413 4BA6           8B46         E4            mov	ax,-$C+..FFF5[bp]
17414 4BA9           8B5E         E6            mov	bx,-$A+..FFF5[bp]
17415 4BAC           8D7E         E0            lea	di,-$10+..FFF5[bp]
17416 4BAF           E8         B500            call	lsubul
17417 4BB2           83C4                   08  add	sp,*8
17418                                           ! Debug: list unsigned long = bx+0 (used reg = )
17419 4BB5           53                         push	bx
17420 4BB6           50                         push	ax
17421                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17422 4BB7           FF76         04            push	4[bp]
17423                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17424 4BBA           FF76         24            push	$24[bp]
17425                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17426 4BBD           E8         FC6D            call	_set_e820_range
17427 4BC0           83C4                   12  add	sp,*$12
17428                                           !BCC_EOS
17429                                           ! 3198                         regs.u.r32.ebx = 5;
17430                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17431 4BC3           B8                   0005  mov	ax,*5
17432 4BC6           31DB                       xor	bx,bx
17433 4BC8           8946         14            mov	$14[bp],ax
17434 4BCB           895E         16            mov	$16[bp],bx
17435                                           !BCC_EOS
17436                                           ! 3199                         break;
17437 4BCE           E9         00F7            br 	.410
17438                                           !BCC_EOS
17439                                           ! 3200                     case 5:
17440                                           ! 3201                         set_e820_range(ES, regs.u.r16.di,
17441                       00004BD1            .41B:
17442                                           ! 3202                                        extended_memory_size - 0x00010000L,
17443                                           ! 3203                                        extended_memory_size, 0, 0, 3);
17444                                           ! Debug: list int = const 3 (used reg = )
17445 4BD1           B8                   0003  mov	ax,*3
17446 4BD4           50                         push	ax
17447                                           ! Debug: list int = const 0 (used reg = )
17448 4BD5           31C0                       xor	ax,ax
17449 4BD7           50                         push	ax
17450                                           ! Debug: list int = const 0 (used reg = )
17451 4BD8           31C0                       xor	ax,ax
17452 4BDA           50                         push	ax
17453                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17454 4BDB           FF76         FE            push	-2[bp]
17455 4BDE           FF76         FC            push	-4[bp]
17456                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17457 4BE1           31C0                       xor	ax,ax
17458 4BE3           BB                   0001  mov	bx,*1
17459 4BE6           53                         push	bx
17460 4BE7           50                         push	ax
17461 4BE8           8B46         FC            mov	ax,-4[bp]
17462 4BEB           8B5E         FE            mov	bx,-2[bp]
17463 4BEE           8D7E         E4            lea	di,-$C+..FFF5[bp]
17464 4BF1           E8         B4BE            call	lsubul
17465 4BF4           83C4                   04  add	sp,*4
17466                                           ! Debug: list unsigned long = bx+0 (used reg = )
17467 4BF7           53                         push	bx
17468 4BF8           50                         push	ax
17469                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17470 4BF9           FF76         04            push	4[bp]
17471                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17472 4BFC           FF76         24            push	$24[bp]
17473                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17474 4BFF           E8         FC2B            call	_set_e820_range
17475 4C02           83C4                   12  add	sp,*$12
17476                                           !BCC_EOS
17477                                           ! 3204                         regs.u.r32.ebx = 6;
17478                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17479 4C05           B8                   0006  mov	ax,*6
17480 4C08           31DB                       xor	bx,bx
17481 4C0A           8946         14            mov	$14[bp],ax
17482 4C0D           895E         16            mov	$16[bp],bx
17483                                           !BCC_EOS
17484                                           ! 3205                         break;
17485 4C10           E9         00B5            br 	.410
17486                                           !BCC_EOS
17487                                           ! 3206                     case 6:
17488                                           ! 3207                         set_e820_range(ES, regs.u.r16.di,
17489                       00004C13            .41C:
17490                                           ! 3208                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
17491                                           ! Debug: list int = const 2 (used reg = )
17492 4C13           B8                   0002  mov	ax,*2
17493 4C16           50                         push	ax
17494                                           ! Debug: list int = const 0 (used reg = )
17495 4C17           31C0                       xor	ax,ax
17496 4C19           50                         push	ax
17497                                           ! Debug: list int = const 0 (used reg = )
17498 4C1A           31C0                       xor	ax,ax
17499 4C1C           50                         push	ax
17500                                           ! Debug: list long = const 0 (used reg = )
17501 4C1D           31C0                       xor	ax,ax
17502 4C1F           31DB                       xor	bx,bx
17503 4C21           53                         push	bx
17504 4C22           50                         push	ax
17505                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
17506 4C23           31C0                       xor	ax,ax
17507 4C25           BB                   FFFC  mov	bx,#$FFFC
17508 4C28           53                         push	bx
17509 4C29           50                         push	ax
17510                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17511 4C2A           FF76         04            push	4[bp]
17512                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17513 4C2D           FF76         24            push	$24[bp]
17514                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17515 4C30           E8         FBFA            call	_set_e820_range
17516 4C33           83C4                   12  add	sp,*$12
17517                                           !BCC_EOS
17518                                           ! 3209                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
17519                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17520 4C36           8A46         F3            mov	al,-$D[bp]
17521 4C39           30E4                       xor	ah,ah
17522 4C3B           31DB                       xor	bx,bx
17523 4C3D           E8         B4A5            call	ltstl
17524 4C40           75           0B            jne 	.41E
17525                       00004C42            .41F:
17526 4C42           8B46         F8            mov	ax,-8[bp]
17527 4C45           8B5E         FA            mov	bx,-6[bp]
17528 4C48           E8         B49A            call	ltstl
17529 4C4B           74           0D            je  	.41D
17530                       00004C4D            .41E:
17531                                           ! 3210                             regs.u.r32.ebx = 7;
17532                                           ! Debug: eq int = const 7 to unsigned long regs = [S+$10+$12] (used reg = )
17533 4C4D           B8                   0007  mov	ax,*7
17534 4C50           31DB                       xor	bx,bx
17535 4C52           8946         14            mov	$14[bp],ax
17536 4C55           895E         16            mov	$16[bp],bx
17537                                           !BCC_EOS
17538                                           ! 3211                         else
17539                                           ! 3212                             regs.u.r32.ebx = 0;
17540 4C58           EB           0A            jmp .420
17541                       00004C5A            .41D:
17542                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17543 4C5A           31C0                       xor	ax,ax
17544 4C5C           31DB                       xor	bx,bx
17545 4C5E           8946         14            mov	$14[bp],ax
17546 4C61           895E         16            mov	$16[bp],bx
17547                                           !BCC_EOS
17548                                           ! 3213                         break;
17549                       00004C64            .420:
17550 4C64           EB           62            jmp .410
17551                                           !BCC_EOS
17552                                           ! 3214                     case 7:
17553                                           ! 3215                         set_e820_range(ES, regs.u.r16.di, 0x00000000L,
17554                       00004C66            .421:
17555                                           ! 3216                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
17556                                           ! 3217                                        + 1, 1);
17557                                           ! Debug: list int = const 1 (used reg = )
17558 4C66           B8                   0001  mov	ax,*1
17559 4C69           50                         push	ax
17560                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
17561 4C6A           8A46         F3            mov	al,-$D[bp]
17562 4C6D           30E4                       xor	ah,ah
17563                                           ! Debug: list unsigned int = ax+1 (used reg = )
17564 4C6F           40                         inc	ax
17565 4C70           50                         push	ax
17566                                           ! Debug: list int = const 1 (used reg = )
17567 4C71           B8                   0001  mov	ax,*1
17568 4C74           50                         push	ax
17569                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
17570 4C75           FF76         FA            push	-6[bp]
17571 4C78           FF76         F8            push	-8[bp]
17572                                           ! Debug: list long = const 0 (used reg = )
17573 4C7B           31C0                       xor	ax,ax
17574 4C7D           31DB                       xor	bx,bx
17575 4C7F           53                         push	bx
17576 4C80           50                         push	ax
17577                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17578 4C81           FF76         04            push	4[bp]
17579                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17580 4C84           FF76         24            push	$24[bp]
17581                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17582 4C87           E8         FBA3            call	_set_e820_range
17583 4C8A           83C4                   12  add	sp,*$12
17584                                           !BCC_EOS
17585                                           ! 3218                         regs.u.r32.ebx = 0;
17586                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17587 4C8D           31C0                       xor	ax,ax
17588 4C8F           31DB                       xor	bx,bx
17589 4C91           8946         14            mov	$14[bp],ax
17590 4C94           895E         16            mov	$16[bp],bx
17591                                           !BCC_EOS
17592                                           ! 3219                         break;
17593 4C97           EB           2F            jmp .410
17594                                           !BCC_EOS
17595                                           ! 3220                     default:
17596                                           ! 3221                         goto int15_unimplemented;
17597                       00004C99            .422:
17598 4C99           83C4                   00  add	sp,#..FFF4-..FFF5
17599 4C9C           E9         00BA            br 	.FFF4
17600                                           !BCC_EOS
17601                                           ! 3222                         break;
17602 4C9F           EB           27            jmp .410
17603                                           !BCC_EOS
17604                                           ! 3223                 }
17605                                           ! 3224                 regs.u.r32.eax = 0x534D4150;
17606 4CA1           EB           25            jmp .410
17607                       00004CA3            .412:
17608 4CA3           2D                   0000  sub	ax,*0
17609 4CA6           7C           F1            jl 	.422
17610 4CA8           3D                   0007  cmp	ax,*7
17611 4CAB           77           19            ja  	.423
17612 4CAD           D1E0                       shl	ax,*1
17613 4CAF           89C3                       mov	bx,ax
17614 4CB1           2E                         seg	cs
17615 4CB2           FFA7       4CB6            br	.424[bx]
17616                       00004CB6            .424:
17617 4CB6                      4A70            .word	.413
17618 4CB8                      4AA2            .word	.414
17619 4CBA                      4AD5            .word	.415
17620 4CBC                      4B22            .word	.419
17621 4CBE                      4B65            .word	.41A
17622 4CC0                      4BD1            .word	.41B
17623 4CC2                      4C13            .word	.41C
17624 4CC4                      4C66            .word	.421
17625                       00004CC6            .423:
17626 4CC6           EB           D1            jmp	.422
17627                       00004CC8            .410:
17628                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
17629 4CC8           B8                   4150  mov	ax,#$4150
17630 4CCB           BB                   534D  mov	bx,#$534D
17631 4CCE           8946         20            mov	$20[bp],ax
17632 4CD1           895E         22            mov	$22[bp],bx
17633                                           !BCC_EOS
17634                                           ! 3225                 regs.u.r32.ecx = 0x14;
17635                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
17636 4CD4           B8                   0014  mov	ax,*$14
17637 4CD7           31DB                       xor	bx,bx
17638 4CD9           8946         1C            mov	$1C[bp],ax
17639 4CDC           895E         1E            mov	$1E[bp],bx
17640                                           !BCC_EOS
17641                                           ! 3226                 FLAGS &= 0xfffe;
17642                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17643 4CDF           8B46         28            mov	ax,$28[bp]
17644 4CE2           24                     FE  and	al,#$FE
17645 4CE4           8946         28            mov	$28[bp],ax
17646                                           !BCC_EOS
17647                                           ! 3227     
17648                                           ! 3227         } else {
17649 4CE7           EB           05            jmp .425
17650                       00004CE9            .40A:
17651                                           ! 3228               goto int15_unimplemented;
17652 4CE9           83C4                   00  add	sp,#..FFF4-..FFF5
17653 4CEC           EB           6B            jmp .FFF4
17654                                           !BCC_EOS
17655                                           ! 3229             }
17656                                           ! 3230             break;
17657                       00004CEE            .425:
17658 4CEE           EB           67            jmp .406
17659                                           !BCC_EOS
17660                                           ! 3231         case 0x01:
17661                                           ! 3232           FLAGS &= 0xfffe;
17662                       00004CF0            .426:
17663                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17664 4CF0           8B46         28            mov	ax,$28[bp]
17665 4CF3           24                     FE  and	al,#$FE
17666 4CF5           8946         28            mov	$28[bp],ax
17667                                           !BCC_EOS
17668                                           ! 3233           regs.u.r8.cl = inb_cmos(0x30);
17669                                           ! Debug: list int = const $30 (used reg = )
17670 4CF8           B8                   0030  mov	ax,*$30
17671 4CFB           50                         push	ax
17672                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17673 4CFC           E8         B86F            call	_inb_cmos
17674 4CFF           44                         inc	sp
17675 4D00           44                         inc	sp
17676                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
17677 4D01           8846         1C            mov	$1C[bp],al
17678                                           !BCC_EOS
17679                                           ! 3234           regs.u.r8.ch = inb_cmos(0x31);
17680                                           ! Debug: list int = const $31 (used reg = )
17681 4D04           B8                   0031  mov	ax,*$31
17682 4D07           50                         push	ax
17683                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17684 4D08           E8         B863            call	_inb_cmos
17685 4D0B           44                         inc	sp
17686 4D0C           44                         inc	sp
17687                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
17688 4D0D           8846         1D            mov	$1D[bp],al
17689                                           !BCC_EOS
17690                                           ! 3235           if(regs.u.r16.cx > 0x3c00)
17691                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17692 4D10           8B46         1C            mov	ax,$1C[bp]
17693 4D13           3D                   3C00  cmp	ax,#$3C00
17694 4D16           76           06            jbe 	.427
17695                       00004D18            .428:
17696                                           ! 3236           {
17697                                           ! 3237             regs.u.r16.cx = 0x3c00;
17698                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17699 4D18           B8                   3C00  mov	ax,#$3C00
17700 4D1B           8946         1C            mov	$1C[bp],ax
17701                                           !BCC_EOS
17702                                           ! 3238           }
17703                                           ! 3239           regs.u.r8.dl = inb_cmos(0x34);
17704                       00004D1E            .427:
17705                                           ! Debug: list int = const $34 (used reg = )
17706 4D1E           B8                   0034  mov	ax,*$34
17707 4D21           50                         push	ax
17708                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17709 4D22           E8         B849            call	_inb_cmos
17710 4D25           44                         inc	sp
17711 4D26           44                         inc	sp
17712                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
17713 4D27           8846         18            mov	$18[bp],al
17714                                           !BCC_EOS
17715                                           ! 3240           regs.u.r8.dh = inb_cmos(0x35);
17716                                           ! Debug: list int = const $35 (used reg = )
17717 4D2A           B8                   0035  mov	ax,*$35
17718 4D2D           50                         push	ax
17719                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17720 4D2E           E8         B83D            call	_inb_cmos
17721 4D31           44                         inc	sp
17722 4D32           44                         inc	sp
17723                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
17724 4D33           8846         19            mov	$19[bp],al
17725                                           !BCC_EOS
17726                                           ! 3241           regs.u.r16.ax = regs.u.r16.cx;
17727                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
17728 4D36           8B46         1C            mov	ax,$1C[bp]
17729 4D39           8946         20            mov	$20[bp],ax
17730                                           !BCC_EOS
17731                                           ! 3242           regs.u.r16.bx = regs.u.r16.dx;
17732                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
17733 4D3C           8B46         18            mov	ax,$18[bp]
17734 4D3F           8946         14            mov	$14[bp],ax
17735                                           !BCC_EOS
17736                                           ! 3243           break;
17737 4D42           EB           13            jmp .406
17738                                           !BCC_EOS
17739                                           ! 3244         default:
17740                                           ! 3245           goto int15_unimplemented;
17741                       00004D44            .429:
17742 4D44           83C4                   00  add	sp,#..FFF4-..FFF5
17743 4D47           EB           10            jmp .FFF4
17744                                           !BCC_EOS
17745                                           ! 3246        }
17746                                           ! 3247        break;
17747 4D49           EB           0C            jmp .406
17748                       00004D4B            .408:
17749 4D4B           2C                     01  sub	al,*1
17750 4D4D           74           A1            je 	.426
17751 4D4F           2C                     1F  sub	al,*$1F
17752 4D51         0F84         FBEE            beq 	.409
17753 4D55           EB           ED            jmp	.429
17754                       00004D57            .406:
17755 4D57           EB           33            jmp .401
17756                                           !BCC_EOS
17757                                           ! 3248     int15_unimplemented:
17758                       00004D59            .FFF4:
17759                                           ! 3249     default:
17760                                           ! 3250       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17761                       00004D59            .42A:
17762                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
17763 4D59           FF76         14            push	$14[bp]
17764                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
17765 4D5C           FF76         20            push	$20[bp]
17766                                           ! Debug: list * char = .42B+0 (used reg = )
17767 4D5F           BB                   D3B9  mov	bx,#.42B
17768 4D62           53                         push	bx
17769                                           ! Debug: list int = const 4 (used reg = )
17770 4D63           B8                   0004  mov	ax,*4
17771 4D66           50                         push	ax
17772                                           ! Debug: func () void = bios_printf+0 (used reg = )
17773 4D67           E8         BBCF            call	_bios_printf
17774 4D6A           83C4                   08  add	sp,*8
17775                                           !BCC_EOS
17776                                           ! 3251       FLAGS |= 0x0001;
17777                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
17778 4D6D           8B46         28            mov	ax,$28[bp]
17779 4D70           0C                     01  or	al,*1
17780 4D72           8946         28            mov	$28[bp],ax
17781                                           !BCC_EOS
17782                                           ! 3252       regs.u.r8.ah = 0x86;
17783                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
17784 4D75           B0                     86  mov	al,#$86
17785 4D77           8846         21            mov	$21[bp],al
17786                                           !BCC_EOS
17787                                           ! 3253       break;
17788 4D7A           EB           10            jmp .401
17789                                           !BCC_EOS
17790                                           ! 3254     }
17791                                           ! 3255 }
17792 4D7C           EB           0E            jmp .401
17793                       00004D7E            .403:
17794 4D7E           2C                     86  sub	al,#$86
17795 4D80         0F84         FB73            beq 	.404
17796 4D84           2C                     62  sub	al,*$62
17797 4D86         0F84         FBB3            beq 	.405
17798 4D8A           EB           CD            jmp	.42A
17799                       00004D8C            .401:
17800                       FFFFFFF0            ..FFF5	=	-$10
17801                       FFFFFFF0            ..FFF4	=	-$10
17802 4D8C           89EC                       mov	sp,bp
17803 4D8E           5D                         pop	bp
17804 4D8F           C3                         ret
17805                                           ! 3256   void
17806                                           ! Register BX used in function int15_function32
17807                                           ! 3257 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
17808                                           ! 3258   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
17809                                           export	_int16_function
17810                       00004D90            _int16_function:
17811                                           !BCC_EOS
17812                                           ! 3259 {
17813                                           ! 3260   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
17814                                           !BCC_EOS
17815                                           ! 3261   Bit16u kbd_code, max;
17816                                           !BCC_EOS
17817                                           ! 3262   ;
17818 4D90           55                         push	bp
17819 4D91           89E5                       mov	bp,sp
17820 4D93           83C4                   F6  add	sp,*-$A
17821                                           !BCC_EOS
17822                                           ! 3263   shift_flags = *((Bit8u *)(0x17));
17823                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
17824 4D96           A0         0017            mov	al,[$17]
17825 4D99           8846         FD            mov	-3[bp],al
17826                                           !BCC_EOS
17827                                           ! 3264   led_flags = *((Bit8u *)(0x97));
17828                                           ! Debug: eq unsigned char = [+$97] to unsigned char led_flags = [S+$C-6] (used reg = )
17829 4D9C           A0         0097            mov	al,[$97]
17830 4D9F           8846         FC            mov	-4[bp],al
17831                                           !BCC_EOS
17832                                           ! 3265   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
17833                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17834 4DA2           8A46         FC            mov	al,-4[bp]
17835 4DA5           24                     07  and	al,*7
17836 4DA7           50                         push	ax
17837                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
17838 4DA8           8A46         FD            mov	al,-3[bp]
17839 4DAB           30E4                       xor	ah,ah
17840 4DAD           B1                     04  mov	cl,*4
17841 4DAF           D3E8                       shr	ax,cl
17842                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17843 4DB1           24                     07  and	al,*7
17844                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
17845 4DB3           3246         F4            xor	al,-$C[bp]
17846 4DB6           44                         inc	sp
17847 4DB7           44                         inc	sp
17848                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
17849 4DB8           84C0                       test	al,al
17850 4DBA         0F84         0095            beq 	.42C
17851                       00004DBE            .42D:
17852                                           ! 3266 #asm
17853                                           !BCC_EOS
17854                                           !BCC_ASM
17855                       00000012            _int16_function.BP	set	$12
17856                       00000008            .int16_function.BP	set	8
17857                       00000005            _int16_function.count	set	5
17858                       FFFFFFFB            .int16_function.count	set	-5
17859                       0000001A            _int16_function.CX	set	$1A
17860                       00000010            .int16_function.CX	set	$10
17861                       00000008            _int16_function.ascii_code	set	8
17862                       FFFFFFFE            .int16_function.ascii_code	set	-2
17863                       0000000E            _int16_function.DI	set	$E
17864                       00000004            .int16_function.DI	set	4
17865                       0000001E            _int16_function.FLAGS	set	$1E
17866                       00000014            .int16_function.FLAGS	set	$14
17867                       00000002            _int16_function.kbd_code	set	2
17868                       FFFFFFF8            .int16_function.kbd_code	set	-8
17869                       00000009            _int16_function.scan_code	set	9
17870                       FFFFFFFF            .int16_function.scan_code	set	-1
17871                       00000018            _int16_function.DX	set	$18
17872                       0000000E            .int16_function.DX	set	$E
17873                       00000006            _int16_function.led_flags	set	6
17874                       FFFFFFFC            .int16_function.led_flags	set	-4
17875                       00000010            _int16_function.SI	set	$10
17876                       00000006            .int16_function.SI	set	6
17877                       0000001C            _int16_function.AX	set	$1C
17878                       00000012            .int16_function.AX	set	$12
17879                       00000014            _int16_function.SP	set	$14
17880                       0000000A            .int16_function.SP	set	$A
17881                       00000016            _int16_function.BX	set	$16
17882                       0000000C            .int16_function.BX	set	$C
17883                       00000007            _int16_function.shift_flags	set	7
17884                       FFFFFFFD            .int16_function.shift_flags	set	-3
17885                       00000000            _int16_function.max	set	0
17886                       FFFFFFF6            .int16_function.max	set	-$A
17887 4DBE           FA                             cli
17888                                           ! 3268 endasm
17889                                           !BCC_ENDASM
17890                                           !BCC_EOS
17891                                           ! 3269     outb(0x0060, 0xed);
17892                                           ! Debug: list int = const $ED (used reg = )
17893 4DBF           B8                   00ED  mov	ax,#$ED
17894 4DC2           50                         push	ax
17895                                           ! Debug: list int = const $60 (used reg = )
17896 4DC3           B8                   0060  mov	ax,*$60
17897 4DC6           50                         push	ax
17898                                           ! Debug: func () void = outb+0 (used reg = )
17899 4DC7           E8         B775            call	_outb
17900 4DCA           83C4                   04  add	sp,*4
17901                                           !BCC_EOS
17902                                           ! 3270     while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17903 4DCD           EB           0E            jmp .42F
17904                       00004DCF            .430:
17905                                           ! Debug: list int = const $21 (used reg = )
17906 4DCF           B8                   0021  mov	ax,*$21
17907 4DD2           50                         push	ax
17908                                           ! Debug: list int = const $80 (used reg = )
17909 4DD3           B8                   0080  mov	ax,#$80
17910 4DD6           50                         push	ax
17911                                           ! Debug: func () void = outb+0 (used reg = )
17912 4DD7           E8         B765            call	_outb
17913 4DDA           83C4                   04  add	sp,*4
17914                                           !BCC_EOS
17915                                           ! 3271     if ((inb(0x0060) == 0xfa)) {
17916                       00004DDD            .42F:
17917                                           ! Debug: list int = const $64 (used reg = )
17918 4DDD           B8                   0064  mov	ax,*$64
17919 4DE0           50                         push	ax
17920                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17921 4DE1           E8         B745            call	_inb
17922 4DE4           44                         inc	sp
17923 4DE5           44                         inc	sp
17924                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17925 4DE6           24                     01  and	al,*1
17926                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17927 4DE8           84C0                       test	al,al
17928 4DEA           74           E3            je 	.430
17929                       00004DEC            .431:
17930                       00004DEC            .42E:
17931                                           ! Debug: list int = const $60 (used reg = )
17932 4DEC           B8                   0060  mov	ax,*$60
17933 4DEF           50                         push	ax
17934                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17935 4DF0           E8         B736            call	_inb
17936 4DF3           44                         inc	sp
17937 4DF4           44                         inc	sp
17938                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
17939 4DF5           3C                     FA  cmp	al,#$FA
17940 4DF7           75           59            jne 	.432
17941                       00004DF9            .433:
17942                                           ! 3272       led_flags &= 0xf8;
17943                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
17944 4DF9           8A46         FC            mov	al,-4[bp]
17945 4DFC           24                     F8  and	al,#$F8
17946 4DFE           8846         FC            mov	-4[bp],al
17947                                           !BCC_EOS
17948                                           ! 3273       led_flags |= ((shift_flags >> 4) & 0x07);
17949                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
17950 4E01           8A46         FD            mov	al,-3[bp]
17951 4E04           30E4                       xor	ah,ah
17952 4E06           B1                     04  mov	cl,*4
17953 4E08           D3E8                       shr	ax,cl
17954                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17955 4E0A           24                     07  and	al,*7
17956                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
17957 4E0C           0A46         FC            or	al,-4[bp]
17958 4E0F           8846         FC            mov	-4[bp],al
17959                                           !BCC_EOS
17960                                           ! 3274       outb(0x0060, led_flags & 0x07);
17961                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17962 4E12           8A46         FC            mov	al,-4[bp]
17963 4E15           24                     07  and	al,*7
17964                                           ! Debug: list unsigned char = al+0 (used reg = )
17965 4E17           30E4                       xor	ah,ah
17966 4E19           50                         push	ax
17967                                           ! Debug: list int = const $60 (used reg = )
17968 4E1A           B8                   0060  mov	ax,*$60
17969 4E1D           50                         push	ax
17970                                           ! Debug: func () void = outb+0 (used reg = )
17971 4E1E           E8         B71E            call	_outb
17972 4E21           83C4                   04  add	sp,*4
17973                                           !BCC_EOS
17974                                           ! 3275       while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17975 4E24           EB           0E            jmp .435
17976                       00004E26            .436:
17977                                           ! Debug: list int = const $21 (used reg = )
17978 4E26           B8                   0021  mov	ax,*$21
17979 4E29           50                         push	ax
17980                                           ! Debug: list int = const $80 (used reg = )
17981 4E2A           B8                   0080  mov	ax,#$80
17982 4E2D           50                         push	ax
17983                                           ! Debug: func () void = outb+0 (used reg = )
17984 4E2E           E8         B70E            call	_outb
17985 4E31           83C4                   04  add	sp,*4
17986                                           !BCC_EOS
17987                                           ! 3276       inb(0x0060);
17988                       00004E34            .435:
17989                                           ! Debug: list int = const $64 (used reg = )
17990 4E34           B8                   0064  mov	ax,*$64
17991 4E37           50                         push	ax
17992                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17993 4E38           E8         B6EE            call	_inb
17994 4E3B           44                         inc	sp
17995 4E3C           44                         inc	sp
17996                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17997 4E3D           24                     01  and	al,*1
17998                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17999 4E3F           84C0                       test	al,al
18000 4E41           74           E3            je 	.436
18001                       00004E43            .437:
18002                       00004E43            .434:
18003                                           ! Debug: list int = const $60 (used reg = )
18004 4E43           B8                   0060  mov	ax,*$60
18005 4E46           50                         push	ax
18006                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18007 4E47           E8         B6DF            call	_inb
18008 4E4A           44                         inc	sp
18009 4E4B           44                         inc	sp
18010                                           !BCC_EOS
18011                                           ! 3277       *((Bit8u *)(0x97)) = (led_flags);
18012                                           ! Debug: eq unsigned char led_flags = [S+$C-6] to unsigned char = [+$97] (used reg = )
18013 4E4C           8A46         FC            mov	al,-4[bp]
18014 4E4F           A2         0097            mov	[$97],al
18015                                           !BCC_EOS
18016                                           ! 3278     }
18017                                           ! 3279 #asm
18018                       00004E52            .432:
18019                                           !BCC_EOS
18020                                           !BCC_ASM
18021                       00000012            _int16_function.BP	set	$12
18022                       00000008            .int16_function.BP	set	8
18023                       00000005            _int16_function.count	set	5
18024                       FFFFFFFB            .int16_function.count	set	-5
18025                       0000001A            _int16_function.CX	set	$1A
18026                       00000010            .int16_function.CX	set	$10
18027                       00000008            _int16_function.ascii_code	set	8
18028                       FFFFFFFE            .int16_function.ascii_code	set	-2
18029                       0000000E            _int16_function.DI	set	$E
18030                       00000004            .int16_function.DI	set	4
18031                       0000001E            _int16_function.FLAGS	set	$1E
18032                       00000014            .int16_function.FLAGS	set	$14
18033                       00000002            _int16_function.kbd_code	set	2
18034                       FFFFFFF8            .int16_function.kbd_code	set	-8
18035                       00000009            _int16_function.scan_code	set	9
18036                       FFFFFFFF            .int16_function.scan_code	set	-1
18037                       00000018            _int16_function.DX	set	$18
18038                       0000000E            .int16_function.DX	set	$E
18039                       00000006            _int16_function.led_flags	set	6
18040                       FFFFFFFC            .int16_function.led_flags	set	-4
18041                       00000010            _int16_function.SI	set	$10
18042                       00000006            .int16_function.SI	set	6
18043                       0000001C            _int16_function.AX	set	$1C
18044                       00000012            .int16_function.AX	set	$12
18045                       00000014            _int16_function.SP	set	$14
18046                       0000000A            .int16_function.SP	set	$A
18047                       00000016            _int16_function.BX	set	$16
18048                       0000000C            .int16_function.BX	set	$C
18049                       00000007            _int16_function.shift_flags	set	7
18050                       FFFFFFFD            .int16_function.shift_flags	set	-3
18051                       00000000            _int16_function.max	set	0
18052                       FFFFFFF6            .int16_function.max	set	-$A
18053 4E52           FB                             sti
18054                                           ! 3281 endasm
18055                                           !BCC_ENDASM
18056                                           !BCC_EOS
18057                                           ! 3282   }
18058                                           ! 3283   switch (*(((Bit8u *)&AX)+1)) {
18059                       00004E53            .42C:
18060 4E53           8A46         13            mov	al,$13[bp]
18061 4E56           E9         029E            br 	.43A
18062                                           ! 3284     case 0x00:
18063                                           ! 3285       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18064                       00004E59            .43B:
18065                                           ! Debug: list int = const 1 (used reg = )
18066 4E59           B8                   0001  mov	ax,*1
18067 4E5C           50                         push	ax
18068                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18069 4E5D           8D5E         FE            lea	bx,-2[bp]
18070 4E60           53                         push	bx
18071                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18072 4E61           8D5E         FF            lea	bx,-1[bp]
18073 4E64           53                         push	bx
18074                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18075 4E65           E8         02DA            call	_dequeue_key
18076 4E68           83C4                   06  add	sp,*6
18077 4E6B           85C0                       test	ax,ax
18078 4E6D           75           0E            jne 	.43C
18079                       00004E6F            .43D:
18080                                           ! 3286         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18081                                           ! Debug: list * char = .43E+0 (used reg = )
18082 4E6F           BB                   D395  mov	bx,#.43E
18083 4E72           53                         push	bx
18084                                           ! Debug: list int = const 7 (used reg = )
18085 4E73           B8                   0007  mov	ax,*7
18086 4E76           50                         push	ax
18087                                           ! Debug: func () void = bios_printf+0 (used reg = )
18088 4E77           E8         BABF            call	_bios_printf
18089 4E7A           83C4                   04  add	sp,*4
18090                                           !BCC_EOS
18091                                           ! 3287       }
18092                                           ! 3288       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18093                       00004E7D            .43C:
18094                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18095 4E7D           8A46         FF            mov	al,-1[bp]
18096 4E80           84C0                       test	al,al
18097 4E82           74           0E            je  	.43F
18098                       00004E84            .441:
18099                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18100 4E84           8A46         FE            mov	al,-2[bp]
18101 4E87           3C                     F0  cmp	al,#$F0
18102 4E89           75           07            jne 	.43F
18103                       00004E8B            .440:
18104                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18105 4E8B           30C0                       xor	al,al
18106 4E8D           8846         FE            mov	-2[bp],al
18107                                           !BCC_EOS
18108                                           ! 3289       else if (ascii_code == 0xE0) ascii_code = 0;
18109 4E90           EB           0C            jmp .442
18110                       00004E92            .43F:
18111                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18112 4E92           8A46         FE            mov	al,-2[bp]
18113 4E95           3C                     E0  cmp	al,#$E0
18114 4E97           75           05            jne 	.443
18115                       00004E99            .444:
18116                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18117 4E99           30C0                       xor	al,al
18118 4E9B           8846         FE            mov	-2[bp],al
18119                                           !BCC_EOS
18120                                           ! 3290       AX = (scan_code << 8) | ascii_code;
18121                       00004E9E            .443:
18122                       00004E9E            .442:
18123                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18124 4E9E           8A46         FF            mov	al,-1[bp]
18125 4EA1           30E4                       xor	ah,ah
18126 4EA3           88C4                       mov	ah,al
18127 4EA5           30C0                       xor	al,al
18128                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18129 4EA7           0A46         FE            or	al,-2[bp]
18130                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18131 4EAA           8946         12            mov	$12[bp],ax
18132                                           !BCC_EOS
18133                                           ! 3291       break;
18134 4EAD           E9         028E            br 	.438
18135                                           !BCC_EOS
18136                                           ! 3292     case 0x01:
18137                                           ! 3293       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18138                       00004EB0            .445:
18139                                           ! Debug: list int = const 0 (used reg = )
18140 4EB0           31C0                       xor	ax,ax
18141 4EB2           50                         push	ax
18142                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18143 4EB3           8D5E         FE            lea	bx,-2[bp]
18144 4EB6           53                         push	bx
18145                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18146 4EB7           8D5E         FF            lea	bx,-1[bp]
18147 4EBA           53                         push	bx
18148                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18149 4EBB           E8         0284            call	_dequeue_key
18150 4EBE           83C4                   06  add	sp,*6
18151 4EC1           85C0                       test	ax,ax
18152 4EC3           75           0C            jne 	.446
18153                       00004EC5            .447:
18154                                           ! 3294         FLAGS |= 0x0040;
18155                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18156 4EC5           8B46         14            mov	ax,$14[bp]
18157 4EC8           0C                     40  or	al,*$40
18158 4ECA           8946         14            mov	$14[bp],ax
18159                                           !BCC_EOS
18160                                           ! 3295         return;
18161 4ECD           89EC                       mov	sp,bp
18162 4ECF           5D                         pop	bp
18163 4ED0           C3                         ret
18164                                           !BCC_EOS
18165                                           ! 3296       }
18166                                           ! 3297       if (scan_code !=0
18167                       00004ED1            .446:
18168                                           ! 3297  && ascii_code == 0xF0) ascii_code = 0;
18169                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18170 4ED1           8A46         FF            mov	al,-1[bp]
18171 4ED4           84C0                       test	al,al
18172 4ED6           74           0E            je  	.448
18173                       00004ED8            .44A:
18174                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18175 4ED8           8A46         FE            mov	al,-2[bp]
18176 4EDB           3C                     F0  cmp	al,#$F0
18177 4EDD           75           07            jne 	.448
18178                       00004EDF            .449:
18179                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18180 4EDF           30C0                       xor	al,al
18181 4EE1           8846         FE            mov	-2[bp],al
18182                                           !BCC_EOS
18183                                           ! 3298       else if (ascii_code == 0xE0) ascii_code = 0;
18184 4EE4           EB           0C            jmp .44B
18185                       00004EE6            .448:
18186                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18187 4EE6           8A46         FE            mov	al,-2[bp]
18188 4EE9           3C                     E0  cmp	al,#$E0
18189 4EEB           75           05            jne 	.44C
18190                       00004EED            .44D:
18191                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18192 4EED           30C0                       xor	al,al
18193 4EEF           8846         FE            mov	-2[bp],al
18194                                           !BCC_EOS
18195                                           ! 3299       AX = (scan_code << 8) | ascii_code;
18196                       00004EF2            .44C:
18197                       00004EF2            .44B:
18198                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18199 4EF2           8A46         FF            mov	al,-1[bp]
18200 4EF5           30E4                       xor	ah,ah
18201 4EF7           88C4                       mov	ah,al
18202 4EF9           30C0                       xor	al,al
18203                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18204 4EFB           0A46         FE            or	al,-2[bp]
18205                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18206 4EFE           8946         12            mov	$12[bp],ax
18207                                           !BCC_EOS
18208                                           ! 3300       FLAGS &= 0xffbf;
18209                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18210 4F01           8B46         14            mov	ax,$14[bp]
18211 4F04           24                     BF  and	al,#$BF
18212 4F06           8946         14            mov	$14[bp],ax
18213                                           !BCC_EOS
18214                                           ! 3301       break;
18215 4F09           E9         0232            br 	.438
18216                                           !BCC_EOS
18217                                           ! 3302     case 0x02:
18218                                           ! 3303       shift_flags = *((Bit8u *)(0x17));
18219                       00004F0C            .44E:
18220                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18221 4F0C           A0         0017            mov	al,[$17]
18222 4F0F           8846         FD            mov	-3[bp],al
18223                                           !BCC_EOS
18224                                           ! 3304       *((Bit8u *)&AX) = (shift_flags);
18225                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18226 4F12           8A46         FD            mov	al,-3[bp]
18227 4F15           8846         12            mov	$12[bp],al
18228                                           !BCC_EOS
18229                                           ! 3305       break;
18230 4F18           E9         0223            br 	.438
18231                                           !BCC_EOS
18232                                           ! 3306     case 0x05:
18233                                           ! 3307       if ( !enqueue_key(*(((Bit8u *)&CX)+1), ( CX & 0x00ff )) ) {
18234                       00004F1B            .44F:
18235                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
18236 4F1B           8A46         10            mov	al,$10[bp]
18237                                           ! Debug: list unsigned char = al+0 (used reg = )
18238 4F1E           30E4                       xor	ah,ah
18239 4F20           50                         push	ax
18240                                           ! Debug: list unsigned char CX = [S+$E+$F] (used reg = )
18241 4F21           8A46         11            mov	al,$11[bp]
18242 4F24           30E4                       xor	ah,ah
18243 4F26           50                         push	ax
18244                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
18245 4F27           E8         0A57            call	_enqueue_key
18246 4F2A           83C4                   04  add	sp,*4
18247 4F2D           85C0                       test	ax,ax
18248 4F2F           75           07            jne 	.450
18249                       00004F31            .451:
18250                                           ! 3308         *((Bit8u *)&AX) = (1);
18251                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$C+$10] (used reg = )
18252 4F31           B0                     01  mov	al,*1
18253 4F33           8846         12            mov	$12[bp],al
18254                                           !BCC_EOS
18255                                           ! 3309       }
18256                                           ! 3310       else {
18257 4F36           EB           05            jmp .452
18258                       00004F38            .450:
18259                                           ! 3311         *((Bit8u *)&AX) = (0);
18260                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$C+$10] (used reg = )
18261 4F38           30C0                       xor	al,al
18262 4F3A           8846         12            mov	$12[bp],al
18263                                           !BCC_EOS
18264                                           ! 3312       }
18265                                           ! 3313       break;
18266                       00004F3D            .452:
18267 4F3D           E9         01FE            br 	.438
18268                                           !BCC_EOS
18269                                           ! 3314     case 0x09:
18270                                           ! 3315       *((Bit8u *)&AX) = (0x30);
18271                       00004F40            .453:
18272                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$C+$10] (used reg = )
18273 4F40           B0                     30  mov	al,*$30
18274 4F42           8846         12            mov	$12[bp],al
18275                                           !BCC_EOS
18276                                           ! 3316       break;
18277 4F45           E9         01F6            br 	.438
18278                                           !BCC_EOS
18279                                           ! 3317     case 0x0A:
18280                                           ! 3318       count = 2;
18281                       00004F48            .454:
18282                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
18283 4F48           B0                     02  mov	al,*2
18284 4F4A           8846         FB            mov	-5[bp],al
18285                                           !BCC_EOS
18286                                           ! 3319       kbd_code = 0x0;
18287                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18288 4F4D           31C0                       xor	ax,ax
18289 4F4F           8946         F8            mov	-8[bp],ax
18290                                           !BCC_EOS
18291                                           ! 3320       outb(0x0060, 0xf2);
18292                                           ! Debug: list int = const $F2 (used reg = )
18293 4F52           B8                   00F2  mov	ax,#$F2
18294 4F55           50                         push	ax
18295                                           ! Debug: list int = const $60 (used reg = )
18296 4F56           B8                   0060  mov	ax,*$60
18297 4F59           50                         push	ax
18298                                           ! Debug: func () void = outb+0 (used reg = )
18299 4F5A           E8         B5E2            call	_outb
18300 4F5D           83C4                   04  add	sp,*4
18301                                           !BCC_EOS
18302                                           ! 3321       max=0xffff;
18303                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18304 4F60           B8                   FFFF  mov	ax,#$FFFF
18305 4F63           8946         F6            mov	-$A[bp],ax
18306                                           !BCC_EOS
18307                                           ! 3322       while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18308 4F66           EB           0D            jmp .456
18309                       00004F68            .457:
18310                                           ! Debug: list int = const 0 (used reg = )
18311 4F68           31C0                       xor	ax,ax
18312 4F6A           50                         push	ax
18313                                           ! Debug: list int = const $80 (used reg = )
18314 4F6B           B8                   0080  mov	ax,#$80
18315 4F6E           50                         push	ax
18316                                           ! Debug: func () void = outb+0 (used reg = )
18317 4F6F           E8         B5CD            call	_outb
18318 4F72           83C4                   04  add	sp,*4
18319                                           !BCC_EOS
18320                                           ! 3323       if (max>0x0) {
18321                       00004F75            .456:
18322                                           ! Debug: list int = const $64 (used reg = )
18323 4F75           B8                   0064  mov	ax,*$64
18324 4F78           50                         push	ax
18325                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18326 4F79           E8         B5AD            call	_inb
18327 4F7C           44                         inc	sp
18328 4F7D           44                         inc	sp
18329                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18330 4F7E           24                     01  and	al,*1
18331                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18332 4F80           84C0                       test	al,al
18333 4F82           75           0B            jne 	.458
18334                       00004F84            .459:
18335                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18336 4F84           8B46         F6            mov	ax,-$A[bp]
18337 4F87           48                         dec	ax
18338 4F88           8946         F6            mov	-$A[bp],ax
18339                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18340 4F8B           85C0                       test	ax,ax
18341 4F8D           75           D9            jne	.457
18342                       00004F8F            .458:
18343                       00004F8F            .455:
18344                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18345 4F8F           8B46         F6            mov	ax,-$A[bp]
18346 4F92           85C0                       test	ax,ax
18347 4F94         0F84         006D            beq 	.45A
18348                       00004F98            .45B:
18349                                           ! 3324         if ((inb(0x0060) == 0xfa)) {
18350                                           ! Debug: list int = const $60 (used reg = )
18351 4F98           B8                   0060  mov	ax,*$60
18352 4F9B           50                         push	ax
18353                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18354 4F9C           E8         B58A            call	_inb
18355 4F9F           44                         inc	sp
18356 4FA0           44                         inc	sp
18357                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18358 4FA1           3C                     FA  cmp	al,#$FA
18359 4FA3           75           60            jne 	.45C
18360                       00004FA5            .45D:
18361                                           ! 3325           do {
18362                       00004FA5            .460:
18363                                           ! 3326             max=0xffff;
18364                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18365 4FA5           B8                   FFFF  mov	ax,#$FFFF
18366 4FA8           8946         F6            mov	-$A[bp],ax
18367                                           !BCC_EOS
18368                                           ! 3327             while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18369 4FAB           EB           0D            jmp .462
18370                       00004FAD            .463:
18371                                           ! Debug: list int = const 0 (used reg = )
18372 4FAD           31C0                       xor	ax,ax
18373 4FAF           50                         push	ax
18374                                           ! Debug: list int = const $80 (used reg = )
18375 4FB0           B8                   0080  mov	ax,#$80
18376 4FB3           50                         push	ax
18377                                           ! Debug: func () void = outb+0 (used reg = )
18378 4FB4           E8         B588            call	_outb
18379 4FB7           83C4                   04  add	sp,*4
18380                                           !BCC_EOS
18381                                           ! 3328             if (max>0x0) {
18382                       00004FBA            .462:
18383                                           ! Debug: list int = const $64 (used reg = )
18384 4FBA           B8                   0064  mov	ax,*$64
18385 4FBD           50                         push	ax
18386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18387 4FBE           E8         B568            call	_inb
18388 4FC1           44                         inc	sp
18389 4FC2           44                         inc	sp
18390                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18391 4FC3           24                     01  and	al,*1
18392                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18393 4FC5           84C0                       test	al,al
18394 4FC7           75           0B            jne 	.464
18395                       00004FC9            .465:
18396                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18397 4FC9           8B46         F6            mov	ax,-$A[bp]
18398 4FCC           48                         dec	ax
18399 4FCD           8946         F6            mov	-$A[bp],ax
18400                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18401 4FD0           85C0                       test	ax,ax
18402 4FD2           75           D9            jne	.463
18403                       00004FD4            .464:
18404                       00004FD4            .461:
18405                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18406 4FD4           8B46         F6            mov	ax,-$A[bp]
18407 4FD7           85C0                       test	ax,ax
18408 4FD9           74           1F            je  	.466
18409                       00004FDB            .467:
18410                                           ! 3329               kbd_code >>= 8;
18411                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18412 4FDB           8B46         F8            mov	ax,-8[bp]
18413 4FDE           88E0                       mov	al,ah
18414 4FE0           30E4                       xor	ah,ah
18415 4FE2           8946         F8            mov	-8[bp],ax
18416                                           !BCC_EOS
18417                                           ! 3330               kbd_code |= (inb(0x0060) << 8);
18418                                           ! Debug: list int = const $60 (used reg = )
18419 4FE5           B8                   0060  mov	ax,*$60
18420 4FE8           50                         push	ax
18421                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18422 4FE9           E8         B53D            call	_inb
18423 4FEC           44                         inc	sp
18424 4FED           44                         inc	sp
18425                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
18426 4FEE           30E4                       xor	ah,ah
18427 4FF0           88C4                       mov	ah,al
18428 4FF2           30C0                       xor	al,al
18429                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18430 4FF4           0B46         F8            or	ax,-8[bp]
18431 4FF7           8946         F8            mov	-8[bp],ax
18432                                           !BCC_EOS
18433                                           ! 3331             }
18434                                           ! 3332           } while (--count>0);
18435                       00004FFA            .466:
18436                       00004FFA            .45F:
18437                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
18438 4FFA           8A46         FB            mov	al,-5[bp]
18439 4FFD           48                         dec	ax
18440 4FFE           8846         FB            mov	-5[bp],al
18441                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
18442 5001           84C0                       test	al,al
18443 5003           75           A0            jne	.460
18444                       00005005            .468:
18445                                           !BCC_EOS
18446                                           ! 3333         }
18447                       00005005            .45E:
18448                                           ! 3334       }
18449                       00005005            .45C:
18450                                           ! 3335       BX=kbd_code;
18451                       00005005            .45A:
18452                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
18453 5005           8B46         F8            mov	ax,-8[bp]
18454 5008           8946         0C            mov	$C[bp],ax
18455                                           !BCC_EOS
18456                                           ! 3336       break;
18457 500B           E9         0130            br 	.438
18458                                           !BCC_EOS
18459                                           ! 3337     case 0x10:
18460                                           ! 3338       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18461                       0000500E            .469:
18462                                           ! Debug: list int = const 1 (used reg = )
18463 500E           B8                   0001  mov	ax,*1
18464 5011           50                         push	ax
18465                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18466 5012           8D5E         FE            lea	bx,-2[bp]
18467 5015           53                         push	bx
18468                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18469 5016           8D5E         FF            lea	bx,-1[bp]
18470 5019           53                         push	bx
18471                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18472 501A           E8         0125            call	_dequeue_key
18473 501D           83C4                   06  add	sp,*6
18474 5020           85C0                       test	ax,ax
18475 5022           75           0E            jne 	.46A
18476                       00005024            .46B:
18477                                           ! 3339         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18478                                           ! Debug: list * char = .46C+0 (used reg = )
18479 5024           BB                   D371  mov	bx,#.46C
18480 5027           53                         push	bx
18481                                           ! Debug: list int = const 7 (used reg = )
18482 5028           B8                   0007  mov	ax,*7
18483 502B           50                         push	ax
18484                                           ! Debug: func () void = bios_printf+0 (used reg = )
18485 502C           E8         B90A            call	_bios_printf
18486 502F           83C4                   04  add	sp,*4
18487                                           !BCC_EOS
18488                                           ! 3340       }
18489                                           ! 3341       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18490                       00005032            .46A:
18491                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18492 5032           8A46         FF            mov	al,-1[bp]
18493 5035           84C0                       test	al,al
18494 5037           74           0C            je  	.46D
18495                       00005039            .46F:
18496                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18497 5039           8A46         FE            mov	al,-2[bp]
18498 503C           3C                     F0  cmp	al,#$F0
18499 503E           75           05            jne 	.46D
18500                       00005040            .46E:
18501                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18502 5040           30C0                       xor	al,al
18503 5042           8846         FE            mov	-2[bp],al
18504                                           !BCC_EOS
18505                                           ! 3342       AX = (scan_code << 8) | ascii_code;
18506                       00005045            .46D:
18507                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18508 5045           8A46         FF            mov	al,-1[bp]
18509 5048           30E4                       xor	ah,ah
18510 504A           88C4                       mov	ah,al
18511 504C           30C0                       xor	al,al
18512                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18513 504E           0A46         FE            or	al,-2[bp]
18514                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18515 5051           8946         12            mov	$12[bp],ax
18516                                           !BCC_EOS
18517                                           ! 3343       break;
18518 5054           E9         00E7            br 	.438
18519                                           !BCC_EOS
18520                                           ! 3344     case 0x11:
18521                                           ! 3345       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18522                       00005057            .470:
18523                                           ! Debug: list int = const 0 (used reg = )
18524 5057           31C0                       xor	ax,ax
18525 5059           50                         push	ax
18526                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18527 505A           8D5E         FE            lea	bx,-2[bp]
18528 505D           53                         push	bx
18529                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18530 505E           8D5E         FF            lea	bx,-1[bp]
18531 5061           53                         push	bx
18532                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18533 5062           E8         00DD            call	_dequeue_key
18534 5065           83C4                   06  add	sp,*6
18535 5068           85C0                       test	ax,ax
18536 506A           75           0C            jne 	.471
18537                       0000506C            .472:
18538                                           ! 3346         FLAGS |= 0x0040;
18539                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18540 506C           8B46         14            mov	ax,$14[bp]
18541 506F           0C                     40  or	al,*$40
18542 5071           8946         14            mov	$14[bp],ax
18543                                           !BCC_EOS
18544                                           ! 3347         return;
18545 5074           89EC                       mov	sp,bp
18546 5076           5D                         pop	bp
18547 5077           C3                         ret
18548                                           !BCC_EOS
18549                                           ! 3348       }
18550                                           ! 3349       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18551                       00005078            .471:
18552                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18553 5078           8A46         FF            mov	al,-1[bp]
18554 507B           84C0                       test	al,al
18555 507D           74           0C            je  	.473
18556                       0000507F            .475:
18557                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18558 507F           8A46         FE            mov	al,-2[bp]
18559 5082           3C                     F0  cmp	al,#$F0
18560 5084           75           05            jne 	.473
18561                       00005086            .474:
18562                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18563 5086           30C0                       xor	al,al
18564 5088           8846         FE            mov	-2[bp],al
18565                                           !BCC_EOS
18566                                           ! 3350       AX = (scan_code << 8) | ascii_code;
18567                       0000508B            .473:
18568                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18569 508B           8A46         FF            mov	al,-1[bp]
18570 508E           30E4                       xor	ah,ah
18571 5090           88C4                       mov	ah,al
18572 5092           30C0                       xor	al,al
18573                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18574 5094           0A46         FE            or	al,-2[bp]
18575                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18576 5097           8946         12            mov	$12[bp],ax
18577                                           !BCC_EOS
18578                                           ! 3351       FLAGS &= 0xffbf;
18579                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18580 509A           8B46         14            mov	ax,$14[bp]
18581 509D           24                     BF  and	al,#$BF
18582 509F           8946         14            mov	$14[bp],ax
18583                                           !BCC_EOS
18584                                           ! 3352       break;
18585 50A2           E9         0099            br 	.438
18586                                           !BCC_EOS
18587                                           ! 3353     case 0x12:
18588                                           ! 3354       shift_flags = *((Bit8u *)(0x17));
18589                       000050A5            .476:
18590                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18591 50A5           A0         0017            mov	al,[$17]
18592 50A8           8846         FD            mov	-3[bp],al
18593                                           !BCC_EOS
18594                                           ! 3355       *((Bit8u *)&AX) = (shift_flags);
18595                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18596 50AB           8A46         FD            mov	al,-3[bp]
18597 50AE           8846         12            mov	$12[bp],al
18598                                           !BCC_EOS
18599                                           ! 3356       shift_flags = *((Bit8u *)(0x18)) & 0x73;
18600                                           ! Debug: and int = const $73 to unsigned char = [+$18] (used reg = )
18601 50B1           A0         0018            mov	al,[$18]
18602 50B4           24                     73  and	al,*$73
18603                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18604 50B6           8846         FD            mov	-3[bp],al
18605                                           !BCC_EOS
18606                                           ! 3357       shift_flags |= *((Bit8u *)(0x96)) & 0x0c;
18607                                           ! Debug: and int = const $C to unsigned char = [+$96] (used reg = )
18608 50B9           A0         0096            mov	al,[$96]
18609 50BC           24                     0C  and	al,*$C
18610                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18611 50BE           0A46         FD            or	al,-3[bp]
18612 50C1           8846         FD            mov	-3[bp],al
18613                                           !BCC_EOS
18614                                           ! 3358       *(((Bit8u *)&AX)+1) = (shift_flags);
18615                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$11] (used reg = )
18616 50C4           8A46         FD            mov	al,-3[bp]
18617 50C7           8846         13            mov	$13[bp],al
18618                                           !BCC_EOS
18619                                           ! 3359       ;
18620                                           !BCC_EOS
18621                                           ! 3360       break;
18622 50CA           EB           72            jmp .438
18623                                           !BCC_EOS
18624                                           ! 3361     case 0x92:
18625                                           ! 3362       *(((Bit8u *)&AX)+1) = (0x80);
18626                       000050CC            .477:
18627                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$C+$11] (used reg = )
18628 50CC           B0                     80  mov	al,#$80
18629 50CE           8846         13            mov	$13[bp],al
18630                                           !BCC_EOS
18631                                           ! 3363       break;
18632 50D1           EB           6B            jmp .438
18633                                           !BCC_EOS
18634                                           ! 3364     case 0xA2:
18635                                           ! 3365       break;
18636                       000050D3            .478:
18637 50D3           EB           69            jmp .438
18638                                           !BCC_EOS
18639                                           ! 3366     case 0x6F:
18640                                           ! 3367       if (( AX & 0x00ff ) == 0x08)
18641                       000050D5            .479:
18642                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
18643 50D5           8A46         12            mov	al,$12[bp]
18644                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
18645 50D8           3C                     08  cmp	al,*8
18646 50DA           75           05            jne 	.47A
18647                       000050DC            .47B:
18648                                           ! 3368         *(((Bit8u *)&AX)+1) = (0x02);
18649                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$C+$11] (used reg = )
18650 50DC           B0                     02  mov	al,*2
18651 50DE           8846         13            mov	$13[bp],al
18652                                           !BCC_EOS
18653                                           ! 3369     defau
18654                                           ! 3369 lt:
18655                       000050E1            .47A:
18656                                           ! 3370       bios_printf(4, "KBD: unsupported int 16h function %02x\n", *(((Bit8u *)&AX)+1));
18657                       000050E1            .47C:
18658                                           ! Debug: list unsigned char AX = [S+$C+$11] (used reg = )
18659 50E1           8A46         13            mov	al,$13[bp]
18660 50E4           30E4                       xor	ah,ah
18661 50E6           50                         push	ax
18662                                           ! Debug: list * char = .47D+0 (used reg = )
18663 50E7           BB                   D349  mov	bx,#.47D
18664 50EA           53                         push	bx
18665                                           ! Debug: list int = const 4 (used reg = )
18666 50EB           B8                   0004  mov	ax,*4
18667 50EE           50                         push	ax
18668                                           ! Debug: func () void = bios_printf+0 (used reg = )
18669 50EF           E8         B847            call	_bios_printf
18670 50F2           83C4                   06  add	sp,*6
18671                                           !BCC_EOS
18672                                           ! 3371   }
18673                                           ! 3372 }
18674 50F5           EB           47            jmp .438
18675                       000050F7            .43A:
18676 50F7           2C                     00  sub	al,*0
18677 50F9           72           E6            jb 	.47C
18678 50FB           3C                     12  cmp	al,*$12
18679 50FD           77           31            ja  	.47E
18680 50FF           30E4                       xor	ah,ah
18681 5101           D1E0                       shl	ax,*1
18682 5103           89C3                       mov	bx,ax
18683 5105           2E                         seg	cs
18684 5106           FFA7       510A            br	.47F[bx]
18685                       0000510A            .47F:
18686 510A                      4E59            .word	.43B
18687 510C                      4EB0            .word	.445
18688 510E                      4F0C            .word	.44E
18689 5110                      50E1            .word	.47C
18690 5112                      50E1            .word	.47C
18691 5114                      4F1B            .word	.44F
18692 5116                      50E1            .word	.47C
18693 5118                      50E1            .word	.47C
18694 511A                      50E1            .word	.47C
18695 511C                      4F40            .word	.453
18696 511E                      4F48            .word	.454
18697 5120                      50E1            .word	.47C
18698 5122                      50E1            .word	.47C
18699 5124                      50E1            .word	.47C
18700 5126                      50E1            .word	.47C
18701 5128                      50E1            .word	.47C
18702 512A                      500E            .word	.469
18703 512C                      5057            .word	.470
18704 512E                      50A5            .word	.476
18705                       00005130            .47E:
18706 5130           2C                     6F  sub	al,*$6F
18707 5132           74           A1            je 	.479
18708 5134           2C                     23  sub	al,*$23
18709 5136           74           94            je 	.477
18710 5138           2C                     10  sub	al,*$10
18711 513A           74           97            je 	.478
18712 513C           EB           A3            jmp	.47C
18713                       0000513E            .438:
18714                       FFFFFFF4            ..FFF3	=	-$C
18715 513E           89EC                       mov	sp,bp
18716 5140           5D                         pop	bp
18717 5141           C3                         ret
18718                                           ! 3373   unsigned int
18719                                           ! Register BX used in function int16_function
18720                                           ! 3374 dequeue_key(scan_code, ascii_code, incr)
18721                                           ! 3375   Bit8u *scan_code;
18722                                           export	_dequeue_key
18723                       00005142            _dequeue_key:
18724                                           !BCC_EOS
18725                                           ! 3376   Bit8u *ascii_code;
18726                                           !BCC_EOS
18727                                           ! 3377   unsigned int incr;
18728                                           !BCC_EOS
18729                                           ! 3378 {
18730                                           ! 3379   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
18731                                           !BCC_EOS
18732                                           ! 3380   Bit8u acode, scode;
18733                                           !BCC_EOS
18734                                           ! 3381   buffer_start = *((Bit16u *)(0x0080));
18735 5142           55                         push	bp
18736 5143           89E5                       mov	bp,sp
18737 5145           83C4                   F6  add	sp,*-$A
18738                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$C-4] (used reg = )
18739 5148           A1         0080            mov	ax,[$80]
18740 514B           8946         FE            mov	-2[bp],ax
18741                                           !BCC_EOS
18742                                           ! 3382   buffer_end = *((Bit16u *)(0x0082));
18743                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$C-6] (used reg = )
18744 514E           A1         0082            mov	ax,[$82]
18745 5151           8946         FC            mov	-4[bp],ax
18746                                           !BCC_EOS
18747                                           ! 3383   buffer_head = *((Bit16u *)(0x001a));
18748                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18749 5154           A1         001A            mov	ax,[$1A]
18750 5157           8946         FA            mov	-6[bp],ax
18751                                           !BCC_EOS
18752                                           ! 3384   buffer_tail = *((Bit16u *)(0x001c));
18753                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
18754 515A           A1         001C            mov	ax,[$1C]
18755 515D           8946         F8            mov	-8[bp],ax
18756                                           !BCC_EOS
18757                                           ! 3385   if (buffer_head != buffer_tail) {
18758                                           ! Debug: ne unsigned short buffer_tail = [S+$C-$A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18759 5160           8B46         FA            mov	ax,-6[bp]
18760 5163           3B46         F8            cmp	ax,-8[bp]
18761 5166           74           5D            je  	.480
18762                       00005168            .481:
18763                                           ! 3386     acode = *((Bit8u *)(buffer_head));
18764 5168           8B5E         FA            mov	bx,-6[bp]
18765                                           ! Debug: eq unsigned char = [bx+0] to unsigned char acode = [S+$C-$B] (used reg = )
18766 516B           8A07                       mov	al,[bx]
18767 516D           8846         F7            mov	-9[bp],al
18768                                           !BCC_EOS
18769                                           ! 3387     scode = *((Bit8u *)(buffer_head+1));
18770                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$C-8] (used reg = )
18771 5170           8B46         FA            mov	ax,-6[bp]
18772                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
18773 5173           89C3                       mov	bx,ax
18774                                           ! Debug: eq unsigned char = [bx+1] to unsigned char scode = [S+$C-$C] (used reg = )
18775 5175           8A47         01            mov	al,1[bx]
18776 5178           8846         F6            mov	-$A[bp],al
18777                                           !BCC_EOS
18778                                           ! 3388     _write_byte_SS(acode, ascii_code);
18779                                           ! Debug: list * unsigned char ascii_code = [S+$C+4] (used reg = )
18780 517B           FF76         06            push	6[bp]
18781                                           ! Debug: list unsigned char acode = [S+$E-$B] (used reg = )
18782 517E           8A46         F7            mov	al,-9[bp]
18783 5181           30E4                       xor	ah,ah
18784 5183           50                         push	ax
18785                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18786 5184           E8         B4B0            call	__write_byte_SS
18787 5187           83C4                   04  add	sp,*4
18788                                           !BCC_EOS
18789                                           ! 3389     _write_byte_SS(scode, scan_code);
18790                                           ! Debug: list * unsigned char scan_code = [S+$C+2] (used reg = )
18791 518A           FF76         04            push	4[bp]
18792                                           ! Debug: list unsigned char scode = [S+$E-$C] (used reg = )
18793 518D           8A46         F6            mov	al,-$A[bp]
18794 5190           30E4                       xor	ah,ah
18795 5192           50                         push	ax
18796                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18797 5193           E8         B4A1            call	__write_byte_SS
18798 5196           83C4                   04  add	sp,*4
18799                                           !BCC_EOS
18800                                           ! 3390     if (incr) {
18801 5199           8B46         08            mov	ax,8[bp]
18802 519C           85C0                       test	ax,ax
18803 519E           74           1C            je  	.482
18804                       000051A0            .483:
18805                                           ! 3391       buffer_head += 2;
18806                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$C-8] (used reg = )
18807 51A0           8B46         FA            mov	ax,-6[bp]
18808 51A3           40                         inc	ax
18809 51A4           40                         inc	ax
18810 51A5           8946         FA            mov	-6[bp],ax
18811                                           !BCC_EOS
18812                                           ! 3392       if (buffer_head >= buffer_end)
18813                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_head = [S+$C-8] (used reg = )
18814 51A8           8B46         FA            mov	ax,-6[bp]
18815 51AB           3B46         FC            cmp	ax,-4[bp]
18816 51AE           72           06            jb  	.484
18817                       000051B0            .485:
18818                                           ! 3393         buffer_head = buffer_start;
18819                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_head = [S+$C-8] (used reg = )
18820 51B0           8B46         FE            mov	ax,-2[bp]
18821 51B3           8946         FA            mov	-6[bp],ax
18822                                           !BCC_EOS
18823                                           ! 3394       *((Bit16u *)(0x001a)) = (buffer_head);
18824                       000051B6            .484:
18825                                           ! Debug: eq unsigned short buffer_head = [S+$C-8] to unsigned short = [+$1A] (used reg = )
18826 51B6           8B46         FA            mov	ax,-6[bp]
18827 51B9           A3         001A            mov	[$1A],ax
18828                                           !BCC_EOS
18829                                           ! 3395     }
18830                                           ! 3396     return(1);
18831                       000051BC            .482:
18832 51BC           B8                   0001  mov	ax,*1
18833 51BF           89EC                       mov	sp,bp
18834 51C1           5D                         pop	bp
18835 51C2           C3                         ret
18836                                           !BCC_EOS
18837                                           ! 3397   }
18838                                           ! 3398   else {
18839 51C3           EB           06            jmp .486
18840                       000051C5            .480:
18841                                           ! 3399     return(0);
18842 51C5           31C0                       xor	ax,ax
18843 51C7           89EC                       mov	sp,bp
18844 51C9           5D                         pop	bp
18845 51CA           C3                         ret
18846                                           !BCC_EOS
18847                                           ! 3400   }
18848                                           ! 3401 }
18849                       000051CB            .486:
18850 51CB           89EC                       mov	sp,bp
18851 51CD           5D                         pop	bp
18852 51CE           C3                         ret
18853                                           ! 3402 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
18854                                           ! Register BX used in function dequeue_key
18855                                           
18856                       000051CF            _panic_msg_keyb_buffer_full:
18857                       000051CF            .487:
18858 51CF                        25            .ascii	"%s: keyboard input buffer full"
18859 51ED                        0A            .byte	$A
18860 51EE                        00            .byte	0
18861                                           !BCC_EOS
18862                                           ! 3403   Bit8u
18863                                           ! 3404 inhibit_mouse_int_and_events()
18864                                           ! 3405 {
18865                                           
18866                                           export	_inhibit_mouse_int_and_events
18867                       000051EF            _inhibit_mouse_int_and_events:
18868                                           ! 3406   Bit8u command_byte, prev_command_byte;
18869                                           !BCC_EOS
18870                                           ! 3407   if ( inb(0x0064) & 0x02 )
18871 51EF           55                         push	bp
18872 51F0           89E5                       mov	bp,sp
18873 51F2           4C                         dec	sp
18874 51F3           4C                         dec	sp
18875                                           ! Debug: list int = const $64 (used reg = )
18876 51F4           B8                   0064  mov	ax,*$64
18877 51F7           50                         push	ax
18878                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18879 51F8           E8         B32E            call	_inb
18880 51FB           44                         inc	sp
18881 51FC           44                         inc	sp
18882                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18883 51FD           24                     02  and	al,*2
18884 51FF           84C0                       test	al,al
18885 5201           74           12            je  	.488
18886                       00005203            .489:
18887                                           ! 3408     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18888                                           ! Debug: list * char = .48A+0 (used reg = )
18889 5203           BB                   D33E  mov	bx,#.48A
18890 5206           53                         push	bx
18891                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18892 5207           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
18893 520A           53                         push	bx
18894                                           ! Debug: list int = const 7 (used reg = )
18895 520B           B8                   0007  mov	ax,*7
18896 520E           50                         push	ax
18897                                           ! Debug: func () void = bios_printf+0 (used reg = )
18898 520F           E8         B727            call	_bios_printf
18899 5212           83C4                   06  add	sp,*6
18900                                           !BCC_EOS
18901                                           ! 3409   outb(0x0064, 0x20);
18902                       00005215            .488:
18903                                           ! Debug: list int = const $20 (used reg = )
18904 5215           B8                   0020  mov	ax,*$20
18905 5218           50                         push	ax
18906                                           ! Debug: list int = const $64 (used reg = )
18907 5219           B8                   0064  mov	ax,*$64
18908 521C           50                         push	ax
18909                                           ! Debug: func () void = outb+0 (used reg = )
18910 521D           E8         B31F            call	_outb
18911 5220           83C4                   04  add	sp,*4
18912                                           !BCC_EOS
18913                                           ! 3410   while ( (inb(0x0064) & 0x01) != 0x01 );
18914 5223           EB           00            jmp .48C
18915                       00005225            .48D:
18916                                           !BCC_EOS
18917                                           ! 3411   prev_command_byte = inb(0x0060);
18918                       00005225            .48C:
18919                                           ! Debug: list int = const $64 (used reg = )
18920 5225           B8                   0064  mov	ax,*$64
18921 5228           50                         push	ax
18922                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18923 5229           E8         B2FD            call	_inb
18924 522C           44                         inc	sp
18925 522D           44                         inc	sp
18926                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18927 522E           24                     01  and	al,*1
18928                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18929 5230           3C                     01  cmp	al,*1
18930 5232           75           F1            jne	.48D
18931                       00005234            .48E:
18932                       00005234            .48B:
18933                                           ! Debug: list int = const $60 (used reg = )
18934 5234           B8                   0060  mov	ax,*$60
18935 5237           50                         push	ax
18936                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18937 5238           E8         B2EE            call	_inb
18938 523B           44                         inc	sp
18939 523C           44                         inc	sp
18940                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
18941 523D           8846         FE            mov	-2[bp],al
18942                                           !BCC_EOS
18943                                           ! 3412   command_byte = prev_command_byte;
18944                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
18945 5240           8A46         FE            mov	al,-2[bp]
18946 5243           8846         FF            mov	-1[bp],al
18947                                           !BCC_EOS
18948                                           ! 3413   if ( inb(0x0064) & 0x02 )
18949                                           ! Debug: list int = const $64 (used reg = )
18950 5246           B8                   0064  mov	ax,*$64
18951 5249           50                         push	ax
18952                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18953 524A           E8         B2DC            call	_inb
18954 524D           44                         inc	sp
18955 524E           44                         inc	sp
18956                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18957 524F           24                     02  and	al,*2
18958 5251           84C0                       test	al,al
18959 5253           74           12            je  	.48F
18960                       00005255            .490:
18961                                           ! 3414     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18962                                           ! Debug: list * char = .491+0 (used reg = )
18963 5255           BB                   D333  mov	bx,#.491
18964 5258           53                         push	bx
18965                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18966 5259           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
18967 525C           53                         push	bx
18968                                           ! Debug: list int = const 7 (used reg = )
18969 525D           B8                   0007  mov	ax,*7
18970 5260           50                         push	ax
18971                                           ! Debug: func () void = bios_printf+0 (used reg = )
18972 5261           E8         B6D5            call	_bios_printf
18973 5264           83C4                   06  add	sp,*6
18974                                           !BCC_EOS
18975                                           ! 3415   command_byte &= 0xfd;
18976                       00005267            .48F:
18977                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
18978 5267           8A46         FF            mov	al,-1[bp]
18979 526A           24                     FD  and	al,#$FD
18980 526C           8846         FF            mov	-1[bp],al
18981                                           !BCC_EOS
18982                                           ! 3416   command_byte |= 0x20;
18983                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
18984 526F           8A46         FF            mov	al,-1[bp]
18985 5272           0C                     20  or	al,*$20
18986 5274           8846         FF            mov	-1[bp],al
18987                                           !BCC_EOS
18988                                           ! 3417   outb(0x0064, 0x60);
18989                                           ! Debug: list int = const $60 (used reg = )
18990 5277           B8                   0060  mov	ax,*$60
18991 527A           50                         push	ax
18992                                           ! Debug: list int = const $64 (used reg = )
18993 527B           B8                   0064  mov	ax,*$64
18994 527E           50                         push	ax
18995                                           ! Debug: func () void = outb+0 (used reg = )
18996 527F           E8         B2BD            call	_outb
18997 5282           83C4                   04  add	sp,*4
18998                                           !BCC_EOS
18999                                           ! 3418   outb(0x0060, command_byte);
19000                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19001 5285           8A46         FF            mov	al,-1[bp]
19002 5288           30E4                       xor	ah,ah
19003 528A           50                         push	ax
19004                                           ! Debug: list int = const $60 (used reg = )
19005 528B           B8                   0060  mov	ax,*$60
19006 528E           50                         push	ax
19007                                           ! Debug: func () void = outb+0 (used reg = )
19008 528F           E8         B2AD            call	_outb
19009 5292           83C4                   04  add	sp,*4
19010                                           !BCC_EOS
19011                                           ! 3419   return(prev_command_byte);
19012 5295           8A46         FE            mov	al,-2[bp]
19013 5298           89EC                       mov	sp,bp
19014 529A           5D                         pop	bp
19015 529B           C3                         ret
19016                                           !BCC_EOS
19017                                           ! 3420 }
19018                                           ! 3421   void
19019                                           ! Register BX used in function inhibit_mouse_int_and_events
19020                                           ! 3422 enable_mouse_int_and_events()
19021                                           ! 3423 {
19022                                           export	_enable_mouse_int_and_events
19023                       0000529C            _enable_mouse_int_and_events:
19024                                           ! 3424   Bit8u command_byte;
19025                                           !BCC_EOS
19026                                           ! 3425   if ( inb(0x0064) & 0x02 )
19027 529C           55                         push	bp
19028 529D           89E5                       mov	bp,sp
19029 529F           4C                         dec	sp
19030 52A0           4C                         dec	sp
19031                                           ! Debug: list int = const $64 (used reg = )
19032 52A1           B8                   0064  mov	ax,*$64
19033 52A4           50                         push	ax
19034                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19035 52A5           E8         B281            call	_inb
19036 52A8           44                         inc	sp
19037 52A9           44                         inc	sp
19038                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19039 52AA           24                     02  and	al,*2
19040 52AC           84C0                       test	al,al
19041 52AE           74           12            je  	.492
19042                       000052B0            .493:
19043                                           ! 3426     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19044                                           ! Debug: list * char = .494+0 (used reg = )
19045 52B0           BB                   D329  mov	bx,#.494
19046 52B3           53                         push	bx
19047                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19048 52B4           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
19049 52B7           53                         push	bx
19050                                           ! Debug: list int = const 7 (used reg = )
19051 52B8           B8                   0007  mov	ax,*7
19052 52BB           50                         push	ax
19053                                           ! Debug: func () void = bios_printf+0 (used reg = )
19054 52BC           E8         B67A            call	_bios_printf
19055 52BF           83C4                   06  add	sp,*6
19056                                           !BCC_EOS
19057                                           ! 3427   outb(0x0064, 0x20);
19058                       000052C2            .492:
19059                                           ! Debug: list int = const $20 (used reg = )
19060 52C2           B8                   0020  mov	ax,*$20
19061 52C5           50                         push	ax
19062                                           ! Debug: list int = const $64 (used reg = )
19063 52C6           B8                   0064  mov	ax,*$64
19064 52C9           50                         push	ax
19065                                           ! Debug: func () void = outb+0 (used reg = )
19066 52CA           E8         B272            call	_outb
19067 52CD           83C4                   04  add	sp,*4
19068                                           !BCC_EOS
19069                                           ! 3428   while ( (inb(0x0064) & 0x01) != 0x01 );
19070 52D0           EB           00            jmp .496
19071                       000052D2            .497:
19072                                           !BCC_EOS
19073                                           ! 3429   command_byte = inb(0x0060);
19074                       000052D2            .496:
19075                                           ! Debug: list int = const $64 (used reg = )
19076 52D2           B8                   0064  mov	ax,*$64
19077 52D5           50                         push	ax
19078                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19079 52D6           E8         B250            call	_inb
19080 52D9           44                         inc	sp
19081 52DA           44                         inc	sp
19082                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19083 52DB           24                     01  and	al,*1
19084                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
19085 52DD           3C                     01  cmp	al,*1
19086 52DF           75           F1            jne	.497
19087                       000052E1            .498:
19088                       000052E1            .495:
19089                                           ! Debug: list int = const $60 (used reg = )
19090 52E1           B8                   0060  mov	ax,*$60
19091 52E4           50                         push	ax
19092                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19093 52E5           E8         B241            call	_inb
19094 52E8           44                         inc	sp
19095 52E9           44                         inc	sp
19096                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
19097 52EA           8846         FF            mov	-1[bp],al
19098                                           !BCC_EOS
19099                                           ! 3430   if ( inb(0x0064) & 0x02 )
19100                                           ! Debug: list int = const $64 (used reg = )
19101 52ED           B8                   0064  mov	ax,*$64
19102 52F0           50                         push	ax
19103                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19104 52F1           E8         B235            call	_inb
19105 52F4           44                         inc	sp
19106 52F5           44                         inc	sp
19107                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19108 52F6           24                     02  and	al,*2
19109 52F8           84C0                       test	al,al
19110 52FA           74           12            je  	.499
19111                       000052FC            .49A:
19112                                           ! 3431     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19113                                           ! Debug: list * char = .49B+0 (used reg = )
19114 52FC           BB                   D31F  mov	bx,#.49B
19115 52FF           53                         push	bx
19116                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19117 5300           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
19118 5303           53                         push	bx
19119                                           ! Debug: list int = const 7 (used reg = )
19120 5304           B8                   0007  mov	ax,*7
19121 5307           50                         push	ax
19122                                           ! Debug: func () void = bios_printf+0 (used reg = )
19123 5308           E8         B62E            call	_bios_printf
19124 530B           83C4                   06  add	sp,*6
19125                                           !BCC_EOS
19126                                           ! 3432   command_byte |= 0x02;
19127                       0000530E            .499:
19128                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
19129 530E           8A46         FF            mov	al,-1[bp]
19130 5311           0C                     02  or	al,*2
19131 5313           8846         FF            mov	-1[bp],al
19132                                           !BCC_EOS
19133                                           ! 3433   command_byte &= 0xdf;
19134                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
19135 5316           8A46         FF            mov	al,-1[bp]
19136 5319           24                     DF  and	al,#$DF
19137 531B           8846         FF            mov	-1[bp],al
19138                                           !BCC_EOS
19139                                           ! 3434   outb(0x0064, 0x60);
19140                                           ! Debug: list int = const $60 (used reg = )
19141 531E           B8                   0060  mov	ax,*$60
19142 5321           50                         push	ax
19143                                           ! Debug: list int = const $64 (used reg = )
19144 5322           B8                   0064  mov	ax,*$64
19145 5325           50                         push	ax
19146                                           ! Debug: func () void = outb+0 (used reg = )
19147 5326           E8         B216            call	_outb
19148 5329           83C4                   04  add	sp,*4
19149                                           !BCC_EOS
19150                                           ! 3435   outb(0x0060, command_byte);
19151                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19152 532C           8A46         FF            mov	al,-1[bp]
19153 532F           30E4                       xor	ah,ah
19154 5331           50                         push	ax
19155                                           ! Debug: list int = const $60 (used reg = )
19156 5332           B8                   0060  mov	ax,*$60
19157 5335           50                         push	ax
19158                                           ! Debug: func () void = outb+0 (used reg = )
19159 5336           E8         B206            call	_outb
19160 5339           83C4                   04  add	sp,*4
19161                                           !BCC_EOS
19162                                           ! 3436 }
19163 533C           89EC                       mov	sp,bp
19164 533E           5D                         pop	bp
19165 533F           C3                         ret
19166                                           ! 3437   Bit8u
19167                                           ! Register BX used in function enable_mouse_int_and_events
19168                                           ! 3438 send_to_mouse_ctrl(sendbyte)
19169                                           ! 3439   Bit8u sendbyte;
19170                                           export	_send_to_mouse_ctrl
19171                       00005340            _send_to_mouse_ctrl:
19172                                           !BCC_EOS
19173                                           ! 3440 {
19174                                           ! 3441   Bit8u response;
19175                                           !BCC_EOS
19176                                           ! 3442   if ( inb(0x0064) & 0x02 )
19177 5340           55                         push	bp
19178 5341           89E5                       mov	bp,sp
19179 5343           4C                         dec	sp
19180 5344           4C                         dec	sp
19181                                           ! Debug: list int = const $64 (used reg = )
19182 5345           B8                   0064  mov	ax,*$64
19183 5348           50                         push	ax
19184                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19185 5349           E8         B1DD            call	_inb
19186 534C           44                         inc	sp
19187 534D           44                         inc	sp
19188                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19189 534E           24                     02  and	al,*2
19190 5350           84C0                       test	al,al
19191 5352           74           12            je  	.49C
19192                       00005354            .49D:
19193                                           ! 3443     b
19194                                           ! 3443 ios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
19195                                           ! Debug: list * char = .49E+0 (used reg = )
19196 5354           BB                   D315  mov	bx,#.49E
19197 5357           53                         push	bx
19198                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19199 5358           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
19200 535B           53                         push	bx
19201                                           ! Debug: list int = const 7 (used reg = )
19202 535C           B8                   0007  mov	ax,*7
19203 535F           50                         push	ax
19204                                           ! Debug: func () void = bios_printf+0 (used reg = )
19205 5360           E8         B5D6            call	_bios_printf
19206 5363           83C4                   06  add	sp,*6
19207                                           !BCC_EOS
19208                                           ! 3444   outb(0x0064, 0xD4);
19209                       00005366            .49C:
19210                                           ! Debug: list int = const $D4 (used reg = )
19211 5366           B8                   00D4  mov	ax,#$D4
19212 5369           50                         push	ax
19213                                           ! Debug: list int = const $64 (used reg = )
19214 536A           B8                   0064  mov	ax,*$64
19215 536D           50                         push	ax
19216                                           ! Debug: func () void = outb+0 (used reg = )
19217 536E           E8         B1CE            call	_outb
19218 5371           83C4                   04  add	sp,*4
19219                                           !BCC_EOS
19220                                           ! 3445   outb(0x0060, sendbyte);
19221                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
19222 5374           8A46         04            mov	al,4[bp]
19223 5377           30E4                       xor	ah,ah
19224 5379           50                         push	ax
19225                                           ! Debug: list int = const $60 (used reg = )
19226 537A           B8                   0060  mov	ax,*$60
19227 537D           50                         push	ax
19228                                           ! Debug: func () void = outb+0 (used reg = )
19229 537E           E8         B1BE            call	_outb
19230 5381           83C4                   04  add	sp,*4
19231                                           !BCC_EOS
19232                                           ! 3446   return(0);
19233 5384           30C0                       xor	al,al
19234 5386           89EC                       mov	sp,bp
19235 5388           5D                         pop	bp
19236 5389           C3                         ret
19237                                           !BCC_EOS
19238                                           ! 3447 }
19239                                           ! 3448   Bit8u
19240                                           ! Register BX used in function send_to_mouse_ctrl
19241                                           ! 3449 get_mouse_data(data)
19242                                           ! 3450   Bit8u *data;
19243                                           export	_get_mouse_data
19244                       0000538A            _get_mouse_data:
19245                                           !BCC_EOS
19246                                           ! 3451 {
19247                                           ! 3452   Bit8u response;
19248                                           !BCC_EOS
19249                                           ! 3453   while ((inb(0x0064) & 0x21) != 0x21) { }
19250 538A           55                         push	bp
19251 538B           89E5                       mov	bp,sp
19252 538D           4C                         dec	sp
19253 538E           4C                         dec	sp
19254 538F           EB           00            jmp .4A0
19255                       00005391            .4A1:
19256                                           ! 3454   response = inb(0x0060);
19257                       00005391            .4A0:
19258                                           ! Debug: list int = const $64 (used reg = )
19259 5391           B8                   0064  mov	ax,*$64
19260 5394           50                         push	ax
19261                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19262 5395           E8         B191            call	_inb
19263 5398           44                         inc	sp
19264 5399           44                         inc	sp
19265                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
19266 539A           24                     21  and	al,*$21
19267                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
19268 539C           3C                     21  cmp	al,*$21
19269 539E           75           F1            jne	.4A1
19270                       000053A0            .4A2:
19271                       000053A0            .49F:
19272                                           ! Debug: list int = const $60 (used reg = )
19273 53A0           B8                   0060  mov	ax,*$60
19274 53A3           50                         push	ax
19275                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19276 53A4           E8         B182            call	_inb
19277 53A7           44                         inc	sp
19278 53A8           44                         inc	sp
19279                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+4-3] (used reg = )
19280 53A9           8846         FF            mov	-1[bp],al
19281                                           !BCC_EOS
19282                                           ! 3455   _write_byte_SS(response, data);
19283                                           ! Debug: list * unsigned char data = [S+4+2] (used reg = )
19284 53AC           FF76         04            push	4[bp]
19285                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
19286 53AF           8A46         FF            mov	al,-1[bp]
19287 53B2           30E4                       xor	ah,ah
19288 53B4           50                         push	ax
19289                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
19290 53B5           E8         B27F            call	__write_byte_SS
19291 53B8           83C4                   04  add	sp,*4
19292                                           !BCC_EOS
19293                                           ! 3456   return(0);
19294 53BB           30C0                       xor	al,al
19295 53BD           89EC                       mov	sp,bp
19296 53BF           5D                         pop	bp
19297 53C0           C3                         ret
19298                                           !BCC_EOS
19299                                           ! 3457 }
19300                                           ! 3458   void
19301                                           ! 3459 set_kbd_command_byte(command_byte)
19302                                           ! 3460   Bit8u command_byte;
19303                                           export	_set_kbd_command_byte
19304                       000053C1            _set_kbd_command_byte:
19305                                           !BCC_EOS
19306                                           ! 3461 {
19307                                           ! 3462   if ( inb(0x0064) & 0x02 )
19308 53C1           55                         push	bp
19309 53C2           89E5                       mov	bp,sp
19310                                           ! Debug: list int = const $64 (used reg = )
19311 53C4           B8                   0064  mov	ax,*$64
19312 53C7           50                         push	ax
19313                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19314 53C8           E8         B15E            call	_inb
19315 53CB           89EC                       mov	sp,bp
19316                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19317 53CD           24                     02  and	al,*2
19318 53CF           84C0                       test	al,al
19319 53D1           74           11            je  	.4A3
19320                       000053D3            .4A4:
19321                                           ! 3463     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
19322                                           ! Debug: list * char = .4A5+0 (used reg = )
19323 53D3           BB                   D30A  mov	bx,#.4A5
19324 53D6           53                         push	bx
19325                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19326 53D7           BB                   51CF  mov	bx,#_panic_msg_keyb_buffer_full
19327 53DA           53                         push	bx
19328                                           ! Debug: list int = const 7 (used reg = )
19329 53DB           B8                   0007  mov	ax,*7
19330 53DE           50                         push	ax
19331                                           ! Debug: func () void = bios_printf+0 (used reg = )
19332 53DF           E8         B557            call	_bios_printf
19333 53E2           89EC                       mov	sp,bp
19334                                           !BCC_EOS
19335                                           ! 3464   outb(0x0064, 0xD4);
19336                       000053E4            .4A3:
19337                                           ! Debug: list int = const $D4 (used reg = )
19338 53E4           B8                   00D4  mov	ax,#$D4
19339 53E7           50                         push	ax
19340                                           ! Debug: list int = const $64 (used reg = )
19341 53E8           B8                   0064  mov	ax,*$64
19342 53EB           50                         push	ax
19343                                           ! Debug: func () void = outb+0 (used reg = )
19344 53EC           E8         B150            call	_outb
19345 53EF           89EC                       mov	sp,bp
19346                                           !BCC_EOS
19347                                           ! 3465   outb(0x0064, 0x60);
19348                                           ! Debug: list int = const $60 (used reg = )
19349 53F1           B8                   0060  mov	ax,*$60
19350 53F4           50                         push	ax
19351                                           ! Debug: list int = const $64 (used reg = )
19352 53F5           B8                   0064  mov	ax,*$64
19353 53F8           50                         push	ax
19354                                           ! Debug: func () void = outb+0 (used reg = )
19355 53F9           E8         B143            call	_outb
19356 53FC           89EC                       mov	sp,bp
19357                                           !BCC_EOS
19358                                           ! 3466   outb(0x0060, command_byte);
19359                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
19360 53FE           8A46         04            mov	al,4[bp]
19361 5401           30E4                       xor	ah,ah
19362 5403           50                         push	ax
19363                                           ! Debug: list int = const $60 (used reg = )
19364 5404           B8                   0060  mov	ax,*$60
19365 5407           50                         push	ax
19366                                           ! Debug: func () void = outb+0 (used reg = )
19367 5408           E8         B134            call	_outb
19368 540B           89EC                       mov	sp,bp
19369                                           !BCC_EOS
19370                                           ! 3467 }
19371 540D           5D                         pop	bp
19372 540E           C3                         ret
19373                                           ! 3468   void
19374                                           ! Register BX used in function set_kbd_command_byte
19375                                           ! 3469 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
19376                                           ! 3470   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
19377                                           export	_int09_function
19378                       0000540F            _int09_function:
19379                                           !BCC_EOS
19380                                           ! 3471 {
19381                                           ! 3472   Bit8u scancode, asciicode, shift_flags;
19382                                           !BCC_EOS
19383                                           ! 3473   Bit8u mf2_flags, mf2_state;
19384                                           !BCC_EOS
19385                                           ! 3474   scancode = ( AX & 0x00ff );
19386 540F           55                         push	bp
19387 5410           89E5                       mov	bp,sp
19388 5412           83C4                   FA  add	sp,*-6
19389                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
19390 5415           8A46         12            mov	al,$12[bp]
19391                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
19392 5418           8846         FF            mov	-1[bp],al
19393                                           !BCC_EOS
19394                                           ! 3475   if (scancode == 0) {
19395                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
19396 541B           8A46         FF            mov	al,-1[bp]
19397 541E           84C0                       test	al,al
19398 5420           75           12            jne 	.4A6
19399                       00005422            .4A7:
19400                                           ! 3476     bios_printf(4, "KBD: int09 handler: AL=0\n");
19401                                           ! Debug: list * char = .4A8+0 (used reg = )
19402 5422           BB                   D2F0  mov	bx,#.4A8
19403 5425           53                         push	bx
19404                                           ! Debug: list int = const 4 (used reg = )
19405 5426           B8                   0004  mov	ax,*4
19406 5429           50                         push	ax
19407                                           ! Debug: func () void = bios_printf+0 (used reg = )
19408 542A           E8         B50C            call	_bios_printf
19409 542D           83C4                   04  add	sp,*4
19410                                           !BCC_EOS
19411                                           ! 3477     return;
19412 5430           89EC                       mov	sp,bp
19413 5432           5D                         pop	bp
19414 5433           C3                         ret
19415                                           !BCC_EOS
19416                                           ! 3478   }
19417                                           ! 3479   shift_flags = *((Bit8u *)(0x17));
19418                       00005434            .4A6:
19419                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+8-5] (used reg = )
19420 5434           A0         0017            mov	al,[$17]
19421 5437           8846         FD            mov	-3[bp],al
19422                                           !BCC_EOS
19423                                           ! 3480   mf2_flags = *((Bit8u *)(0x18));
19424                                           ! Debug: eq unsigned char = [+$18] to unsigned char mf2_flags = [S+8-6] (used reg = )
19425 543A           A0         0018            mov	al,[$18]
19426 543D           8846         FC            mov	-4[bp],al
19427                                           !BCC_EOS
19428                                           ! 3481   mf2_state = *((Bit8u *)(0x96));
19429                                           ! Debug: eq unsigned char = [+$96] to unsigned char mf2_state = [S+8-7] (used reg = )
19430 5440           A0         0096            mov	al,[$96]
19431 5443           8846         FB            mov	-5[bp],al
19432                                           !BCC_EOS
19433                                           ! 3482   asciicode = 0;
19434                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
19435 5446           30C0                       xor	al,al
19436 5448           8846         FE            mov	-2[bp],al
19437                                           !BCC_EOS
19438                                           ! 3483   switch (scancode) {
19439 544B           8A46         FF            mov	al,-1[bp]
19440 544E           E9         04B6            br 	.4AB
19441                                           ! 3484     case 0x3a:
19442                                           ! 3485       shift_flags ^= 0x40;
19443                       00005451            .4AC:
19444                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
19445 5451           8A46         FD            mov	al,-3[bp]
19446 5454           34                     40  xor	al,*$40
19447 5456           8846         FD            mov	-3[bp],al
19448                                           !BCC_EOS
19449                                           ! 3486       *((Bit8u *)(0x17)) = (shift_flags);
19450                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19451 5459           8A46         FD            mov	al,-3[bp]
19452 545C           A2         0017            mov	[$17],al
19453                                           !BCC_EOS
19454                                           ! 3487       mf2_flags |= 0x40;
19455                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
19456 545F           8A46         FC            mov	al,-4[bp]
19457 5462           0C                     40  or	al,*$40
19458 5464           8846         FC            mov	-4[bp],al
19459                                           !BCC_EOS
19460                                           ! 3488       *((Bit8u *)(0x18)) = (mf2_flags);
19461                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19462 5467           8A46         FC            mov	al,-4[bp]
19463 546A           A2         0018            mov	[$18],al
19464                                           !BCC_EOS
19465                                           ! 3489       break;
19466 546D           E9         04EE            br 	.4A9
19467                                           !BCC_EOS
19468                                           ! 3490     case 0xba:
19469                                           ! 3491       mf2_flags &= ~0x40;
19470                       00005470            .4AD:
19471                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
19472 5470           8A46         FC            mov	al,-4[bp]
19473 5473           24                     BF  and	al,#$BF
19474 5475           8846         FC            mov	-4[bp],al
19475                                           !BCC_EOS
19476                                           ! 3492       *((Bit8u *)(0x18)) = (mf2_flags);
19477                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19478 5478           8A46         FC            mov	al,-4[bp]
19479 547B           A2         0018            mov	[$18],al
19480                                           !BCC_EOS
19481                                           ! 3493       break;
19482 547E           E9         04DD            br 	.4A9
19483                                           !BCC_EOS
19484                                           ! 3494     case 0x2a:
19485                                           ! 3495       shift_flags |= 0x02;
19486                       00005481            .4AE:
19487                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
19488 5481           8A46         FD            mov	al,-3[bp]
19489 5484           0C                     02  or	al,*2
19490 5486           8846         FD            mov	-3[bp],al
19491                                           !BCC_EOS
19492                                           ! 3496       *((Bit8u *)(0x17)) = (shift_flags);
19493                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19494 5489           8A46         FD            mov	al,-3[bp]
19495 548C           A2         0017            mov	[$17],al
19496                                           !BCC_EOS
19497                                           ! 3497       break;
19498 548F           E9         04CC            br 	.4A9
19499                                           !BCC_EOS
19500                                           ! 3498     case 0xaa:
19501                                           ! 3499       shift_flags &= ~0x02;
19502                       00005492            .4AF:
19503                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
19504 5492           8A46         FD            mov	al,-3[bp]
19505 5495           24                     FD  and	al,#$FD
19506 5497           8846         FD            mov	-3[bp],al
19507                                           !BCC_EOS
19508                                           ! 3500       *((Bit8u *)(0x17)) = (shift_flags);
19509                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19510 549A           8A46         FD            mov	al,-3[bp]
19511 549D           A2         0017            mov	[$17],al
19512                                           !BCC_EOS
19513                                           ! 3501       break;
19514 54A0           E9         04BB            br 	.4A9
19515                                           !BCC_EOS
19516                                           ! 3502     case 0x36:
19517                                           ! 3503       shift_flags |= 0x01;
19518                       000054A3            .4B0:
19519                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
19520 54A3           8A46         FD            mov	al,-3[bp]
19521 54A6           0C                     01  or	al,*1
19522 54A8           8846         FD            mov	-3[bp],al
19523                                           !BCC_EOS
19524                                           ! 3504       *((Bit8u *)(0x17)) = (shift_flags);
19525                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19526 54AB           8A46         FD            mov	al,-3[bp]
19527 54AE           A2         0017            mov	[$17],al
19528                                           !BCC_EOS
19529                                           ! 3505       break;
19530 54B1           E9         04AA            br 	.4A9
19531                                           !BCC_EOS
19532                                           ! 3506     case 0xb6:
19533                                           ! 3507       shift_flags &= ~0x01;
19534                       000054B4            .4B1:
19535                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
19536 54B4           8A46         FD            mov	al,-3[bp]
19537 54B7           24                     FE  and	al,#$FE
19538 54B9           8846         FD            mov	-3[bp],al
19539                                           !BCC_EOS
19540                                           ! 3508       *((Bit8u *)(0x17)) = (shift_flags);
19541                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19542 54BC           8A46         FD            mov	al,-3[bp]
19543 54BF           A2         0017            mov	[$17],al
19544                                           !BCC_EOS
19545                                           ! 3509       break;
19546 54C2           E9         0499            br 	.4A9
19547                                           !BCC_EOS
19548                                           ! 3510     case 0x1d:
19549                                           ! 3511       if ((mf2_state & 0x01) == 0) {
19550                       000054C5            .4B2:
19551                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19552 54C5           8A46         FB            mov	al,-5[bp]
19553 54C8           24                     01  and	al,*1
19554                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19555 54CA           84C0                       test	al,al
19556 54CC           75           35            jne 	.4B3
19557                       000054CE            .4B4:
19558                                           ! 3512         shift_flags |= 0x04;
19559                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19560 54CE           8A46         FD            mov	al,-3[bp]
19561 54D1           0C                     04  or	al,*4
19562 54D3           8846         FD            mov	-3[bp],al
19563                                           !BCC_EOS
19564                                           ! 3513         *((Bit8u *)(0x17)) = (shift_flags);
19565                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19566 54D6           8A46         FD            mov	al,-3[bp]
19567 54D9           A2         0017            mov	[$17],al
19568                                           !BCC_EOS
19569                                           ! 3514         if (mf2_state & 0x02) {
19570                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19571 54DC           8A46         FB            mov	al,-5[bp]
19572 54DF           24                     02  and	al,*2
19573 54E1           84C0                       test	al,al
19574 54E3           74           10            je  	.4B5
19575                       000054E5            .4B6:
19576                                           ! 3515           mf2_state |= 0x04;
19577                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
19578 54E5           8A46         FB            mov	al,-5[bp]
19579 54E8           0C                     04  or	al,*4
19580 54EA           8846         FB            mov	-5[bp],al
19581                                           !BCC_EOS
19582                                           ! 3516           *((Bit8u *)(0x96)) = (mf2_state);
19583                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19584 54ED           8A46         FB            mov	al,-5[bp]
19585 54F0           A2         0096            mov	[$96],al
19586                                           !BCC_EOS
19587                                           ! 3517         } else {
19588 54F3           EB           0E            jmp .4B7
19589                       000054F5            .4B5:
19590                                           ! 3518           mf2_flags |= 0x01;
19591                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
19592 54F5           8A46         FC            mov	al,-4[bp]
19593 54F8           0C                     01  or	al,*1
19594 54FA           8846         FC            mov	-4[bp],al
19595                                           !BCC_EOS
19596                                           ! 3519           *((Bit8u *)(0x18)) = (mf2_flags);
19597                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19598 54FD           8A46         FC            mov	al,-4[bp]
19599 5500           A2         0018            mov	[$18],al
19600                                           !BCC_EOS
19601                                           ! 3520         }
19602                                           ! 3521       }
19603                       00005503            .4B7:
19604                                           ! 3522       break;
19605                       00005503            .4B3:
19606 5503           E9         0458            br 	.4A9
19607                                           !BCC_EOS
19608                                           ! 3523     case 0x9d:
19609                                           ! 3524       if ((mf2_state & 0x01) == 0) {
19610                       00005506            .4B8:
19611                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19612 5506           8A46         FB            mov	al,-5[bp]
19613 5509           24                     01  and	al,*1
19614                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19615 550B           84C0                       test	al,al
19616 550D           75           35            jne 	.4B9
19617                       0000550F            .4BA:
19618                                           ! 3525         shift_fla
19619                                           ! 3525 gs &= ~0x04;
19620                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
19621 550F           8A46         FD            mov	al,-3[bp]
19622 5512           24                     FB  and	al,#$FB
19623 5514           8846         FD            mov	-3[bp],al
19624                                           !BCC_EOS
19625                                           ! 3526         *((Bit8u *)(0x17)) = (shift_flags);
19626                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19627 5517           8A46         FD            mov	al,-3[bp]
19628 551A           A2         0017            mov	[$17],al
19629                                           !BCC_EOS
19630                                           ! 3527         if (mf2_state & 0x02) {
19631                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19632 551D           8A46         FB            mov	al,-5[bp]
19633 5520           24                     02  and	al,*2
19634 5522           84C0                       test	al,al
19635 5524           74           10            je  	.4BB
19636                       00005526            .4BC:
19637                                           ! 3528           mf2_state &= ~0x04;
19638                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
19639 5526           8A46         FB            mov	al,-5[bp]
19640 5529           24                     FB  and	al,#$FB
19641 552B           8846         FB            mov	-5[bp],al
19642                                           !BCC_EOS
19643                                           ! 3529           *((Bit8u *)(0x96)) = (mf2_state);
19644                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19645 552E           8A46         FB            mov	al,-5[bp]
19646 5531           A2         0096            mov	[$96],al
19647                                           !BCC_EOS
19648                                           ! 3530         } else {
19649 5534           EB           0E            jmp .4BD
19650                       00005536            .4BB:
19651                                           ! 3531           mf2_flags &= ~0x01;
19652                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19653 5536           8A46         FC            mov	al,-4[bp]
19654 5539           24                     FE  and	al,#$FE
19655 553B           8846         FC            mov	-4[bp],al
19656                                           !BCC_EOS
19657                                           ! 3532           *((Bit8u *)(0x18)) = (mf2_flags);
19658                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19659 553E           8A46         FC            mov	al,-4[bp]
19660 5541           A2         0018            mov	[$18],al
19661                                           !BCC_EOS
19662                                           ! 3533         }
19663                                           ! 3534       }
19664                       00005544            .4BD:
19665                                           ! 3535       break;
19666                       00005544            .4B9:
19667 5544           E9         0417            br 	.4A9
19668                                           !BCC_EOS
19669                                           ! 3536     case 0x38:
19670                                           ! 3537       shift_flags |= 0x08;
19671                       00005547            .4BE:
19672                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
19673 5547           8A46         FD            mov	al,-3[bp]
19674 554A           0C                     08  or	al,*8
19675 554C           8846         FD            mov	-3[bp],al
19676                                           !BCC_EOS
19677                                           ! 3538       *((Bit8u *)(0x17)) = (shift_flags);
19678                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19679 554F           8A46         FD            mov	al,-3[bp]
19680 5552           A2         0017            mov	[$17],al
19681                                           !BCC_EOS
19682                                           ! 3539       if (mf2_state & 0x02) {
19683                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19684 5555           8A46         FB            mov	al,-5[bp]
19685 5558           24                     02  and	al,*2
19686 555A           84C0                       test	al,al
19687 555C           74           10            je  	.4BF
19688                       0000555E            .4C0:
19689                                           ! 3540         mf2_state |= 0x08;
19690                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
19691 555E           8A46         FB            mov	al,-5[bp]
19692 5561           0C                     08  or	al,*8
19693 5563           8846         FB            mov	-5[bp],al
19694                                           !BCC_EOS
19695                                           ! 3541         *((Bit8u *)(0x96)) = (mf2_state);
19696                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19697 5566           8A46         FB            mov	al,-5[bp]
19698 5569           A2         0096            mov	[$96],al
19699                                           !BCC_EOS
19700                                           ! 3542       } else {
19701 556C           EB           0E            jmp .4C1
19702                       0000556E            .4BF:
19703                                           ! 3543         mf2_flags |= 0x02;
19704                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19705 556E           8A46         FC            mov	al,-4[bp]
19706 5571           0C                     02  or	al,*2
19707 5573           8846         FC            mov	-4[bp],al
19708                                           !BCC_EOS
19709                                           ! 3544         *((Bit8u *)(0x18)) = (mf2_flags);
19710                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19711 5576           8A46         FC            mov	al,-4[bp]
19712 5579           A2         0018            mov	[$18],al
19713                                           !BCC_EOS
19714                                           ! 3545       }
19715                                           ! 3546       break;
19716                       0000557C            .4C1:
19717 557C           E9         03DF            br 	.4A9
19718                                           !BCC_EOS
19719                                           ! 3547     case 0xb8:
19720                                           ! 3548       shift_flags &= ~0x08;
19721                       0000557F            .4C2:
19722                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
19723 557F           8A46         FD            mov	al,-3[bp]
19724 5582           24                     F7  and	al,#$F7
19725 5584           8846         FD            mov	-3[bp],al
19726                                           !BCC_EOS
19727                                           ! 3549       *((Bit8u *)(0x17)) = (shift_flags);
19728                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19729 5587           8A46         FD            mov	al,-3[bp]
19730 558A           A2         0017            mov	[$17],al
19731                                           !BCC_EOS
19732                                           ! 3550       if (mf2_state & 0x02) {
19733                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19734 558D           8A46         FB            mov	al,-5[bp]
19735 5590           24                     02  and	al,*2
19736 5592           84C0                       test	al,al
19737 5594           74           10            je  	.4C3
19738                       00005596            .4C4:
19739                                           ! 3551         mf2_state &= ~0x08;
19740                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
19741 5596           8A46         FB            mov	al,-5[bp]
19742 5599           24                     F7  and	al,#$F7
19743 559B           8846         FB            mov	-5[bp],al
19744                                           !BCC_EOS
19745                                           ! 3552         *((Bit8u *)(0x96)) = (mf2_state);
19746                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19747 559E           8A46         FB            mov	al,-5[bp]
19748 55A1           A2         0096            mov	[$96],al
19749                                           !BCC_EOS
19750                                           ! 3553       } else {
19751 55A4           EB           0E            jmp .4C5
19752                       000055A6            .4C3:
19753                                           ! 3554         mf2_flags &= ~0x02;
19754                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
19755 55A6           8A46         FC            mov	al,-4[bp]
19756 55A9           24                     FD  and	al,#$FD
19757 55AB           8846         FC            mov	-4[bp],al
19758                                           !BCC_EOS
19759                                           ! 3555         *((Bit8u *)(0x18)) = (mf2_flags);
19760                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19761 55AE           8A46         FC            mov	al,-4[bp]
19762 55B1           A2         0018            mov	[$18],al
19763                                           !BCC_EOS
19764                                           ! 3556       }
19765                                           ! 3557       break;
19766                       000055B4            .4C5:
19767 55B4           E9         03A7            br 	.4A9
19768                                           !BCC_EOS
19769                                           ! 3558     case 0x45:
19770                                           ! 3559       if ((mf2_state & 0x03) == 0) {
19771                       000055B7            .4C6:
19772                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19773 55B7           8A46         FB            mov	al,-5[bp]
19774 55BA           24                     03  and	al,*3
19775                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19776 55BC           84C0                       test	al,al
19777 55BE           75           1C            jne 	.4C7
19778                       000055C0            .4C8:
19779                                           ! 3560         mf2_flags |= 0x20;
19780                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
19781 55C0           8A46         FC            mov	al,-4[bp]
19782 55C3           0C                     20  or	al,*$20
19783 55C5           8846         FC            mov	-4[bp],al
19784                                           !BCC_EOS
19785                                           ! 3561         *((Bit8u *)(0x18)) = (mf2_flags);
19786                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19787 55C8           8A46         FC            mov	al,-4[bp]
19788 55CB           A2         0018            mov	[$18],al
19789                                           !BCC_EOS
19790                                           ! 3562         shift_flags ^= 0x20;
19791                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
19792 55CE           8A46         FD            mov	al,-3[bp]
19793 55D1           34                     20  xor	al,*$20
19794 55D3           8846         FD            mov	-3[bp],al
19795                                           !BCC_EOS
19796                                           ! 3563         *((Bit8u *)(0x17)) = (shift_flags);
19797                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19798 55D6           8A46         FD            mov	al,-3[bp]
19799 55D9           A2         0017            mov	[$17],al
19800                                           !BCC_EOS
19801                                           ! 3564       }
19802                                           ! 3565       break;
19803                       000055DC            .4C7:
19804 55DC           E9         037F            br 	.4A9
19805                                           !BCC_EOS
19806                                           ! 3566     case 0xc5:
19807                                           ! 3567       if ((mf2_state & 0x03) == 0) {
19808                       000055DF            .4C9:
19809                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19810 55DF           8A46         FB            mov	al,-5[bp]
19811 55E2           24                     03  and	al,*3
19812                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19813 55E4           84C0                       test	al,al
19814 55E6           75           0E            jne 	.4CA
19815                       000055E8            .4CB:
19816                                           ! 3568         mf2_flags &= ~0x20;
19817                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
19818 55E8           8A46         FC            mov	al,-4[bp]
19819 55EB           24                     DF  and	al,#$DF
19820 55ED           8846         FC            mov	-4[bp],al
19821                                           !BCC_EOS
19822                                           ! 3569         *((Bit8u *)(0x18)) = (mf2_flags);
19823                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19824 55F0           8A46         FC            mov	al,-4[bp]
19825 55F3           A2         0018            mov	[$18],al
19826                                           !BCC_EOS
19827                                           ! 3570       }
19828                                           ! 3571       break;
19829                       000055F6            .4CA:
19830 55F6           E9         0365            br 	.4A9
19831                                           !BCC_EOS
19832                                           ! 3572     case 0x46:
19833                                           ! 3573       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19834                       000055F9            .4CC:
19835                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19836 55F9           8A46         FB            mov	al,-5[bp]
19837 55FC           24                     02  and	al,*2
19838 55FE           84C0                       test	al,al
19839 5600           75           12            jne 	.4CE
19840                       00005602            .4CF:
19841                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19842 5602           8A46         FB            mov	al,-5[bp]
19843 5605           24                     10  and	al,*$10
19844 5607           84C0                       test	al,al
19845 5609           75           32            jne 	.4CD
19846                       0000560B            .4D0:
19847                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19848 560B           8A46         FD            mov	al,-3[bp]
19849 560E           24                     04  and	al,*4
19850 5610           84C0                       test	al,al
19851 5612           74           29            je  	.4CD
19852                       00005614            .4CE:
19853                                           ! 3574         mf2_state &= ~0x02;
19854                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
19855 5614           8A46         FB            mov	al,-5[bp]
19856 5617           24                     FD  and	al,#$FD
19857 5619           8846         FB            mov	-5[bp],al
19858                                           !BCC_EOS
19859                                           ! 3575         *((Bit8u *)(0x96)) = (mf2_state);
19860                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19861 561C           8A46         FB            mov	al,-5[bp]
19862 561F           A2         0096            mov	[$96],al
19863                                           !BCC_EOS
19864                                           ! 3576         *((Bit8u *)(0x71)) = (0x80);
19865                                           ! Debug: eq int = const $80 to unsigned char = [+$71] (used reg = )
19866 5622           B0                     80  mov	al,#$80
19867 5624           A2         0071            mov	[$71],al
19868                                           !BCC_EOS
19869                                           ! 3577         *((Bit16u *)(0x001C)) = (*((Bit16u *)(0x001A)));
19870                                           ! Debug: eq unsigned short = [+$1A] to unsigned short = [+$1C] (used reg = )
19871 5627           A1         001A            mov	ax,[$1A]
19872 562A           A3         001C            mov	[$1C],ax
19873                                           !BCC_EOS
19874                                           ! 3578 #asm
19875                                           !BCC_EOS
19876                                           !BCC_ASM
19877                       0000000E            _int09_function.BP	set	$E
19878                       00000008            .int09_function.BP	set	8
19879                       00000016            _int09_function.CX	set	$16
19880                       00000010            .int09_function.CX	set	$10
19881                       0000000A            _int09_function.DI	set	$A
19882                       00000004            .int09_function.DI	set	4
19883                       00000014            _int09_function.DX	set	$14
19884                       0000000E            .int09_function.DX	set	$E
19885                       00000002            _int09_function.mf2_flags	set	2
19886                       FFFFFFFC            .int09_function.mf2_flags	set	-4
19887                       0000000C            _int09_function.SI	set	$C
19888                       00000006            .int09_function.SI	set	6
19889                       00000001            _int09_function.mf2_state	set	1
19890                       FFFFFFFB            .int09_function.mf2_state	set	-5
19891                       00000018            _int09_function.AX	set	$18
19892                       00000012            .int09_function.AX	set	$12
19893                       00000004            _int09_function.asciicode	set	4
19894                       FFFFFFFE            .int09_function.asciicode	set	-2
19895                       00000005            _int09_function.scancode	set	5
19896                       FFFFFFFF            .int09_function.scancode	set	-1
19897                       00000010            _int09_function.SP	set	$10
19898                       0000000A            .int09_function.SP	set	$A
19899                       00000012            _int09_function.BX	set	$12
19900                       0000000C            .int09_function.BX	set	$C
19901                       00000003            _int09_function.shift_flags	set	3
19902                       FFFFFFFD            .int09_function.shift_flags	set	-3
19903 562D           CD                     1B          int #0x1B
19904                                           ! 3580 endasm
19905                                           !BCC_ENDASM
19906                                           !BCC_EOS
19907                                           ! 3581         enqueue_key(0, 0);
19908                                           ! Debug: list int = const 0 (used reg = )
19909 562F           31C0                       xor	ax,ax
19910 5631           50                         push	ax
19911                                           ! Debug: list int = const 0 (used reg = )
19912 5632           31C0                       xor	ax,ax
19913 5634           50                         push	ax
19914                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
19915 5635           E8         0349            call	_enqueue_key
19916 5638           83C4                   04  add	sp,*4
19917                                           !BCC_EOS
19918                                           ! 3582       } else {
19919 563B           EB           1C            jmp .4D1
19920                       0000563D            .4CD:
19921                                           ! 3583         mf2_flags |= 0x10;
19922                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
19923 563D           8A46         FC            mov	al,-4[bp]
19924 5640           0C                     10  or	al,*$10
19925 5642           8846         FC            mov	-4[bp],al
19926                                           !BCC_EOS
19927                                           ! 3584         *((Bit8u *)(0x18)) = (mf2_flags);
19928                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19929 5645           8A46         FC            mov	al,-4[bp]
19930 5648           A2         0018            mov	[$18],al
19931                                           !BCC_EOS
19932                                           ! 3585         shift_flags ^= 0x10;
19933                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
19934 564B           8A46         FD            mov	al,-3[bp]
19935 564E           34                     10  xor	al,*$10
19936 5650           8846         FD            mov	-3[bp],al
19937                                           !BCC_EOS
19938                                           ! 3586         *((Bit8u *)(0x17)) = (shift_flags);
19939                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19940 5653           8A46         FD            mov	al,-3[bp]
19941 5656           A2         0017            mov	[$17],al
19942                                           !BCC_EOS
19943                                           ! 3587       }
19944                                           ! 3588       break;
19945                       00005659            .4D1:
19946 5659           E9         0302            br 	.4A9
19947                                           !BCC_EOS
19948                                           ! 3589     case 0xc6:
19949                                           ! 3590       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19950                       0000565C            .4D2:
19951                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19952 565C           8A46         FB            mov	al,-5[bp]
19953 565F           24                     02  and	al,*2
19954 5661           84C0                       test	al,al
19955 5663           75           12            jne 	.4D4
19956                       00005665            .4D5:
19957                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19958 5665           8A46         FB            mov	al,-5[bp]
19959 5668           24                     10  and	al,*$10
19960 566A           84C0                       test	al,al
19961 566C           75           0B            jne 	.4D3
19962                       0000566E            .4D6:
19963                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19964 566E           8A46         FD            mov	al,-3[bp]
19965 5671           24                     04  and	al,*4
19966 5673           84C0                       test	al,al
19967 5675           74           02            je  	.4D3
19968                       00005677            .4D4:
19969                                           ! 3591       } else {
19970 5677           EB           0E            jmp .4D7
19971                       00005679            .4D3:
19972                                           ! 3592         mf2_flags &= ~0x10;
19973                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
19974 5679           8A46         FC            mov	al,-4[bp]
19975 567C           24                     EF  and	al,#$EF
19976 567E           8846         FC            mov	-4[bp],al
19977                                           !BCC_EOS
19978                                           ! 3593         *((Bit8u *)(0x18)) = (mf2_flags);
19979                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19980 5681           8A46         FC            mov	al,-4[bp]
19981 5684           A2         0018            mov	[$18],al
19982                                           !BCC_EOS
19983                                           ! 3594       }
19984                                           ! 3595       break;
19985                       00005687            .4D7:
19986 5687           E9         02D4            br 	.4A9
19987                                           !BCC_EOS
19988                                           ! 3596     default:
19989                                           ! 3597       if (scancode & 0x80) {
19990                       0000568A            .4D8:
19991                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
19992 568A           8A46         FF            mov	al,-1[bp]
19993 568D           24                     80  and	al,#$80
19994 568F           84C0                       test	al,al
19995 5691           74           03            je  	.4D9
19996                       00005693            .4DA:
19997                                           ! 3598         break;
19998 5693           E9         02C8            br 	.4A9
19999                                           !BCC_EOS
20000                                           ! 3599       }
20001                                           ! 3600       if (scancode > 0x58) {
20002                       00005696            .4D9:
20003                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
20004 5696           8A46         FF            mov	al,-1[bp]
20005 5699           3C                     58  cmp	al,*$58
20006 569B           76           18            jbe 	.4DB
20007                       0000569D            .4DC:
20008                                           ! 3601         bios_printf(4, "KBD: int09
20009                                           ! 3601 h_handler(): unknown scancode read: 0x%02x!\n", scancode);
20010                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
20011 569D           8A46         FF            mov	al,-1[bp]
20012 56A0           30E4                       xor	ah,ah
20013 56A2           50                         push	ax
20014                                           ! Debug: list * char = .4DD+0 (used reg = )
20015 56A3           BB                   D2B9  mov	bx,#.4DD
20016 56A6           53                         push	bx
20017                                           ! Debug: list int = const 4 (used reg = )
20018 56A7           B8                   0004  mov	ax,*4
20019 56AA           50                         push	ax
20020                                           ! Debug: func () void = bios_printf+0 (used reg = )
20021 56AB           E8         B28B            call	_bios_printf
20022 56AE           83C4                   06  add	sp,*6
20023                                           !BCC_EOS
20024                                           ! 3602         return;
20025 56B1           89EC                       mov	sp,bp
20026 56B3           5D                         pop	bp
20027 56B4           C3                         ret
20028                                           !BCC_EOS
20029                                           ! 3603       }
20030                                           ! 3604       if (scancode == 0x53) {
20031                       000056B5            .4DB:
20032                                           ! Debug: logeq int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20033 56B5           8A46         FF            mov	al,-1[bp]
20034 56B8           3C                     53  cmp	al,*$53
20035 56BA           75           14            jne 	.4DE
20036                       000056BC            .4DF:
20037                                           ! 3605         if ((shift_flags & 0x0f) == 0x0c) {
20038                                           ! Debug: and int = const $F to unsigned char shift_flags = [S+8-5] (used reg = )
20039 56BC           8A46         FD            mov	al,-3[bp]
20040 56BF           24                     0F  and	al,*$F
20041                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
20042 56C1           3C                     0C  cmp	al,*$C
20043 56C3           75           0B            jne 	.4E0
20044                       000056C5            .4E1:
20045                                           ! 3606           *((Bit16u *)(0x0072)) = (0x1234);
20046                                           ! Debug: eq int = const $1234 to unsigned short = [+$72] (used reg = )
20047 56C5           B8                   1234  mov	ax,#$1234
20048 56C8           A3         0072            mov	[$72],ax
20049                                           !BCC_EOS
20050                                           ! 3607 #asm
20051                                           !BCC_EOS
20052                                           !BCC_ASM
20053                       0000000E            _int09_function.BP	set	$E
20054                       00000008            .int09_function.BP	set	8
20055                       00000016            _int09_function.CX	set	$16
20056                       00000010            .int09_function.CX	set	$10
20057                       0000000A            _int09_function.DI	set	$A
20058                       00000004            .int09_function.DI	set	4
20059                       00000014            _int09_function.DX	set	$14
20060                       0000000E            .int09_function.DX	set	$E
20061                       00000002            _int09_function.mf2_flags	set	2
20062                       FFFFFFFC            .int09_function.mf2_flags	set	-4
20063                       0000000C            _int09_function.SI	set	$C
20064                       00000006            .int09_function.SI	set	6
20065                       00000001            _int09_function.mf2_state	set	1
20066                       FFFFFFFB            .int09_function.mf2_state	set	-5
20067                       00000018            _int09_function.AX	set	$18
20068                       00000012            .int09_function.AX	set	$12
20069                       00000004            _int09_function.asciicode	set	4
20070                       FFFFFFFE            .int09_function.asciicode	set	-2
20071                       00000005            _int09_function.scancode	set	5
20072                       FFFFFFFF            .int09_function.scancode	set	-1
20073                       00000010            _int09_function.SP	set	$10
20074                       0000000A            .int09_function.SP	set	$A
20075                       00000012            _int09_function.BX	set	$12
20076                       0000000C            .int09_function.BX	set	$C
20077                       00000003            _int09_function.shift_flags	set	3
20078                       FFFFFFFD            .int09_function.shift_flags	set	-3
20079 56CB           EA         E05B      F000            jmp 0xf000:post;
20080                                           ! 3609 endasm
20081                                           !BCC_ENDASM
20082                                           !BCC_EOS
20083                                           ! 3610         }
20084                                           ! 3611       }
20085                       000056D0            .4E0:
20086                                           ! 3612       set_DS(get_CS());
20087                       000056D0            .4DE:
20088                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
20089 56D0           E8         AF84            call	_get_CS
20090                                           ! Debug: list unsigned short = ax+0 (used reg = )
20091 56D3           50                         push	ax
20092                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20093 56D4           E8         AF86            call	_set_DS
20094 56D7           44                         inc	sp
20095 56D8           44                         inc	sp
20096                                           !BCC_EOS
20097                                           ! 3613       if (shift_flags & 0x08) {
20098                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
20099 56D9           8A46         FD            mov	al,-3[bp]
20100 56DC           24                     08  and	al,*8
20101 56DE           84C0                       test	al,al
20102 56E0           74           3D            je  	.4E2
20103                       000056E2            .4E3:
20104                                           ! 3614         asciicode = scan_to_scanascii[scancode].alt;
20105                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20106 56E2           8A46         FF            mov	al,-1[bp]
20107 56E5           30E4                       xor	ah,ah
20108 56E7           89C2                       mov	dx,ax
20109 56E9           D1E0                       shl	ax,*1
20110 56EB           D1E0                       shl	ax,*1
20111 56ED           01D0                       add	ax,dx
20112 56EF           D1E0                       shl	ax,*1
20113 56F1           89C3                       mov	bx,ax
20114 56F3           81C3                 01AF  add	bx,#_scan_to_scanascii
20115                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
20116 56F7           8A47         06            mov	al,6[bx]
20117 56FA           8846         FE            mov	-2[bp],al
20118                                           !BCC_EOS
20119                                           ! 3615         scancode = scan_to_scanascii[scancode].alt >> 8;
20120                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20121 56FD           8A46         FF            mov	al,-1[bp]
20122 5700           30E4                       xor	ah,ah
20123 5702           89C2                       mov	dx,ax
20124 5704           D1E0                       shl	ax,*1
20125 5706           D1E0                       shl	ax,*1
20126 5708           01D0                       add	ax,dx
20127 570A           D1E0                       shl	ax,*1
20128 570C           89C3                       mov	bx,ax
20129 570E           81C3                 01AF  add	bx,#_scan_to_scanascii
20130                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
20131 5712           8B47         06            mov	ax,6[bx]
20132 5715           88E0                       mov	al,ah
20133 5717           30E4                       xor	ah,ah
20134                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20135 5719           8846         FF            mov	-1[bp],al
20136                                           !BCC_EOS
20137                                           ! 3616       } else if (shift_flags & 0x04) {
20138 571C           E9         01AD            br 	.4E4
20139                       0000571F            .4E2:
20140                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20141 571F           8A46         FD            mov	al,-3[bp]
20142 5722           24                     04  and	al,*4
20143 5724           84C0                       test	al,al
20144 5726           74           3D            je  	.4E5
20145                       00005728            .4E6:
20146                                           ! 3617         asciicode = scan_to_scanascii[scancode].control;
20147                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20148 5728           8A46         FF            mov	al,-1[bp]
20149 572B           30E4                       xor	ah,ah
20150 572D           89C2                       mov	dx,ax
20151 572F           D1E0                       shl	ax,*1
20152 5731           D1E0                       shl	ax,*1
20153 5733           01D0                       add	ax,dx
20154 5735           D1E0                       shl	ax,*1
20155 5737           89C3                       mov	bx,ax
20156 5739           81C3                 01AF  add	bx,#_scan_to_scanascii
20157                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
20158 573D           8A47         04            mov	al,4[bx]
20159 5740           8846         FE            mov	-2[bp],al
20160                                           !BCC_EOS
20161                                           ! 3618         scancode = scan_to_scanascii[scancode].control >> 8;
20162                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20163 5743           8A46         FF            mov	al,-1[bp]
20164 5746           30E4                       xor	ah,ah
20165 5748           89C2                       mov	dx,ax
20166 574A           D1E0                       shl	ax,*1
20167 574C           D1E0                       shl	ax,*1
20168 574E           01D0                       add	ax,dx
20169 5750           D1E0                       shl	ax,*1
20170 5752           89C3                       mov	bx,ax
20171 5754           81C3                 01AF  add	bx,#_scan_to_scanascii
20172                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
20173 5758           8B47         04            mov	ax,4[bx]
20174 575B           88E0                       mov	al,ah
20175 575D           30E4                       xor	ah,ah
20176                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20177 575F           8846         FF            mov	-1[bp],al
20178                                           !BCC_EOS
20179                                           ! 3619       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
20180 5762           E9         0167            br 	.4E7
20181                       00005765            .4E5:
20182                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20183 5765           8A46         FB            mov	al,-5[bp]
20184 5768           24                     02  and	al,*2
20185                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20186 576A           84C0                       test	al,al
20187 576C           74           32            je  	.4E8
20188                       0000576E            .4EA:
20189                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
20190 576E           8A46         FF            mov	al,-1[bp]
20191 5771           3C                     47  cmp	al,*$47
20192 5773           72           2B            jb  	.4E8
20193                       00005775            .4EB:
20194                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20195 5775           8A46         FF            mov	al,-1[bp]
20196 5778           3C                     53  cmp	al,*$53
20197 577A           77           24            ja  	.4E8
20198                       0000577C            .4E9:
20199                                           ! 3620         asciicode = 0xe0;
20200                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
20201 577C           B0                     E0  mov	al,#$E0
20202 577E           8846         FE            mov	-2[bp],al
20203                                           !BCC_EOS
20204                                           ! 3621         scancode = scan_to_scanascii[scancode].normal >> 8;
20205                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20206 5781           8A46         FF            mov	al,-1[bp]
20207 5784           30E4                       xor	ah,ah
20208 5786           89C2                       mov	dx,ax
20209 5788           D1E0                       shl	ax,*1
20210 578A           D1E0                       shl	ax,*1
20211 578C           01D0                       add	ax,dx
20212 578E           D1E0                       shl	ax,*1
20213 5790           89C3                       mov	bx,ax
20214                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20215 5792           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20216 5796           88E0                       mov	al,ah
20217 5798           30E4                       xor	ah,ah
20218                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20219 579A           8846         FF            mov	-1[bp],al
20220                                           !BCC_EOS
20221                                           ! 3622       } else if (shift_flags & 0x03) {
20222 579D           E9         012C            br 	.4EC
20223                       000057A0            .4E8:
20224                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
20225 57A0           8A46         FD            mov	al,-3[bp]
20226 57A3           24                     03  and	al,*3
20227 57A5           84C0                       test	al,al
20228 57A7         0F84         0092            beq 	.4ED
20229                       000057AB            .4EE:
20230                                           ! 3623         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20231                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20232 57AB           8A46         FF            mov	al,-1[bp]
20233 57AE           30E4                       xor	ah,ah
20234 57B0           89C2                       mov	dx,ax
20235 57B2           D1E0                       shl	ax,*1
20236 57B4           D1E0                       shl	ax,*1
20237 57B6           01D0                       add	ax,dx
20238 57B8           D1E0                       shl	ax,*1
20239 57BA           89C3                       mov	bx,ax
20240 57BC           81C3                 01AF  add	bx,#_scan_to_scanascii
20241                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20242 57C0           8A46         FD            mov	al,-3[bp]
20243 57C3           2247         08            and	al,8[bx]
20244 57C6           84C0                       test	al,al
20245 57C8           74           36            je  	.4EF
20246                       000057CA            .4F0:
20247                                           ! 3624           asciicode = scan_to_scanascii[scancode].normal;
20248                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20249 57CA           8A46         FF            mov	al,-1[bp]
20250 57CD           30E4                       xor	ah,ah
20251 57CF           89C2                       mov	dx,ax
20252 57D1           D1E0                       shl	ax,*1
20253 57D3           D1E0                       shl	ax,*1
20254 57D5           01D0                       add	ax,dx
20255 57D7           D1E0                       shl	ax,*1
20256 57D9           89C3                       mov	bx,ax
20257                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20258 57DB           8A87       01AF            mov	al,_scan_to_scanascii[bx]
20259 57DF           8846         FE            mov	-2[bp],al
20260                                           !BCC_EOS
20261                                           ! 3625           scancode = scan_to_scanascii[scancode].normal >> 8;
20262                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20263 57E2           8A46         FF            mov	al,-1[bp]
20264 57E5           30E4                       xor	ah,ah
20265 57E7           89C2                       mov	dx,ax
20266 57E9           D1E0                       shl	ax,*1
20267 57EB           D1E0                       shl	ax,*1
20268 57ED           01D0                       add	ax,dx
20269 57EF           D1E0                       shl	ax,*1
20270 57F1           89C3                       mov	bx,ax
20271                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20272 57F3           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20273 57F7           88E0                       mov	al,ah
20274 57F9           30E4                       xor	ah,ah
20275                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20276 57FB           8846         FF            mov	-1[bp],al
20277                                           !BCC_EOS
20278                                           ! 3626         } else {
20279 57FE           EB           3A            jmp .4F1
20280                       00005800            .4EF:
20281                                           ! 3627           asciicode = scan_to_scanascii[scancode].shift;
20282                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20283 5800           8A46         FF            mov	al,-1[bp]
20284 5803           30E4                       xor	ah,ah
20285 5805           89C2                       mov	dx,ax
20286 5807           D1E0                       shl	ax,*1
20287 5809           D1E0                       shl	ax,*1
20288 580B           01D0                       add	ax,dx
20289 580D           D1E0                       shl	ax,*1
20290 580F           89C3                       mov	bx,ax
20291 5811           81C3                 01AF  add	bx,#_scan_to_scanascii
20292                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20293 5815           8A47         02            mov	al,2[bx]
20294 5818           8846         FE            mov	-2[bp],al
20295                                           !BCC_EOS
20296                                           ! 3628           scancode = scan_to_scanascii[scancode].shift >> 8;
20297                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20298 581B           8A46         FF            mov	al,-1[bp]
20299 581E           30E4                       xor	ah,ah
20300 5820           89C2                       mov	dx,ax
20301 5822           D1E0                       shl	ax,*1
20302 5824           D1E0                       shl	ax,*1
20303 5826           01D0                       add	ax,dx
20304 5828           D1E0                       shl	ax,*1
20305 582A           89C3                       mov	bx,ax
20306 582C           81C3                 01AF  add	bx,#_scan_to_scanascii
20307                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20308 5830           8B47         02            mov	ax,2[bx]
20309 5833           88E0                       mov	al,ah
20310 5835           30E4                       xor	ah,ah
20311                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20312 5837           8846         FF            mov	-1[bp],al
20313                                           !BCC_EOS
20314                                           ! 3629         }
20315                                           ! 3630       } else {
20316                       0000583A            .4F1:
20317 583A           E9         008F            br 	.4F2
20318                       0000583D            .4ED:
20319                                           ! 3631         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20320                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20321 583D           8A46         FF            mov	al,-1[bp]
20322 5840           30E4                       xor	ah,ah
20323 5842           89C2                       mov	dx,ax
20324 5844           D1E0                       shl	ax,*1
20325 5846           D1E0                       shl	ax,*1
20326 5848           01D0                       add	ax,dx
20327 584A           D1E0                       shl	ax,*1
20328 584C           89C3                       mov	bx,ax
20329 584E           81C3                 01AF  add	bx,#_scan_to_scanascii
20330                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20331 5852           8A46         FD            mov	al,-3[bp]
20332 5855           2247         08            and	al,8[bx]
20333 5858           84C0                       test	al,al
20334 585A           74           3C            je  	.4F3
20335                       0000585C            .4F4:
20336                                           ! 3632           asciicode = scan_to_scanascii[scancode].shift;
20337                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20338 585C           8A46         FF            mov	al,-1[bp]
20339 585F           30E4                       xor	ah,ah
20340 5861           89C2                       mov	dx,ax
20341 5863           D1E0                       shl	ax,*1
20342 5865           D1E0                       shl	ax,*1
20343 5867           01D0                       add	ax,dx
20344 5869           D1E0                       shl	ax,*1
20345 586B           89C3                       mov	bx,ax
20346 586D           81C3                 01AF  add	bx,#_scan_to_scanascii
20347                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20348 5871           8A47         02            mov	al,2[bx]
20349 5874           8846         FE            mov	-2[bp],al
20350                                           !BCC_EOS
20351                                           ! 3633           scancode = scan_to_scanascii[scancode].shift >> 8;
20352                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20353 5877           8A46         FF            mov	al,-1[bp]
20354 587A           30E4                       xor	ah,ah
20355 587C           89C2                       mov	dx,ax
20356 587E           D1E0                       shl	ax,*1
20357 5880           D1E0                       shl	ax,*1
20358 5882           01D0                       add	ax,dx
20359 5884           D1E0                       shl	ax,*1
20360 5886           89C3                       mov	bx,ax
20361 5888           81C3                 01AF  add	bx,#_scan_to_scanascii
20362                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20363 588C           8B47         02            mov	ax,2[bx]
20364 588F           88E0                       mov	al,ah
20365 5891           30E4                       xor	ah,ah
20366                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20367 5893           8846         FF            mov	-1[bp],al
20368                                           !BCC_EOS
20369                                           ! 3634         } else {
20370 5896           EB           34            jmp .4F5
20371                       00005898            .4F3:
20372                                           ! 3635           asciicode = scan_to_scanascii[scancode].normal;
20373                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20374 5898           8A46         FF            mov	al,-1[bp]
20375 589B           30E4                       xor	ah,ah
20376 589D           89C2                       mov	dx,ax
20377 589F           D1E0                       shl	ax,*1
20378 58A1           D1E0                       shl	ax,*1
20379 58A3           01D0                       add	ax,dx
20380 58A5           D1E0                       shl	ax,*1
20381 58A7           89C3                       mov	bx,ax
20382                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20383 58A9           8A87       01AF            mov	al,_scan_to_scanascii[bx]
20384 58AD           8846         FE            mov	-2[bp],al
20385                                           !BCC_EOS
20386                                           ! 3636           scancode = scan_to_scanascii[scancode].normal >> 8;
20387                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20388 58B0           8A46         FF            mov	al,-1[bp]
20389 58B3           30E4                       xor	ah,ah
20390 58B5           89C2                       mov	dx,ax
20391 58B7           D1E0                       shl	ax,*1
20392 58B9           D1E0                       shl	ax,*1
20393 58BB           01D0                       add	ax,dx
20394 58BD           D1E0                       shl	ax,*1
20395 58BF           89C3                       mov	bx,ax
20396                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20397 58C1           8B87       01AF            mov	ax,_scan_to_scanascii[bx]
20398 58C5           88E0                       mov	al,ah
20399 58C7           30E4                       xor	ah,ah
20400                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20401 58C9           8846         FF            mov	-1[bp],al
20402                                           !BCC_EOS
20403                                           ! 3637         }
20404                                           ! 3638       }
20405                       000058CC            .4F5:
20406                                           ! 3639       set_DS(0x40);
20407                       000058CC            .4F2:
20408                       000058CC            .4EC:
20409                       000058CC            .4E7:
20410                       000058CC            .4E4:
20411                                           ! Debug: list int = const $40 (used reg = )
20412 58CC           B8                   0040  mov	ax,*$40
20413 58CF           50                         push	ax
20414                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20415 58D0           E8         AD8A            call	_set_DS
20416 58D3           44                         inc	sp
20417 58D4           44                         inc	sp
20418                                           !BCC_EOS
20419                                           ! 3640       if (scancode==0 && asciicode==0) {
20420                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
20421 58D5           8A46         FF            mov	al,-1[bp]
20422 58D8           84C0                       test	al,al
20423 58DA           75           15            jne 	.4F6
20424                       000058DC            .4F8:
20425                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
20426 58DC           8A46         FE            mov	al,-2[bp]
20427 58DF           84C0                       test	al,al
20428 58E1           75           0E            jne 	.4F6
20429                       000058E3            .4F7:
20430                                           ! 3641         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
20431                                           ! Debug: list * char = .4F9+0 (used reg = )
20432 58E3           BB                   D282  mov	bx,#.4F9
20433 58E6           53                         push	bx
20434                                           ! Debug: list int = const 4 (used reg = )
20435 58E7           B8                   0004  mov	ax,*4
20436 58EA           50                         push	ax
20437                                           ! Debug: func () void = bios_printf+0 (used reg = )
20438 58EB           E8         B04B            call	_bios_printf
20439 58EE           83C4                   04  add	sp,*4
20440                                           !BCC_EOS
20441                                           ! 3642       }
20442                                           ! 3643       enqueue_key(scancode, asciicode);
20443                       000058F1            .4F6:
20444                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
20445 58F1           8A46         FE            mov	al,-2[bp]
20446 58F4           30E4                       xor	ah,ah
20447 58F6           50                         push	ax
20448                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
20449 58F7           8A46         FF            mov	al,-1[bp]
20450 58FA           30E4                       xor	ah,ah
20451 58FC           50                         push	ax
20452                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20453 58FD           E8         0081            call	_enqueue_key
20454 5900           83C4                   04  add	sp,*4
20455                                           !BCC_EOS
20456                                           ! 3644       break;
20457 5903           EB           59            jmp .4A9
20458                                           !BCC_EOS
20459                                           ! 3645   }
20460                                           ! 3646   if ((scancode & 0x7f) != 0x1d) {
20461 5905           EB           57            jmp .4A9
20462                       00005907            .4AB:
20463 5907           2C                     1D  sub	al,*$1D
20464 5909         0F84         FBB8            beq 	.4B2
20465 590D           2C                     0D  sub	al,*$D
20466 590F         0F84         FB6E            beq 	.4AE
20467 5913           2C                     0C  sub	al,*$C
20468 5915         0F84         FB8A            beq 	.4B0
20469 5919           2C                     02  sub	al,*2
20470 591B         0F84         FC28            beq 	.4BE
20471 591F           2C                     02  sub	al,*2
20472 5921         0F84         FB2C            beq 	.4AC
20473 5925           2C                     0B  sub	al,*$B
20474 5927         0F84         FC8C            beq 	.4C6
20475 592B           2C                     01  sub	al,*1
20476 592D         0F84         FCC8            beq 	.4CC
20477 5931           2C                     57  sub	al,*$57
20478 5933         0F84         FBCF            beq 	.4B8
20479 5937           2C                     0D  sub	al,*$D
20480 5939         0F84         FB55            beq 	.4AF
20481 593D           2C                     0C  sub	al,*$C
20482 593F         0F84         FB71            beq 	.4B1
20483 5943           2C                     02  sub	al,*2
20484 5945         0F84         FC36            beq 	.4C2
20485 5949           2C                     02  sub	al,*2
20486 594B         0F84         FB21            beq 	.4AD
20487 594F           2C                     0B  sub	al,*$B
20488 5951         0F84         FC8A            beq 	.4C9
20489 5955           2C                     01  sub	al,*1
20490 5957         0F84         FD01            beq 	.4D2
20491 595B           E9         FD2C            br 	.4D8
20492                       0000595E            .4A9:
20493                       FFFFFFF8            ..FFF2	=	-8
20494                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
20495 595E           8A46         FF            mov	al,-1[bp]
20496 5961           24                     7F  and	al,*$7F
20497                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
20498 5963           3C                     1D  cmp	al,*$1D
20499 5965           74           08            je  	.4FA
20500                       00005967            .4FB:
20501                                           ! 3647     mf2_state &= ~0x01;
20502                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
20503 5967           8A46         FB            mov	al,-5[bp]
20504 596A           24                     FE  and	al,#$FE
20505 596C           8846         FB            mov	-5[bp],al
20506                                           !BCC_EOS
20507                                           ! 3648   }
20508                                           ! 3649   mf2_state &= ~0x02;
20509                       0000596F            .4FA:
20510                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
20511 596F           8A46         FB            mov	al,-5[bp]
20512 5972           24                     FD  and	al,#$FD
20513 5974           8846         FB            mov	-5[bp],al
20514                                           !BCC_EOS
20515                                           ! 3650   *((Bit8u *)(0x96)) = (mf2_state);
20516                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
20517 5977           8A46         FB            mov	al,-5[bp]
20518 597A           A2         0096            mov	[$96],al
20519                                           !BCC_EOS
20520                                           ! 3651 }
20521 597D           89EC                       mov	sp,bp
20522 597F           5D                         pop	bp
20523 5980           C3                         ret
20524                                           ! 3652   unsigned int
20525                                           ! Register BX used in function int09_function
20526                                           ! 3653 enqueue_key(scan_code, ascii_code)
20527                                           ! 3654   Bit8u scan_code, ascii_code;
20528                                           export	_enqueue_key
20529                       00005981            _enqueue_key:
20530                                           !BCC_EOS
20531                                           ! 3655 {
20532                                           ! 3656   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail, old_ds;
20533                                           !BCC_EOS
20534                                           ! 3657   old_ds = set_DS(0x40);
20535 5981           55                         push	bp
20536 5982           89E5                       mov	bp,sp
20537 5984           83C4                   F4  add	sp,*-$C
20538                                           ! Debug: list int = const $40 (used reg = )
20539 5987           B8                   0040  mov	ax,*$40
20540 598A           50                         push	ax
20541                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20542 598B           E8         ACCF            call	_set_DS
20543 598E           44                         inc	sp
20544 598F           44                         inc	sp
20545                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$E-$E] (used reg = )
20546 5990           8946         F4            mov	-$C[bp],ax
20547                                           !BCC_EOS
20548                                           ! 3658   buffer_start = *((Bit16u *)(0x0080));
20549                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$E-4] (used reg = )
20550 5993           A1         0080            mov	ax,[$80]
20551 5996           8946         FE            mov	-2[bp],ax
20552                                           !BCC_EOS
20553                                           ! 3659  
20554                                           ! 3659  buffer_end = *((Bit16u *)(0x0082));
20555                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$E-6] (used reg = )
20556 5999           A1         0082            mov	ax,[$82]
20557 599C           8946         FC            mov	-4[bp],ax
20558                                           !BCC_EOS
20559                                           ! 3660   buffer_head = *((Bit16u *)(0x001A));
20560                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20561 599F           A1         001A            mov	ax,[$1A]
20562 59A2           8946         FA            mov	-6[bp],ax
20563                                           !BCC_EOS
20564                                           ! 3661   buffer_tail = *((Bit16u *)(0x001C));
20565                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20566 59A5           A1         001C            mov	ax,[$1C]
20567 59A8           8946         F8            mov	-8[bp],ax
20568                                           !BCC_EOS
20569                                           ! 3662   temp_tail = buffer_tail;
20570                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short temp_tail = [S+$E-$C] (used reg = )
20571 59AB           8B46         F8            mov	ax,-8[bp]
20572 59AE           8946         F6            mov	-$A[bp],ax
20573                                           !BCC_EOS
20574                                           ! 3663   buffer_tail += 2;
20575                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20576 59B1           8B46         F8            mov	ax,-8[bp]
20577 59B4           40                         inc	ax
20578 59B5           40                         inc	ax
20579 59B6           8946         F8            mov	-8[bp],ax
20580                                           !BCC_EOS
20581                                           ! 3664   if (buffer_tail >= buffer_end)
20582                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20583 59B9           8B46         F8            mov	ax,-8[bp]
20584 59BC           3B46         FC            cmp	ax,-4[bp]
20585 59BF           72           06            jb  	.4FC
20586                       000059C1            .4FD:
20587                                           ! 3665     buffer_tail = buffer_start;
20588                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20589 59C1           8B46         FE            mov	ax,-2[bp]
20590 59C4           8946         F8            mov	-8[bp],ax
20591                                           !BCC_EOS
20592                                           ! 3666   if (buffer_tail == buffer_head) {
20593                       000059C7            .4FC:
20594                                           ! Debug: logeq unsigned short buffer_head = [S+$E-8] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20595 59C7           8B46         F8            mov	ax,-8[bp]
20596 59CA           3B46         FA            cmp	ax,-6[bp]
20597 59CD           75           0E            jne 	.4FE
20598                       000059CF            .4FF:
20599                                           ! 3667     set_DS(old_ds);
20600                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20601 59CF           FF76         F4            push	-$C[bp]
20602                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20603 59D2           E8         AC88            call	_set_DS
20604 59D5           44                         inc	sp
20605 59D6           44                         inc	sp
20606                                           !BCC_EOS
20607                                           ! 3668     return(0);
20608 59D7           31C0                       xor	ax,ax
20609 59D9           89EC                       mov	sp,bp
20610 59DB           5D                         pop	bp
20611 59DC           C3                         ret
20612                                           !BCC_EOS
20613                                           ! 3669   }
20614                                           ! 3670   *((Bit8u *)(temp_tail)) = (ascii_code);
20615                       000059DD            .4FE:
20616 59DD           8B5E         F6            mov	bx,-$A[bp]
20617                                           ! Debug: eq unsigned char ascii_code = [S+$E+4] to unsigned char = [bx+0] (used reg = )
20618 59E0           8A46         06            mov	al,6[bp]
20619 59E3           8807                       mov	[bx],al
20620                                           !BCC_EOS
20621                                           ! 3671   *((Bit8u *)(temp_tail+1)) = (scan_code);
20622                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
20623 59E5           8B46         F6            mov	ax,-$A[bp]
20624                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
20625 59E8           89C3                       mov	bx,ax
20626                                           ! Debug: eq unsigned char scan_code = [S+$E+2] to unsigned char = [bx+1] (used reg = )
20627 59EA           8A46         04            mov	al,4[bp]
20628 59ED           8847         01            mov	1[bx],al
20629                                           !BCC_EOS
20630                                           ! 3672   *((Bit16u *)(0x001C)) = (buffer_tail);
20631                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short = [+$1C] (used reg = )
20632 59F0           8B46         F8            mov	ax,-8[bp]
20633 59F3           A3         001C            mov	[$1C],ax
20634                                           !BCC_EOS
20635                                           ! 3673   set_DS(old_ds);
20636                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20637 59F6           FF76         F4            push	-$C[bp]
20638                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20639 59F9           E8         AC61            call	_set_DS
20640 59FC           44                         inc	sp
20641 59FD           44                         inc	sp
20642                                           !BCC_EOS
20643                                           ! 3674   return(1);
20644 59FE           B8                   0001  mov	ax,*1
20645 5A01           89EC                       mov	sp,bp
20646 5A03           5D                         pop	bp
20647 5A04           C3                         ret
20648                                           !BCC_EOS
20649                                           ! 3675 }
20650                                           ! 3676   void
20651                                           ! Register BX used in function enqueue_key
20652                                           ! 3677 int74_function(make_farcall, Z, Y, X, status)
20653                                           ! 3678   Bit16u make_farcall, Z, Y, X, status;
20654                                           export	_int74_function
20655                       00005A05            _int74_function:
20656                                           !BCC_EOS
20657                                           ! 3679 {
20658                                           ! 3680   Bit8u in_byte, index, package_count;
20659                                           !BCC_EOS
20660                                           ! 3681   Bit8u mouse_flags_1, mouse_flags_2;
20661                                           !BCC_EOS
20662                                           ! 3682 ;
20663 5A05           55                         push	bp
20664 5A06           89E5                       mov	bp,sp
20665 5A08           83C4                   FA  add	sp,*-6
20666                                           !BCC_EOS
20667                                           ! 3683   make_farcall = 0;
20668                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+8+2] (used reg = )
20669 5A0B           31C0                       xor	ax,ax
20670 5A0D           8946         04            mov	4[bp],ax
20671                                           !BCC_EOS
20672                                           ! 3684   in_byte = inb(0x0064);
20673                                           ! Debug: list int = const $64 (used reg = )
20674 5A10           B8                   0064  mov	ax,*$64
20675 5A13           50                         push	ax
20676                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20677 5A14           E8         AB12            call	_inb
20678 5A17           44                         inc	sp
20679 5A18           44                         inc	sp
20680                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20681 5A19           8846         FF            mov	-1[bp],al
20682                                           !BCC_EOS
20683                                           ! 3685   if ((in_byte & 0x21) != 0x21) {
20684                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+8-3] (used reg = )
20685 5A1C           8A46         FF            mov	al,-1[bp]
20686 5A1F           24                     21  and	al,*$21
20687                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20688 5A21           3C                     21  cmp	al,*$21
20689 5A23           74           04            je  	.500
20690                       00005A25            .501:
20691                                           ! 3686     return;
20692 5A25           89EC                       mov	sp,bp
20693 5A27           5D                         pop	bp
20694 5A28           C3                         ret
20695                                           !BCC_EOS
20696                                           ! 3687   }
20697                                           ! 3688   in_byte = inb(0x0060);
20698                       00005A29            .500:
20699                                           ! Debug: list int = const $60 (used reg = )
20700 5A29           B8                   0060  mov	ax,*$60
20701 5A2C           50                         push	ax
20702                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20703 5A2D           E8         AAF9            call	_inb
20704 5A30           44                         inc	sp
20705 5A31           44                         inc	sp
20706                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20707 5A32           8846         FF            mov	-1[bp],al
20708                                           !BCC_EOS
20709                                           ! 3689 ;
20710                                           !BCC_EOS
20711                                           ! 3690   mouse_flags_1 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1));
20712                                           ! Debug: eq unsigned char = [+$26] to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20713 5A35           A0         0026            mov	al,[$26]
20714 5A38           8846         FC            mov	-4[bp],al
20715                                           !BCC_EOS
20716                                           ! 3691   mouse_flags_2 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag2));
20717                                           ! Debug: eq unsigned char = [+$27] to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20718 5A3B           A0         0027            mov	al,[$27]
20719 5A3E           8846         FB            mov	-5[bp],al
20720                                           !BCC_EOS
20721                                           ! 3692   if ((mouse_flags_2 & 0x80) != 0x80) {
20722                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20723 5A41           8A46         FB            mov	al,-5[bp]
20724 5A44           24                     80  and	al,#$80
20725                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
20726 5A46           3C                     80  cmp	al,#$80
20727 5A48           74           04            je  	.502
20728                       00005A4A            .503:
20729                                           ! 3693       return;
20730 5A4A           89EC                       mov	sp,bp
20731 5A4C           5D                         pop	bp
20732 5A4D           C3                         ret
20733                                           !BCC_EOS
20734                                           ! 3694   }
20735                                           ! 3695   package_count = mouse_flags_2 & 0x07;
20736                       00005A4E            .502:
20737                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20738 5A4E           8A46         FB            mov	al,-5[bp]
20739 5A51           24                     07  and	al,*7
20740                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+8-5] (used reg = )
20741 5A53           8846         FD            mov	-3[bp],al
20742                                           !BCC_EOS
20743                                           ! 3696   index = mouse_flags_1 & 0x07;
20744                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20745 5A56           8A46         FC            mov	al,-4[bp]
20746 5A59           24                     07  and	al,*7
20747                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+8-4] (used reg = )
20748 5A5B           8846         FE            mov	-2[bp],al
20749                                           !BCC_EOS
20750                                           ! 3697   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[index])) = (in_byte);
20751                                           ! Debug: ptradd unsigned char index = [S+8-4] to [8] unsigned char = const $28 (used reg = )
20752 5A5E           8A46         FE            mov	al,-2[bp]
20753 5A61           30E4                       xor	ah,ah
20754 5A63           89C3                       mov	bx,ax
20755                                           ! Debug: address unsigned char = [bx+$28] (used reg = )
20756                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$28 (used reg = )
20757                                           ! Debug: eq unsigned char in_byte = [S+8-3] to unsigned char = [bx+$28] (used reg = )
20758 5A65           8A46         FF            mov	al,-1[bp]
20759 5A68           8847         28            mov	$28[bx],al
20760                                           !BCC_EOS
20761                                           ! 3698   if (index >= package_count) {
20762                                           ! Debug: ge unsigned char package_count = [S+8-5] to unsigned char index = [S+8-4] (used reg = )
20763 5A6B           8A46         FE            mov	al,-2[bp]
20764 5A6E           3A46         FD            cmp	al,-3[bp]
20765 5A71         0F82         005A            blo 	.504
20766                       00005A75            .505:
20767                                           ! 3699 ;
20768                                           !BCC_EOS
20769                                           ! 3700     if (package_count == 3) {
20770                                           ! Debug: logeq int = const 3 to unsigned char package_count = [S+8-5] (used reg = )
20771 5A75           8A46         FD            mov	al,-3[bp]
20772 5A78           3C                     03  cmp	al,*3
20773 5A7A           75           20            jne 	.506
20774                       00005A7C            .507:
20775                                           ! 3701       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20776                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20777 5A7C           A0         0028            mov	al,[$28]
20778 5A7F           30E4                       xor	ah,ah
20779 5A81           8946         0C            mov	$C[bp],ax
20780                                           !BCC_EOS
20781                                           ! 3702       *(((Bit8u *)&status)+1) = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20782                                           ! Debug: eq unsigned char = [+$29] to unsigned char status = [S+8+$B] (used reg = )
20783 5A84           A0         0029            mov	al,[$29]
20784 5A87           8846         0D            mov	$D[bp],al
20785                                           !BCC_EOS
20786                                           ! 3703       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20787                                           ! Debug: eq unsigned char = [+$2A] to unsigned short X = [S+8+8] (used reg = )
20788 5A8A           A0         002A            mov	al,[$2A]
20789 5A8D           30E4                       xor	ah,ah
20790 5A8F           8946         0A            mov	$A[bp],ax
20791                                           !BCC_EOS
20792                                           ! 3704       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[3]));
20793                                           ! Debug: eq unsigned char = [+$2B] to unsigned short Y = [S+8+6] (used reg = )
20794 5A92           A0         002B            mov	al,[$2B]
20795 5A95           30E4                       xor	ah,ah
20796 5A97           8946         08            mov	8[bp],ax
20797                                           !BCC_EOS
20798                                           ! 3705     } else {
20799 5A9A           EB           18            jmp .508
20800                       00005A9C            .506:
20801                                           ! 3706       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20802                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20803 5A9C           A0         0028            mov	al,[$28]
20804 5A9F           30E4                       xor	ah,ah
20805 5AA1           8946         0C            mov	$C[bp],ax
20806                                           !BCC_EOS
20807                                           ! 3707       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20808                                           ! Debug: eq unsigned char = [+$29] to unsigned short X = [S+8+8] (used reg = )
20809 5AA4           A0         0029            mov	al,[$29]
20810 5AA7           30E4                       xor	ah,ah
20811 5AA9           8946         0A            mov	$A[bp],ax
20812                                           !BCC_EOS
20813                                           ! 3708       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20814                                           ! Debug: eq unsigned char = [+$2A] to unsigned short Y = [S+8+6] (used reg = )
20815 5AAC           A0         002A            mov	al,[$2A]
20816 5AAF           30E4                       xor	ah,ah
20817 5AB1           8946         08            mov	8[bp],ax
20818                                           !BCC_EOS
20819                                           ! 3709     }
20820                                           ! 3710     Z = 0;
20821                       00005AB4            .508:
20822                                           ! Debug: eq int = const 0 to unsigned short Z = [S+8+4] (used reg = )
20823 5AB4           31C0                       xor	ax,ax
20824 5AB6           8946         06            mov	6[bp],ax
20825                                           !BCC_EOS
20826                                           ! 3711     mouse_flags_1 = 0;
20827                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20828 5AB9           30C0                       xor	al,al
20829 5ABB           8846         FC            mov	-4[bp],al
20830                                           !BCC_EOS
20831                                           ! 3712     if (mouse_flags_2 & 0x80)
20832                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20833 5ABE           8A46         FB            mov	al,-5[bp]
20834 5AC1           24                     80  and	al,#$80
20835 5AC3           84C0                       test	al,al
20836 5AC5           74           06            je  	.509
20837                       00005AC7            .50A:
20838                                           ! 3713       make_farcall = 1;
20839                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+8+2] (used reg = )
20840 5AC7           B8                   0001  mov	ax,*1
20841 5ACA           8946         04            mov	4[bp],ax
20842                                           !BCC_EOS
20843                                           ! 3714   } else {
20844                       00005ACD            .509:
20845 5ACD           EB           07            jmp .50B
20846                       00005ACF            .504:
20847                                           ! 3715     mouse_flags_1++;
20848                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20849 5ACF           8A46         FC            mov	al,-4[bp]
20850 5AD2           40                         inc	ax
20851 5AD3           8846         FC            mov	-4[bp],al
20852                                           !BCC_EOS
20853                                           ! 3716   }
20854                                           ! 3717   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1)) = (mouse_flags_1);
20855                       00005AD6            .50B:
20856                                           ! Debug: eq unsigned char mouse_flags_1 = [S+8-6] to unsigned char = [+$26] (used reg = )
20857 5AD6           8A46         FC            mov	al,-4[bp]
20858 5AD9           A2         0026            mov	[$26],al
20859                                           !BCC_EOS
20860                                           ! 3718 }
20861 5ADC           89EC                       mov	sp,bp
20862 5ADE           5D                         pop	bp
20863 5ADF           C3                         ret
20864                                           ! 3719   int
20865                                           ! Register BX used in function int74_function
20866                                           ! 3720 int13_edd(DS, SI, device)
20867                                           ! 3721   Bit16u DS, SI;
20868                                           export	_int13_edd
20869                       00005AE0            _int13_edd:
20870                                           !BCC_EOS
20871                                           ! 3722   Bit8u device;
20872                                           !BCC_EOS
20873                                           ! 3723 {
20874                                           ! 3724   Bit32u lba_low, lba_high;
20875                                           !BCC_EOS
20876                                           ! 3725   Bit16u npc, nph, npspt, size, t13;
20877                                           !BCC_EOS
20878                                           ! 3726   Bit16u ebda_seg=get_ebda_seg();
20879 5AE0           55                         push	bp
20880 5AE1           89E5                       mov	bp,sp
20881 5AE3           83C4                   EC  add	sp,*-$14
20882                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
20883 5AE6           E8         AB7E            call	_get_ebda_seg
20884                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$16-$16] (used reg = )
20885 5AE9           8946         EC            mov	-$14[bp],ax
20886                                           !BCC_EOS
20887                                           ! 3727   Bit8u type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devi
20888 5AEC           4C                         dec	sp
20889                                           ! 3727 ces[device].type));
20890                                           ! Debug: ptradd unsigned char device = [S+$17+6] to [8] struct  = const $142 (used reg = )
20891 5AED           8A46         08            mov	al,8[bp]
20892 5AF0           30E4                       xor	ah,ah
20893 5AF2           B9                   001E  mov	cx,*$1E
20894 5AF5           F7E9                       imul	cx
20895 5AF7           89C3                       mov	bx,ax
20896                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
20897                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
20898                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$17-$17] (used reg = )
20899 5AF9           8A87       0142            mov	al,$142[bx]
20900 5AFD           8846         EB            mov	-$15[bp],al
20901                                           !BCC_EOS
20902                                           ! 3728   size=_read_word(SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20903 5B00           4C                         dec	sp
20904                                           ! Debug: list unsigned short DS = [S+$18+2] (used reg = )
20905 5B01           FF76         04            push	4[bp]
20906                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1A+4] (used reg = )
20907 5B04           8B46         06            mov	ax,6[bp]
20908                                           ! Debug: list unsigned int = ax+0 (used reg = )
20909 5B07           50                         push	ax
20910                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
20911 5B08           E8         AAE2            call	__read_word
20912 5B0B           83C4                   04  add	sp,*4
20913                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$18-$12] (used reg = )
20914 5B0E           8946         F0            mov	-$10[bp],ax
20915                                           !BCC_EOS
20916                                           ! 3729   t13 = size == 74;
20917                                           ! Debug: logeq int = const $4A to unsigned short size = [S+$18-$12] (used reg = )
20918 5B11           8B46         F0            mov	ax,-$10[bp]
20919 5B14           3D                   004A  cmp	ax,*$4A
20920 5B17           75           04            jne	.50C
20921 5B19           B0                     01  mov	al,*1
20922 5B1B           EB           02            jmp	.50D
20923                       00005B1D            .50C:
20924 5B1D           30C0                       xor	al,al
20925                       00005B1F            .50D:
20926                                           ! Debug: eq char = al+0 to unsigned short t13 = [S+$18-$14] (used reg = )
20927 5B1F           30E4                       xor	ah,ah
20928 5B21           8946         EE            mov	-$12[bp],ax
20929                                           !BCC_EOS
20930                                           ! 3730   if(size < 26)
20931                                           ! Debug: lt int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20932 5B24           8B46         F0            mov	ax,-$10[bp]
20933 5B27           3D                   001A  cmp	ax,*$1A
20934 5B2A           73           07            jae 	.50E
20935                       00005B2C            .50F:
20936                                           ! 3731     return 1;
20937 5B2C           B8                   0001  mov	ax,*1
20938 5B2F           89EC                       mov	sp,bp
20939 5B31           5D                         pop	bp
20940 5B32           C3                         ret
20941                                           !BCC_EOS
20942                                           ! 3732   if(size >= 26) {
20943                       00005B33            .50E:
20944                                           ! Debug: ge int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20945 5B33           8B46         F0            mov	ax,-$10[bp]
20946 5B36           3D                   001A  cmp	ax,*$1A
20947 5B39         0F82         01DB            blo 	.510
20948                       00005B3D            .511:
20949                                           ! 3733     Bit16u blksize, infos;
20950                                           !BCC_EOS
20951                                           ! 3734     _write_word(26, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20952 5B3D           83C4                   FC  add	sp,*-4
20953                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
20954 5B40           FF76         04            push	4[bp]
20955                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1E+4] (used reg = )
20956 5B43           8B46         06            mov	ax,6[bp]
20957                                           ! Debug: list unsigned int = ax+0 (used reg = )
20958 5B46           50                         push	ax
20959                                           ! Debug: list int = const $1A (used reg = )
20960 5B47           B8                   001A  mov	ax,*$1A
20961 5B4A           50                         push	ax
20962                                           ! Debug: func () void = _write_word+0 (used reg = )
20963 5B4B           E8         AAC0            call	__write_word
20964 5B4E           83C4                   06  add	sp,*6
20965                                           !BCC_EOS
20966                                           ! 3735     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
20967                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
20968 5B51           8A46         08            mov	al,8[bp]
20969 5B54           30E4                       xor	ah,ah
20970 5B56           B9                   001E  mov	cx,*$1E
20971 5B59           F7E9                       imul	cx
20972 5B5B           89C3                       mov	bx,ax
20973                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
20974                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
20975                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$1C-$1A] (used reg = )
20976 5B5D           8B9F       0148            mov	bx,$148[bx]
20977 5B61           895E         E8            mov	-$18[bp],bx
20978                                           !BCC_EOS
20979                                           ! 3736     if (type == 0x02)
20980                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1C-$17] (used reg = )
20981 5B64           8A46         EB            mov	al,-$15[bp]
20982 5B67           3C                     02  cmp	al,*2
20983 5B69         0F85         00DB            bne 	.512
20984                       00005B6D            .513:
20985                                           ! 3737     {
20986                                           ! 3738       npc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders));
20987                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
20988 5B6D           8A46         08            mov	al,8[bp]
20989 5B70           30E4                       xor	ah,ah
20990 5B72           B9                   001E  mov	cx,*$1E
20991 5B75           F7E9                       imul	cx
20992 5B77           89C3                       mov	bx,ax
20993                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
20994                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
20995                                           ! Debug: eq unsigned short = [bx+$154] to unsigned short npc = [S+$1C-$C] (used reg = )
20996 5B79           8B9F       0154            mov	bx,$154[bx]
20997 5B7D           895E         F6            mov	-$A[bp],bx
20998                                           !BCC_EOS
20999                                           ! 3739       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
21000                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21001 5B80           8A46         08            mov	al,8[bp]
21002 5B83           30E4                       xor	ah,ah
21003 5B85           B9                   001E  mov	cx,*$1E
21004 5B88           F7E9                       imul	cx
21005 5B8A           89C3                       mov	bx,ax
21006                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
21007                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
21008                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$1C-$E] (used reg = )
21009 5B8C           8B9F       0152            mov	bx,$152[bx]
21010 5B90           895E         F4            mov	-$C[bp],bx
21011                                           !BCC_EOS
21012                                           ! 3740       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
21013                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21014 5B93           8A46         08            mov	al,8[bp]
21015 5B96           30E4                       xor	ah,ah
21016 5B98           B9                   001E  mov	cx,*$1E
21017 5B9B           F7E9                       imul	cx
21018 5B9D           89C3                       mov	bx,ax
21019                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21020                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
21021                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$1C-$10] (used reg = )
21022 5B9F           8B9F       0156            mov	bx,$156[bx]
21023 5BA3           895E         F2            mov	-$E[bp],bx
21024                                           !BCC_EOS
21025                                           ! 3741       lba_low = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low));
21026                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21027 5BA6           8A46         08            mov	al,8[bp]
21028 5BA9           30E4                       xor	ah,ah
21029 5BAB           B9                   001E  mov	cx,*$1E
21030 5BAE           F7E9                       imul	cx
21031 5BB0           89C3                       mov	bx,ax
21032                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
21033                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
21034                                           ! Debug: eq unsigned long = [bx+$158] to unsigned long lba_low = [S+$1C-6] (used reg = )
21035 5BB2           8B87       0158            mov	ax,$158[bx]
21036 5BB6           8B9F       015A            mov	bx,$15A[bx]
21037 5BBA           8946         FC            mov	-4[bp],ax
21038 5BBD           895E         FE            mov	-2[bp],bx
21039                                           !BCC_EOS
21040                                           ! 3742       lba_high = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high));
21041                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21042 5BC0           8A46         08            mov	al,8[bp]
21043 5BC3           30E4                       xor	ah,ah
21044 5BC5           B9                   001E  mov	cx,*$1E
21045 5BC8           F7E9                       imul	cx
21046 5BCA           89C3                       mov	bx,ax
21047                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
21048                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
21049                                           ! Debug: eq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$1C-$A] (used reg = )
21050 5BCC           8B87       015C            mov	ax,$15C[bx]
21051 5BD0           8B9F       015E            mov	bx,$15E[bx]
21052 5BD4           8946         F8            mov	-8[bp],ax
21053 5BD7           895E         FA            mov	-6[bp],bx
21054                                           !BCC_EOS
21055                                           ! 3743       if (lba_high || (lba_low/npspt)/nph > 0x3fff)
21056 5BDA           8B46         F8            mov	ax,-8[bp]
21057 5BDD           8B5E         FA            mov	bx,-6[bp]
21058 5BE0           E8         A502            call	ltstl
21059 5BE3           75           50            jne 	.515
21060                       00005BE5            .516:
21061                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$1C-$E] (used reg = )
21062 5BE5           8B46         F4            mov	ax,-$C[bp]
21063 5BE8           31DB                       xor	bx,bx
21064 5BEA           53                         push	bx
21065 5BEB           50                         push	ax
21066                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21067 5BEC           8B46         F2            mov	ax,-$E[bp]
21068 5BEF           31DB                       xor	bx,bx
21069                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$20-6] (used reg = )
21070 5BF1           53                         push	bx
21071 5BF2           50                         push	ax
21072 5BF3           8B46         FC            mov	ax,-4[bp]
21073 5BF6           8B5E         FE            mov	bx,-2[bp]
21074 5BF9           8D7E         DE            lea	di,-$22[bp]
21075 5BFC           E8         A540            call	ldivul
21076 5BFF           83C4                   04  add	sp,*4
21077                                           ! Debug: div unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
21078 5C02           8D7E         E2            lea	di,-$1E[bp]
21079 5C05           E8         A537            call	ldivul
21080 5C08           83C4                   04  add	sp,*4
21081                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
21082 5C0B           53                         push	bx
21083 5C0C           50                         push	ax
21084 5C0D           B8                   3FFF  mov	ax,#$3FFF
21085 5C10           31DB                       xor	bx,bx
21086 5C12           53                         push	bx
21087 5C13           50                         push	ax
21088 5C14           8B46         E2            mov	ax,-$1E[bp]
21089 5C17           8B5E         E4            mov	bx,-$1C[bp]
21090 5C1A           8D7E         DE            lea	di,-$22[bp]
21091 5C1D           E8         A47C            call	lcmpul
21092 5C20           76           04            jbe	.517
21093 5C22           B0                     01  mov	al,*1
21094 5C24           EB           02            jmp	.518
21095                       00005C26            .517:
21096 5C26           30C0                       xor	al,al
21097                       00005C28            .518:
21098 5C28           83C4                   08  add	sp,*8
21099                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
21100 5C2B           30E4                       xor	ah,ah
21101 5C2D           99                         cwd
21102 5C2E           89D3                       mov	bx,dx
21103 5C30           E8         A4B2            call	ltstl
21104 5C33           74           0D            je  	.514
21105                       00005C35            .515:
21106                                           ! 3744       {
21107                                           ! 3745         infos = 0 << 1;
21108                                           ! Debug: eq int = const 0 to unsigned short infos = [S+$1C-$1C] (used reg = )
21109 5C35           31C0                       xor	ax,ax
21110 5C37           8946         E6            mov	-$1A[bp],ax
21111                                           !BCC_EOS
21112                                           ! 3746         npc = 0x3fff;
21113                                           ! Debug: eq int = const $3FFF to unsigned short npc = [S+$1C-$C] (used reg = )
21114 5C3A           B8                   3FFF  mov	ax,#$3FFF
21115 5C3D           8946         F6            mov	-$A[bp],ax
21116                                           !BCC_EOS
21117                                           ! 3747       }
21118                                           ! 3748       else
21119                                           ! 3749       {
21120 5C40           EB           06            jmp .51A
21121                       00005C42            .514:
21122                                           ! 3750         infos = 1 << 1;
21123                                           ! Debug: eq int = const 2 to unsigned short infos = [S+$1C-$1C] (used reg = )
21124 5C42           B8                   0002  mov	ax,*2
21125 5C45           8946         E6            mov	-$1A[bp],ax
21126                                           !BCC_EOS
21127                                           ! 3751       }
21128                                           ! 3752     }
21129                       00005C48            .51A:
21130                                           ! 3753     if (type == 0x03)
21131                       00005C48            .512:
21132                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1C-$17] (used reg = )
21133 5C48           8A46         EB            mov	al,-$15[bp]
21134 5C4B           3C                     03  cmp	al,*3
21135 5C4D           75           30            jne 	.51B
21136                       00005C4F            .51C:
21137                                           ! 3754     {
21138                                           ! 3755       npc = 0xffffffff;
21139                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npc = [S+$1C-$C] (used reg = )
21140 5C4F           B8                   FFFF  mov	ax,#$FFFF
21141 5C52           8946         F6            mov	-$A[bp],ax
21142                                           !BCC_EOS
21143                                           ! 3756       nph = 0xffffffff;
21144                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short nph = [S+$1C-$E] (used reg = )
21145 5C55           B8                   FFFF  mov	ax,#$FFFF
21146 5C58           8946         F4            mov	-$C[bp],ax
21147                                           !BCC_EOS
21148                                           ! 3757       npspt = 0xffffffff;
21149                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npspt = [S+$1C-$10] (used reg = )
21150 5C5B           B8                   FFFF  mov	ax,#$FFFF
21151 5C5E           8946         F2            mov	-$E[bp],ax
21152                                           !BCC_EOS
21153                                           ! 3758       lba_low = 0xffffffff;
21154                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_low = [S+$1C-6] (used reg = )
21155 5C61           B8                   FFFF  mov	ax,#$FFFF
21156 5C64           BB                   FFFF  mov	bx,#$FFFF
21157 5C67           8946         FC            mov	-4[bp],ax
21158 5C6A           895E         FE            mov	-2[bp],bx
21159                                           !BCC_EOS
21160                                           ! 3759       lba_high = 0xffffffff;
21161                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_high = [S+$1C-$A] (used reg = )
21162 5C6D           B8                   FFFF  mov	ax,#$FFFF
21163 5C70           BB                   FFFF  mov	bx,#$FFFF
21164 5C73           8946         F8            mov	-8[bp],ax
21165 5C76           895E         FA            mov	-6[bp],bx
21166                                           !BCC_EOS
21167                                           ! 3760       infos = 1 << 2 | 1 << 4 |
21168                                           ! 3761                1 << 5 | 1 << 6;
21169                                           ! Debug: eq int = const $74 to unsigned short infos = [S+$1C-$1C] (used reg = )
21170 5C79           B8                   0074  mov	ax,*$74
21171 5C7C           8946         E6            mov	-$1A[bp],ax
21172                                           !BCC_EOS
21173                                           ! 3762     }
21174                                           ! 3763     _write_word(infos, SI+(Bit16u)&((dpt_t *) 0)->infos, DS);
21175                       00005C7F            .51B:
21176                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21177 5C7F           FF76         04            push	4[bp]
21178                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$1E+4] (used reg = )
21179 5C82           8B46         06            mov	ax,6[bp]
21180                                           ! Debug: list unsigned int = ax+2 (used reg = )
21181 5C85           40                         inc	ax
21182 5C86           40                         inc	ax
21183 5C87           50                         push	ax
21184                                           ! Debug: list unsigned short infos = [S+$20-$1C] (used reg = )
21185 5C88           FF76         E6            push	-$1A[bp]
21186                                           ! Debug: func () void = _write_word+0 (used reg = )
21187 5C8B           E8         A980            call	__write_word
21188 5C8E           83C4                   06  add	sp,*6
21189                                           !BCC_EOS
21190                                           ! 3764     _write_dword((Bit32u)npc, SI+(Bit16u)&((dpt_t *) 0)->cylinders, DS);
21191                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21192 5C91           FF76         04            push	4[bp]
21193                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$1E+4] (used reg = )
21194 5C94           8B46         06            mov	ax,6[bp]
21195                                           ! Debug: list unsigned int = ax+4 (used reg = )
21196 5C97           05                   0004  add	ax,*4
21197 5C9A           50                         push	ax
21198                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$20-$C] (used reg = )
21199 5C9B           8B46         F6            mov	ax,-$A[bp]
21200 5C9E           31DB                       xor	bx,bx
21201                                           ! Debug: list unsigned long = bx+0 (used reg = )
21202 5CA0           53                         push	bx
21203 5CA1           50                         push	ax
21204                                           ! Debug: func () void = _write_dword+0 (used reg = )
21205 5CA2           E8         A3C2            call	__write_dword
21206 5CA5           83C4                   08  add	sp,*8
21207                                           !BCC_EOS
21208                                           ! 3765     _write_dword((Bit32u)nph, SI+(Bit16u)&((dpt_t *) 0)->heads, DS);
21209                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21210 5CA8           FF76         04            push	4[bp]
21211                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$1E+4] (used reg = )
21212 5CAB           8B46         06            mov	ax,6[bp]
21213                                           ! Debug: list unsigned int = ax+8 (used reg = )
21214 5CAE           05                   0008  add	ax,*8
21215 5CB1           50                         push	ax
21216                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$20-$E] (used reg = )
21217 5CB2           8B46         F4            mov	ax,-$C[bp]
21218 5CB5           31DB                       xor	bx,bx
21219                                           ! Debug: list unsigned long = bx+0 (used reg = )
21220 5CB7           53                         push	bx
21221 5CB8           50                         push	ax
21222                                           ! Debug: func () void = _write_dword+0 (used reg = )
21223 5CB9           E8         A3AB            call	__write_dword
21224 5CBC           83C4                   08  add	sp,*8
21225                                           !BCC_EOS
21226                                           ! 3766     _write_dword((Bit32u)npspt, SI+(Bit16u)&((dpt_t *) 0)->spt, DS);
21227                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21228 5CBF           FF76         04            push	4[bp]
21229                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$1E+4] (used reg = )
21230 5CC2           8B46         06            mov	ax,6[bp]
21231                                           ! Debug: list unsigned int = ax+$C (used reg = )
21232 5CC5           05                   000C  add	ax,*$C
21233 5CC8           50                         push	ax
21234                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21235 5CC9           8B46         F2            mov	ax,-$E[bp]
21236 5CCC           31DB                       xor	bx,bx
21237                                           ! Debug: list unsigned long = bx+0 (used reg = )
21238 5CCE           53                         push	bx
21239 5CCF           50                         push	ax
21240                                           ! Debug: func () void = _write_dword+0 (used reg = )
21241 5CD0           E8         A394            call	__write_dword
21242 5CD3           83C4                   08  add	sp,*8
21243                                           !BCC_EOS
21244                                           ! 3767     _write_dword(lba_low, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, DS);
21245                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21246 5CD6           FF76         04            push	4[bp]
21247                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$1E+4] (used reg = )
21248 5CD9           8B46         06            mov	ax,6[bp]
21249                                           ! Debug: list unsigned int = ax+$10 (used reg = )
21250 5CDC           05                   0010  add	ax,*$10
21251 5CDF           50                         push	ax
21252                                           ! Debug: list unsigned long lba_low = [S+$20-6] (used reg = )
21253 5CE0           FF76         FE            push	-2[bp]
21254 5CE3           FF76         FC            push	-4[bp]
21255                                           ! Debug: func () void = _write_dword+0 (used reg = )
21256 5CE6           E8         A37E            call	__write_dword
21257 5CE9           83C4                   08  add	sp,*8
21258                                           !BCC_EOS
21259                                           ! 3768     _write_dword(lba_high, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, DS);
21260                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21261 5CEC           FF76         04            push	4[bp]
21262                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$1E+4] (used reg = )
21263 5CEF           8B46         06            mov	ax,6[bp]
21264                                           ! Debug: list unsigned int = ax+$14 (used reg = )
21265 5CF2           05                   0014  add	ax,*$14
21266 5CF5           50                         push	ax
21267                                           ! Debug: list unsigned long lba_high = [S+$20-$A] (used reg = )
21268 5CF6           FF76         FA            push	-6[bp]
21269 5CF9           FF76         F8            push	-8[bp]
21270                                           ! Debug: func () void = _write_dword+0 (used reg = )
21271 5CFC           E8         A368            call	__write_dword
21272 5CFF           83C4                   08  add	sp,*8
21273                                           !BCC_EOS
21274                                           ! 3769     _write_word(blksize, SI+(Bit16u)&((dpt_t *) 0)->blksize, DS);
21275                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21276 5D02           FF76         04            push	4[bp]
21277                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$1E+4] (used reg = )
21278 5D05           8B46         06            mov	ax,6[bp]
21279                                           ! Debug: list unsigned int = ax+$18 (used reg = )
21280 5D08           05                   0018  add	ax,*$18
21281 5D0B           50                         push	ax
21282                                           ! Debug: list unsigned short blksize = [S+$20-$1A] (used reg = )
21283 5D0C           FF76         E8            push	-$18[bp]
21284                                           ! Debug: func () void = _write_word+0 (used reg = )
21285 5D0F           E8         A8FC            call	__write_word
21286 5D12           83C4                   06  add	sp,*6
21287                                           !BCC_EOS
21288                                           ! 3770   }
21289 5D15           83C4                   04  add	sp,*4
21290                                           ! 3771   if(size >= 30) {
21291                       00005D18            .510:
21292                                           ! Debug: ge int = const $1E to unsigned short size = [S+$18-$12] (used reg = )
21293 5D18           8B46         F0            mov	ax,-$10[bp]
21294 5D1B           3D                   001E  cmp	ax,*$1E
21295 5D1E         0F82         01BC            blo 	.51D
21296                       00005D22            .51E:
21297                                           ! 3772     Bit8u channel, dev, irq, mode, checksum, i, translation;
21298                                           !BCC_EOS
21299                                           ! 3773     Bit16u iobase1, iobase2, options;
21300                                           !BCC_EOS
21301                                           ! 3774     _write_word(30, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21302 5D22           83C4                   F2  add	sp,*-$E
21303                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21304 5D25           FF76         04            push	4[bp]
21305                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+4] (used reg = )
21306 5D28           8B46         06            mov	ax,6[bp]
21307                                           ! Debug: list unsigned int = ax+0 (used reg = )
21308 5D2B           50                         push	ax
21309                                           ! Debug: list int = const $1E (used reg = )
21310 5D2C           B8                   001E  mov	ax,*$1E
21311 5D2F           50                         push	ax
21312                                           ! Debug: func () void = _write_word+0 (used reg = )
21313 5D30           E8         A8DB            call	__write_word
21314 5D33           83C4                   06  add	sp,*6
21315                                           !BCC_EOS
21316                                           ! 3775     _write_word(ebda_seg, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, DS);
21317                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21318 5D36           FF76         04            push	4[bp]
21319                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$28+4] (used reg = )
21320 5D39           8B46         06            mov	ax,6[bp]
21321                                           ! Debug: list unsigned int = ax+$1C (used reg = )
21322 5D3C           05                   001C  add	ax,*$1C
21323 5D3F           50                         push	ax
21324                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$16] (used reg = )
21325 5D40           FF76         EC            push	-$14[bp]
21326                                           ! Debug: func () void = _write_word+0 (used reg = )
21327 5D43           E8         A8C8            call	__write_word
21328 5D46           83C4                   06  add	sp,*6
21329                                           !BCC_EOS
21330                                           ! 3776     _write_word(&((ebda_data_t *) 0)->ata.dpte, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, DS);
21331                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21332 5D49           FF76         04            push	4[bp]
21333                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$28+4] (used reg = )
21334 5D4C           8B46         06            mov	ax,6[bp]
21335                                           ! Debug: list unsigned int = ax+$1A (used reg = )
21336 5D4F           05                   001A  add	ax,*$1A
21337 5D52           50                         push	ax
21338                                           ! Debug: list * struct  = const $244 (used reg = )
21339 5D53           B8                   0244  mov	ax,#$244
21340 5D56           50                         push	ax
21341                                           ! Debug: func () void = _write_word+0 (used reg = )
21342 5D57           E8         A8B4            call	__write_word
21343 5D5A           83C4                   06  add	sp,*6
21344                                           !BCC_EOS
21345                                           ! 3777     channel = device / 2;
21346                                           ! Debug: div int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21347 5D5D           8A46         08            mov	al,8[bp]
21348 5D60           30E4                       xor	ah,ah
21349 5D62           D1E8                       shr	ax,*1
21350                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$26-$19] (used reg = )
21351 5D64           8846         E9            mov	-$17[bp],al
21352                                           !BCC_EOS
21353                                           ! 3778     iobase1 = *((Bit16u *)(&((eb
21354                                           ! 3778 da_data_t *) 0)->ata.channels[channel].iobase1));
21355                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21356 5D67           8A46         E9            mov	al,-$17[bp]
21357 5D6A           30E4                       xor	ah,ah
21358 5D6C           B1                     03  mov	cl,*3
21359 5D6E           D3E0                       shl	ax,cl
21360 5D70           89C3                       mov	bx,ax
21361                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21362                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21363                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$26-$22] (used reg = )
21364 5D72           8B9F       0124            mov	bx,$124[bx]
21365 5D76           895E         E0            mov	-$20[bp],bx
21366                                           !BCC_EOS
21367                                           ! 3779     iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
21368                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21369 5D79           8A46         E9            mov	al,-$17[bp]
21370 5D7C           30E4                       xor	ah,ah
21371 5D7E           B1                     03  mov	cl,*3
21372 5D80           D3E0                       shl	ax,cl
21373 5D82           89C3                       mov	bx,ax
21374                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
21375                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
21376                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$26-$24] (used reg = )
21377 5D84           8B9F       0126            mov	bx,$126[bx]
21378 5D88           895E         DE            mov	-$22[bp],bx
21379                                           !BCC_EOS
21380                                           ! 3780     irq = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq));
21381                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21382 5D8B           8A46         E9            mov	al,-$17[bp]
21383 5D8E           30E4                       xor	ah,ah
21384 5D90           B1                     03  mov	cl,*3
21385 5D92           D3E0                       shl	ax,cl
21386 5D94           89C3                       mov	bx,ax
21387                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
21388                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
21389                                           ! Debug: eq unsigned char = [bx+$128] to unsigned char irq = [S+$26-$1B] (used reg = )
21390 5D96           8A87       0128            mov	al,$128[bx]
21391 5D9A           8846         E7            mov	-$19[bp],al
21392                                           !BCC_EOS
21393                                           ! 3781     mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
21394                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21395 5D9D           8A46         08            mov	al,8[bp]
21396 5DA0           30E4                       xor	ah,ah
21397 5DA2           B9                   001E  mov	cx,*$1E
21398 5DA5           F7E9                       imul	cx
21399 5DA7           89C3                       mov	bx,ax
21400                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
21401                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
21402                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$26-$1C] (used reg = )
21403 5DA9           8A87       0146            mov	al,$146[bx]
21404 5DAD           8846         E6            mov	-$1A[bp],al
21405                                           !BCC_EOS
21406                                           ! 3782     translation = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation));
21407                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21408 5DB0           8A46         08            mov	al,8[bp]
21409 5DB3           30E4                       xor	ah,ah
21410 5DB5           B9                   001E  mov	cx,*$1E
21411 5DB8           F7E9                       imul	cx
21412 5DBA           89C3                       mov	bx,ax
21413                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
21414                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
21415                                           ! Debug: eq unsigned char = [bx+$14A] to unsigned char translation = [S+$26-$1F] (used reg = )
21416 5DBC           8A87       014A            mov	al,$14A[bx]
21417 5DC0           8846         E3            mov	-$1D[bp],al
21418                                           !BCC_EOS
21419                                           ! 3783     options = (1<<4);
21420                                           ! Debug: eq int = const $10 to unsigned short options = [S+$26-$26] (used reg = )
21421 5DC3           B8                   0010  mov	ax,*$10
21422 5DC6           8946         DC            mov	-$24[bp],ax
21423                                           !BCC_EOS
21424                                           ! 3784     options |= (mode==0x01?1:0)<<7;
21425                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$26-$1C] (used reg = )
21426 5DC9           8A46         E6            mov	al,-$1A[bp]
21427 5DCC           3C                     01  cmp	al,*1
21428 5DCE           75           04            jne 	.51F
21429                       00005DD0            .520:
21430 5DD0           B0                     01  mov	al,*1
21431 5DD2           EB           02            jmp .521
21432                       00005DD4            .51F:
21433 5DD4           30C0                       xor	al,al
21434                       00005DD6            .521:
21435                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
21436 5DD6           30E4                       xor	ah,ah
21437 5DD8           B1                     07  mov	cl,*7
21438 5DDA           D3E0                       shl	ax,cl
21439                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21440 5DDC           0B46         DC            or	ax,-$24[bp]
21441 5DDF           8946         DC            mov	-$24[bp],ax
21442                                           !BCC_EOS
21443                                           ! 3785     if (type == 0x02)
21444                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$26-$17] (used reg = )
21445 5DE2           8A46         EB            mov	al,-$15[bp]
21446 5DE5           3C                     02  cmp	al,*2
21447 5DE7           75           4F            jne 	.522
21448                       00005DE9            .523:
21449                                           ! 3786     {
21450                                           ! 3787       options |= (translation==0?0:1)<<3;
21451                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$26-$1F] (used reg = )
21452 5DE9           8A46         E3            mov	al,-$1D[bp]
21453 5DEC           84C0                       test	al,al
21454 5DEE           75           04            jne 	.524
21455                       00005DF0            .525:
21456 5DF0           30C0                       xor	al,al
21457 5DF2           EB           02            jmp .526
21458                       00005DF4            .524:
21459 5DF4           B0                     01  mov	al,*1
21460                       00005DF6            .526:
21461                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
21462 5DF6           30E4                       xor	ah,ah
21463 5DF8           B1                     03  mov	cl,*3
21464 5DFA           D3E0                       shl	ax,cl
21465                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21466 5DFC           0B46         DC            or	ax,-$24[bp]
21467 5DFF           8946         DC            mov	-$24[bp],ax
21468                                           !BCC_EOS
21469                                           ! 3788       options |= (translation==1?1:0)<<9;
21470                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$26-$1F] (used reg = )
21471 5E02           8A46         E3            mov	al,-$1D[bp]
21472 5E05           3C                     01  cmp	al,*1
21473 5E07           75           04            jne 	.527
21474                       00005E09            .528:
21475 5E09           B0                     01  mov	al,*1
21476 5E0B           EB           02            jmp .529
21477                       00005E0D            .527:
21478 5E0D           30C0                       xor	al,al
21479                       00005E0F            .529:
21480                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21481 5E0F           30E4                       xor	ah,ah
21482 5E11           88C4                       mov	ah,al
21483 5E13           30C0                       xor	al,al
21484 5E15           D1E0                       shl	ax,*1
21485                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21486 5E17           0B46         DC            or	ax,-$24[bp]
21487 5E1A           8946         DC            mov	-$24[bp],ax
21488                                           !BCC_EOS
21489                                           ! 3789       options |= (translation==3?3:0)<<9;
21490                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$26-$1F] (used reg = )
21491 5E1D           8A46         E3            mov	al,-$1D[bp]
21492 5E20           3C                     03  cmp	al,*3
21493 5E22           75           04            jne 	.52A
21494                       00005E24            .52B:
21495 5E24           B0                     03  mov	al,*3
21496 5E26           EB           02            jmp .52C
21497                       00005E28            .52A:
21498 5E28           30C0                       xor	al,al
21499                       00005E2A            .52C:
21500                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21501 5E2A           30E4                       xor	ah,ah
21502 5E2C           88C4                       mov	ah,al
21503 5E2E           30C0                       xor	al,al
21504 5E30           D1E0                       shl	ax,*1
21505                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21506 5E32           0B46         DC            or	ax,-$24[bp]
21507 5E35           8946         DC            mov	-$24[bp],ax
21508                                           !BCC_EOS
21509                                           ! 3790     }
21510                                           ! 3791     if (type == 0x03)
21511                       00005E38            .522:
21512                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$26-$17] (used reg = )
21513 5E38           8A46         EB            mov	al,-$15[bp]
21514 5E3B           3C                     03  cmp	al,*3
21515 5E3D           75           10            jne 	.52D
21516                       00005E3F            .52E:
21517                                           ! 3792     {
21518                                           ! 3793       options |= (1<<5);
21519                                           ! Debug: orab int = const $20 to unsigned short options = [S+$26-$26] (used reg = )
21520 5E3F           8B46         DC            mov	ax,-$24[bp]
21521 5E42           0C                     20  or	al,*$20
21522 5E44           8946         DC            mov	-$24[bp],ax
21523                                           !BCC_EOS
21524                                           ! 3794       options |= (1<<6);
21525                                           ! Debug: orab int = const $40 to unsigned short options = [S+$26-$26] (used reg = )
21526 5E47           8B46         DC            mov	ax,-$24[bp]
21527 5E4A           0C                     40  or	al,*$40
21528 5E4C           8946         DC            mov	-$24[bp],ax
21529                                           !BCC_EOS
21530                                           ! 3795     }
21531                                           ! 3796     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase1)) = (iobase1);
21532                       00005E4F            .52D:
21533                                           ! Debug: eq unsigned short iobase1 = [S+$26-$22] to unsigned short = [+$244] (used reg = )
21534 5E4F           8B46         E0            mov	ax,-$20[bp]
21535 5E52           A3         0244            mov	[$244],ax
21536                                           !BCC_EOS
21537                                           ! 3797     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase2)) = (iobase2 + 6);
21538                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$26-$24] (used reg = )
21539 5E55           8B46         DE            mov	ax,-$22[bp]
21540                                           ! Debug: eq unsigned int = ax+6 to unsigned short = [+$246] (used reg = )
21541 5E58           05                   0006  add	ax,*6
21542 5E5B           A3         0246            mov	[$246],ax
21543                                           !BCC_EOS
21544                                           ! 3798     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.prefix)) = ((0xe | (device % 2))<<4);
21545                                           ! Debug: mod int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21546 5E5E           8A46         08            mov	al,8[bp]
21547 5E61           30E4                       xor	ah,ah
21548 5E63           24                     01  and	al,*1
21549                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
21550                                           ! Debug: expression subtree swapping
21551 5E65           0C                     0E  or	al,*$E
21552                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
21553 5E67           30E4                       xor	ah,ah
21554 5E69           B1                     04  mov	cl,*4
21555 5E6B           D3E0                       shl	ax,cl
21556                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$248] (used reg = )
21557 5E6D           A2         0248            mov	[$248],al
21558                                           !BCC_EOS
21559                                           ! 3799     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.unused)) = (0xcb);
21560                                           ! Debug: eq int = const $CB to unsigned char = [+$249] (used reg = )
21561 5E70           B0                     CB  mov	al,#$CB
21562 5E72           A2         0249            mov	[$249],al
21563                                           !BCC_EOS
21564                                           ! 3800     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.irq)) = (irq);
21565                                           ! Debug: eq unsigned char irq = [S+$26-$1B] to unsigned char = [+$24A] (used reg = )
21566 5E75           8A46         E7            mov	al,-$19[bp]
21567 5E78           A2         024A            mov	[$24A],al
21568                                           !BCC_EOS
21569                                           ! 3801     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.blkcount)) = (1);
21570                                           ! Debug: eq int = const 1 to unsigned char = [+$24B] (used reg = )
21571 5E7B           B0                     01  mov	al,*1
21572 5E7D           A2         024B            mov	[$24B],al
21573                                           !BCC_EOS
21574                                           ! 3802     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.dma)) = (0);
21575                                           ! Debug: eq int = const 0 to unsigned char = [+$24C] (used reg = )
21576 5E80           30C0                       xor	al,al
21577 5E82           A2         024C            mov	[$24C],al
21578                                           !BCC_EOS
21579                                           ! 3803     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.pio)) = (0);
21580                                           ! Debug: eq int = const 0 to unsigned char = [+$24D] (used reg = )
21581 5E85           30C0                       xor	al,al
21582 5E87           A2         024D            mov	[$24D],al
21583                                           !BCC_EOS
21584                                           ! 3804     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.options)) = (options);
21585                                           ! Debug: eq unsigned short options = [S+$26-$26] to unsigned short = [+$24E] (used reg = )
21586 5E8A           8B46         DC            mov	ax,-$24[bp]
21587 5E8D           A3         024E            mov	[$24E],ax
21588                                           !BCC_EOS
21589                                           ! 3805     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.reserved)) = (0);
21590                                           ! Debug: eq int = const 0 to unsigned short = [+$250] (used reg = )
21591 5E90           31C0                       xor	ax,ax
21592 5E92           A3         0250            mov	[$250],ax
21593                                           !BCC_EOS
21594                                           ! 3806     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.revision)) = (0x11);
21595                                           ! Debug: eq int = const $11 to unsigned char = [+$252] (used reg = )
21596 5E95           B0                     11  mov	al,*$11
21597 5E97           A2         0252            mov	[$252],al
21598                                           !BCC_EOS
21599                                           ! 3807     checksum=0;
21600                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21601 5E9A           30C0                       xor	al,al
21602 5E9C           8846         E5            mov	-$1B[bp],al
21603                                           !BCC_EOS
21604                                           ! 3808     for (i=0; i<15; i++) checksum+=*((Bit8u *)(((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i));
21605                                           ! Debug: eq int = const 0 to unsigned char i = [S+$26-$1E] (used reg = )
21606 5E9F           30C0                       xor	al,al
21607 5EA1           8846         E4            mov	-$1C[bp],al
21608                                           !BCC_EOS
21609                                           !BCC_EOS
21610 5EA4           EB           1D            jmp .531
21611                       00005EA6            .532:
21612                                           ! Debug: ptradd unsigned char i = [S+$26-$1E] to * unsigned char = const $244 (used reg = )
21613 5EA6           8A46         E4            mov	al,-$1C[bp]
21614 5EA9           30E4                       xor	ah,ah
21615                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = ax+$244 (used reg = )
21616 5EAB           89C3                       mov	bx,ax
21617                                           ! Debug: addab unsigned char = [bx+$244] to unsigned char checksum = [S+$26-$1D] (used reg = )
21618 5EAD           8A46         E5            mov	al,-$1B[bp]
21619 5EB0           30E4                       xor	ah,ah
21620 5EB2           0287       0244            add	al,$244[bx]
21621 5EB6           80D4                   00  adc	ah,*0
21622 5EB9           8846         E5            mov	-$1B[bp],al
21623                                           !BCC_EOS
21624                                           ! 3809     checksum = -checksum;
21625                       00005EBC            .530:
21626                                           ! Debug: postinc unsigned char i = [S+$26-$1E] (used reg = )
21627 5EBC           8A46         E4            mov	al,-$1C[bp]
21628 5EBF           40                         inc	ax
21629 5EC0           8846         E4            mov	-$1C[bp],al
21630                       00005EC3            .531:
21631                                           ! Debug: lt int = const $F to unsigned char i = [S+$26-$1E] (used reg = )
21632 5EC3           8A46         E4            mov	al,-$1C[bp]
21633 5EC6           3C                     0F  cmp	al,*$F
21634 5EC8           72           DC            jb 	.532
21635                       00005ECA            .533:
21636                       00005ECA            .52F:
21637                                           ! Debug: neg unsigned char checksum = [S+$26-$1D] (used reg = )
21638 5ECA           31C0                       xor	ax,ax
21639 5ECC           2A46         E5            sub	al,-$1B[bp]
21640 5ECF           80DC                   00  sbb	ah,*0
21641                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21642 5ED2           8846         E5            mov	-$1B[bp],al
21643                                           !BCC_EOS
21644                                           ! 3810     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.checksum)) = (checksum);
21645                                           ! Debug: eq unsigned char checksum = [S+$26-$1D] to unsigned char = [+$253] (used reg = )
21646 5ED5           8A46         E5            mov	al,-$1B[bp]
21647 5ED8           A2         0253            mov	[$253],al
21648                                           !BCC_EOS
21649                                           ! 3811   }
21650 5EDB           83C4                   0E  add	sp,*$E
21651                                           ! 3812   if(size >= 66) {
21652                       00005EDE            .51D:
21653                                           ! Debug: ge int = const $42 to unsigned short size = [S+$18-$12] (used reg = )
21654 5EDE           8B46         F0            mov	ax,-$10[bp]
21655 5EE1           3D                   0042  cmp	ax,*$42
21656 5EE4         0F82         0268            blo 	.534
21657                       00005EE8            .535:
21658                                           ! 3813     Bit8u channel, iface, checksum, i;
21659                                           !BCC_EOS
21660                                           ! 3814     Bit16u iobase1;
21661                                           !BCC_EOS
21662                                           ! 3815     channel = device / 2;
21663 5EE8           83C4                   FA  add	sp,*-6
21664                                           ! Debug: div int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
21665 5EEB           8A46         08            mov	al,8[bp]
21666 5EEE           30E4                       xor	ah,ah
21667 5EF0           D1E8                       shr	ax,*1
21668                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$19] (used reg = )
21669 5EF2           8846         E9            mov	-$17[bp],al
21670                                           !BCC_EOS
21671                                           ! 3816     iface = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface));
21672                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21673 5EF5           8A46         E9            mov	al,-$17[bp]
21674 5EF8           30E4                       xor	ah,ah
21675 5EFA           B1                     03  mov	cl,*3
21676 5EFC           D3E0                       shl	ax,cl
21677 5EFE           89C3                       mov	bx,ax
21678                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
21679                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
21680                                           ! Debug: eq unsigned char = [bx+$122] to unsigned char iface = [S+$1E-$1A] (used reg = )
21681 5F00           8A87       0122            mov	al,$122[bx]
21682 5F04           8846         E8            mov	-$18[bp],al
21683                                           !BCC_EOS
21684                                           ! 3817     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21685                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21686 5F07           8A46         E9            mov	al,-$17[bp]
21687 5F0A           30E4                       xor	ah,ah
21688 5F0C           B1                     03  mov	cl,*3
21689 5F0E           D3E0                       shl	ax,cl
21690 5F10           89C3                       mov	bx,ax
21691                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21692                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21693                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$1E-$1E] (used reg = )
21694 5F12           8B9F       0124            mov	bx,$124[bx]
21695 5F16           895E         E4            mov	-$1C[bp],bx
21696                                           !BCC_EOS
21697                                           ! 3818     set_DS(DS);
21698                                           ! Debug: list unsigned short DS = [S+$1E+2] (used reg = )
21699 5F19           FF76         04            push	4[bp]
21700                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
21701 5F1C           E8         A73E            call	_set_DS
21702 5F1F           44                         inc	sp
21703 5F20           44                         inc	sp
21704                                           !BCC_EOS
21705                                           ! 3819     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.key)) = (0xbedd);
21706                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$1E+4] (used reg = )
21707 5F21           8B46         06            mov	ax,6[bp]
21708                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$1E (used reg = )
21709 5F24           89C3                       mov	bx,ax
21710                                           ! Debug: eq unsigned int = const $BEDD to unsigned short = [bx+$1E] (used reg = )
21711 5F26           B8                   BEDD  mov	ax,#$BEDD
21712 5F29           8947         1E            mov	$1E[bx],ax
21713                                           !BCC_EOS
21714                                           ! 3820     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.dpi_length)) = (t
21715                                           ! 3820 13 ? 44 : 36);
21716 5F2C           8B46         EE            mov	ax,-$12[bp]
21717 5F2F           85C0                       test	ax,ax
21718 5F31           74           04            je  	.536
21719                       00005F33            .537:
21720 5F33           B0                     2C  mov	al,*$2C
21721 5F35           EB           02            jmp .538
21722                       00005F37            .536:
21723 5F37           B0                     24  mov	al,*$24
21724                       00005F39            .538:
21725 5F39           50                         push	ax
21726                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$20+4] (used reg = )
21727 5F3A           8B46         06            mov	ax,6[bp]
21728                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$20 (used reg = )
21729 5F3D           89C3                       mov	bx,ax
21730                                           ! Debug: eq char (temp) = [S+$20-$20] to unsigned char = [bx+$20] (used reg = )
21731 5F3F           8A46         E2            mov	al,-$1E[bp]
21732 5F42           8847         20            mov	$20[bx],al
21733 5F45           44                         inc	sp
21734 5F46           44                         inc	sp
21735                                           !BCC_EOS
21736                                           ! 3821     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved1)) = (0);
21737                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$1E+4] (used reg = )
21738 5F47           8B46         06            mov	ax,6[bp]
21739                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$21 (used reg = )
21740 5F4A           89C3                       mov	bx,ax
21741                                           ! Debug: eq int = const 0 to unsigned char = [bx+$21] (used reg = )
21742 5F4C           30C0                       xor	al,al
21743 5F4E           8847         21            mov	$21[bx],al
21744                                           !BCC_EOS
21745                                           ! 3822     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved2)) = (0);
21746                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$1E+4] (used reg = )
21747 5F51           8B46         06            mov	ax,6[bp]
21748                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
21749 5F54           89C3                       mov	bx,ax
21750                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
21751 5F56           31C0                       xor	ax,ax
21752 5F58           8947         22            mov	$22[bx],ax
21753                                           !BCC_EOS
21754                                           ! 3823     if (iface==0x00) {
21755                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21756 5F5B           8A46         E8            mov	al,-$18[bp]
21757 5F5E           84C0                       test	al,al
21758 5F60           75           2A            jne 	.539
21759                       00005F62            .53A:
21760                                           ! 3824       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[0])) = ('I');
21761                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$1E+4] (used reg = )
21762 5F62           8B46         06            mov	ax,6[bp]
21763                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
21764 5F65           89C3                       mov	bx,ax
21765                                           ! Debug: eq int = const $49 to unsigned char = [bx+$24] (used reg = )
21766 5F67           B0                     49  mov	al,*$49
21767 5F69           8847         24            mov	$24[bx],al
21768                                           !BCC_EOS
21769                                           ! 3825       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[1])) = ('S');
21770                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$1E+4] (used reg = )
21771 5F6C           8B46         06            mov	ax,6[bp]
21772                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
21773 5F6F           89C3                       mov	bx,ax
21774                                           ! Debug: eq int = const $53 to unsigned char = [bx+$25] (used reg = )
21775 5F71           B0                     53  mov	al,*$53
21776 5F73           8847         25            mov	$25[bx],al
21777                                           !BCC_EOS
21778                                           ! 3826       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[2])) = ('A');
21779                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$1E+4] (used reg = )
21780 5F76           8B46         06            mov	ax,6[bp]
21781                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$26 (used reg = )
21782 5F79           89C3                       mov	bx,ax
21783                                           ! Debug: eq int = const $41 to unsigned char = [bx+$26] (used reg = )
21784 5F7B           B0                     41  mov	al,*$41
21785 5F7D           8847         26            mov	$26[bx],al
21786                                           !BCC_EOS
21787                                           ! 3827       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[3])) = (' ');
21788                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$1E+4] (used reg = )
21789 5F80           8B46         06            mov	ax,6[bp]
21790                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$27 (used reg = )
21791 5F83           89C3                       mov	bx,ax
21792                                           ! Debug: eq int = const $20 to unsigned char = [bx+$27] (used reg = )
21793 5F85           B0                     20  mov	al,*$20
21794 5F87           8847         27            mov	$27[bx],al
21795                                           !BCC_EOS
21796                                           ! 3828     }
21797                                           ! 3829     else {
21798 5F8A           EB           00            jmp .53B
21799                       00005F8C            .539:
21800                                           ! 3830     }
21801                                           ! 3831     if (type == 0x02) {
21802                       00005F8C            .53B:
21803                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1E-$17] (used reg = )
21804 5F8C           8A46         EB            mov	al,-$15[bp]
21805 5F8F           3C                     02  cmp	al,*2
21806 5F91           75           53            jne 	.53C
21807                       00005F93            .53D:
21808                                           ! 3832         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21809                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21810 5F93           8B46         06            mov	ax,6[bp]
21811                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21812 5F96           89C3                       mov	bx,ax
21813                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21814 5F98           B0                     41  mov	al,*$41
21815 5F9A           8847         28            mov	$28[bx],al
21816                                           !BCC_EOS
21817                                           ! 3833         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21818                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21819 5F9D           8B46         06            mov	ax,6[bp]
21820                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21821 5FA0           89C3                       mov	bx,ax
21822                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21823 5FA2           B0                     54  mov	al,*$54
21824 5FA4           8847         29            mov	$29[bx],al
21825                                           !BCC_EOS
21826                                           ! 3834         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21827                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21828 5FA7           8B46         06            mov	ax,6[bp]
21829                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21830 5FAA           89C3                       mov	bx,ax
21831                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21832 5FAC           B0                     41  mov	al,*$41
21833 5FAE           8847         2A            mov	$2A[bx],al
21834                                           !BCC_EOS
21835                                           ! 3835         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = (' ');
21836                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21837 5FB1           8B46         06            mov	ax,6[bp]
21838                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21839 5FB4           89C3                       mov	bx,ax
21840                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2B] (used reg = )
21841 5FB6           B0                     20  mov	al,*$20
21842 5FB8           8847         2B            mov	$2B[bx],al
21843                                           !BCC_EOS
21844                                           ! 3836         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = (' ');
21845                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21846 5FBB           8B46         06            mov	ax,6[bp]
21847                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21848 5FBE           89C3                       mov	bx,ax
21849                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2C] (used reg = )
21850 5FC0           B0                     20  mov	al,*$20
21851 5FC2           8847         2C            mov	$2C[bx],al
21852                                           !BCC_EOS
21853                                           ! 3837         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21854                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21855 5FC5           8B46         06            mov	ax,6[bp]
21856                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21857 5FC8           89C3                       mov	bx,ax
21858                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21859 5FCA           B0                     20  mov	al,*$20
21860 5FCC           8847         2D            mov	$2D[bx],al
21861                                           !BCC_EOS
21862                                           ! 3838         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21863                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21864 5FCF           8B46         06            mov	ax,6[bp]
21865                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21866 5FD2           89C3                       mov	bx,ax
21867                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21868 5FD4           B0                     20  mov	al,*$20
21869 5FD6           8847         2E            mov	$2E[bx],al
21870                                           !BCC_EOS
21871                                           ! 3839         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21872                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21873 5FD9           8B46         06            mov	ax,6[bp]
21874                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21875 5FDC           89C3                       mov	bx,ax
21876                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21877 5FDE           B0                     20  mov	al,*$20
21878 5FE0           8847         2F            mov	$2F[bx],al
21879                                           !BCC_EOS
21880                                           ! 3840     } else if (type == 0x03) {
21881 5FE3           E9         0059            br 	.53E
21882                       00005FE6            .53C:
21883                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1E-$17] (used reg = )
21884 5FE6           8A46         EB            mov	al,-$15[bp]
21885 5FE9           3C                     03  cmp	al,*3
21886 5FEB         0F85         0050            bne 	.53F
21887                       00005FEF            .540:
21888                                           ! 3841         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21889                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21890 5FEF           8B46         06            mov	ax,6[bp]
21891                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21892 5FF2           89C3                       mov	bx,ax
21893                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21894 5FF4           B0                     41  mov	al,*$41
21895 5FF6           8847         28            mov	$28[bx],al
21896                                           !BCC_EOS
21897                                           ! 3842         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21898                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21899 5FF9           8B46         06            mov	ax,6[bp]
21900                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21901 5FFC           89C3                       mov	bx,ax
21902                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21903 5FFE           B0                     54  mov	al,*$54
21904 6000           8847         29            mov	$29[bx],al
21905                                           !BCC_EOS
21906                                           ! 3843         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21907                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21908 6003           8B46         06            mov	ax,6[bp]
21909                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21910 6006           89C3                       mov	bx,ax
21911                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21912 6008           B0                     41  mov	al,*$41
21913 600A           8847         2A            mov	$2A[bx],al
21914                                           !BCC_EOS
21915                                           ! 3844         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = ('P');
21916                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21917 600D           8B46         06            mov	ax,6[bp]
21918                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21919 6010           89C3                       mov	bx,ax
21920                                           ! Debug: eq int = const $50 to unsigned char = [bx+$2B] (used reg = )
21921 6012           B0                     50  mov	al,*$50
21922 6014           8847         2B            mov	$2B[bx],al
21923                                           !BCC_EOS
21924                                           ! 3845         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = ('I');
21925                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21926 6017           8B46         06            mov	ax,6[bp]
21927                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21928 601A           89C3                       mov	bx,ax
21929                                           ! Debug: eq int = const $49 to unsigned char = [bx+$2C] (used reg = )
21930 601C           B0                     49  mov	al,*$49
21931 601E           8847         2C            mov	$2C[bx],al
21932                                           !BCC_EOS
21933                                           ! 3846         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21934                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21935 6021           8B46         06            mov	ax,6[bp]
21936                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21937 6024           89C3                       mov	bx,ax
21938                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21939 6026           B0                     20  mov	al,*$20
21940 6028           8847         2D            mov	$2D[bx],al
21941                                           !BCC_EOS
21942                                           ! 3847         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21943                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21944 602B           8B46         06            mov	ax,6[bp]
21945                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21946 602E           89C3                       mov	bx,ax
21947                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21948 6030           B0                     20  mov	al,*$20
21949 6032           8847         2E            mov	$2E[bx],al
21950                                           !BCC_EOS
21951                                           ! 3848         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21952                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21953 6035           8B46         06            mov	ax,6[bp]
21954                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21955 6038           89C3                       mov	bx,ax
21956                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21957 603A           B0                     20  mov	al,*$20
21958 603C           8847         2F            mov	$2F[bx],al
21959                                           !BCC_EOS
21960                                           ! 3849     }
21961                                           ! 3850     if (iface==0x00) {
21962                       0000603F            .53F:
21963                       0000603F            .53E:
21964                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21965 603F           8A46         E8            mov	al,-$18[bp]
21966 6042           84C0                       test	al,al
21967 6044           75           26            jne 	.541
21968                       00006046            .542:
21969                                           ! 3851       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[0])) = (iobase1);
21970                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$1E+4] (used reg = )
21971 6046           8B46         06            mov	ax,6[bp]
21972                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$30 (used reg = )
21973 6049           89C3                       mov	bx,ax
21974                                           ! Debug: eq unsigned short iobase1 = [S+$1E-$1E] to unsigned short = [bx+$30] (used reg = )
21975 604B           8B46         E4            mov	ax,-$1C[bp]
21976 604E           8947         30            mov	$30[bx],ax
21977                                           !BCC_EOS
21978                                           ! 3852       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[2])) = (0);
21979                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$1E+4] (used reg = )
21980 6051           8B46         06            mov	ax,6[bp]
21981                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$32 (used reg = )
21982 6054           89C3                       mov	bx,ax
21983                                           ! Debug: eq int = const 0 to unsigned short = [bx+$32] (used reg = )
21984 6056           31C0                       xor	ax,ax
21985 6058           8947         32            mov	$32[bx],ax
21986                                           !BCC_EOS
21987                                           ! 3853       *((Bit32u *)
21988                                           ! 3853 (SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[4])) = (0L);
21989                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$1E+4] (used reg = )
21990 605B           8B46         06            mov	ax,6[bp]
21991                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$34 (used reg = )
21992 605E           89C3                       mov	bx,ax
21993                                           ! Debug: eq long = const 0 to unsigned long = [bx+$34] (used reg = )
21994 6060           31C0                       xor	ax,ax
21995 6062           31F6                       xor	si,si
21996 6064           8947         34            mov	$34[bx],ax
21997 6067           8977         36            mov	$36[bx],si
21998                                           !BCC_EOS
21999                                           ! 3854     }
22000                                           ! 3855     else {
22001 606A           EB           00            jmp .543
22002                       0000606C            .541:
22003                                           ! 3856     }
22004                                           ! 3857     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[0])) = (device%2);
22005                       0000606C            .543:
22006                                           ! Debug: mod int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
22007 606C           8A46         08            mov	al,8[bp]
22008 606F           30E4                       xor	ah,ah
22009 6071           24                     01  and	al,*1
22010 6073           50                         push	ax
22011                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$20+4] (used reg = )
22012 6074           8B46         06            mov	ax,6[bp]
22013                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$38 (used reg = )
22014 6077           89C3                       mov	bx,ax
22015                                           ! Debug: eq unsigned char (temp) = [S+$20-$20] to unsigned char = [bx+$38] (used reg = )
22016 6079           8A46         E2            mov	al,-$1E[bp]
22017 607C           8847         38            mov	$38[bx],al
22018 607F           44                         inc	sp
22019 6080           44                         inc	sp
22020                                           !BCC_EOS
22021                                           ! 3858     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[1])) = (0);
22022                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$1E+4] (used reg = )
22023 6081           8B46         06            mov	ax,6[bp]
22024                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$39 (used reg = )
22025 6084           89C3                       mov	bx,ax
22026                                           ! Debug: eq int = const 0 to unsigned char = [bx+$39] (used reg = )
22027 6086           30C0                       xor	al,al
22028 6088           8847         39            mov	$39[bx],al
22029                                           !BCC_EOS
22030                                           ! 3859     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[2])) = (0);
22031                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$1E+4] (used reg = )
22032 608B           8B46         06            mov	ax,6[bp]
22033                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
22034 608E           89C3                       mov	bx,ax
22035                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
22036 6090           31C0                       xor	ax,ax
22037 6092           8947         3A            mov	$3A[bx],ax
22038                                           !BCC_EOS
22039                                           ! 3860     *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[4])) = (0L);
22040                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$1E+4] (used reg = )
22041 6095           8B46         06            mov	ax,6[bp]
22042                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$3C (used reg = )
22043 6098           89C3                       mov	bx,ax
22044                                           ! Debug: eq long = const 0 to unsigned long = [bx+$3C] (used reg = )
22045 609A           31C0                       xor	ax,ax
22046 609C           31F6                       xor	si,si
22047 609E           8947         3C            mov	$3C[bx],ax
22048 60A1           8977         3E            mov	$3E[bx],si
22049                                           !BCC_EOS
22050                                           ! 3861     if (t13) {
22051 60A4           8B46         EE            mov	ax,-$12[bp]
22052 60A7           85C0                       test	ax,ax
22053 60A9           74           1E            je  	.544
22054                       000060AB            .545:
22055                                           ! 3862       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[8])) = (0L);
22056                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22057 60AB           8B46         06            mov	ax,6[bp]
22058                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$40 (used reg = )
22059 60AE           89C3                       mov	bx,ax
22060                                           ! Debug: eq long = const 0 to unsigned long = [bx+$40] (used reg = )
22061 60B0           31C0                       xor	ax,ax
22062 60B2           31F6                       xor	si,si
22063 60B4           8947         40            mov	$40[bx],ax
22064 60B7           8977         42            mov	$42[bx],si
22065                                           !BCC_EOS
22066                                           ! 3863       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[12])) = (0L);
22067                                           ! Debug: add unsigned short = const $44 to unsigned short SI = [S+$1E+4] (used reg = )
22068 60BA           8B46         06            mov	ax,6[bp]
22069                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$44 (used reg = )
22070 60BD           89C3                       mov	bx,ax
22071                                           ! Debug: eq long = const 0 to unsigned long = [bx+$44] (used reg = )
22072 60BF           31C0                       xor	ax,ax
22073 60C1           31F6                       xor	si,si
22074 60C3           8947         44            mov	$44[bx],ax
22075 60C6           8977         46            mov	$46[bx],si
22076                                           !BCC_EOS
22077                                           ! 3864     }
22078                                           ! 3865     if (t13)
22079                       000060C9            .544:
22080 60C9           8B46         EE            mov	ax,-$12[bp]
22081 60CC           85C0                       test	ax,ax
22082 60CE           74           0C            je  	.546
22083                       000060D0            .547:
22084                                           ! 3866       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved3)) = (0);
22085                                           ! Debug: add unsigned short = const $48 to unsigned short SI = [S+$1E+4] (used reg = )
22086 60D0           8B46         06            mov	ax,6[bp]
22087                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$48 (used reg = )
22088 60D3           89C3                       mov	bx,ax
22089                                           ! Debug: eq int = const 0 to unsigned char = [bx+$48] (used reg = )
22090 60D5           30C0                       xor	al,al
22091 60D7           8847         48            mov	$48[bx],al
22092                                           !BCC_EOS
22093                                           ! 3867     else
22094                                           ! 3868       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.reserved3)) = (0);
22095 60DA           EB           0A            jmp .548
22096                       000060DC            .546:
22097                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22098 60DC           8B46         06            mov	ax,6[bp]
22099                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$40 (used reg = )
22100 60DF           89C3                       mov	bx,ax
22101                                           ! Debug: eq int = const 0 to unsigned char = [bx+$40] (used reg = )
22102 60E1           30C0                       xor	al,al
22103 60E3           8847         40            mov	$40[bx],al
22104                                           !BCC_EOS
22105                                           ! 3869     checksum = 0;
22106                       000060E6            .548:
22107                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22108 60E6           30C0                       xor	al,al
22109 60E8           8846         E7            mov	-$19[bp],al
22110                                           !BCC_EOS
22111                                           ! 3870     for (i = 30; i < (t13 ? 73 : 65); i++) checksum += *((Bit8u *)(SI + i));
22112                                           ! Debug: eq int = const $1E to unsigned char i = [S+$1E-$1C] (used reg = )
22113 60EB           B0                     1E  mov	al,*$1E
22114 60ED           8846         E6            mov	-$1A[bp],al
22115                                           !BCC_EOS
22116                                           !BCC_EOS
22117 60F0           EB           1F            jmp .54B
22118                       000060F2            .54C:
22119                                           ! Debug: add unsigned char i = [S+$1E-$1C] to unsigned short SI = [S+$1E+4] (used reg = )
22120 60F2           8B46         06            mov	ax,6[bp]
22121 60F5           0246         E6            add	al,-$1A[bp]
22122 60F8           80D4                   00  adc	ah,*0
22123                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
22124 60FB           89C3                       mov	bx,ax
22125                                           ! Debug: addab unsigned char = [bx+0] to unsigned char checksum = [S+$1E-$1B] (used reg = )
22126 60FD           8A46         E7            mov	al,-$19[bp]
22127 6100           30E4                       xor	ah,ah
22128 6102           0207                       add	al,[bx]
22129 6104           80D4                   00  adc	ah,*0
22130 6107           8846         E7            mov	-$19[bp],al
22131                                           !BCC_EOS
22132                                           ! 3871     checksum = -checksum;
22133                       0000610A            .54A:
22134                                           ! Debug: postinc unsigned char i = [S+$1E-$1C] (used reg = )
22135 610A           8A46         E6            mov	al,-$1A[bp]
22136 610D           40                         inc	ax
22137 610E           8846         E6            mov	-$1A[bp],al
22138                       00006111            .54B:
22139 6111           8B46         EE            mov	ax,-$12[bp]
22140 6114           85C0                       test	ax,ax
22141 6116           74           04            je  	.54E
22142                       00006118            .54F:
22143 6118           B0                     49  mov	al,*$49
22144 611A           EB           02            jmp .550
22145                       0000611C            .54E:
22146 611C           B0                     41  mov	al,*$41
22147                       0000611E            .550:
22148                                           ! Debug: lt char = al+0 to unsigned char i = [S+$1E-$1C] (used reg = )
22149 611E           3A46         E6            cmp	al,-$1A[bp]
22150 6121           77           CF            ja 	.54C
22151                       00006123            .54D:
22152                       00006123            .549:
22153                                           ! Debug: neg unsigned char checksum = [S+$1E-$1B] (used reg = )
22154 6123           31C0                       xor	ax,ax
22155 6125           2A46         E7            sub	al,-$19[bp]
22156 6128           80DC                   00  sbb	ah,*0
22157                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22158 612B           8846         E7            mov	-$19[bp],al
22159                                           !BCC_EOS
22160                                           ! 3872     if (t13)
22161 612E           8B46         EE            mov	ax,-$12[bp]
22162 6131           85C0                       test	ax,ax
22163 6133           74           0D            je  	.551
22164                       00006135            .552:
22165                                           ! 3873       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.checksum)) = (checksum);
22166                                           ! Debug: add unsigned short = const $49 to unsigned short SI = [S+$1E+4] (used reg = )
22167 6135           8B46         06            mov	ax,6[bp]
22168                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$49 (used reg = )
22169 6138           89C3                       mov	bx,ax
22170                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$49] (used reg = )
22171 613A           8A46         E7            mov	al,-$19[bp]
22172 613D           8847         49            mov	$49[bx],al
22173                                           !BCC_EOS
22174                                           ! 3874     else
22175                                           ! 3875       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.checksum)) = (checksum);
22176 6140           EB           0B            jmp .553
22177                       00006142            .551:
22178                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$1E+4] (used reg = )
22179 6142           8B46         06            mov	ax,6[bp]
22180                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$41 (used reg = )
22181 6145           89C3                       mov	bx,ax
22182                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$41] (used reg = )
22183 6147           8A46         E7            mov	al,-$19[bp]
22184 614A           8847         41            mov	$41[bx],al
22185                                           !BCC_EOS
22186                                           ! 3876   }
22187                       0000614D            .553:
22188 614D           83C4                   06  add	sp,*6
22189                                           ! 3877   return 0;
22190                       00006150            .534:
22191 6150           31C0                       xor	ax,ax
22192 6152           89EC                       mov	sp,bp
22193 6154           5D                         pop	bp
22194 6155           C3                         ret
22195                                           !BCC_EOS
22196                                           ! 3878 }
22197                                           ! 3879   void
22198                                           ! Register BX used in function int13_edd
22199                                           ! 3880 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22200                                           ! 3881   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22201                                           export	_int13_harddisk
22202                       00006156            _int13_harddisk:
22203                                           !BCC_EOS
22204                                           ! 3882 {
22205                                           ! 3883   Bit32u lba_low, lba_high;
22206                                           !BCC_EOS
22207                                           ! 3884   Bit16u cylinder, head, sector;
22208                                           !BCC_EOS
22209                                           ! 3885   Bit16u segment, offset;
22210                                           !BCC_EOS
22211                                           ! 3886   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22212                                           !BCC_EOS
22213                                           ! 3887   Bit16u size, count;
22214                                           !BCC_EOS
22215                                           ! 3888   Bit8u device, status;
22216                                           !BCC_EOS
22217                                           ! 3889   ;
22218 6156           55                         push	bp
22219 6157           89E5                       mov	bp,sp
22220 6159           83C4                   DC  add	sp,*-$24
22221                                           !BCC_EOS
22222                                           ! 3890   _write_byte(0, 0x008e, 0x0040);
22223                                           ! Debug: list int = const $40 (used reg = )
22224 615C           B8                   0040  mov	ax,*$40
22225 615F           50                         push	ax
22226                                           ! Debug: list int = const $8E (used reg = )
22227 6160           B8                   008E  mov	ax,#$8E
22228 6163           50                         push	ax
22229                                           ! Debug: list int = const 0 (used reg = )
22230 6164           31C0                       xor	ax,ax
22231 6166           50                         push	ax
22232                                           ! Debug: func () void = _write_byte+0 (used reg = )
22233 6167           E8         A491            call	__write_byte
22234 616A           83C4                   06  add	sp,*6
22235                                           !BCC_EOS
22236                                           ! 3891   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
22237                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22238 616D           8A46         10            mov	al,$10[bp]
22239                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22240 6170           3C                     80  cmp	al,#$80
22241 6172           72           07            jb  	.555
22242                       00006174            .556:
22243                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22244 6174           8A46         10            mov	al,$10[bp]
22245                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22246 6177           3C                     88  cmp	al,#$88
22247 6179           72           20            jb  	.554
22248                       0000617B            .555:
22249                                           ! 3892     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22250                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22251 617B           8A46         10            mov	al,$10[bp]
22252                                           ! Debug: list unsigned char = al+0 (used reg = )
22253 617E           30E4                       xor	ah,ah
22254 6180           50                         push	ax
22255                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22256 6181           8A46         19            mov	al,$19[bp]
22257 6184           30E4                       xor	ah,ah
22258 6186           50                         push	ax
22259                                           ! Debug: list * char = .557+0 (used reg = )
22260 6187           BB                   D24B  mov	bx,#.557
22261 618A           53                         push	bx
22262                                           ! Debug: list int = const 4 (used reg = )
22263 618B           B8                   0004  mov	ax,*4
22264 618E           50                         push	ax
22265                                           ! Debug: func () void = bios_printf+0 (used reg = )
22266 618F           E8         A7A7            call	_bios_printf
22267 6192           83C4                   08  add	sp,*8
22268                                           !BCC_EOS
22269                                           ! 3893     goto int13_fail;
22270 6195           83C4                   00  add	sp,#..FFF1+$26
22271 6198           E9         0727            br 	.FFF1
22272                                           !BCC_EOS
22273                                           ! 3894   }
22274                                           ! 3895   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]));
22275                       0000619B            .554:
22276                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22277 619B           8A46         10            mov	al,$10[bp]
22278                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22279 619E           30E4                       xor	ah,ah
22280                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22281 61A0           05                   FF80  add	ax,*-$80
22282 61A3           89C3                       mov	bx,ax
22283                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22284                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
22285                                           ! Debug: eq unsigned char = [bx+$233] to unsigned char device = [S+$26-$25] (used reg = )
22286 61A5           8A87       0233            mov	al,$233[bx]
22287 61A9           8846         DD            mov	-$23[bp],al
22288                                           !BCC_EOS
22289                                           ! 3896   if (device >= (4*2)) {
22290                                           ! Debug: ge int = const 8 to unsigned char device = [S+$26-$25] (used reg = )
22291 61AC           8A46         DD            mov	al,-$23[bp]
22292 61AF           3C                     08  cmp	al,*8
22293 61B1           72           20            jb  	.558
22294                       000061B3            .559:
22295                                           ! 3897     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22296                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22297 61B3           8A46         10            mov	al,$10[bp]
22298                                           ! Debug: list unsigned char = al+0 (used reg = )
22299 61B6           30E4                       xor	ah,ah
22300 61B8           50                         push	ax
22301                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22302 61B9           8A46         19            mov	al,$19[bp]
22303 61BC           30E4                       xor	ah,ah
22304 61BE           50                         push	ax
22305                                           ! Debug: list * char = .55A+0 (used reg = )
22306 61BF           BB                   D20D  mov	bx,#.55A
22307 61C2           53                         push	bx
22308                                           ! Debug: list int = const 4 (used reg = )
22309 61C3           B8                   0004  mov	ax,*4
22310 61C6           50                         push	ax
22311                                           ! Debug: func () void = bios_printf+0 (used reg = )
22312 61C7           E8         A76F            call	_bios_printf
22313 61CA           83C4                   08  add	sp,*8
22314                                           !BCC_EOS
22315                                           ! 3898     goto int13_fail;
22316 61CD           83C4                   00  add	sp,#..FFF1+$26
22317 61D0           E9         06EF            br 	.FFF1
22318                                           !BCC_EOS
22319                                           ! 3899   }
22320                                           ! 3900   switch (*(((Bit8u *)&AX)+1)) {
22321                       000061D3            .558:
22322 61D3           8A46         19            mov	al,$19[bp]
22323 61D6           E9         066E            br 	.55D
22324                                           ! 3901     case 0x00:
22325                                           ! 3902       ata_reset (device);
22326                       000061D9            .55E:
22327                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
22328 61D9           8A46         DD            mov	al,-$23[bp]
22329 61DC           30E4                       xor	ah,ah
22330 61DE           50                         push	ax
22331                                           ! Debug: func () void = ata_reset+0 (used reg = )
22332 61DF           E8         C677            call	_ata_reset
22333 61E2           44                         inc	sp
22334 61E3           44                         inc	sp
22335                                           !BCC_EOS
22336                                           ! 3903       goto int13_success;
22337 61E4           83C4                   00  add	sp,#..FFEF-..FFF0
22338 61E7           E9         06FD            br 	.FFEF
22339                                           !BCC_EOS
22340                                           ! 3904       break;
22341 61EA           E9         06D5            br 	.55B
22342                                           !BCC_EOS
22343                                           ! 3905     case 0x01:
22344                                           ! 3906     
22345                                           ! 3906   status = _read_byte(0x0074, 0x0040);
22346                       000061ED            .55F:
22347                                           ! Debug: list int = const $40 (used reg = )
22348 61ED           B8                   0040  mov	ax,*$40
22349 61F0           50                         push	ax
22350                                           ! Debug: list int = const $74 (used reg = )
22351 61F1           B8                   0074  mov	ax,*$74
22352 61F4           50                         push	ax
22353                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
22354 61F5           E8         A3E7            call	__read_byte
22355 61F8           83C4                   04  add	sp,*4
22356                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22357 61FB           8846         DC            mov	-$24[bp],al
22358                                           !BCC_EOS
22359                                           ! 3907       *(((Bit8u *)&AX)+1) = (status);
22360                                           ! Debug: eq unsigned char status = [S+$26-$26] to unsigned char AX = [S+$26+$17] (used reg = )
22361 61FE           8A46         DC            mov	al,-$24[bp]
22362 6201           8846         19            mov	$19[bp],al
22363                                           !BCC_EOS
22364                                           ! 3908       _write_byte(0, 0x0074, 0x0040);
22365                                           ! Debug: list int = const $40 (used reg = )
22366 6204           B8                   0040  mov	ax,*$40
22367 6207           50                         push	ax
22368                                           ! Debug: list int = const $74 (used reg = )
22369 6208           B8                   0074  mov	ax,*$74
22370 620B           50                         push	ax
22371                                           ! Debug: list int = const 0 (used reg = )
22372 620C           31C0                       xor	ax,ax
22373 620E           50                         push	ax
22374                                           ! Debug: func () void = _write_byte+0 (used reg = )
22375 620F           E8         A3E9            call	__write_byte
22376 6212           83C4                   06  add	sp,*6
22377                                           !BCC_EOS
22378                                           ! 3909       if (status) goto int13_fail_nostatus;
22379 6215           8A46         DC            mov	al,-$24[bp]
22380 6218           84C0                       test	al,al
22381 621A           74           08            je  	.560
22382                       0000621C            .561:
22383 621C           83C4                   00  add	sp,#..FFEE-..FFF0
22384 621F           E9         06B9            br 	.FFEE
22385                                           !BCC_EOS
22386                                           ! 3910       else goto int13_success_noah;
22387 6222           EB           06            jmp .562
22388                       00006224            .560:
22389 6224           83C4                   00  add	sp,#..FFED-..FFF0
22390 6227           E9         06C2            br 	.FFED
22391                                           !BCC_EOS
22392                                           ! 3911       break;
22393                       0000622A            .562:
22394 622A           E9         0695            br 	.55B
22395                                           !BCC_EOS
22396                                           ! 3912     case 0x02:
22397                                           ! 3913     case 0x03:
22398                       0000622D            .563:
22399                                           ! 3914     case 0x04:
22400                       0000622D            .564:
22401                                           ! 3915       count = ( AX & 0x00ff );
22402                       0000622D            .565:
22403                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
22404 622D           8A46         18            mov	al,$18[bp]
22405                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$26-$24] (used reg = )
22406 6230           30E4                       xor	ah,ah
22407 6232           8946         DE            mov	-$22[bp],ax
22408                                           !BCC_EOS
22409                                           ! 3916       cylinder = *(((Bit8u *)&CX)+1);
22410                                           ! Debug: eq unsigned char CX = [S+$26+$15] to unsigned short cylinder = [S+$26-$C] (used reg = )
22411 6235           8A46         17            mov	al,$17[bp]
22412 6238           30E4                       xor	ah,ah
22413 623A           8946         F6            mov	-$A[bp],ax
22414                                           !BCC_EOS
22415                                           ! 3917       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
22416                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22417 623D           8A46         16            mov	al,$16[bp]
22418                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
22419 6240           30E4                       xor	ah,ah
22420                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
22421 6242           D1E0                       shl	ax,*1
22422 6244           D1E0                       shl	ax,*1
22423                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
22424 6246           25                   0300  and	ax,#$300
22425                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$26-$C] (used reg = )
22426 6249           0B46         F6            or	ax,-$A[bp]
22427 624C           8946         F6            mov	-$A[bp],ax
22428                                           !BCC_EOS
22429                                           ! 3918       sector = (( CX & 0x00ff ) & 0x3f);
22430                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22431 624F           8A46         16            mov	al,$16[bp]
22432                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
22433 6252           24                     3F  and	al,*$3F
22434                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$26-$10] (used reg = )
22435 6254           30E4                       xor	ah,ah
22436 6256           8946         F2            mov	-$E[bp],ax
22437                                           !BCC_EOS
22438                                           ! 3919       head = *(((Bit8u *)&DX)+1);
22439                                           ! Debug: eq unsigned char DX = [S+$26+$13] to unsigned short head = [S+$26-$E] (used reg = )
22440 6259           8A46         15            mov	al,$15[bp]
22441 625C           30E4                       xor	ah,ah
22442 625E           8946         F4            mov	-$C[bp],ax
22443                                           !BCC_EOS
22444                                           ! 3920       segment = ES;
22445                                           ! Debug: eq unsigned short ES = [S+$26+6] to unsigned short segment = [S+$26-$12] (used reg = )
22446 6261           8B46         08            mov	ax,8[bp]
22447 6264           8946         F0            mov	-$10[bp],ax
22448                                           !BCC_EOS
22449                                           ! 3921       offset = BX;
22450                                           ! Debug: eq unsigned short BX = [S+$26+$10] to unsigned short offset = [S+$26-$14] (used reg = )
22451 6267           8B46         12            mov	ax,$12[bp]
22452 626A           8946         EE            mov	-$12[bp],ax
22453                                           !BCC_EOS
22454                                           ! 3922       if ((count > 128) || (count == 0) || (sector == 0)) {
22455                                           ! Debug: gt int = const $80 to unsigned short count = [S+$26-$24] (used reg = )
22456 626D           8B46         DE            mov	ax,-$22[bp]
22457 6270           3D                   0080  cmp	ax,#$80
22458 6273           77           0E            ja  	.567
22459                       00006275            .569:
22460                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$26-$24] (used reg = )
22461 6275           8B46         DE            mov	ax,-$22[bp]
22462 6278           85C0                       test	ax,ax
22463 627A           74           07            je  	.567
22464                       0000627C            .568:
22465                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22466 627C           8B46         F2            mov	ax,-$E[bp]
22467 627F           85C0                       test	ax,ax
22468 6281           75           1A            jne 	.566
22469                       00006283            .567:
22470                                           ! 3923         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",*(((Bit8u *)&AX)+1));
22471                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
22472 6283           8A46         19            mov	al,$19[bp]
22473 6286           30E4                       xor	ah,ah
22474 6288           50                         push	ax
22475                                           ! Debug: list * char = .56A+0 (used reg = )
22476 6289           BB                   D1D5  mov	bx,#.56A
22477 628C           53                         push	bx
22478                                           ! Debug: list int = const 4 (used reg = )
22479 628D           B8                   0004  mov	ax,*4
22480 6290           50                         push	ax
22481                                           ! Debug: func () void = bios_printf+0 (used reg = )
22482 6291           E8         A6A5            call	_bios_printf
22483 6294           83C4                   06  add	sp,*6
22484                                           !BCC_EOS
22485                                           ! 3924         goto int13_fail;
22486 6297           83C4                   00  add	sp,#..FFF1-..FFF0
22487 629A           E9         0625            br 	.FFF1
22488                                           !BCC_EOS
22489                                           ! 3925       }
22490                                           ! 3926       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22491                       0000629D            .566:
22492                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22493 629D           8A46         DD            mov	al,-$23[bp]
22494 62A0           30E4                       xor	ah,ah
22495 62A2           B9                   001E  mov	cx,*$1E
22496 62A5           F7E9                       imul	cx
22497 62A7           89C3                       mov	bx,ax
22498                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22499                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22500                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22501 62A9           8B9F       014E            mov	bx,$14E[bx]
22502 62AD           895E         E6            mov	-$1A[bp],bx
22503                                           !BCC_EOS
22504                                           ! 3927       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22505                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22506 62B0           8A46         DD            mov	al,-$23[bp]
22507 62B3           30E4                       xor	ah,ah
22508 62B5           B9                   001E  mov	cx,*$1E
22509 62B8           F7E9                       imul	cx
22510 62BA           89C3                       mov	bx,ax
22511                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22512                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22513                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22514 62BC           8B9F       014C            mov	bx,$14C[bx]
22515 62C0           895E         E4            mov	-$1C[bp],bx
22516                                           !BCC_EOS
22517                                           ! 3928       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22518                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22519 62C3           8A46         DD            mov	al,-$23[bp]
22520 62C6           30E4                       xor	ah,ah
22521 62C8           B9                   001E  mov	cx,*$1E
22522 62CB           F7E9                       imul	cx
22523 62CD           89C3                       mov	bx,ax
22524                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22525                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22526                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22527 62CF           8B9F       0150            mov	bx,$150[bx]
22528 62D3           895E         E2            mov	-$1E[bp],bx
22529                                           !BCC_EOS
22530                                           ! 3929       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
22531                                           ! Debug: ge unsigned short nlc = [S+$26-$1C] to unsigned short cylinder = [S+$26-$C] (used reg = )
22532 62D6           8B46         F6            mov	ax,-$A[bp]
22533 62D9           3B46         E6            cmp	ax,-$1A[bp]
22534 62DC           73           10            jae 	.56C
22535                       000062DE            .56E:
22536                                           ! Debug: ge unsigned short nlh = [S+$26-$1E] to unsigned short head = [S+$26-$E] (used reg = )
22537 62DE           8B46         F4            mov	ax,-$C[bp]
22538 62E1           3B46         E4            cmp	ax,-$1C[bp]
22539 62E4           73           08            jae 	.56C
22540                       000062E6            .56D:
22541                                           ! Debug: gt unsigned short nlspt = [S+$26-$20] to unsigned short sector = [S+$26-$10] (used reg = )
22542 62E6           8B46         F2            mov	ax,-$E[bp]
22543 62E9           3B46         E2            cmp	ax,-$1E[bp]
22544 62EC           76           23            jbe 	.56B
22545                       000062EE            .56C:
22546                                           ! 3930         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", *(((Bit8u *)&AX)+1), cylinder, head, sector);
22547                                           ! Debug: list unsigned short sector = [S+$26-$10] (used reg = )
22548 62EE           FF76         F2            push	-$E[bp]
22549                                           ! Debug: list unsigned short head = [S+$28-$E] (used reg = )
22550 62F1           FF76         F4            push	-$C[bp]
22551                                           ! Debug: list unsigned short cylinder = [S+$2A-$C] (used reg = )
22552 62F4           FF76         F6            push	-$A[bp]
22553                                           ! Debug: list unsigned char AX = [S+$2C+$17] (used reg = )
22554 62F7           8A46         19            mov	al,$19[bp]
22555 62FA           30E4                       xor	ah,ah
22556 62FC           50                         push	ax
22557                                           ! Debug: list * char = .56F+0 (used reg = )
22558 62FD           BB                   D18D  mov	bx,#.56F
22559 6300           53                         push	bx
22560                                           ! Debug: list int = const 4 (used reg = )
22561 6301           B8                   0004  mov	ax,*4
22562 6304           50                         push	ax
22563                                           ! Debug: func () void = bios_printf+0 (used reg = )
22564 6305           E8         A631            call	_bios_printf
22565 6308           83C4                   0C  add	sp,*$C
22566                                           !BCC_EOS
22567                                           ! 3931         goto int13_fail;
22568 630B           83C4                   00  add	sp,#..FFF1-..FFF0
22569 630E           E9         05B1            br 	.FFF1
22570                                           !BCC_EOS
22571                                           ! 3932       }
22572                                           ! 3933       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
22573                       00006311            .56B:
22574                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$26+$17] (used reg = )
22575 6311           8A46         19            mov	al,$19[bp]
22576 6314           3C                     04  cmp	al,*4
22577 6316           75           06            jne 	.570
22578                       00006318            .571:
22579 6318           83C4                   00  add	sp,#..FFEF-..FFF0
22580 631B           E9         05C9            br 	.FFEF
22581                                           !BCC_EOS
22582                                           ! 3934       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
22583                       0000631E            .570:
22584                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22585 631E           8A46         DD            mov	al,-$23[bp]
22586 6321           30E4                       xor	ah,ah
22587 6323           B9                   001E  mov	cx,*$1E
22588 6326           F7E9                       imul	cx
22589 6328           89C3                       mov	bx,ax
22590                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
22591                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
22592                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$26-$18] (used reg = )
22593 632A           8B9F       0152            mov	bx,$152[bx]
22594 632E           895E         EA            mov	-$16[bp],bx
22595                                           !BCC_EOS
22596                                           ! 3935       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
22597                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22598 6331           8A46         DD            mov	al,-$23[bp]
22599 6334           30E4                       xor	ah,ah
22600 6336           B9                   001E  mov	cx,*$1E
22601 6339           F7E9                       imul	cx
22602 633B           89C3                       mov	bx,ax
22603                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
22604                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
22605                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$26-$1A] (used reg = )
22606 633D           8B9F       0156            mov	bx,$156[bx]
22607 6341           895E         E8            mov	-$18[bp],bx
22608                                           !BCC_EOS
22609                                           ! 3936       if ( (nph != nlh) || (npspt != nlspt)) {
22610                                           ! Debug: ne unsigned short nlh = [S+$26-$1E] to unsigned short nph = [S+$26-$18] (used reg = )
22611 6344           8B46         EA            mov	ax,-$16[bp]
22612 6347           3B46         E4            cmp	ax,-$1C[bp]
22613 634A           75           08            jne 	.573
22614                       0000634C            .574:
22615                                           ! Debug: ne unsigned short nlspt = [S+$26-$20] to unsigned short npspt = [S+$26-$1A] (used reg = )
22616 634C           8B46         E8            mov	ax,-$18[bp]
22617 634F           3B46         E2            cmp	ax,-$1E[bp]
22618 6352           74           72            je  	.572
22619                       00006354            .573:
22620                                           ! 3937         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
22621                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22622 6354           8B46         F2            mov	ax,-$E[bp]
22623 6357           31DB                       xor	bx,bx
22624 6359           53                         push	bx
22625 635A           50                         push	ax
22626                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2A-$20] (used reg = )
22627 635B           8B46         E2            mov	ax,-$1E[bp]
22628 635E           31DB                       xor	bx,bx
22629 6360           53                         push	bx
22630 6361           50                         push	ax
22631                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$2E-$E] (used reg = )
22632 6362           8B46         F4            mov	ax,-$C[bp]
22633 6365           31DB                       xor	bx,bx
22634 6367           53                         push	bx
22635 6368           50                         push	ax
22636                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$32-$1E] (used reg = )
22637 6369           8B46         E4            mov	ax,-$1C[bp]
22638 636C           31DB                       xor	bx,bx
22639 636E           53                         push	bx
22640 636F           50                         push	ax
22641                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$36-$C] (used reg = )
22642 6370           8B46         F6            mov	ax,-$A[bp]
22643 6373           31DB                       xor	bx,bx
22644                                           ! Debug: mul unsigned long (temp) = [S+$36-$36] to unsigned long = bx+0 (used reg = )
22645 6375           8D7E         CC            lea	di,-$E+..FFF0[bp]
22646 6378           E8         9D3F            call	lmulul
22647 637B           83C4                   04  add	sp,*4
22648                                           ! Debug: add unsigned long (temp) = [S+$32-$32] to unsigned long = bx+0 (used reg = )
22649 637E           8D7E         D0            lea	di,-$A+..FFF0[bp]
22650 6381           E8         9D10            call	laddul
22651 6384           83C4                   04  add	sp,*4
22652                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
22653 6387           8D7E         D4            lea	di,-6+..FFF0[bp]
22654 638A           E8         9D2D            call	lmulul
22655 638D           83C4                   04  add	sp,*4
22656                                           ! Debug: add unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
22657 6390           8D7E         D8            lea	di,-2+..FFF0[bp]
22658 6393           E8         9CFE            call	laddul
22659 6396           83C4                   04  add	sp,*4
22660                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
22661 6399           53                         push	bx
22662 639A           50                         push	ax
22663 639B           B8                   0001  mov	ax,*1
22664 639E           31DB                       xor	bx,bx
22665 63A0           53                         push	bx
22666 63A1           50                         push	ax
22667 63A2           8B46         D8            mov	ax,-2+..FFF0[bp]
22668 63A5           8B5E         DA            mov	bx,0+..FFF0[bp]
22669 63A8           8D7E         D4            lea	di,-6+..FFF0[bp]
22670 63AB           E8         9D04            call	lsubul
22671 63AE           83C4                   08  add	sp,*8
22672                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
22673 63B1           8946         FC            mov	-4[bp],ax
22674 63B4           895E         FE            mov	-2[bp],bx
22675                                           !BCC_EOS
22676                                           ! 3938         lba_high = 0;
22677                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$26-$A] (used reg = )
22678 63B7           31C0                       xor	ax,ax
22679 63B9           31DB                       xor	bx,bx
22680 63BB           8946         F8            mov	-8[bp],ax
22681 63BE           895E         FA            mov	-6[bp],bx
22682                                           !BCC_EOS
22683                                           ! 3939         sector = 0;
22684                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22685 63C1           31C0                       xor	ax,ax
22686 63C3           8946         F2            mov	-$E[bp],ax
22687                                           !BCC_EOS
22688                                           ! 3940       }
22689                                           ! 3941       if (*(((Bit8u *)&AX)+1) == 0x02)
22690                       000063C6            .572:
22691                                           ! Debug: logeq int = const 2 to unsigned char AX = [S+$26+$17] (used reg = )
22692 63C6           8A46         19            mov	al,$19[bp]
22693 63C9           3C                     02  cmp	al,*2
22694 63CB           75           36            jne 	.575
22695                       000063CD            .576:
22696                                           ! 3942         status=ata_cmd_data_io(0, device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22697                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22698 63CD           FF76         EE            push	-$12[bp]
22699                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22700 63D0           FF76         F0            push	-$10[bp]
22701                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22702 63D3           FF76         FA            push	-6[bp]
22703 63D6           FF76         F8            push	-8[bp]
22704                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22705 63D9           FF76         FE            push	-2[bp]
22706 63DC           FF76         FC            push	-4[bp]
22707                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22708 63DF           FF76         F2            push	-$E[bp]
22709                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22710 63E2           FF76         F4            push	-$C[bp]
22711                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22712 63E5           FF76         F6            push	-$A[bp]
22713                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22714 63E8           FF76         DE            push	-$22[bp]
22715                                           ! Debug: list int = const $20 (used reg = )
22716 63EB           B8                   0020  mov	ax,*$20
22717 63EE           50                         push	ax
22718                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22719 63EF           8A46         DD            mov	al,-$23[bp]
22720 63F2           30E4                       xor	ah,ah
22721 63F4           50                         push	ax
22722                                           ! Debug: list int = const 0 (used reg = )
22723 63F5           31C0                       xor	ax,ax
22724 63F7           50                         push	ax
22725                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22726 63F8           E8         C585            call	_ata_cmd_data_io
22727 63FB           83C4                   1A  add	sp,*$1A
22728                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22729 63FE           8846         DC            mov	-$24[bp],al
22730                                           !BCC_EOS
22731                                           ! 3943       else
22732                                           ! 3944         status=ata_cmd_data_io(1, device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22733 6401           EB           35            jmp .577
22734                       00006403            .575:
22735                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22736 6403           FF76         EE            push	-$12[bp]
22737                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22738 6406           FF76         F0            push	-$10[bp]
22739                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22740 6409           FF76         FA            push	-6[bp]
22741 640C           FF76         F8            push	-8[bp]
22742                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22743 640F           FF76         FE            push	-2[bp]
22744 6412           FF76         FC            push	-4[bp]
22745                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22746 6415           FF76         F2            push	-$E[bp]
22747                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22748 6418           FF76         F4            push	-$C[bp]
22749                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22750 641B           FF76         F6            push	-$A[bp]
22751                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22752 641E           FF76         DE            push	-$22[bp]
22753                                           ! Debug: list int = const $30 (used reg = )
22754 6421           B8                   0030  mov	ax,*$30
22755 6424           50                         push	ax
22756                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22757 6425           8A46         DD            mov	al,-$23[bp]
22758 6428           30E4                       xor	ah,ah
22759 642A           50                         push	ax
22760                                           ! Debug: list int = const 1 (used reg = )
22761 642B           B8                   0001  mov	ax,*1
22762 642E           50                         push	ax
22763                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22764 642F           E8         C54E            call	_ata_cmd_data_io
22765 6432           83C4                   1A  add	sp,*$1A
22766                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22767 6435           8846         DC            mov	-$24[bp],al
22768                                           !BCC_EOS
22769                                           ! 3945       *((Bit8u *)&AX) = (*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)));
22770                       00006438            .577:
22771                                           ! Debug: eq unsigned short = [+$254] to unsigned char AX = [S+$26+$16] (used reg = )
22772 6438           A0         0254            mov	al,[$254]
22773 643B           8846         18            mov	$18[bp],al
22774                                           !BCC_EOS
22775                                           ! 3946       if (status != 0) {
22776                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
22777 643E           8A46         DC            mov	al,-$24[bp]
22778 6441           84C0                       test	al,al
22779 6443           74           25            je  	.578
22780                       00006445            .579:
22781                                           ! 3947         bios_printf(4, "int13_harddisk: functi
22782                                           ! 3947 on %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
22783                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
22784 6445           8A46         DC            mov	al,-$24[bp]
22785 6448           30E4                       xor	ah,ah
22786 644A           50                         push	ax
22787                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22788 644B           8A46         19            mov	al,$19[bp]
22789 644E           30E4                       xor	ah,ah
22790 6450           50                         push	ax
22791                                           ! Debug: list * char = .57A+0 (used reg = )
22792 6451           BB                   D160  mov	bx,#.57A
22793 6454           53                         push	bx
22794                                           ! Debug: list int = const 4 (used reg = )
22795 6455           B8                   0004  mov	ax,*4
22796 6458           50                         push	ax
22797                                           ! Debug: func () void = bios_printf+0 (used reg = )
22798 6459           E8         A4DD            call	_bios_printf
22799 645C           83C4                   08  add	sp,*8
22800                                           !BCC_EOS
22801                                           ! 3948         *(((Bit8u *)&AX)+1) = (0x0c);
22802                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
22803 645F           B0                     0C  mov	al,*$C
22804 6461           8846         19            mov	$19[bp],al
22805                                           !BCC_EOS
22806                                           ! 3949         goto int13_fail_noah;
22807 6464           83C4                   00  add	sp,#..FFEC-..FFF0
22808 6467           E9         045D            br 	.FFEC
22809                                           !BCC_EOS
22810                                           ! 3950       }
22811                                           ! 3951       goto int13_success;
22812                       0000646A            .578:
22813 646A           83C4                   00  add	sp,#..FFEF-..FFF0
22814 646D           E9         0477            br 	.FFEF
22815                                           !BCC_EOS
22816                                           ! 3952       break;
22817 6470           E9         044F            br 	.55B
22818                                           !BCC_EOS
22819                                           ! 3953     case 0x05:
22820                                           ! 3954       bios_printf(4, "format disk track called\n");
22821                       00006473            .57B:
22822                                           ! Debug: list * char = .57C+0 (used reg = )
22823 6473           BB                   D146  mov	bx,#.57C
22824 6476           53                         push	bx
22825                                           ! Debug: list int = const 4 (used reg = )
22826 6477           B8                   0004  mov	ax,*4
22827 647A           50                         push	ax
22828                                           ! Debug: func () void = bios_printf+0 (used reg = )
22829 647B           E8         A4BB            call	_bios_printf
22830 647E           83C4                   04  add	sp,*4
22831                                           !BCC_EOS
22832                                           ! 3955       goto int13_success;
22833 6481           83C4                   00  add	sp,#..FFEF-..FFF0
22834 6484           E9         0460            br 	.FFEF
22835                                           !BCC_EOS
22836                                           ! 3956       return;
22837 6487           89EC                       mov	sp,bp
22838 6489           5D                         pop	bp
22839 648A           C3                         ret
22840                                           !BCC_EOS
22841                                           ! 3957       break;
22842 648B           E9         0434            br 	.55B
22843                                           !BCC_EOS
22844                                           ! 3958     case 0x08:
22845                                           ! 3959       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22846                       0000648E            .57D:
22847                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22848 648E           8A46         DD            mov	al,-$23[bp]
22849 6491           30E4                       xor	ah,ah
22850 6493           B9                   001E  mov	cx,*$1E
22851 6496           F7E9                       imul	cx
22852 6498           89C3                       mov	bx,ax
22853                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22854                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22855                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22856 649A           8B9F       014E            mov	bx,$14E[bx]
22857 649E           895E         E6            mov	-$1A[bp],bx
22858                                           !BCC_EOS
22859                                           ! 3960       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22860                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22861 64A1           8A46         DD            mov	al,-$23[bp]
22862 64A4           30E4                       xor	ah,ah
22863 64A6           B9                   001E  mov	cx,*$1E
22864 64A9           F7E9                       imul	cx
22865 64AB           89C3                       mov	bx,ax
22866                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22867                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22868                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22869 64AD           8B9F       014C            mov	bx,$14C[bx]
22870 64B1           895E         E4            mov	-$1C[bp],bx
22871                                           !BCC_EOS
22872                                           ! 3961       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22873                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22874 64B4           8A46         DD            mov	al,-$23[bp]
22875 64B7           30E4                       xor	ah,ah
22876 64B9           B9                   001E  mov	cx,*$1E
22877 64BC           F7E9                       imul	cx
22878 64BE           89C3                       mov	bx,ax
22879                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22880                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22881                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22882 64C0           8B9F       0150            mov	bx,$150[bx]
22883 64C4           895E         E2            mov	-$1E[bp],bx
22884                                           !BCC_EOS
22885                                           ! 3962       count = *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount));
22886                                           ! Debug: eq unsigned char = [+$232] to unsigned short count = [S+$26-$24] (used reg = )
22887 64C7           A0         0232            mov	al,[$232]
22888 64CA           30E4                       xor	ah,ah
22889 64CC           8946         DE            mov	-$22[bp],ax
22890                                           !BCC_EOS
22891                                           ! 3963       nlc = nlc - 1;
22892                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22893 64CF           8B46         E6            mov	ax,-$1A[bp]
22894                                           ! Debug: eq unsigned int = ax-1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22895 64D2           48                         dec	ax
22896 64D3           8946         E6            mov	-$1A[bp],ax
22897                                           !BCC_EOS
22898                                           ! 3964       *((Bit8u *)&AX) = (0);
22899                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$16] (used reg = )
22900 64D6           30C0                       xor	al,al
22901 64D8           8846         18            mov	$18[bp],al
22902                                           !BCC_EOS
22903                                           ! 3965       *(((Bit8u *)&CX)+1) = (nlc & 0xff);
22904                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$26-$1C] (used reg = )
22905 64DB           8A46         E6            mov	al,-$1A[bp]
22906                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$15] (used reg = )
22907 64DE           8846         17            mov	$17[bp],al
22908                                           !BCC_EOS
22909                                           ! 3966       *((Bit8u *)&CX) = (((nlc >> 2) & 0xc0) | (nlspt & 0x3f));
22910                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$26-$20] (used reg = )
22911 64E1           8A46         E2            mov	al,-$1E[bp]
22912 64E4           24                     3F  and	al,*$3F
22913 64E6           50                         push	ax
22914                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$28-$1C] (used reg = )
22915 64E7           8B46         E6            mov	ax,-$1A[bp]
22916 64EA           D1E8                       shr	ax,*1
22917 64EC           D1E8                       shr	ax,*1
22918                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
22919 64EE           24                     C0  and	al,#$C0
22920                                           ! Debug: or unsigned char (temp) = [S+$28-$28] to unsigned char = al+0 (used reg = )
22921 64F0           0A46         DA            or	al,0+..FFF0[bp]
22922 64F3           44                         inc	sp
22923 64F4           44                         inc	sp
22924                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$14] (used reg = )
22925 64F5           8846         16            mov	$16[bp],al
22926                                           !BCC_EOS
22927                                           ! 3967       *(((Bit8u *)&DX)+1) = (nlh - 1);
22928                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$26-$1E] (used reg = )
22929 64F8           8B46         E4            mov	ax,-$1C[bp]
22930                                           ! Debug: eq unsigned int = ax-1 to unsigned char DX = [S+$26+$13] (used reg = )
22931 64FB           48                         dec	ax
22932 64FC           8846         15            mov	$15[bp],al
22933                                           !BCC_EOS
22934                                           ! 3968       *((Bit8u *)&DX) = (count);
22935                                           ! Debug: eq unsigned short count = [S+$26-$24] to unsigned char DX = [S+$26+$12] (used reg = )
22936 64FF           8A46         DE            mov	al,-$22[bp]
22937 6502           8846         14            mov	$14[bp],al
22938                                           !BCC_EOS
22939                                           ! 3969       goto int13_success;
22940 6505           83C4                   00  add	sp,#..FFEF-..FFF0
22941 6508           E9         03DC            br 	.FFEF
22942                                           !BCC_EOS
22943                                           ! 3970       break;
22944 650B           E9         03B4            br 	.55B
22945                                           !BCC_EOS
22946                                           ! 3971     case 0x10:
22947                                           ! 3972       status = inb(*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[device/2].iobase1)) + 7);
22948                       0000650E            .57E:
22949                                           ! Debug: div int = const 2 to unsigned char device = [S+$26-$25] (used reg = )
22950 650E           8A46         DD            mov	al,-$23[bp]
22951 6511           30E4                       xor	ah,ah
22952 6513           D1E8                       shr	ax,*1
22953                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
22954 6515           B1                     03  mov	cl,*3
22955 6517           D3E0                       shl	ax,cl
22956 6519           89C3                       mov	bx,ax
22957                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
22958                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
22959                                           ! Debug: add int = const 7 to unsigned short = [bx+$124] (used reg = )
22960 651B           8B9F       0124            mov	bx,$124[bx]
22961                                           ! Debug: list unsigned int = bx+7 (used reg = )
22962 651F           83C3                   07  add	bx,*7
22963 6522           53                         push	bx
22964                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22965 6523           E8         A003            call	_inb
22966 6526           44                         inc	sp
22967 6527           44                         inc	sp
22968                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22969 6528           8846         DC            mov	-$24[bp],al
22970                                           !BCC_EOS
22971                                           ! 3973       if ( (status & (0x80 | 0x40)) == 0x40 ) {
22972                                           ! Debug: and int = const $C0 to unsigned char status = [S+$26-$26] (used reg = )
22973 652B           8A46         DC            mov	al,-$24[bp]
22974 652E           24                     C0  and	al,#$C0
22975                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
22976 6530           3C                     40  cmp	al,*$40
22977 6532           75           08            jne 	.57F
22978                       00006534            .580:
22979                                           ! 3974         goto int13_success;
22980 6534           83C4                   00  add	sp,#..FFEF-..FFF0
22981 6537           E9         03AD            br 	.FFEF
22982                                           !BCC_EOS
22983                                           ! 3975       }
22984                                           ! 3976       else {
22985 653A           EB           0B            jmp .581
22986                       0000653C            .57F:
22987                                           ! 3977         *(((Bit8u *)&AX)+1) = (0xAA);
22988                                           ! Debug: eq int = const $AA to unsigned char AX = [S+$26+$17] (used reg = )
22989 653C           B0                     AA  mov	al,#$AA
22990 653E           8846         19            mov	$19[bp],al
22991                                           !BCC_EOS
22992                                           ! 3978         goto int13_fail_noah;
22993 6541           83C4                   00  add	sp,#..FFEC-..FFF0
22994 6544           E9         0380            br 	.FFEC
22995                                           !BCC_EOS
22996                                           ! 3979       }
22997                                           ! 3980       break;
22998                       00006547            .581:
22999 6547           E9         0378            br 	.55B
23000                                           !BCC_EOS
23001                                           ! 3981     case 0x15:
23002                                           ! 3982       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
23003                       0000654A            .582:
23004                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23005 654A           8A46         DD            mov	al,-$23[bp]
23006 654D           30E4                       xor	ah,ah
23007 654F           B9                   001E  mov	cx,*$1E
23008 6552           F7E9                       imul	cx
23009 6554           89C3                       mov	bx,ax
23010                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23011                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
23012                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
23013 6556           8B9F       014E            mov	bx,$14E[bx]
23014 655A           895E         E6            mov	-$1A[bp],bx
23015                                           !BCC_EOS
23016                                           ! 3983       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
23017                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23018 655D           8A46         DD            mov	al,-$23[bp]
23019 6560           30E4                       xor	ah,ah
23020 6562           B9                   001E  mov	cx,*$1E
23021 6565           F7E9                       imul	cx
23022 6567           89C3                       mov	bx,ax
23023                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23024                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
23025                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
23026 6569           8B9F       014C            mov	bx,$14C[bx]
23027 656D           895E         E4            mov	-$1C[bp],bx
23028                                           !BCC_EOS
23029                                           ! 3984       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
23030                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23031 6570           8A46         DD            mov	al,-$23[bp]
23032 6573           30E4                       xor	ah,ah
23033 6575           B9                   001E  mov	cx,*$1E
23034 6578           F7E9                       imul	cx
23035 657A           89C3                       mov	bx,ax
23036                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23037                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
23038                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
23039 657C           8B9F       0150            mov	bx,$150[bx]
23040 6580           895E         E2            mov	-$1E[bp],bx
23041                                           !BCC_EOS
23042                                           ! 3985       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23043                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$26-$20] (used reg = )
23044 6583           8B46         E2            mov	ax,-$1E[bp]
23045 6586           31DB                       xor	bx,bx
23046 6588           53                         push	bx
23047 6589           50                         push	ax
23048                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2A-$1E] (used reg = )
23049 658A           8B46         E4            mov	ax,-$1C[bp]
23050 658D           31DB                       xor	bx,bx
23051 658F           53                         push	bx
23052 6590           50                         push	ax
23053                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$2E-$1C] (used reg = )
23054 6591           8B46         E6            mov	ax,-$1A[bp]
23055                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23056 6594           48                         dec	ax
23057 6595           31DB                       xor	bx,bx
23058                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
23059 6597           8D7E         D4            lea	di,-6+..FFF0[bp]
23060 659A           E8         9B1D            call	lmulul
23061 659D           83C4                   04  add	sp,*4
23062                                           ! Debug: mul unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
23063 65A0           8D7E         D8            lea	di,-2+..FFF0[bp]
23064 65A3           E8         9B14            call	lmulul
23065 65A6           83C4                   04  add	sp,*4
23066                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23067 65A9           8946         FC            mov	-4[bp],ax
23068 65AC           895E         FE            mov	-2[bp],bx
23069                                           !BCC_EOS
23070                                           ! 3986       CX = *(((Bit16u *)&lba_low)+1);
23071                                           ! Debug: eq unsigned short lba_low = [S+$26-4] to unsigned short CX = [S+$26+$14] (used reg = )
23072 65AF           8B46         FE            mov	ax,-2[bp]
23073 65B2           8946         16            mov	$16[bp],ax
23074                                           !BCC_EOS
23075                                           ! 3987       DX = *((Bit16u *)&lba_low);
23076                                           ! Debug: eq unsigned short lba_low = [S+$26-6] to unsigned short DX = [S+$26+$12] (used reg = )
23077 65B5           8B46         FC            mov	ax,-4[bp]
23078 65B8           8946         14            mov	$14[bp],ax
23079                                           !BCC_EOS
23080                                           ! 3988       *(((Bit8u *)&AX)+1) = (3);
23081                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$26+$17] (used reg = )
23082 65BB           B0                     03  mov	al,*3
23083 65BD           8846         19            mov	$19[bp],al
23084                                           !BCC_EOS
23085                                           ! 3989       goto int13_success_noah;
23086 65C0           83C4                   00  add	sp,#..FFED-..FFF0
23087 65C3           E9         0326            br 	.FFED
23088                                           !BCC_EOS
23089                                           ! 3990       break;
23090 65C6           E9         02F9            br 	.55B
23091                                           !BCC_EOS
23092                                           ! 3991     case 0x41:
23093                                           ! 3992       BX=0xaa55;
23094                       000065C9            .583:
23095                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$26+$10] (used reg = )
23096 65C9           B8                   AA55  mov	ax,#$AA55
23097 65CC           8946         12            mov	$12[bp],ax
23098                                           !BCC_EOS
23099                                           ! 3993       *(((Bit8u *)&AX)+1) = (0x30);
23100                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$26+$17] (used reg = )
23101 65CF           B0                     30  mov	al,*$30
23102 65D1           8846         19            mov	$19[bp],al
23103                                           !BCC_EOS
23104                                           ! 3994       CX=0x0007;
23105                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$26+$14] (used reg = )
23106 65D4           B8                   0007  mov	ax,*7
23107 65D7           8946         16            mov	$16[bp],ax
23108                                           !BCC_EOS
23109                                           ! 3995       goto int13_success_noah;
23110 65DA           83C4                   00  add	sp,#..FFED-..FFF0
23111 65DD           E9         030C            br 	.FFED
23112                                           !BCC_EOS
23113                                           ! 3996       break;
23114 65E0           E9         02DF            br 	.55B
23115                                           !BCC_EOS
23116                                           ! 3997     case 0x42:
23117                                           ! 3998     case 0x43:
23118                       000065E3            .584:
23119                                           ! 3999     case 0x44:
23120                       000065E3            .585:
23121                                           ! 4000     case 0x47:
23122                       000065E3            .586:
23123                                           ! 4001       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23124                       000065E3            .587:
23125                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23126 65E3           FF76         06            push	6[bp]
23127                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23128 65E6           8B46         0C            mov	ax,$C[bp]
23129                                           ! Debug: list unsigned int = ax+2 (used reg = )
23130 65E9           40                         inc	ax
23131 65EA           40                         inc	ax
23132 65EB           50                         push	ax
23133                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23134 65EC           E8         9FFE            call	__read_word
23135 65EF           83C4                   04  add	sp,*4
23136                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$26-$24] (used reg = )
23137 65F2           8946         DE            mov	-$22[bp],ax
23138                                           !BCC_EOS
23139                                           ! 4002       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
23140                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23141 65F5           FF76         06            push	6[bp]
23142                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23143 65F8           8B46         0C            mov	ax,$C[bp]
23144                                           ! Debug: list unsigned int = ax+6 (used reg = )
23145 65FB           05                   0006  add	ax,*6
23146 65FE           50                         push	ax
23147                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23148 65FF           E8         9FEB            call	__read_word
23149 6602           83C4                   04  add	sp,*4
23150                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$26-$12] (used reg = )
23151 6605           8946         F0            mov	-$10[bp],ax
23152                                           !BCC_EOS
23153                                           ! 4003       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
23154                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23155 6608           FF76         06            push	6[bp]
23156                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23157 660B           8B46         0C            mov	ax,$C[bp]
23158                                           ! Debug: list unsigned int = ax+4 (used reg = )
23159 660E           05                   0004  add	ax,*4
23160 6611           50                         push	ax
23161                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23162 6612           E8         9FD8            call	__read_word
23163 6615           83C4                   04  add	sp,*4
23164                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$26-$14] (used reg = )
23165 6618           8946         EE            mov	-$12[bp],ax
23166                                           !BCC_EOS
23167                                           ! 4004  
23168                                           ! 4004      lba_high=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
23169                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23170 661B           FF76         06            push	6[bp]
23171                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23172 661E           8B46         0C            mov	ax,$C[bp]
23173                                           ! Debug: list unsigned int = ax+$C (used reg = )
23174 6621           05                   000C  add	ax,*$C
23175 6624           50                         push	ax
23176                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23177 6625           E8         9A2E            call	__read_dword
23178 6628           89D3                       mov	bx,dx
23179 662A           83C4                   04  add	sp,*4
23180                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$26-$A] (used reg = )
23181 662D           8946         F8            mov	-8[bp],ax
23182 6630           895E         FA            mov	-6[bp],bx
23183                                           !BCC_EOS
23184                                           ! 4005       if (lba_high > *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) ) {
23185                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23186 6633           8A46         DD            mov	al,-$23[bp]
23187 6636           30E4                       xor	ah,ah
23188 6638           B9                   001E  mov	cx,*$1E
23189 663B           F7E9                       imul	cx
23190 663D           89C3                       mov	bx,ax
23191                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23192                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23193                                           ! Debug: gt unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23194 663F           8B87       015C            mov	ax,$15C[bx]
23195 6643           8B9F       015E            mov	bx,$15E[bx]
23196 6647           8D7E         F8            lea	di,-8[bp]
23197 664A           E8         9A4F            call	lcmpul
23198 664D           73           1A            jae 	.588
23199                       0000664F            .589:
23200                                           ! 4006         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23201                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23202 664F           8A46         19            mov	al,$19[bp]
23203 6652           30E4                       xor	ah,ah
23204 6654           50                         push	ax
23205                                           ! Debug: list * char = .58A+0 (used reg = )
23206 6655           BB                   D115  mov	bx,#.58A
23207 6658           53                         push	bx
23208                                           ! Debug: list int = const 4 (used reg = )
23209 6659           B8                   0004  mov	ax,*4
23210 665C           50                         push	ax
23211                                           ! Debug: func () void = bios_printf+0 (used reg = )
23212 665D           E8         A2D9            call	_bios_printf
23213 6660           83C4                   06  add	sp,*6
23214                                           !BCC_EOS
23215                                           ! 4007         goto int13_fail;
23216 6663           83C4                   00  add	sp,#..FFF1-..FFF0
23217 6666           E9         0259            br 	.FFF1
23218                                           !BCC_EOS
23219                                           ! 4008       }
23220                                           ! 4009       lba_low=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
23221                       00006669            .588:
23222                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23223 6669           FF76         06            push	6[bp]
23224                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
23225 666C           8B46         0C            mov	ax,$C[bp]
23226                                           ! Debug: list unsigned int = ax+8 (used reg = )
23227 666F           05                   0008  add	ax,*8
23228 6672           50                         push	ax
23229                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23230 6673           E8         99E0            call	__read_dword
23231 6676           89D3                       mov	bx,dx
23232 6678           83C4                   04  add	sp,*4
23233                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23234 667B           8946         FC            mov	-4[bp],ax
23235 667E           895E         FE            mov	-2[bp],bx
23236                                           !BCC_EOS
23237                                           ! 4010       if (lba_high == *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high))
23238                                           ! 4011           && lba_low >= *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) ) {
23239                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23240 6681           8A46         DD            mov	al,-$23[bp]
23241 6684           30E4                       xor	ah,ah
23242 6686           B9                   001E  mov	cx,*$1E
23243 6689           F7E9                       imul	cx
23244 668B           89C3                       mov	bx,ax
23245                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23246                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23247                                           ! Debug: logeq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23248 668D           8B87       015C            mov	ax,$15C[bx]
23249 6691           8B9F       015E            mov	bx,$15E[bx]
23250 6695           8D7E         F8            lea	di,-8[bp]
23251 6698           E8         9A01            call	lcmpul
23252 669B           75           36            jne 	.58B
23253                       0000669D            .58D:
23254                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23255 669D           8A46         DD            mov	al,-$23[bp]
23256 66A0           30E4                       xor	ah,ah
23257 66A2           B9                   001E  mov	cx,*$1E
23258 66A5           F7E9                       imul	cx
23259 66A7           89C3                       mov	bx,ax
23260                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
23261                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
23262                                           ! Debug: ge unsigned long = [bx+$158] to unsigned long lba_low = [S+$26-6] (used reg = )
23263 66A9           8B87       0158            mov	ax,$158[bx]
23264 66AD           8B9F       015A            mov	bx,$15A[bx]
23265 66B1           8D7E         FC            lea	di,-4[bp]
23266 66B4           E8         99E5            call	lcmpul
23267 66B7           77           1A            ja  	.58B
23268                       000066B9            .58C:
23269                                           ! 4012         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23270                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23271 66B9           8A46         19            mov	al,$19[bp]
23272 66BC           30E4                       xor	ah,ah
23273 66BE           50                         push	ax
23274                                           ! Debug: list * char = .58E+0 (used reg = )
23275 66BF           BB                   D0E4  mov	bx,#.58E
23276 66C2           53                         push	bx
23277                                           ! Debug: list int = const 4 (used reg = )
23278 66C3           B8                   0004  mov	ax,*4
23279 66C6           50                         push	ax
23280                                           ! Debug: func () void = bios_printf+0 (used reg = )
23281 66C7           E8         A26F            call	_bios_printf
23282 66CA           83C4                   06  add	sp,*6
23283                                           !BCC_EOS
23284                                           ! 4013         goto int13_fail;
23285 66CD           83C4                   00  add	sp,#..FFF1-..FFF0
23286 66D0           E9         01EF            br 	.FFF1
23287                                           !BCC_EOS
23288                                           ! 4014       }
23289                                           ! 4015       if (( *(((Bit8u *)&AX)+1) == 0x44 ) || ( *(((Bit8u *)&AX)+1) == 0x47 ))
23290                       000066D3            .58B:
23291                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$26+$17] (used reg = )
23292 66D3           8A46         19            mov	al,$19[bp]
23293 66D6           3C                     44  cmp	al,*$44
23294 66D8           74           07            je  	.590
23295                       000066DA            .591:
23296                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$26+$17] (used reg = )
23297 66DA           8A46         19            mov	al,$19[bp]
23298 66DD           3C                     47  cmp	al,*$47
23299 66DF           75           06            jne 	.58F
23300                       000066E1            .590:
23301                                           ! 4016         goto int13_success;
23302 66E1           83C4                   00  add	sp,#..FFEF-..FFF0
23303 66E4           E9         0200            br 	.FFEF
23304                                           !BCC_EOS
23305                                           ! 4017       if (*(((Bit8u *)&AX)+1) == 0x42)
23306                       000066E7            .58F:
23307                                           ! Debug: logeq int = const $42 to unsigned char AX = [S+$26+$17] (used reg = )
23308 66E7           8A46         19            mov	al,$19[bp]
23309 66EA           3C                     42  cmp	al,*$42
23310 66EC           75           36            jne 	.592
23311                       000066EE            .593:
23312                                           ! 4018         status=ata_cmd_data_io(0, device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23313                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23314 66EE           FF76         EE            push	-$12[bp]
23315                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23316 66F1           FF76         F0            push	-$10[bp]
23317                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23318 66F4           FF76         FA            push	-6[bp]
23319 66F7           FF76         F8            push	-8[bp]
23320                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23321 66FA           FF76         FE            push	-2[bp]
23322 66FD           FF76         FC            push	-4[bp]
23323                                           ! Debug: list int = const 0 (used reg = )
23324 6700           31C0                       xor	ax,ax
23325 6702           50                         push	ax
23326                                           ! Debug: list int = const 0 (used reg = )
23327 6703           31C0                       xor	ax,ax
23328 6705           50                         push	ax
23329                                           ! Debug: list int = const 0 (used reg = )
23330 6706           31C0                       xor	ax,ax
23331 6708           50                         push	ax
23332                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23333 6709           FF76         DE            push	-$22[bp]
23334                                           ! Debug: list int = const $20 (used reg = )
23335 670C           B8                   0020  mov	ax,*$20
23336 670F           50                         push	ax
23337                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23338 6710           8A46         DD            mov	al,-$23[bp]
23339 6713           30E4                       xor	ah,ah
23340 6715           50                         push	ax
23341                                           ! Debug: list int = const 0 (used reg = )
23342 6716           31C0                       xor	ax,ax
23343 6718           50                         push	ax
23344                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23345 6719           E8         C264            call	_ata_cmd_data_io
23346 671C           83C4                   1A  add	sp,*$1A
23347                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23348 671F           8846         DC            mov	-$24[bp],al
23349                                           !BCC_EOS
23350                                           ! 4019       else
23351                                           ! 4020         status=ata_cmd_data_io(1, device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23352 6722           EB           35            jmp .594
23353                       00006724            .592:
23354                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23355 6724           FF76         EE            push	-$12[bp]
23356                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23357 6727           FF76         F0            push	-$10[bp]
23358                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23359 672A           FF76         FA            push	-6[bp]
23360 672D           FF76         F8            push	-8[bp]
23361                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23362 6730           FF76         FE            push	-2[bp]
23363 6733           FF76         FC            push	-4[bp]
23364                                           ! Debug: list int = const 0 (used reg = )
23365 6736           31C0                       xor	ax,ax
23366 6738           50                         push	ax
23367                                           ! Debug: list int = const 0 (used reg = )
23368 6739           31C0                       xor	ax,ax
23369 673B           50                         push	ax
23370                                           ! Debug: list int = const 0 (used reg = )
23371 673C           31C0                       xor	ax,ax
23372 673E           50                         push	ax
23373                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23374 673F           FF76         DE            push	-$22[bp]
23375                                           ! Debug: list int = const $30 (used reg = )
23376 6742           B8                   0030  mov	ax,*$30
23377 6745           50                         push	ax
23378                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23379 6746           8A46         DD            mov	al,-$23[bp]
23380 6749           30E4                       xor	ah,ah
23381 674B           50                         push	ax
23382                                           ! Debug: list int = const 1 (used reg = )
23383 674C           B8                   0001  mov	ax,*1
23384 674F           50                         push	ax
23385                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23386 6750           E8         C22D            call	_ata_cmd_data_io
23387 6753           83C4                   1A  add	sp,*$1A
23388                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23389 6756           8846         DC            mov	-$24[bp],al
23390                                           !BCC_EOS
23391                                           ! 4021       count=*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors));
23392                       00006759            .594:
23393                                           ! Debug: eq unsigned short = [+$254] to unsigned short count = [S+$26-$24] (used reg = )
23394 6759           A1         0254            mov	ax,[$254]
23395 675C           8946         DE            mov	-$22[bp],ax
23396                                           !BCC_EOS
23397                                           ! 4022       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23398                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23399 675F           FF76         06            push	6[bp]
23400                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23401 6762           8B46         0C            mov	ax,$C[bp]
23402                                           ! Debug: list unsigned int = ax+2 (used reg = )
23403 6765           40                         inc	ax
23404 6766           40                         inc	ax
23405 6767           50                         push	ax
23406                                           ! Debug: list unsigned short count = [S+$2A-$24] (used reg = )
23407 6768           FF76         DE            push	-$22[bp]
23408                                           ! Debug: func () void = _write_word+0 (used reg = )
23409 676B           E8         9EA0            call	__write_word
23410 676E           83C4                   06  add	sp,*6
23411                                           !BCC_EOS
23412                                           ! 4023       if (status != 0) {
23413                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
23414 6771           8A46         DC            mov	al,-$24[bp]
23415 6774           84C0                       test	al,al
23416 6776           74           25            je  	.595
23417                       00006778            .596:
23418                                           ! 4024         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
23419                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
23420 6778           8A46         DC            mov	al,-$24[bp]
23421 677B           30E4                       xor	ah,ah
23422 677D           50                         push	ax
23423                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
23424 677E           8A46         19            mov	al,$19[bp]
23425 6781           30E4                       xor	ah,ah
23426 6783           50                         push	ax
23427                                           ! Debug: list * char = .597+0 (used reg = )
23428 6784           BB                   D0B7  mov	bx,#.597
23429 6787           53                         push	bx
23430                                           ! Debug: list int = const 4 (used reg = )
23431 6788           B8                   0004  mov	ax,*4
23432 678B           50                         push	ax
23433                                           ! Debug: func () void = bios_printf+0 (used reg = )
23434 678C           E8         A1AA            call	_bios_printf
23435 678F           83C4                   08  add	sp,*8
23436                                           !BCC_EOS
23437                                           ! 4025         *(((Bit8u *)&AX)+1) = (0x0c);
23438                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
23439 6792           B0                     0C  mov	al,*$C
23440 6794           8846         19            mov	$19[bp],al
23441                                           !BCC_EOS
23442                                           ! 4026         goto int13_fail_noah;
23443 6797           83C4                   00  add	sp,#..FFEC-..FFF0
23444 679A           E9         012A            br 	.FFEC
23445                                           !BCC_EOS
23446                                           ! 4027       }
23447                                           ! 4028       goto int13_success;
23448                       0000679D            .595:
23449 679D           83C4                   00  add	sp,#..FFEF-..FFF0
23450 67A0           E9         0144            br 	.FFEF
23451                                           !BCC_EOS
23452                                           ! 4029       break;
23453 67A3           E9         011C            br 	.55B
23454                                           !BCC_EOS
23455                                           ! 4030     case 0x45:
23456                                           ! 4031     case 0x49:
23457                       000067A6            .598:
23458                                           ! 4032       goto int13_success;
23459                       000067A6            .599:
23460 67A6           83C4                   00  add	sp,#..FFEF-..FFF0
23461 67A9           E9         013B            br 	.FFEF
23462                                           !BCC_EOS
23463                                           ! 4033       break;
23464 67AC           E9         0113            br 	.55B
23465                                           !BCC_EOS
23466                                           ! 4034     case 0x46:
23467                                           ! 4035       *(((Bit8u *)&AX)+1) = (0xb2);
23468                       000067AF            .59A:
23469                                           ! Debug: eq int = const $B2 to unsigned char AX = [S+$26+$17] (used reg = )
23470 67AF           B0                     B2  mov	al,#$B2
23471 67B1           8846         19            mov	$19[bp],al
23472                                           !BCC_EOS
23473                                           ! 4036       goto int13_fail_noah;
23474 67B4           83C4                   00  add	sp,#..FFEC-..FFF0
23475 67B7           E9         010D            br 	.FFEC
23476                                           !BCC_EOS
23477                                           ! 4037       break;
23478 67BA           E9         0105            br 	.55B
23479                                           !BCC_EOS
23480                                           ! 4038     case 0x48:
23481                                           ! 4039       if (int13_edd(DS, SI, device))
23482                       000067BD            .59B:
23483                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
23484 67BD           8A46         DD            mov	al,-$23[bp]
23485 67C0           30E4                       xor	ah,ah
23486 67C2           50                         push	ax
23487                                           ! Debug: list unsigned short SI = [S+$28+$A] (used reg = )
23488 67C3           FF76         0C            push	$C[bp]
23489                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23490 67C6           FF76         06            push	6[bp]
23491                                           ! Debug: func () int = int13_edd+0 (used reg = )
23492 67C9           E8         F314            call	_int13_edd
23493 67CC           83C4                   06  add	sp,*6
23494 67CF           85C0                       test	ax,ax
23495 67D1           74           06            je  	.59C
23496                       000067D3            .59D:
23497                                           ! 4040         goto int13_fail;
23498 67D3           83C4                   00  add	sp,#..FFF1-..FFF0
23499 67D6           E9         00E9            br 	.FFF1
23500                                           !BCC_EOS
23501                                           ! 4041       goto int13_success;
23502                       000067D9            .59C:
23503 67D9           83C4                   00  add	sp,#..FFEF-..FFF0
23504 67DC           E9         0108            br 	.FFEF
23505                                           !BCC_EOS
23506                                           ! 4042       break;
23507 67DF           E9         00E0            br 	.55B
23508                                           !BCC_EOS
23509                                           ! 4043     case 0x4e:
23510                                           ! 4044       switch (( AX & 0x00ff )) {
23511                       000067E2            .59E:
23512                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
23513 67E2           8A46         18            mov	al,$18[bp]
23514 67E5           EB           10            jmp .5A1
23515                                           ! 4045         case 0x01:
23516                                           ! 4046         case 0x03:
23517                       000067E7            .5A2:
23518                                           ! 4047         case 0x04:
23519                       000067E7            .5A3:
23520                                           ! 4048         case 0x06:
23521                       000067E7            .5A4:
23522                                           ! 4049           goto int13_success;
23523                       000067E7            .5A5:
23524 67E7           83C4                   00  add	sp,#..FFEF-..FFF0
23525 67EA           E9         00FA            br 	.FFEF
23526                                           !BCC_EOS
23527                                           ! 4050           break;
23528 67ED           EB           1A            jmp .59F
23529                                           !BCC_EOS
23530                                           ! 4051         default:
23531                                           ! 4052           goto int13_fail;
23532                       000067EF            .5A6:
23533 67EF           83C4                   00  add	sp,#..FFF1-..FFF0
23534 67F2           E9         00CD            br 	.FFF1
23535                                           !BCC_EOS
23536                                           ! 4053       }
23537                                           ! 4054       break;
23538 67F5           EB           12            jmp .59F
23539                       000067F7            .5A1:
23540 67F7           2C                     01  sub	al,*1
23541 67F9           74           EC            je 	.5A2
23542 67FB           2C                     02  sub	al,*2
23543 67FD           74           E8            je 	.5A3
23544 67FF           2C                     01  sub	al,*1
23545 6801           74           E4            je 	.5A4
23546 6803           2C                     02  sub	al,*2
23547 6805           74           E0            je 	.5A5
23548 6807           EB           E6            jmp	.5A6
23549                       00006809            .59F:
23550 6809           E9         00B6            br 	.55B
23551                                           !BCC_EOS
23552                                           ! 4055     case 0x09:
23553                                           ! 4056     case 0x0c:
23554                       0000680C            .5A7:
23555                                           ! 4057     case 0x0d:
23556                       0000680C            .5A8:
23557                                           ! 4058     case 0x11:
23558                       0000680C            .5A9:
23559                                           ! 4059     case 0x14:
23560                       0000680C            .5AA:
23561                                           ! 4060       bios_printf(4, "int13_harddisk: functio
23562                       0000680C            .5AB:
23563                                           ! 4060 n %02xh unimplemented, returns success\n", *(((Bit8u *)&AX)+1));
23564                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23565 680C           8A46         19            mov	al,$19[bp]
23566 680F           30E4                       xor	ah,ah
23567 6811           50                         push	ax
23568                                           ! Debug: list * char = .5AC+0 (used reg = )
23569 6812           BB                   D078  mov	bx,#.5AC
23570 6815           53                         push	bx
23571                                           ! Debug: list int = const 4 (used reg = )
23572 6816           B8                   0004  mov	ax,*4
23573 6819           50                         push	ax
23574                                           ! Debug: func () void = bios_printf+0 (used reg = )
23575 681A           E8         A11C            call	_bios_printf
23576 681D           83C4                   06  add	sp,*6
23577                                           !BCC_EOS
23578                                           ! 4061       goto int13_success;
23579 6820           83C4                   00  add	sp,#..FFEF-..FFF0
23580 6823           E9         00C1            br 	.FFEF
23581                                           !BCC_EOS
23582                                           ! 4062       break;
23583 6826           E9         0099            br 	.55B
23584                                           !BCC_EOS
23585                                           ! 4063     case 0x0a:
23586                                           ! 4064     case 0x0b:
23587                       00006829            .5AD:
23588                                           ! 4065     case 0x18:
23589                       00006829            .5AE:
23590                                           ! 4066     case 0x50:
23591                       00006829            .5AF:
23592                                           ! 4067     default:
23593                       00006829            .5B0:
23594                                           ! 4068       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
23595                       00006829            .5B1:
23596                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23597 6829           8A46         19            mov	al,$19[bp]
23598 682C           30E4                       xor	ah,ah
23599 682E           50                         push	ax
23600                                           ! Debug: list * char = .5B2+0 (used reg = )
23601 682F           BB                   D03E  mov	bx,#.5B2
23602 6832           53                         push	bx
23603                                           ! Debug: list int = const 4 (used reg = )
23604 6833           B8                   0004  mov	ax,*4
23605 6836           50                         push	ax
23606                                           ! Debug: func () void = bios_printf+0 (used reg = )
23607 6837           E8         A0FF            call	_bios_printf
23608 683A           83C4                   06  add	sp,*6
23609                                           !BCC_EOS
23610                                           ! 4069       goto int13_fail;
23611 683D           83C4                   00  add	sp,#..FFF1-..FFF0
23612 6840           E9         007F            jmp .FFF1
23613                                           !BCC_EOS
23614                                           ! 4070       break;
23615 6843           EB           7D            jmp .55B
23616                                           !BCC_EOS
23617                                           ! 4071   }
23618                                           ! 4072 int13_fail:
23619 6845           EB           7B            jmp .55B
23620                       00006847            .55D:
23621 6847           2C                     00  sub	al,*0
23622 6849           72           DE            jb 	.5B1
23623 684B           3C                     18  cmp	al,*$18
23624 684D           77           3D            ja  	.5B3
23625 684F           30E4                       xor	ah,ah
23626 6851           D1E0                       shl	ax,*1
23627 6853           89C3                       mov	bx,ax
23628 6855           2E                         seg	cs
23629 6856           FFA7       685A            br	.5B4[bx]
23630                       0000685A            .5B4:
23631 685A                      61D9            .word	.55E
23632 685C                      61ED            .word	.55F
23633 685E                      622D            .word	.563
23634 6860                      622D            .word	.564
23635 6862                      622D            .word	.565
23636 6864                      6473            .word	.57B
23637 6866                      6829            .word	.5B1
23638 6868                      6829            .word	.5B1
23639 686A                      648E            .word	.57D
23640 686C                      680C            .word	.5A7
23641 686E                      6829            .word	.5AD
23642 6870                      6829            .word	.5AE
23643 6872                      680C            .word	.5A8
23644 6874                      680C            .word	.5A9
23645 6876                      6829            .word	.5B1
23646 6878                      6829            .word	.5B1
23647 687A                      650E            .word	.57E
23648 687C                      680C            .word	.5AA
23649 687E                      6829            .word	.5B1
23650 6880                      6829            .word	.5B1
23651 6882                      680C            .word	.5AB
23652 6884                      654A            .word	.582
23653 6886                      6829            .word	.5B1
23654 6888                      6829            .word	.5B1
23655 688A                      6829            .word	.5AF
23656                       0000688C            .5B3:
23657 688C           2C                     41  sub	al,*$41
23658 688E           72           99            jb 	.5B1
23659 6890           3C                     0F  cmp	al,*$F
23660 6892           77           2B            ja  	.5B5
23661 6894           30E4                       xor	ah,ah
23662 6896           D1E0                       shl	ax,*1
23663 6898           89C3                       mov	bx,ax
23664 689A           2E                         seg	cs
23665 689B           FFA7       689F            br	.5B6[bx]
23666                       0000689F            .5B6:
23667 689F                      65C9            .word	.583
23668 68A1                      65E3            .word	.584
23669 68A3                      65E3            .word	.585
23670 68A5                      65E3            .word	.586
23671 68A7                      67A6            .word	.598
23672 68A9                      67AF            .word	.59A
23673 68AB                      65E3            .word	.587
23674 68AD                      67BD            .word	.59B
23675 68AF                      67A6            .word	.599
23676 68B1                      6829            .word	.5B1
23677 68B3                      6829            .word	.5B1
23678 68B5                      6829            .word	.5B1
23679 68B7                      6829            .word	.5B1
23680 68B9                      67E2            .word	.59E
23681 68BB                      6829            .word	.5B1
23682 68BD                      6829            .word	.5B0
23683                       000068BF            .5B5:
23684 68BF           E9         FF67            br 	.5B1
23685                       000068C2            .55B:
23686                       FFFFFFDA            ..FFF0	=	-$26
23687                       000068C2            .FFF1:
23688                       FFFFFFDA            ..FFF1	=	-$26
23689                                           ! 4073   *(((Bit8u *)&AX)+1) = (0x01);
23690                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$26+$17] (used reg = )
23691 68C2           B0                     01  mov	al,*1
23692 68C4           8846         19            mov	$19[bp],al
23693                                           !BCC_EOS
23694                                           ! 4074 int13_fail_noah:
23695                       000068C7            .FFEC:
23696                       FFFFFFDA            ..FFEC	=	-$26
23697                                           ! 4075   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
23698                                           ! Debug: list int = const $40 (used reg = )
23699 68C7           B8                   0040  mov	ax,*$40
23700 68CA           50                         push	ax
23701                                           ! Debug: list int = const $74 (used reg = )
23702 68CB           B8                   0074  mov	ax,*$74
23703 68CE           50                         push	ax
23704                                           ! Debug: list unsigned char AX = [S+$2A+$17] (used reg = )
23705 68CF           8A46         19            mov	al,$19[bp]
23706 68D2           30E4                       xor	ah,ah
23707 68D4           50                         push	ax
23708                                           ! Debug: func () void = _write_byte+0 (used reg = )
23709 68D5           E8         9D23            call	__write_byte
23710 68D8           83C4                   06  add	sp,*6
23711                                           !BCC_EOS
23712                                           ! 4076 int13_fail_nostatus:
23713                       000068DB            .FFEE:
23714                       FFFFFFDA            ..FFEE	=	-$26
23715                                           ! 4077   FLAGS |= 0x0001;
23716                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23717 68DB           8B46         1E            mov	ax,$1E[bp]
23718 68DE           0C                     01  or	al,*1
23719 68E0           8946         1E            mov	$1E[bp],ax
23720                                           !BCC_EOS
23721                                           ! 4078   return;
23722 68E3           89EC                       mov	sp,bp
23723 68E5           5D                         pop	bp
23724 68E6           C3                         ret
23725                                           !BCC_EOS
23726                                           ! 4079 int13_success:
23727                       000068E7            .FFEF:
23728                       FFFFFFDA            ..FFEF	=	-$26
23729                                           ! 4080   *(((Bit8u *)&AX)+1) = (0x00);
23730                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$17] (used reg = )
23731 68E7           30C0                       xor	al,al
23732 68E9           8846         19            mov	$19[bp],al
23733                                           !BCC_EOS
23734                                           ! 4081 int13_success_noah:
23735                       000068EC            .FFED:
23736                       FFFFFFDA            ..FFED	=	-$26
23737                                           ! 4082   _write_byte(0x00, 0x0074, 0x0040);
23738                                           ! Debug: list int = const $40 (used reg = )
23739 68EC           B8                   0040  mov	ax,*$40
23740 68EF           50                         push	ax
23741                                           ! Debug: list int = const $74 (used reg = )
23742 68F0           B8                   0074  mov	ax,*$74
23743 68F3           50                         push	ax
23744                                           ! Debug: list int = const 0 (used reg = )
23745 68F4           31C0                       xor	ax,ax
23746 68F6           50                         push	ax
23747                                           ! Debug: func () void = _write_byte+0 (used reg = )
23748 68F7           E8         9D01            call	__write_byte
23749 68FA           83C4                   06  add	sp,*6
23750                                           !BCC_EOS
23751                                           ! 4083   FLAGS &= 0xfffe;
23752                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23753 68FD           8B46         1E            mov	ax,$1E[bp]
23754 6900           24                     FE  and	al,#$FE
23755 6902           8946         1E            mov	$1E[bp],ax
23756                                           !BCC_EOS
23757                                           ! 4084 }
23758 6905           89EC                       mov	sp,bp
23759 6907           5D                         pop	bp
23760 6908           C3                         ret
23761                                           ! 4085   void
23762                                           ! Register BX used in function int13_harddisk
23763                                           ! 4086 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23764                                           ! 4087   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23765                                           export	_int13_cdrom
23766                       00006909            _int13_cdrom:
23767                                           !BCC_EOS
23768                                           ! 4088 {
23769                                           ! 4089   Bit8u device, status, locks;
23770                                           !BCC_EOS
23771                                           ! 4090   Bit8u atacmd[12];
23772                                           !BCC_EOS
23773                                           ! 4091   Bit32u lba;
23774                                           !BCC_EOS
23775                                           ! 4092   Bit16u count, segment, offset, i, size;
23776                                           !BCC_EOS
23777                                           ! 4093   ;
23778 6909           55                         push	bp
23779 690A           89E5                       mov	bp,sp
23780 690C           83C4                   E2  add	sp,*-$1E
23781                                           !BCC_EOS
23782                                           ! 4094   _write_byte(0x00, 0x0074, 0x0040);
23783                                           ! Debug: list int = const $40 (used reg = )
23784 690F           B8                   0040  mov	ax,*$40
23785 6912           50                         push	ax
23786                                           ! Debug: list int = const $74 (used reg = )
23787 6913           B8                   0074  mov	ax,*$74
23788 6916           50                         push	ax
23789                                           ! Debug: list int = const 0 (used reg = )
23790 6917           31C0                       xor	ax,ax
23791 6919           50                         push	ax
23792                                           ! Debug: func () void = _write_byte+0 (used reg = )
23793 691A           E8         9CDE            call	__write_byte
23794 691D           83C4                   06  add	sp,*6
23795                                           !BCC_EOS
23796                                           ! 4095   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
23797                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23798 6920           8A46         10            mov	al,$10[bp]
23799                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
23800 6923           3C                     E0  cmp	al,#$E0
23801 6925           72           07            jb  	.5B8
23802                       00006927            .5B9:
23803                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23804 6927           8A46         10            mov	al,$10[bp]
23805                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
23806 692A           3C                     E8  cmp	al,#$E8
23807 692C           72           20            jb  	.5B7
23808                       0000692E            .5B8:
23809                                           ! 4096     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23810                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23811 692E           8A46         10            mov	al,$10[bp]
23812                                           ! Debug: list unsigned char = al+0 (used reg = )
23813 6931           30E4                       xor	ah,ah
23814 6933           50                         push	ax
23815                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23816 6934           8A46         19            mov	al,$19[bp]
23817 6937           30E4                       xor	ah,ah
23818 6939           50                         push	ax
23819                                           ! Debug: list * char = .5BA+0 (used reg = )
23820 693A           BB                   D00A  mov	bx,#.5BA
23821 693D           53                         push	bx
23822                                           ! Debug: list int = const 4 (used reg = )
23823 693E           B8                   0004  mov	ax,*4
23824 6941           50                         push	ax
23825                                           ! Debug: func () void = bios_printf+0 (used reg = )
23826 6942           E8         9FF4            call	_bios_printf
23827 6945           83C4                   08  add	sp,*8
23828                                           !BCC_EOS
23829                                           ! 4097     goto int13_fail;
23830 6948           83C4                   00  add	sp,#..FFEB+$20
23831 694B           E9         0469            br 	.FFEB
23832                                           !BCC_EOS
23833                                           ! 4098   }
23834                                           ! 4099   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]));
23835                       0000694E            .5B7:
23836                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23837 694E           8A46         10            mov	al,$10[bp]
23838                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
23839 6951           30E4                       xor	ah,ah
23840                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
23841 6953           05                   FF20  add	ax,#-$E0
23842 6956           89C3                       mov	bx,ax
23843                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
23844                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
23845                                           ! Debug: eq unsigned char = [bx+$23C] to unsigned char device = [S+$20-3] (used reg = )
23846 6958           8A87       023C            mov	al,$23C[bx]
23847 695C           8846         FF            mov	-1[bp],al
23848                                           !BCC_EOS
23849                                           ! 4100   if (device >= (4*2)) {
23850                                           ! Debug: ge int = const 8 to unsigned char device = [S+$20-3] (used reg = )
23851 695F           8A46         FF            mov	al,-1[bp]
23852 6962           3C                     08  cmp	al,*8
23853 6964           72           20            jb  	.5BB
23854                       00006966            .5BC:
23855                                           ! 4101     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23856                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23857 6966           8A46         10            mov	al,$10[bp]
23858                                           ! Debug: list unsigned char = al+0 (used reg = )
23859 6969           30E4                       xor	ah,ah
23860 696B           50                         push	ax
23861                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23862 696C           8A46         19            mov	al,$19[bp]
23863 696F           30E4                       xor	ah,ah
23864 6971           50                         push	ax
23865                                           ! Debug: list * char = .5BD+0 (used reg = )
23866 6972           BB                   CFCF  mov	bx,#.5BD
23867 6975           53                         push	bx
23868                                           ! Debug: list int = const 4 (used reg = )
23869 6976           B8                   0004  mov	ax,*4
23870 6979           50                         push	ax
23871                                           ! Debug: func () void = bios_printf+0 (used reg = )
23872 697A           E8         9FBC            call	_bios_printf
23873 697D           83C4                   08  add	sp,*8
23874                                           !BCC_EOS
23875                                           ! 4102     goto int13_fail;
23876 6980           83C4                   00  add	sp,#..FFEB+$20
23877 6983           E9         0431            br 	.FFEB
23878                                           !BCC_EOS
23879                                           ! 4103   }
23880                                           ! 4104   switch (*(((Bit8u *)&AX)+1)) {
23881                       00006986            .5BB:
23882 6986           8A46         19            mov	al,$19[bp]
23883 6989           E9         03B0            br 	.5C0
23884                                           ! 4105     case 0x00:
23885                                           ! 4106     case 0x09:
23886                       0000698C            .5C1:
23887                                           ! 4107     case 0x0c:
23888                       0000698C            .5C2:
23889                                           ! 4108     case 0x0d:
23890                       0000698C            .5C3:
23891                                           ! 4109     case 0x10:
23892                       0000698C            .5C4:
23893                                           ! 4110     case 0x11:
23894                       0000698C            .5C5:
23895                                           ! 4111     case 0x14:
23896                       0000698C            .5C6:
23897                                           ! 4112     case 0x16:
23898                       0000698C            .5C7:
23899                                           ! 4113       goto int13_success;
23900                       0000698C            .5C8:
23901 698C           83C4                   00  add	sp,#..FFE9-..FFEA
23902 698F           E9         044A            br 	.FFE9
23903                                           !BCC_EOS
23904                                           ! 4114       break;
23905 6992           E9         0422            br 	.5BE
23906                                           !BCC_EOS
23907                                           ! 4115     case 0x03:
23908                                           ! 4116     case 0x05:
23909                       00006995            .5C9:
23910                                           ! 4117     case 0x43:
23911                       00006995            .5CA:
23912                                           ! 4118       *(((Bit8u *)&AX)+1) = (0x03);
23913                       00006995            .5CB:
23914                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$20+$17] (used reg = )
23915 6995           B0                     03  mov	al,*3
23916 6997           8846         19            mov	$19[bp],al
23917                                           !BCC_EOS
23918                                           ! 4119       goto int13_fail_noah;
23919 699A           83C4                   00  add	sp,#..FFE8-..FFEA
23920 699D           E9         041C            br 	.FFE8
23921                                           !BCC_EOS
23922                                           ! 4120       break;
23923 69A0           E9         0414            br 	.5BE
23924                                           !BCC_EOS
23925                                           ! 4121     case 0x01:
23926                                           ! 4122       status = _read_byte(0x0074, 0x0040);
23927                       000069A3            .5CC:
23928                                           ! Debug: list int = const $40 (used reg = )
23929 69A3           B8                   0040  mov	ax,*$40
23930 69A6           50                         push	ax
23931                                           ! Debug: list int = const $74 (used reg = )
23932 69A7           B8                   0074  mov	ax,*$74
23933 69AA           50                         push	ax
23934                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
23935 69AB           E8         9C31            call	__read_byte
23936 69AE           83C4                   04  add	sp,*4
23937                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-4] (used reg = )
23938 69B1           8846         FE            mov	-2[bp],al
23939                                           !BCC_EOS
23940                                           ! 4123       *(((Bit8u *)&AX)+1) = (status);
23941                                           ! Debug: eq unsigned char status = [S+$20-4] to unsigned char AX = [S+$20+$17] (used reg = )
23942 69B4           8A46         FE            mov	al,-2[bp]
23943 69B7           8846         19            mov	$19[bp],al
23944                                           !BCC_EOS
23945                                           ! 4124       _write_byte(0, 0x0074, 0x0040);
23946                                           ! Debug: list int = const $40 (used reg = )
23947 69BA           B8                   0040  mov	ax,*$40
23948 69BD           50                         push	ax
23949                                           ! Debug: list int = const $74 (used reg = )
23950 69BE           B8                   0074  mov	ax,*$74
23951 69C1           50                         push	ax
23952                                           ! Debug: list int = const 0 (used reg = )
23953 69C2           31C0                       xor	ax,ax
23954 69C4           50                         push	ax
23955                                           ! Debug: func () void = _write_byte+0 (used reg = )
23956 69C5           E8         9C33            call	__write_byte
23957 69C8           83C4                   06  add	sp,*6
23958                                           !BCC_EOS
23959                                           ! 4125       if (status) goto int13_fail_nostatus;
23960 69CB           8A46         FE            mov	al,-2[bp]
23961 69CE           84C0                       test	al,al
23962 69D0           74           08            je  	.5CD
23963                       000069D2            .5CE:
23964 69D2           83C4                   00  add	sp,#..FFE7-..FFEA
23965 69D5           E9         03F8            br 	.FFE7
23966                                           !BCC_EOS
23967                                           ! 4126       else goto int13_success_noah;
23968 69D8           EB           06            jmp .5CF
23969                       000069DA            .5CD:
23970 69DA           83C4                   00  add	sp,#..FFE6-..FFEA
23971 69DD           E9         0401            br 	.FFE6
23972                                           !BCC_EOS
23973                                           ! 4127       break;
23974                       000069E0            .5CF:
23975 69E0           E9         03D4            br 	.5BE
23976                                           !BCC_EOS
23977                                           ! 4128     case 0x15:
23978                                           ! 4129       *(((Bit8u *)&AX)+1) = (0x02);
23979                       000069E3            .5D0:
23980                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$20+$17] (used reg = )
23981 69E3           B0                     02  mov	al,*2
23982 69E5           8846         19            mov	$19[bp],al
23983                                           !BCC_EOS
23984                                           ! 4130       goto int13_fail_noah;
23985 69E8           83C4                   00  add	sp,#..FFE8-..FFEA
23986 69EB           E9         03CE            br 	.FFE8
23987                                           !BCC_EOS
23988                                           ! 4131       break;
23989 69EE           E9         03C6            br 	.5BE
23990                                           !BCC_EOS
23991                                           ! 4132     case 0x41:
23992                                           ! 4133       BX=0xaa55;
23993                       000069F1            .5D1:
23994                                           ! 4133 
23995                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$20+$10] (used reg = )
23996 69F1           B8                   AA55  mov	ax,#$AA55
23997 69F4           8946         12            mov	$12[bp],ax
23998                                           !BCC_EOS
23999                                           ! 4134       *(((Bit8u *)&AX)+1) = (0x30);
24000                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$20+$17] (used reg = )
24001 69F7           B0                     30  mov	al,*$30
24002 69F9           8846         19            mov	$19[bp],al
24003                                           !BCC_EOS
24004                                           ! 4135       CX=0x0007;
24005                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$20+$14] (used reg = )
24006 69FC           B8                   0007  mov	ax,*7
24007 69FF           8946         16            mov	$16[bp],ax
24008                                           !BCC_EOS
24009                                           ! 4136       goto int13_success_noah;
24010 6A02           83C4                   00  add	sp,#..FFE6-..FFEA
24011 6A05           E9         03D9            br 	.FFE6
24012                                           !BCC_EOS
24013                                           ! 4137       break;
24014 6A08           E9         03AC            br 	.5BE
24015                                           !BCC_EOS
24016                                           ! 4138     case 0x42:
24017                                           ! 4139     case 0x44:
24018                       00006A0B            .5D2:
24019                                           ! 4140     case 0x47:
24020                       00006A0B            .5D3:
24021                                           ! 4141       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24022                       00006A0B            .5D4:
24023                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24024 6A0B           FF76         06            push	6[bp]
24025                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24026 6A0E           8B46         0C            mov	ax,$C[bp]
24027                                           ! Debug: list unsigned int = ax+2 (used reg = )
24028 6A11           40                         inc	ax
24029 6A12           40                         inc	ax
24030 6A13           50                         push	ax
24031                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24032 6A14           E8         9BD6            call	__read_word
24033 6A17           83C4                   04  add	sp,*4
24034                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24035 6A1A           8946         EA            mov	-$16[bp],ax
24036                                           !BCC_EOS
24037                                           ! 4142       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
24038                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24039 6A1D           FF76         06            push	6[bp]
24040                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
24041 6A20           8B46         0C            mov	ax,$C[bp]
24042                                           ! Debug: list unsigned int = ax+6 (used reg = )
24043 6A23           05                   0006  add	ax,*6
24044 6A26           50                         push	ax
24045                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24046 6A27           E8         9BC3            call	__read_word
24047 6A2A           83C4                   04  add	sp,*4
24048                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$20-$1A] (used reg = )
24049 6A2D           8946         E8            mov	-$18[bp],ax
24050                                           !BCC_EOS
24051                                           ! 4143       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
24052                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24053 6A30           FF76         06            push	6[bp]
24054                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
24055 6A33           8B46         0C            mov	ax,$C[bp]
24056                                           ! Debug: list unsigned int = ax+4 (used reg = )
24057 6A36           05                   0004  add	ax,*4
24058 6A39           50                         push	ax
24059                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24060 6A3A           E8         9BB0            call	__read_word
24061 6A3D           83C4                   04  add	sp,*4
24062                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$20-$1C] (used reg = )
24063 6A40           8946         E6            mov	-$1A[bp],ax
24064                                           !BCC_EOS
24065                                           ! 4144       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
24066                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24067 6A43           FF76         06            push	6[bp]
24068                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
24069 6A46           8B46         0C            mov	ax,$C[bp]
24070                                           ! Debug: list unsigned int = ax+$C (used reg = )
24071 6A49           05                   000C  add	ax,*$C
24072 6A4C           50                         push	ax
24073                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24074 6A4D           E8         9606            call	__read_dword
24075 6A50           89D3                       mov	bx,dx
24076 6A52           83C4                   04  add	sp,*4
24077                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24078 6A55           8946         EC            mov	-$14[bp],ax
24079 6A58           895E         EE            mov	-$12[bp],bx
24080                                           !BCC_EOS
24081                                           ! 4145       if (lba != 0L) {
24082                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$20-$16] (used reg = )
24083                                           ! Debug: expression subtree swapping
24084 6A5B           31C0                       xor	ax,ax
24085 6A5D           31DB                       xor	bx,bx
24086 6A5F           53                         push	bx
24087 6A60           50                         push	ax
24088 6A61           8B46         EC            mov	ax,-$14[bp]
24089 6A64           8B5E         EE            mov	bx,-$12[bp]
24090 6A67           8D7E         DE            lea	di,-2+..FFEA[bp]
24091 6A6A           E8         962F            call	lcmpul
24092 6A6D           8D66         E2            lea	sp,2+..FFEA[bp]
24093 6A70           74           1A            je  	.5D5
24094                       00006A72            .5D6:
24095                                           ! 4146         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",*(((Bit8u *)&AX)+1));
24096                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24097 6A72           8A46         19            mov	al,$19[bp]
24098 6A75           30E4                       xor	ah,ah
24099 6A77           50                         push	ax
24100                                           ! Debug: list * char = .5D7+0 (used reg = )
24101 6A78           BB                   CF9D  mov	bx,#.5D7
24102 6A7B           53                         push	bx
24103                                           ! Debug: list int = const 7 (used reg = )
24104 6A7C           B8                   0007  mov	ax,*7
24105 6A7F           50                         push	ax
24106                                           ! Debug: func () void = bios_printf+0 (used reg = )
24107 6A80           E8         9EB6            call	_bios_printf
24108 6A83           83C4                   06  add	sp,*6
24109                                           !BCC_EOS
24110                                           ! 4147         goto int13_fail;
24111 6A86           83C4                   00  add	sp,#..FFEB-..FFEA
24112 6A89           E9         032B            br 	.FFEB
24113                                           !BCC_EOS
24114                                           ! 4148       }
24115                                           ! 4149       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
24116                       00006A8C            .5D5:
24117                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24118 6A8C           FF76         06            push	6[bp]
24119                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
24120 6A8F           8B46         0C            mov	ax,$C[bp]
24121                                           ! Debug: list unsigned int = ax+8 (used reg = )
24122 6A92           05                   0008  add	ax,*8
24123 6A95           50                         push	ax
24124                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24125 6A96           E8         95BD            call	__read_dword
24126 6A99           89D3                       mov	bx,dx
24127 6A9B           83C4                   04  add	sp,*4
24128                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24129 6A9E           8946         EC            mov	-$14[bp],ax
24130 6AA1           895E         EE            mov	-$12[bp],bx
24131                                           !BCC_EOS
24132                                           ! 4150       if ((*(((Bit8u *)&AX)+1) == 0x44) || (*(((Bit8u *)&AX)+1) == 0x47))
24133                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$20+$17] (used reg = )
24134 6AA4           8A46         19            mov	al,$19[bp]
24135 6AA7           3C                     44  cmp	al,*$44
24136 6AA9           74           07            je  	.5D9
24137                       00006AAB            .5DA:
24138                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$20+$17] (used reg = )
24139 6AAB           8A46         19            mov	al,$19[bp]
24140 6AAE           3C                     47  cmp	al,*$47
24141 6AB0           75           06            jne 	.5D8
24142                       00006AB2            .5D9:
24143                                           ! 4151         goto int13_success;
24144 6AB2           83C4                   00  add	sp,#..FFE9-..FFEA
24145 6AB5           E9         0324            br 	.FFE9
24146                                           !BCC_EOS
24147                                           ! 4152       _memsetb(0,atacmd,get_SS(),12);
24148                       00006AB8            .5D8:
24149                                           ! Debug: list int = const $C (used reg = )
24150 6AB8           B8                   000C  mov	ax,*$C
24151 6ABB           50                         push	ax
24152                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24153 6ABC           E8         9B9B            call	_get_SS
24154                                           ! Debug: list unsigned short = ax+0 (used reg = )
24155 6ABF           50                         push	ax
24156                                           ! Debug: list * unsigned char atacmd = S+$24-$11 (used reg = )
24157 6AC0           8D5E         F1            lea	bx,-$F[bp]
24158 6AC3           53                         push	bx
24159                                           ! Debug: list int = const 0 (used reg = )
24160 6AC4           31C0                       xor	ax,ax
24161 6AC6           50                         push	ax
24162                                           ! Debug: func () void = _memsetb+0 (used reg = )
24163 6AC7           E8         9536            call	__memsetb
24164 6ACA           83C4                   08  add	sp,*8
24165                                           !BCC_EOS
24166                                           ! 4153       atacmd[0]=0x28;
24167                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$20-$11] (used reg = )
24168 6ACD           B0                     28  mov	al,*$28
24169 6ACF           8846         F1            mov	-$F[bp],al
24170                                           !BCC_EOS
24171                                           ! 4154       atacmd[7]=*(((Bit8u *)&count)+1);
24172                                           ! Debug: eq unsigned char count = [S+$20-$17] to unsigned char atacmd = [S+$20-$A] (used reg = )
24173 6AD2           8A46         EB            mov	al,-$15[bp]
24174 6AD5           8846         F8            mov	-8[bp],al
24175                                           !BCC_EOS
24176                                           ! 4155       atacmd[8]=*((Bit8u *)&count);
24177                                           ! Debug: eq unsigned char count = [S+$20-$18] to unsigned char atacmd = [S+$20-9] (used reg = )
24178 6AD8           8A46         EA            mov	al,-$16[bp]
24179 6ADB           8846         F9            mov	-7[bp],al
24180                                           !BCC_EOS
24181                                           ! 4156       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
24182                                           ! Debug: eq unsigned char lba = [S+$20-$13] to unsigned char atacmd = [S+$20-$F] (used reg = )
24183 6ADE           8A46         EF            mov	al,-$11[bp]
24184 6AE1           8846         F3            mov	-$D[bp],al
24185                                           !BCC_EOS
24186                                           ! 4157       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
24187                                           ! Debug: eq unsigned char lba = [S+$20-$14] to unsigned char atacmd = [S+$20-$E] (used reg = )
24188 6AE4           8A46         EE            mov	al,-$12[bp]
24189 6AE7           8846         F4            mov	-$C[bp],al
24190                                           !BCC_EOS
24191                                           ! 4158       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
24192                                           ! Debug: eq unsigned char lba = [S+$20-$15] to unsigned char atacmd = [S+$20-$D] (used reg = )
24193 6AEA           8A46         ED            mov	al,-$13[bp]
24194 6AED           8846         F5            mov	-$B[bp],al
24195                                           !BCC_EOS
24196                                           ! 4159       atacmd[5]=*((Bit8u *)&lba);
24197                                           ! Debug: eq unsigned char lba = [S+$20-$16] to unsigned char atacmd = [S+$20-$C] (used reg = )
24198 6AF0           8A46         EC            mov	al,-$14[bp]
24199 6AF3           8846         F6            mov	-$A[bp],al
24200                                           !BCC_EOS
24201                                           ! 4160       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
24202                                           ! Debug: list unsigned short offset = [S+$20-$1C] (used reg = )
24203 6AF6           FF76         E6            push	-$1A[bp]
24204                                           ! Debug: list unsigned short segment = [S+$22-$1A] (used reg = )
24205 6AF9           FF76         E8            push	-$18[bp]
24206                                           ! Debug: list int = const 1 (used reg = )
24207 6AFC           B8                   0001  mov	ax,*1
24208 6AFF           50                         push	ax
24209                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$26-$18] (used reg = )
24210 6B00           8B46         EA            mov	ax,-$16[bp]
24211 6B03           31DB                       xor	bx,bx
24212                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
24213 6B05           53                         push	bx
24214 6B06           50                         push	ax
24215 6B07           B8                   0800  mov	ax,#$800
24216 6B0A           31DB                       xor	bx,bx
24217 6B0C           53                         push	bx
24218 6B0D           50                         push	ax
24219 6B0E           8B46         D8            mov	ax,-8+..FFEA[bp]
24220 6B11           8B5E         DA            mov	bx,-6+..FFEA[bp]
24221 6B14           8D7E         D4            lea	di,-$C+..FFEA[bp]
24222 6B17           E8         95A0            call	lmulul
24223 6B1A           83C4                   08  add	sp,*8
24224                                           ! Debug: list unsigned long = bx+0 (used reg = )
24225 6B1D           53                         push	bx
24226 6B1E           50                         push	ax
24227                                           ! Debug: list int = const 0 (used reg = )
24228 6B1F           31C0                       xor	ax,ax
24229 6B21           50                         push	ax
24230                                           ! Debug: list * unsigned char atacmd = S+$2C-$11 (used reg = )
24231 6B22           8D5E         F1            lea	bx,-$F[bp]
24232 6B25           53                         push	bx
24233                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24234 6B26           E8         9B31            call	_get_SS
24235                                           ! Debug: list unsigned short = ax+0 (used reg = )
24236 6B29           50                         push	ax
24237                                           ! Debug: list int = const $C (used reg = )
24238 6B2A           B8                   000C  mov	ax,*$C
24239 6B2D           50                         push	ax
24240                                           ! Debug: list unsigned char device = [S+$32-3] (used reg = )
24241 6B2E           8A46         FF            mov	al,-1[bp]
24242 6B31           30E4                       xor	ah,ah
24243 6B33           50                         push	ax
24244                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
24245 6B34           E8         C20E            call	_ata_cmd_packet
24246 6B37           83C4                   14  add	sp,*$14
24247                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$20-4] (used reg = )
24248 6B3A           8846         FE            mov	-2[bp],al
24249                                           !BCC_EOS
24250                                           ! 4161       count = (Bit16u)(*((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) >> 11);
24251                                           ! Debug: sr int = const $B to unsigned long = [+$256] (used reg = )
24252 6B3D           A1         0256            mov	ax,[$256]
24253 6B40           8B1E       0258            mov	bx,[$258]
24254 6B44           88E0                       mov	al,ah
24255 6B46           88DC                       mov	ah,bl
24256 6B48           88FB                       mov	bl,bh
24257 6B4A           28FF                       sub	bh,bh
24258 6B4C           BF                   0003  mov	di,*3
24259 6B4F           E8         95A8            call	lsrul
24260                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
24261                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24262 6B52           8946         EA            mov	-$16[bp],ax
24263                                           !BCC_EOS
24264                                           ! 4162       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24265                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24266 6B55           FF76         06            push	6[bp]
24267                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24268 6B58           8B46         0C            mov	ax,$C[bp]
24269                                           ! Debug: list unsigned int = ax+2 (used reg = )
24270 6B5B           40                         inc	ax
24271 6B5C           40                         inc	ax
24272 6B5D           50                         push	ax
24273                                           ! Debug: list unsigned short count = [S+$24-$18] (used reg = )
24274 6B5E           FF76         EA            push	-$16[bp]
24275                                           ! Debug: func () void = _write_word+0 (used reg = )
24276 6B61           E8         9AAA            call	__write_word
24277 6B64           83C4                   06  add	sp,*6
24278                                           !BCC_EOS
24279                                           ! 4163       if (status != 0) {
24280                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24281 6B67           8A46         FE            mov	al,-2[bp]
24282 6B6A           84C0                       test	al,al
24283 6B6C           74           25            je  	.5DB
24284                       00006B6E            .5DC:
24285                                           ! 4164         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",*(((Bit8u *)&AX)+1),status);
24286                                           ! Debug: list unsigned char status = [S+$20-4] (used reg = )
24287 6B6E           8A46         FE            mov	al,-2[bp]
24288 6B71           30E4                       xor	ah,ah
24289 6B73           50                         push	ax
24290                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
24291 6B74           8A46         19            mov	al,$19[bp]
24292 6B77           30E4                       xor	ah,ah
24293 6B79           50                         push	ax
24294                                           ! Debug: list * char = .5DD+0 (used reg = )
24295 6B7A           BB                   CF72  mov	bx,#.5DD
24296 6B7D           53                         push	bx
24297                                           ! Debug: list int = const 4 (used reg = )
24298 6B7E           B8                   0004  mov	ax,*4
24299 6B81           50                         push	ax
24300                                           ! Debug: func () void = bios_printf+0 (used reg = )
24301 6B82           E8         9DB4            call	_bios_printf
24302 6B85           83C4                   08  add	sp,*8
24303                                           !BCC_EOS
24304                                           ! 4165         *(((Bit8u *)&AX)+1) = (0x0c);
24305                                           ! Debug: eq int = const $C to unsigned char AX = [S+$20+$17] (used reg = )
24306 6B88           B0                     0C  mov	al,*$C
24307 6B8A           8846         19            mov	$19[bp],al
24308                                           !BCC_EOS
24309                                           ! 4166         goto int13_fail_noah;
24310 6B8D           83C4                   00  add	sp,#..FFE8-..FFEA
24311 6B90           E9         0229            br 	.FFE8
24312                                           !BCC_EOS
24313                                           ! 4167       }
24314                                           ! 4168       goto int13_success;
24315                       00006B93            .5DB:
24316 6B93           83C4                   00  add	sp,#..FFE9-..FFEA
24317 6B96           E9         0243            br 	.FFE9
24318                                           !BCC_EOS
24319                                           ! 4169       break;
24320 6B99           E9         021B            br 	.5BE
24321                                           !BCC_EOS
24322                                           ! 4170     case 0x45:
24323                                           ! 4171       if (( AX & 0x00ff ) > 2) goto int13_fail;
24324                       00006B9C            .5DE:
24325                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24326 6B9C           8A46         18            mov	al,$18[bp]
24327                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
24328 6B9F           3C                     02  cmp	al,*2
24329 6BA1           76           06            jbe 	.5DF
24330                       00006BA3            .5E0:
24331 6BA3           83C4                   00  add	sp,#..FFEB-..FFEA
24332 6BA6           E9         020E            br 	.FFEB
24333                                           !BCC_EOS
24334                                           ! 4172       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24335                       00006BA9            .5DF:
24336                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24337 6BA9           8A46         FF            mov	al,-1[bp]
24338 6BAC           30E4                       xor	ah,ah
24339 6BAE           B9                   001E  mov	cx,*$1E
24340 6BB1           F7E9                       imul	cx
24341 6BB3           89C3                       mov	bx,ax
24342                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24343                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24344                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24345 6BB5           8A87       0145            mov	al,$145[bx]
24346 6BB9           8846         FD            mov	-3[bp],al
24347                                           !BCC_EOS
24348                                           ! 4173       switch (( AX & 0x00ff )) {
24349                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24350 6BBC           8A46         18            mov	al,$18[bp]
24351 6BBF           E9         0095            br 	.5E3
24352                                           ! 4174         case 0 :
24353                                           ! 4175           if (locks == 0xff) {
24354                       00006BC2            .5E4:
24355                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$20-5] (used reg = )
24356 6BC2           8A46         FD            mov	al,-3[bp]
24357 6BC5           3C                     FF  cmp	al,#$FF
24358 6BC7           75           10            jne 	.5E5
24359                       00006BC9            .5E6:
24360                                           ! 4176             *(((Bit8u *)&AX)+1) = (0xb4);
24361                                           ! Debug: eq int = const $B4 to unsigned char AX = [S+$20+$17] (used reg = )
24362 6BC9           B0                     B4  mov	al,#$B4
24363 6BCB           8846         19            mov	$19[bp],al
24364                                           !BCC_EOS
24365                                           ! 4177             *((Bit8u *)&AX) = (1);
24366                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24367 6BCE           B0                     01  mov	al,*1
24368 6BD0           8846         18            mov	$18[bp],al
24369                                           !BCC_EOS
24370                                           ! 4178             goto int13_fail_noah;
24371 6BD3           83C4                   00  add	sp,#..FFE8-..FFEA
24372 6BD6           E9         01E3            br 	.FFE8
24373                                           !BCC_EOS
24374                                           ! 4179           }
24375                                           ! 4180           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (++locks);
24376                       00006BD9            .5E5:
24377                                           ! Debug: preinc unsigned char locks = [S+$20-5] (used reg = )
24378 6BD9           8A46         FD            mov	al,-3[bp]
24379 6BDC           40                         inc	ax
24380 6BDD           8846         FD            mov	-3[bp],al
24381 6BE0           50                         push	ax
24382                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24383 6BE1           8A46         FF            mov	al,-1[bp]
24384 6BE4           30E4                       xor	ah,ah
24385 6BE6           B9                   001E  mov	cx,*$1E
24386 6BE9           F7E9                       imul	cx
24387 6BEB           89C3                       mov	bx,ax
24388                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24389                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24390                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24391 6BED           8A46         E0            mov	al,0+..FFEA[bp]
24392 6BF0           8887       0145            mov	$145[bx],al
24393 6BF4           44                         inc	sp
24394 6BF5           44                         inc	sp
24395                                           !BCC_EOS
24396                                           ! 4181           *((Bit8u *)&AX) = (1);
24397                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24398 6BF6           B0                     01  mov	al,*1
24399 6BF8           8846         18            mov	$18[bp],al
24400                                           !BCC_EOS
24401                                           ! 4182           break;
24402 6BFB           EB           68            jmp .5E1
24403                                           !BCC_EOS
24404                                           ! 4183        
24405                                           ! 4183  case 1 :
24406                                           ! 4184           if (locks == 0x00) {
24407                       00006BFD            .5E7:
24408                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24409 6BFD           8A46         FD            mov	al,-3[bp]
24410 6C00           84C0                       test	al,al
24411 6C02           75           10            jne 	.5E8
24412                       00006C04            .5E9:
24413                                           ! 4185             *(((Bit8u *)&AX)+1) = (0xb0);
24414                                           ! Debug: eq int = const $B0 to unsigned char AX = [S+$20+$17] (used reg = )
24415 6C04           B0                     B0  mov	al,#$B0
24416 6C06           8846         19            mov	$19[bp],al
24417                                           !BCC_EOS
24418                                           ! 4186             *((Bit8u *)&AX) = (0);
24419                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$16] (used reg = )
24420 6C09           30C0                       xor	al,al
24421 6C0B           8846         18            mov	$18[bp],al
24422                                           !BCC_EOS
24423                                           ! 4187             goto int13_fail_noah;
24424 6C0E           83C4                   00  add	sp,#..FFE8-..FFEA
24425 6C11           E9         01A8            br 	.FFE8
24426                                           !BCC_EOS
24427                                           ! 4188           }
24428                                           ! 4189           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (--locks);
24429                       00006C14            .5E8:
24430                                           ! Debug: predec unsigned char locks = [S+$20-5] (used reg = )
24431 6C14           8A46         FD            mov	al,-3[bp]
24432 6C17           48                         dec	ax
24433 6C18           8846         FD            mov	-3[bp],al
24434 6C1B           50                         push	ax
24435                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24436 6C1C           8A46         FF            mov	al,-1[bp]
24437 6C1F           30E4                       xor	ah,ah
24438 6C21           B9                   001E  mov	cx,*$1E
24439 6C24           F7E9                       imul	cx
24440 6C26           89C3                       mov	bx,ax
24441                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24442                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24443                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24444 6C28           8A46         E0            mov	al,0+..FFEA[bp]
24445 6C2B           8887       0145            mov	$145[bx],al
24446 6C2F           44                         inc	sp
24447 6C30           44                         inc	sp
24448                                           !BCC_EOS
24449                                           ! 4190           *((Bit8u *)&AX) = (locks==0?0:1);
24450                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24451 6C31           8A46         FD            mov	al,-3[bp]
24452 6C34           84C0                       test	al,al
24453 6C36           75           04            jne 	.5EA
24454                       00006C38            .5EB:
24455 6C38           30C0                       xor	al,al
24456 6C3A           EB           02            jmp .5EC
24457                       00006C3C            .5EA:
24458 6C3C           B0                     01  mov	al,*1
24459                       00006C3E            .5EC:
24460                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24461 6C3E           8846         18            mov	$18[bp],al
24462                                           !BCC_EOS
24463                                           ! 4191           break;
24464 6C41           EB           22            jmp .5E1
24465                                           !BCC_EOS
24466                                           ! 4192         case 2 :
24467                                           ! 4193           *((Bit8u *)&AX) = (locks==0?0:1);
24468                       00006C43            .5ED:
24469                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24470 6C43           8A46         FD            mov	al,-3[bp]
24471 6C46           84C0                       test	al,al
24472 6C48           75           04            jne 	.5EE
24473                       00006C4A            .5EF:
24474 6C4A           30C0                       xor	al,al
24475 6C4C           EB           02            jmp .5F0
24476                       00006C4E            .5EE:
24477 6C4E           B0                     01  mov	al,*1
24478                       00006C50            .5F0:
24479                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24480 6C50           8846         18            mov	$18[bp],al
24481                                           !BCC_EOS
24482                                           ! 4194           break;
24483 6C53           EB           10            jmp .5E1
24484                                           !BCC_EOS
24485                                           ! 4195       }
24486                                           ! 4196       goto int13_success;
24487 6C55           EB           0E            jmp .5E1
24488                       00006C57            .5E3:
24489 6C57           2C                     00  sub	al,*0
24490 6C59         0F84         FF65            beq 	.5E4
24491 6C5D           2C                     01  sub	al,*1
24492 6C5F           74           9C            je 	.5E7
24493 6C61           2C                     01  sub	al,*1
24494 6C63           74           DE            je 	.5ED
24495                       00006C65            .5E1:
24496 6C65           83C4                   00  add	sp,#..FFE9-..FFEA
24497 6C68           E9         0171            br 	.FFE9
24498                                           !BCC_EOS
24499                                           ! 4197       break;
24500 6C6B           E9         0149            br 	.5BE
24501                                           !BCC_EOS
24502                                           ! 4198     case 0x46:
24503                                           ! 4199       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24504                       00006C6E            .5F1:
24505                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24506 6C6E           8A46         FF            mov	al,-1[bp]
24507 6C71           30E4                       xor	ah,ah
24508 6C73           B9                   001E  mov	cx,*$1E
24509 6C76           F7E9                       imul	cx
24510 6C78           89C3                       mov	bx,ax
24511                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24512                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24513                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24514 6C7A           8A87       0145            mov	al,$145[bx]
24515 6C7E           8846         FD            mov	-3[bp],al
24516                                           !BCC_EOS
24517                                           ! 4200       if (locks != 0) {
24518                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24519 6C81           8A46         FD            mov	al,-3[bp]
24520 6C84           84C0                       test	al,al
24521 6C86           74           0B            je  	.5F2
24522                       00006C88            .5F3:
24523                                           ! 4201         *(((Bit8u *)&AX)+1) = (0xb1);
24524                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24525 6C88           B0                     B1  mov	al,#$B1
24526 6C8A           8846         19            mov	$19[bp],al
24527                                           !BCC_EOS
24528                                           ! 4202         goto int13_fail_noah;
24529 6C8D           83C4                   00  add	sp,#..FFE8-..FFEA
24530 6C90           E9         0129            br 	.FFE8
24531                                           !BCC_EOS
24532                                           ! 4203       }
24533                                           ! 4204 #asm
24534                       00006C93            .5F2:
24535                                           !BCC_EOS
24536                                           !BCC_ASM
24537                       0000002C            _int13_cdrom.BP	set	$2C
24538                       0000000E            .int13_cdrom.BP	set	$E
24539                       00000022            _int13_cdrom.EHBX	set	$22
24540                       00000004            .int13_cdrom.EHBX	set	4
24541                       0000003A            _int13_cdrom.CS	set	$3A
24542                       0000001C            .int13_cdrom.CS	set	$1C
24543                       00000008            _int13_cdrom.count	set	8
24544                       FFFFFFEA            .int13_cdrom.count	set	-$16
24545                       00000034            _int13_cdrom.CX	set	$34
24546                       00000016            .int13_cdrom.CX	set	$16
24547                       00000006            _int13_cdrom.segment	set	6
24548                       FFFFFFE8            .int13_cdrom.segment	set	-$18
24549                       00000028            _int13_cdrom.DI	set	$28
24550                       0000000A            .int13_cdrom.DI	set	$A
24551                       0000003C            _int13_cdrom.FLAGS	set	$3C
24552                       0000001E            .int13_cdrom.FLAGS	set	$1E
24553                       00000024            _int13_cdrom.DS	set	$24
24554                       00000006            .int13_cdrom.DS	set	6
24555                       0000002E            _int13_cdrom.ELDX	set	$2E
24556                       00000010            .int13_cdrom.ELDX	set	$10
24557                       00000032            _int13_cdrom.DX	set	$32
24558                       00000014            .int13_cdrom.DX	set	$14
24559                       00000000            _int13_cdrom.size	set	0
24560                       FFFFFFE2            .int13_cdrom.size	set	-$1E
24561                       00000002            _int13_cdrom.i	set	2
24562                       FFFFFFE4            .int13_cdrom.i	set	-$1C
24563                       0000001D            _int13_cdrom.device	set	$1D
24564                       FFFFFFFF            .int13_cdrom.device	set	-1
24565                       00000026            _int13_cdrom.ES	set	$26
24566                       00000008            .int13_cdrom.ES	set	8
24567                       0000002A            _int13_cdrom.SI	set	$2A
24568                       0000000C            .int13_cdrom.SI	set	$C
24569                       00000038            _int13_cdrom.IP	set	$38
24570                       0000001A            .int13_cdrom.IP	set	$1A
24571                       0000000A            _int13_cdrom.lba	set	$A
24572                       FFFFFFEC            .int13_cdrom.lba	set	-$14
24573                       0000001C            _int13_cdrom.status	set	$1C
24574                       FFFFFFFE            .int13_cdrom.status	set	-2
24575                       0000000F            _int13_cdrom.atacmd	set	$F
24576                       FFFFFFF1            .int13_cdrom.atacmd	set	-$F
24577                       00000036            _int13_cdrom.AX	set	$36
24578                       00000018            .int13_cdrom.AX	set	$18
24579                       00000004            _int13_cdrom.offset	set	4
24580                       FFFFFFE6            .int13_cdrom.offset	set	-$1A
24581                       00000030            _int13_cdrom.BX	set	$30
24582                       00000012            .int13_cdrom.BX	set	$12
24583                       0000001B            _int13_cdrom.locks	set	$1B
24584                       FFFFFFFD            .int13_cdrom.locks	set	-3
24585 6C93           55                                 push bp
24586 6C94           89E5                               mov bp, sp
24587 6C96           B4                     52          mov ah, #0x52
24588 6C98           CD                     15          int #0x15
24589 6C9A           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
24590 6C9D           73           06                    jnc int13_cdrom_rme_end
24591 6C9F           C706       001C      0001          mov _int13_cdrom.status, #1
24592                       00006CA5            int13_cdrom_rme_end:
24593 6CA5           5D                                 pop bp
24594                                           ! 4214 endasm
24595                                           !BCC_ENDASM
24596                                           !BCC_EOS
24597                                           ! 4215       if (status != 0) {
24598                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24599 6CA6           8A46         FE            mov	al,-2[bp]
24600 6CA9           84C0                       test	al,al
24601 6CAB           74           0B            je  	.5F4
24602                       00006CAD            .5F5:
24603                                           ! 4216         *(((Bit8u *)&AX)+1) = (0xb1);
24604                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24605 6CAD           B0                     B1  mov	al,#$B1
24606 6CAF           8846         19            mov	$19[bp],al
24607                                           !BCC_EOS
24608                                           ! 4217         goto int13_fail_noah;
24609 6CB2           83C4                   00  add	sp,#..FFE8-..FFEA
24610 6CB5           E9         0104            br 	.FFE8
24611                                           !BCC_EOS
24612                                           ! 4218       }
24613                                           ! 4219       goto int13_success;
24614                       00006CB8            .5F4:
24615 6CB8           83C4                   00  add	sp,#..FFE9-..FFEA
24616 6CBB           E9         011E            br 	.FFE9
24617                                           !BCC_EOS
24618                                           ! 4220       break;
24619 6CBE           E9         00F6            br 	.5BE
24620                                           !BCC_EOS
24621                                           ! 4221     case 0x48:
24622                                           ! 4222       if (int13_edd(DS, SI, device))
24623                       00006CC1            .5F6:
24624                                           ! Debug: list unsigned char device = [S+$20-3] (used reg = )
24625 6CC1           8A46         FF            mov	al,-1[bp]
24626 6CC4           30E4                       xor	ah,ah
24627 6CC6           50                         push	ax
24628                                           ! Debug: list unsigned short SI = [S+$22+$A] (used reg = )
24629 6CC7           FF76         0C            push	$C[bp]
24630                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24631 6CCA           FF76         06            push	6[bp]
24632                                           ! Debug: func () int = int13_edd+0 (used reg = )
24633 6CCD           E8         EE10            call	_int13_edd
24634 6CD0           83C4                   06  add	sp,*6
24635 6CD3           85C0                       test	ax,ax
24636 6CD5           74           06            je  	.5F7
24637                       00006CD7            .5F8:
24638                                           ! 4223         goto int13_fail;
24639 6CD7           83C4                   00  add	sp,#..FFEB-..FFEA
24640 6CDA           E9         00DA            br 	.FFEB
24641                                           !BCC_EOS
24642                                           ! 4224       goto int13_success;
24643                       00006CDD            .5F7:
24644 6CDD           83C4                   00  add	sp,#..FFE9-..FFEA
24645 6CE0           E9         00F9            br 	.FFE9
24646                                           !BCC_EOS
24647                                           ! 4225       break;
24648 6CE3           E9         00D1            br 	.5BE
24649                                           !BCC_EOS
24650                                           ! 4226     case 0x49:
24651                                           ! 4227       *(((Bit8u *)&AX)+1) = (06);
24652                       00006CE6            .5F9:
24653                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$20+$17] (used reg = )
24654 6CE6           B0                     06  mov	al,*6
24655 6CE8           8846         19            mov	$19[bp],al
24656                                           !BCC_EOS
24657                                           ! 4228       goto int13_fail_nostatus;
24658 6CEB           83C4                   00  add	sp,#..FFE7-..FFEA
24659 6CEE           E9         00DF            br 	.FFE7
24660                                           !BCC_EOS
24661                                           ! 4229       break;
24662 6CF1           E9         00C3            br 	.5BE
24663                                           !BCC_EOS
24664                                           ! 4230     case 0x4e:
24665                                           ! 4231       switch (( AX & 0x00ff )) {
24666                       00006CF4            .5FA:
24667                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24668 6CF4           8A46         18            mov	al,$18[bp]
24669 6CF7           EB           10            jmp .5FD
24670                                           ! 4232         case 0x01:
24671                                           ! 4233         case 0x03:
24672                       00006CF9            .5FE:
24673                                           ! 4234         case 0x04:
24674                       00006CF9            .5FF:
24675                                           ! 4235         case 0x06:
24676                       00006CF9            .600:
24677                                           ! 4236           goto int13_success;
24678                       00006CF9            .601:
24679 6CF9           83C4                   00  add	sp,#..FFE9-..FFEA
24680 6CFC           E9         00DD            br 	.FFE9
24681                                           !BCC_EOS
24682                                           ! 4237           break;
24683 6CFF           EB           1A            jmp .5FB
24684                                           !BCC_EOS
24685                                           ! 4238         default:
24686                                           ! 4239           goto int13_fail;
24687                       00006D01            .602:
24688 6D01           83C4                   00  add	sp,#..FFEB-..FFEA
24689 6D04           E9         00B0            br 	.FFEB
24690                                           !BCC_EOS
24691                                           ! 4240       }
24692                                           ! 4241       break;
24693 6D07           EB           12            jmp .5FB
24694                       00006D09            .5FD:
24695 6D09           2C                     01  sub	al,*1
24696 6D0B           74           EC            je 	.5FE
24697 6D0D           2C                     02  sub	al,*2
24698 6D0F           74           E8            je 	.5FF
24699 6D11           2C                     01  sub	al,*1
24700 6D13           74           E4            je 	.600
24701 6D15           2C                     02  sub	al,*2
24702 6D17           74           E0            je 	.601
24703 6D19           EB           E6            jmp	.602
24704                       00006D1B            .5FB:
24705 6D1B           E9         0099            br 	.5BE
24706                                           !BCC_EOS
24707                                           ! 4242     case 0x02:
24708                                           ! 4243     case 0x04:
24709                       00006D1E            .603:
24710                                           ! 4244     case 0x08:
24711                       00006D1E            .604:
24712                                           ! 4245     case 0x0a:
24713                       00006D1E            .605:
24714                                           ! 4246     case 0x0b:
24715                       00006D1E            .606:
24716                                           ! 4247     case 0x18:
24717                       00006D1E            .607:
24718                                           ! 4248     case 0x50:
24719                       00006D1E            .608:
24720                                           ! 4249     default:
24721                       00006D1E            .609:
24722                                           ! 4250       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
24723                       00006D1E            .60A:
24724                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24725 6D1E           8A46         19            mov	al,$19[bp]
24726 6D21           30E4                       xor	ah,ah
24727 6D23           50                         push	ax
24728                                           ! Debug: list * char = .60B+0 (used reg = )
24729 6D24           BB                   CF50  mov	bx,#.60B
24730 6D27           53                         push	bx
24731                                           ! Debug: list int = const 4 (used reg = )
24732 6D28           B8                   0004  mov	ax,*4
24733 6D2B           50                         push	ax
24734                                           ! Debug: func () void = bios_printf+0 (used reg = )
24735 6D2C           E8         9C0A            call	_bios_printf
24736 6D2F           83C4                   06  add	sp,*6
24737                                           !BCC_EOS
24738                                           ! 4251       goto int13_fail;
24739 6D32           83C4                   00  add	sp,#..FFEB-..FFEA
24740 6D35           E9         007F            jmp .FFEB
24741                                           !BCC_EOS
24742                                           ! 4252       break;
24743 6D38           EB           7D            jmp .5BE
24744                                           !BCC_EOS
24745                                           ! 4253   }
24746                                           ! 4254 int13_fail:
24747 6D3A           EB           7B            jmp .5BE
24748                       00006D3C            .5C0:
24749 6D3C           2C                     00  sub	al,*0
24750 6D3E           72           DE            jb 	.60A
24751 6D40           3C                     18  cmp	al,*$18
24752 6D42           77           3D            ja  	.60C
24753 6D44           30E4                       xor	ah,ah
24754 6D46           D1E0                       shl	ax,*1
24755 6D48           89C3                       mov	bx,ax
24756 6D4A           2E                         seg	cs
24757 6D4B           FFA7       6D4F            br	.60D[bx]
24758                       00006D4F            .60D:
24759 6D4F                      698C            .word	.5C1
24760 6D51                      69A3            .word	.5CC
24761 6D53                      6D1E            .word	.603
24762 6D55                      6995            .word	.5C9
24763 6D57                      6D1E            .word	.604
24764 6D59                      6995            .word	.5CA
24765 6D5B                      6D1E            .word	.60A
24766 6D5D                      6D1E            .word	.60A
24767 6D5F                      6D1E            .word	.605
24768 6D61                      698C            .word	.5C2
24769 6D63                      6D1E            .word	.606
24770 6D65                      6D1E            .word	.607
24771 6D67                      698C            .word	.5C3
24772 6D69                      698C            .word	.5C4
24773 6D6B                      6D1E            .word	.60A
24774 6D6D                      6D1E            .word	.60A
24775 6D6F                      698C            .word	.5C5
24776 6D71                      698C            .word	.5C6
24777 6D73                      6D1E            .word	.60A
24778 6D75                      6D1E            .word	.60A
24779 6D77                      698C            .word	.5C7
24780 6D79                      69E3            .word	.5D0
24781 6D7B                      698C            .word	.5C8
24782 6D7D                      6D1E            .word	.60A
24783 6D7F                      6D1E            .word	.608
24784                       00006D81            .60C:
24785 6D81           2C                     41  sub	al,*$41
24786 6D83           72           99            jb 	.60A
24787 6D85           3C                     0F  cmp	al,*$F
24788 6D87           77           2B            ja  	.60E
24789 6D89           30E4                       xor	ah,ah
24790 6D8B           D1E0                       shl	ax,*1
24791 6D8D           89C3                       mov	bx,ax
24792 6D8F           2E                         seg	cs
24793 6D90           FFA7       6D94            br	.60F[bx]
24794                       00006D94            .60F:
24795 6D94                      69F1            .word	.5D1
24796 6D96                      6A0B            .word	.5D2
24797 6D98                      6995            .word	.5CB
24798 6D9A                      6A0B            .word	.5D3
24799 6D9C                      6B9C            .word	.5DE
24800 6D9E                      6C6E            .word	.5F1
24801 6DA0                      6A0B            .word	.5D4
24802 6DA2                      6CC1            .word	.5F6
24803 6DA4                      6CE6            .word	.5F9
24804 6DA6                      6D1E            .word	.60A
24805 6DA8                      6D1E            .word	.60A
24806 6DAA                      6D1E            .word	.60A
24807 6DAC                      6D1E            .word	.60A
24808 6DAE                      6CF4            .word	.5FA
24809 6DB0                      6D1E            .word	.60A
24810 6DB2                      6D1E            .word	.609
24811                       00006DB4            .60E:
24812 6DB4           E9         FF67            br 	.60A
24813                       00006DB7            .5BE:
24814                       FFFFFFE0            ..FFEA	=	-$20
24815                       00006DB7            .FFEB:
24816                       FFFFFFE0            ..FFEB	=	-$20
24817                                           ! 4255   *(((Bit8u *)&AX)+1) = (0x01);
24818                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$17] (used reg = )
24819 6DB7           B0                     01  mov	al,*1
24820 6DB9           8846         19            mov	$19[bp],al
24821                                           !BCC_EOS
24822                                           ! 4256 int13_fail_noah:
24823                       00006DBC            .FFE8:
24824                       FFFFFFE0            ..FFE8	=	-$20
24825                                           ! 4257   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
24826                                           ! Debug: list int = const $40 (used reg = )
24827 6DBC           B8                   0040  mov	ax,*$40
24828 6DBF           50                         push	ax
24829                                           ! Debug: list int = const $74 (used reg = )
24830 6DC0           B8                   0074  mov	ax,*$74
24831 6DC3           50                         push	ax
24832                                           ! Debug: list unsigned char AX = [S+$24+$17] (used reg = )
24833 6DC4           8A46         19            mov	al,$19[bp]
24834 6DC7           30E4                       xor	ah,ah
24835 6DC9           50                         push	ax
24836                                           ! Debug: func () void = _write_byte+0 (used reg = )
24837 6DCA           E8         982E            call	__write_byte
24838 6DCD           83C4                   06  add	sp,*6
24839                                           !BCC_EOS
24840                                           ! 4258 int13_fail_nostatus:
24841                       00006DD0            .FFE7:
24842                       FFFFFFE0            ..FFE7	=	-$20
24843                                           ! 4259   FLAGS |= 0x0001;
24844                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24845 6DD0           8B46         1E            mov	ax,$1E[bp]
24846 6DD3           0C                     01  or	al,*1
24847 6DD5           8946         1E            mov	$1E[bp],ax
24848                                           !BCC_EOS
24849                                           ! 4260   return;
24850 6DD8           89EC                       mov	sp,bp
24851 6DDA           5D                         pop	bp
24852 6DDB           C3                         ret
24853                                           !BCC_EOS
24854                                           ! 4261 int13_success:
24855                       00006DDC            .FFE9:
24856                       FFFFFFE0            ..FFE9	=	-$20
24857                                           ! 4262   *(((Bit8u *)&AX)+1) = (0x00);
24858                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$17] (used reg = )
24859 6DDC           30C0                       xor	al,al
24860 6DDE           8846         19            mov	$19[bp],al
24861                                           !BCC_EOS
24862                                           ! 4263 int13_success_noah:
24863                       00006DE1            .FFE6:
24864                       FFFFFFE0            ..FFE6	=	-$20
24865                                           ! 4264   _write_byte(0x00, 0x0074, 0x0040);
24866                                           ! Debug: list int = const $40 (used reg = )
24867 6DE1           B8                   0040  mov	ax,*$40
24868 6DE4           50                         push	ax
24869                                           ! Debug: list int = const $74 (used reg = )
24870 6DE5           B8                   0074  mov	ax,*$74
24871 6DE8           50                         push	ax
24872                                           ! Debug: list int = const 0 (used reg = )
24873 6DE9           31C0                       xor	ax,ax
24874 6DEB           50                         push	ax
24875                                           ! Debug: func () void = _write_byte+0 (used reg = )
24876 6DEC           E8         980C            call	__write_byte
24877 6DEF           83C4                   06  add	sp,*6
24878                                           !BCC_EOS
24879                                           ! 4265   FLAGS &= 0xfffe;
24880                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24881 6DF2           8B46         1E            mov	ax,$1E[bp]
24882 6DF5           24                     FE  and	al,#$FE
24883 6DF7           8946         1E            mov	$1E[bp],ax
24884                                           !BCC_EOS
24885                                           ! 4266 }
24886 6DFA           89EC                       mov	sp,bp
24887 6DFC           5D                         pop	bp
24888 6DFD           C3                         ret
24889                                           ! 4267   void
24890                                           ! Register BX used in function int13_cdrom
24891                                           ! 4268 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAG
24892                                           ! 4268 S)
24893                                           ! 4269   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
24894                                           export	_int13_eltorito
24895                       00006DFE            _int13_eltorito:
24896                                           !BCC_EOS
24897                                           ! 4270 {
24898                                           ! 4271   Bit16u ebda_seg=get_ebda_seg();
24899 6DFE           55                         push	bp
24900 6DFF           89E5                       mov	bp,sp
24901 6E01           4C                         dec	sp
24902 6E02           4C                         dec	sp
24903                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
24904 6E03           E8         9861            call	_get_ebda_seg
24905                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
24906 6E06           8946         FE            mov	-2[bp],ax
24907                                           !BCC_EOS
24908                                           ! 4272   ;
24909                                           !BCC_EOS
24910                                           ! 4273   switch (*(((Bit8u *)&AX)+1)) {
24911 6E09           8A46         17            mov	al,$17[bp]
24912 6E0C           E9         0191            br 	.612
24913                                           ! 4274     case 0x4a:
24914                                           ! 4275     case 0x4c:
24915                       00006E0F            .613:
24916                                           ! 4276     case 0x4d:
24917                       00006E0F            .614:
24918                                           ! 4277       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
24919                       00006E0F            .615:
24920                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
24921 6E0F           FF76         16            push	$16[bp]
24922                                           ! Debug: list * char = .616+0 (used reg = )
24923 6E12           BB                   CF1F  mov	bx,#.616
24924 6E15           53                         push	bx
24925                                           ! Debug: list int = const 7 (used reg = )
24926 6E16           B8                   0007  mov	ax,*7
24927 6E19           50                         push	ax
24928                                           ! Debug: func () void = bios_printf+0 (used reg = )
24929 6E1A           E8         9B1C            call	_bios_printf
24930 6E1D           83C4                   06  add	sp,*6
24931                                           !BCC_EOS
24932                                           ! 4278       goto int13_fail;
24933 6E20           83C4                   00  add	sp,#..FFE4-..FFE5
24934 6E23           E9         0194            br 	.FFE4
24935                                           !BCC_EOS
24936                                           ! 4279       break;
24937 6E26           E9         0191            br 	.610
24938                                           !BCC_EOS
24939                                           ! 4280     case 0x4b:
24940                                           ! 4281       *((Bit8u *)(SI+0x00)) = (0x13);
24941                       00006E29            .617:
24942                                           ! Debug: add int = const 0 to unsigned short SI = [S+4+8] (used reg = )
24943 6E29           8B46         0A            mov	ax,$A[bp]
24944                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
24945 6E2C           89C3                       mov	bx,ax
24946                                           ! Debug: eq int = const $13 to unsigned char = [bx+0] (used reg = )
24947 6E2E           B0                     13  mov	al,*$13
24948 6E30           8807                       mov	[bx],al
24949                                           !BCC_EOS
24950                                           ! 4282       *((Bit8u *)(SI+0x01)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.media, ebda_seg));
24951                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24952 6E32           FF76         FE            push	-2[bp]
24953                                           ! Debug: list * unsigned char = const $25B (used reg = )
24954 6E35           B8                   025B  mov	ax,#$25B
24955 6E38           50                         push	ax
24956                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24957 6E39           E8         97A3            call	__read_byte
24958 6E3C           83C4                   04  add	sp,*4
24959 6E3F           50                         push	ax
24960                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
24961 6E40           8B46         0A            mov	ax,$A[bp]
24962                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
24963 6E43           89C3                       mov	bx,ax
24964                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+1] (used reg = )
24965 6E45           8A46         FC            mov	al,0+..FFE5[bp]
24966 6E48           8847         01            mov	1[bx],al
24967 6E4B           44                         inc	sp
24968 6E4C           44                         inc	sp
24969                                           !BCC_EOS
24970                                           ! 4283       *((Bit8u *)(SI+0x02)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
24971                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24972 6E4D           FF76         FE            push	-2[bp]
24973                                           ! Debug: list * unsigned char = const $25C (used reg = )
24974 6E50           B8                   025C  mov	ax,#$25C
24975 6E53           50                         push	ax
24976                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24977 6E54           E8         9788            call	__read_byte
24978 6E57           83C4                   04  add	sp,*4
24979 6E5A           50                         push	ax
24980                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
24981 6E5B           8B46         0A            mov	ax,$A[bp]
24982                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+2 (used reg = )
24983 6E5E           89C3                       mov	bx,ax
24984                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+2] (used reg = )
24985 6E60           8A46         FC            mov	al,0+..FFE5[bp]
24986 6E63           8847         02            mov	2[bx],al
24987 6E66           44                         inc	sp
24988 6E67           44                         inc	sp
24989                                           !BCC_EOS
24990                                           ! 4284       *((Bit8u *)(SI+0x03)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.controller_index, ebda_seg));
24991                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
24992 6E68           FF76         FE            push	-2[bp]
24993                                           ! Debug: list * unsigned char = const $25D (used reg = )
24994 6E6B           B8                   025D  mov	ax,#$25D
24995 6E6E           50                         push	ax
24996                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
24997 6E6F           E8         976D            call	__read_byte
24998 6E72           83C4                   04  add	sp,*4
24999 6E75           50                         push	ax
25000                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
25001 6E76           8B46         0A            mov	ax,$A[bp]
25002                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+3 (used reg = )
25003 6E79           89C3                       mov	bx,ax
25004                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+3] (used reg = )
25005 6E7B           8A46         FC            mov	al,0+..FFE5[bp]
25006 6E7E           8847         03            mov	3[bx],al
25007 6E81           44                         inc	sp
25008 6E82           44                         inc	sp
25009                                           !BCC_EOS
25010                                           ! 4285       *((Bit32u *)(SI+0x04)) = (_read_dword(&((ebda_data_t *) 0)->cdemu.ilba, ebda_seg));
25011                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25012 6E83           FF76         FE            push	-2[bp]
25013                                           ! Debug: list * unsigned long = const $260 (used reg = )
25014 6E86           B8                   0260  mov	ax,#$260
25015 6E89           50                         push	ax
25016                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
25017 6E8A           E8         91C9            call	__read_dword
25018 6E8D           89D3                       mov	bx,dx
25019 6E8F           83C4                   04  add	sp,*4
25020 6E92           53                         push	bx
25021 6E93           50                         push	ax
25022                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
25023 6E94           8B46         0A            mov	ax,$A[bp]
25024                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+4 (used reg = )
25025 6E97           89C3                       mov	bx,ax
25026                                           ! Debug: eq unsigned long (temp) = [S+8-8] to unsigned long = [bx+4] (used reg = )
25027 6E99           8B46         FA            mov	ax,-2+..FFE5[bp]
25028 6E9C           8B76         FC            mov	si,0+..FFE5[bp]
25029 6E9F           8947         04            mov	4[bx],ax
25030 6EA2           8977         06            mov	6[bx],si
25031 6EA5           83C4                   04  add	sp,*4
25032                                           !BCC_EOS
25033                                           ! 4286       *((Bit16u *)(SI+0x08)) = (_read_word(&((ebda_data_t *) 0)->cdemu.device_spec, ebda_seg));
25034                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25035 6EA8           FF76         FE            push	-2[bp]
25036                                           ! Debug: list * unsigned short = const $25E (used reg = )
25037 6EAB           B8                   025E  mov	ax,#$25E
25038 6EAE           50                         push	ax
25039                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25040 6EAF           E8         973B            call	__read_word
25041 6EB2           83C4                   04  add	sp,*4
25042 6EB5           50                         push	ax
25043                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
25044 6EB6           8B46         0A            mov	ax,$A[bp]
25045                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
25046 6EB9           89C3                       mov	bx,ax
25047                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+8] (used reg = )
25048 6EBB           8B46         FC            mov	ax,0+..FFE5[bp]
25049 6EBE           8947         08            mov	8[bx],ax
25050 6EC1           44                         inc	sp
25051 6EC2           44                         inc	sp
25052                                           !BCC_EOS
25053                                           ! 4287       *((Bit16u *)(SI+0x0a)) = (_read_word(&((ebda_data_t *) 0)->cdemu.buffer_segment, ebda_seg));
25054                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25055 6EC3           FF76         FE            push	-2[bp]
25056                                           ! Debug: list * unsigned short = const $264 (used reg = )
25057 6EC6           B8                   0264  mov	ax,#$264
25058 6EC9           50                         push	ax
25059                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25060 6ECA           E8         9720            call	__read_word
25061 6ECD           83C4                   04  add	sp,*4
25062 6ED0           50                         push	ax
25063                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
25064 6ED1           8B46         0A            mov	ax,$A[bp]
25065                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
25066 6ED4           89C3                       mov	bx,ax
25067                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$A] (used reg = )
25068 6ED6           8B46         FC            mov	ax,0+..FFE5[bp]
25069 6ED9           8947         0A            mov	$A[bx],ax
25070 6EDC           44                         inc	sp
25071 6EDD           44                         inc	sp
25072                                           !BCC_EOS
25073                                           ! 4288       *((Bit16u *)(SI+0x0c)) = (_read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg));
25074                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25075 6EDE           FF76         FE            push	-2[bp]
25076                                           ! Debug: list * unsigned short = const $266 (used reg = )
25077 6EE1           B8                   0266  mov	ax,#$266
25078 6EE4           50                         push	ax
25079                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25080 6EE5           E8         9705            call	__read_word
25081 6EE8           83C4                   04  add	sp,*4
25082 6EEB           50                         push	ax
25083                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
25084 6EEC           8B46         0A            mov	ax,$A[bp]
25085                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
25086 6EEF           89C3                       mov	bx,ax
25087                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$C] (used reg = )
25088 6EF1           8B46         FC            mov	ax,0+..FFE5[bp]
25089 6EF4           8947         0C            mov	$C[bx],ax
25090 6EF7           44                         inc	sp
25091 6EF8           44                         inc	sp
25092                                           !BCC_EOS
25093                                           ! 4289       *((Bit16u *)(SI+0x0e)) = (_read_word(&((ebda_data_t *) 0)->cdemu.sector_count, ebda_seg));
25094                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25095 6EF9           FF76         FE            push	-2[bp]
25096                                           ! Debug: list * unsigned short = const $268 (used reg = )
25097 6EFC           B8                   0268  mov	ax,#$268
25098 6EFF           50                         push	ax
25099                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25100 6F00           E8         96EA            call	__read_word
25101 6F03           83C4                   04  add	sp,*4
25102 6F06           50                         push	ax
25103                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
25104 6F07           8B46         0A            mov	ax,$A[bp]
25105                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
25106 6F0A           89C3                       mov	bx,ax
25107                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$E] (used reg = )
25108 6F0C           8B46         FC            mov	ax,0+..FFE5[bp]
25109 6F0F           8947         0E            mov	$E[bx],ax
25110 6F12           44                         inc	sp
25111 6F13           44                         inc	sp
25112                                           !BCC_EOS
25113                                           ! 4290       *((Bit8u *)(SI+0x10)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders, ebda_seg));
25114                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25115 6F14           FF76         FE            push	-2[bp]
25116                                           ! Debug: list * unsigned short = const $26C (used reg = )
25117 6F17           B8                   026C  mov	ax,#$26C
25118 6F1A           50                         push	ax
25119                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25120 6F1B           E8         96C1            call	__read_byte
25121 6F1E           83C4                   04  add	sp,*4
25122 6F21           50                         push	ax
25123                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
25124 6F22           8B46         0A            mov	ax,$A[bp]
25125                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$10 (used reg = )
25126 6F25           89C3                       mov	bx,ax
25127                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$10] (used reg = )
25128 6F27           8A46         FC            mov	al,0+..FFE5[bp]
25129 6F2A           8847         10            mov	$10[bx],al
25130 6F2D           44                         inc	sp
25131 6F2E           44                         inc	sp
25132                                           !BCC_EOS
25133                                           ! 4291       *((Bit8u *)(SI+0x11)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.spt, ebda_seg));
25134                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25135 6F2F           FF76         FE            push	-2[bp]
25136                                           ! Debug: list * unsigned short = const $26E (used reg = )
25137 6F32           B8                   026E  mov	ax,#$26E
25138 6F35           50                         push	ax
25139                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25140 6F36           E8         96A6            call	__read_byte
25141 6F39           83C4                   04  add	sp,*4
25142 6F3C           50                         push	ax
25143                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
25144 6F3D           8B46         0A            mov	ax,$A[bp]
25145                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$11 (used reg = )
25146 6F40           89C3                       mov	bx,ax
25147                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$11] (used reg = )
25148 6F42           8A46         FC            mov	al,0+..FFE5[bp]
25149 6F45           8847         11            mov	$11[bx],al
25150 6F48           44                         inc	sp
25151 6F49           44                         inc	sp
25152                                           !BCC_EOS
25153                                           ! 4292       *((Bit8u *)(SI+0x12)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.heads, ebda_seg));
25154                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25155 6F4A           FF76         FE            push	-2[bp]
25156                                           ! Debug: list * unsigned short = const $26A (used reg = )
25157 6F4D           B8                   026A  mov	ax,#$26A
25158 6F50           50                         push	ax
25159                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25160 6F51           E8         968B            call	__read_byte
25161 6F54           83C4                   04  add	sp,*4
25162 6F57           50                         push	ax
25163                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
25164 6F58           8B46         0A            mov	ax,$A[bp]
25165                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$12 (used reg = )
25166 6F5B           89C3                       mov	bx,ax
25167                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$12] (used reg = )
25168 6F5D           8A46         FC            mov	al,0+..FFE5[bp]
25169 6F60           8847         12            mov	$12[bx],al
25170 6F63           44                         inc	sp
25171 6F64           44                         inc	sp
25172                                           !BCC_EOS
25173                                           ! 4293       if(( AX & 0x00ff ) == 0x00) {
25174                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
25175 6F65           8A46         16            mov	al,$16[bp]
25176                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
25177 6F68           84C0                       test	al,al
25178 6F6A           75           10            jne 	.618
25179                       00006F6C            .619:
25180                                           ! 4294         _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
25181                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25182 6F6C           FF76         FE            push	-2[bp]
25183                                           ! Debug: list * unsigned char = const $25A (used reg = )
25184 6F6F           B8                   025A  mov	ax,#$25A
25185 6F72           50                         push	ax
25186                                           ! Debug: list int = const 0 (used reg = )
25187 6F73           31C0                       xor	ax,ax
25188 6F75           50                         push	ax
25189                                           ! Debug: func () void = _write_byte+0 (used reg = )
25190 6F76           E8         9682            call	__write_byte
25191 6F79           83C4                   06  add	sp,*6
25192                                           !BCC_EOS
25193                                           ! 4295       }
25194                                           ! 4296       goto int13_success;
25195                       00006F7C            .618:
25196 6F7C           83C4                   00  add	sp,#..FFE3-..FFE5
25197 6F7F           EB           5E            jmp .FFE3
25198                                           !BCC_EOS
25199                                           ! 4297       break;
25200 6F81           EB           37            jmp .610
25201                                           !BCC_EOS
25202                                           ! 4298     default:
25203                                           ! 4299       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
25204                       00006F83            .61A:
25205                                           ! Debug: list unsigned char AX = [S+4+$15] (used reg = )
25206 6F83           8A46         17            mov	al,$17[bp]
25207 6F86           30E4                       xor	ah,ah
25208 6F88           50                         push	ax
25209                                           ! Debug: list * char = .61B+0 (used reg = )
25210 6F89           BB                   CEFA  mov	bx,#.61B
25211 6F8C           53                         push	bx
25212                                           ! Debug: list int = const 4 (used reg = )
25213 6F8D           B8                   0004  mov	ax,*4
25214 6F90           50                         push	ax
25215                                           ! Debug: func () void = bios_printf+0 (used reg = )
25216 6F91           E8         99A5            call	_bios_printf
25217 6F94           83C4                   06  add	sp,*6
25218                                           !BCC_EOS
25219                                           ! 4300       goto int13_fail;
25220 6F97           83C4                   00  add	sp,#..FFE4-..FFE5
25221 6F9A           EB           1E            jmp .FFE4
25222                                           !BCC_EOS
25223                                           ! 4301       break;
25224 6F9C           EB           1C            jmp .610
25225                                           !BCC_EOS
25226                                           ! 4302   }
25227                                           ! 4303 int13_fail:
25228 6F9E           EB           1A            jmp .610
25229                       00006FA0            .612:
25230 6FA0           2C                     4A  sub	al,*$4A
25231 6FA2         0F84         FE69            beq 	.613
25232 6FA6           2C                     01  sub	al,*1
25233 6FA8         0F84         FE7D            beq 	.617
25234 6FAC           2C                     01  sub	al,*1
25235 6FAE         0F84         FE5D            beq 	.614
25236 6FB2           2C                     01  sub	al,*1
25237 6FB4         0F84         FE57            beq 	.615
25238 6FB8           EB           C9            jmp	.61A
25239                       00006FBA            .610:
25240                       FFFFFFFC            ..FFE5	=	-4
25241                       00006FBA            .FFE4:
25242                       FFFFFFFC            ..FFE4	=	-4
25243                                           ! 4304   *(((Bit8u *)&AX)+1) = (0x01);
25244                                           ! Debug: eq int = const 1 to unsigned char AX = [S+4+$15] (used reg = )
25245 6FBA           B0                     01  mov	al,*1
25246 6FBC           8846         17            mov	$17[bp],al
25247                                           !BCC_EOS
25248                                           ! 4305   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
25249                                           ! Debug: list int = const $40 (used reg = )
25250 6FBF           B8                   0040  mov	ax,*$40
25251 6FC2           50                         push	ax
25252                                           ! Debug: list int = const $74 (used reg = )
25253 6FC3           B8                   0074  mov	ax,*$74
25254 6FC6           50                         push	ax
25255                                           ! Debug: list unsigned char AX = [S+8+$15] (used reg = )
25256 6FC7           8A46         17            mov	al,$17[bp]
25257 6FCA           30E4                       xor	ah,ah
25258 6FCC           50                         push	ax
25259                                           ! Debug: func () void = _write_byte+0 (used reg = )
25260 6FCD           E8         962B            call	__write_byte
25261 6FD0           83C4                   06  add	sp,*6
25262                                           !BCC_EOS
25263                                           ! 4306   FLAGS |= 0x0001;
25264                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
25265 6FD3           8B46         1C            mov	ax,$1C[bp]
25266 6FD6           0C                     01  or	al,*1
25267 6FD8           8946         1C            mov	$1C[bp],ax
25268                                           !BCC_EOS
25269                                           ! 4307   return;
25270 6FDB           89EC                       mov	sp,bp
25271 6FDD           5D                         pop	bp
25272 6FDE           C3                         ret
25273                                           !BCC_EOS
25274                                           ! 4308 int13_success:
25275                       00006FDF            .FFE3:
25276                       FFFFFFFC            ..FFE3	=	-4
25277                                           ! 4309   *(((Bit8u *)&AX)+1) = (0x00);
25278                                           ! Debug: eq int = const 0 to unsigned char AX = [S+4+$15] (used reg = )
25279 6FDF           30C0                       xor	al,al
25280 6FE1           8846         17            mov	$17[bp],al
25281                                           !BCC_EOS
25282                                           ! 4310   _write_byte(0x00, 0x0074, 0x0040);
25283                                           ! Debug: list int = const $40 (used reg = )
25284 6FE4           B8                   0040  mov	ax,*$40
25285 6FE7           50                         push	ax
25286                                           ! Debug: list int = const $74 (used reg = )
25287 6FE8           B8                   0074  mov	ax,*$74
25288 6FEB           50                         push	ax
25289                                           ! Debug: list int = const 0 (used reg = )
25290 6FEC           31C0                       xor	ax,ax
25291 6FEE           50                         push	ax
25292                                           ! Debug: func () void = _write_byte+0 (used reg = )
25293 6FEF           E8         9609            call	__write_byte
25294 6FF2           83C4                   06  add	sp,*6
25295                                           !BCC_EOS
25296                                           ! 4311   FLAGS &= 0xfffe;
25297                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
25298 6FF5           8B46         1C            mov	ax,$1C[bp]
25299 6FF8           24                     FE  and	al,#$FE
25300 6FFA           8946         1C            mov	$1C[bp],ax
25301                                           !BCC_EOS
25302                                           ! 4312 }
25303 6FFD           89EC                       mov	sp,bp
25304 6FFF           5D                         pop	bp
25305 7000           C3                         ret
25306                                           ! 4313   void
25307                                           ! Register BX used in function int13_eltorito
25308                                           ! 4314 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
25309                                           ! 4315   Bit16u DS, ES, DI, SI, BP, S
25310                                           export	_int13_cdemu
25311                       00007001            _int13_cdemu:
25312                                           ! 4315 P, BX, DX, CX, AX, IP, CS, FLAGS;
25313                                           !BCC_EOS
25314                                           ! 4316 {
25315                                           ! 4317   Bit8u device, status;
25316                                           !BCC_EOS
25317                                           ! 4318   Bit16u vheads, vspt, vcylinders;
25318                                           !BCC_EOS
25319                                           ! 4319   Bit16u head, sector, cylinder, nbsectors, count;
25320                                           !BCC_EOS
25321                                           ! 4320   Bit32u vlba, ilba, slba, elba, lba;
25322                                           !BCC_EOS
25323                                           ! 4321   Bit16u before, segment, offset;
25324                                           !BCC_EOS
25325                                           ! 4322   Bit8u atacmd[12];
25326                                           !BCC_EOS
25327                                           ! 4323   ;
25328 7001           55                         push	bp
25329 7002           89E5                       mov	bp,sp
25330 7004           83C4                   C8  add	sp,*-$38
25331                                           !BCC_EOS
25332                                           ! 4324   device = *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) * 2;
25333                                           ! Debug: mul int = const 2 to unsigned char = [+$25D] (used reg = )
25334 7007           A0         025D            mov	al,[$25D]
25335 700A           30E4                       xor	ah,ah
25336 700C           D1E0                       shl	ax,*1
25337                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$3A-3] (used reg = )
25338 700E           8846         FF            mov	-1[bp],al
25339                                           !BCC_EOS
25340                                           ! 4325   device += *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec));
25341                                           ! Debug: addab unsigned char = [+$25E] to unsigned char device = [S+$3A-3] (used reg = )
25342 7011           8A46         FF            mov	al,-1[bp]
25343 7014           30E4                       xor	ah,ah
25344 7016           0206       025E            add	al,[$25E]
25345 701A           80D4                   00  adc	ah,*0
25346 701D           8846         FF            mov	-1[bp],al
25347                                           !BCC_EOS
25348                                           ! 4326   _write_byte(0x00, 0x0074, 0x0040);
25349                                           ! Debug: list int = const $40 (used reg = )
25350 7020           B8                   0040  mov	ax,*$40
25351 7023           50                         push	ax
25352                                           ! Debug: list int = const $74 (used reg = )
25353 7024           B8                   0074  mov	ax,*$74
25354 7027           50                         push	ax
25355                                           ! Debug: list int = const 0 (used reg = )
25356 7028           31C0                       xor	ax,ax
25357 702A           50                         push	ax
25358                                           ! Debug: func () void = _write_byte+0 (used reg = )
25359 702B           E8         95CD            call	__write_byte
25360 702E           83C4                   06  add	sp,*6
25361                                           !BCC_EOS
25362                                           ! 4327   if( (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) ==0) ||
25363                                           ! 4328       (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) != ( DX & 0x00ff ))) {
25364                                           ! Debug: logeq int = const 0 to unsigned char = [+$25A] (used reg = )
25365 7031           A0         025A            mov	al,[$25A]
25366 7034           84C0                       test	al,al
25367 7036           74           09            je  	.61D
25368                       00007038            .61E:
25369                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25370 7038           8A46         12            mov	al,$12[bp]
25371                                           ! Debug: ne unsigned char = al+0 to unsigned char = [+$25C] (used reg = )
25372                                           ! Debug: expression subtree swapping
25373 703B           3A06       025C            cmp	al,[$25C]
25374 703F           74           20            je  	.61C
25375                       00007041            .61D:
25376                                           ! 4329     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", *(((Bit8u *)&AX)+1), ( DX & 0x00ff ));
25377                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25378 7041           8A46         12            mov	al,$12[bp]
25379                                           ! Debug: list unsigned char = al+0 (used reg = )
25380 7044           30E4                       xor	ah,ah
25381 7046           50                         push	ax
25382                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25383 7047           8A46         17            mov	al,$17[bp]
25384 704A           30E4                       xor	ah,ah
25385 704C           50                         push	ax
25386                                           ! Debug: list * char = .61F+0 (used reg = )
25387 704D           BB                   CEBB  mov	bx,#.61F
25388 7050           53                         push	bx
25389                                           ! Debug: list int = const 4 (used reg = )
25390 7051           B8                   0004  mov	ax,*4
25391 7054           50                         push	ax
25392                                           ! Debug: func () void = bios_printf+0 (used reg = )
25393 7055           E8         98E1            call	_bios_printf
25394 7058           83C4                   08  add	sp,*8
25395                                           !BCC_EOS
25396                                           ! 4330     goto int13_fail;
25397 705B           83C4                   00  add	sp,#..FFE2+$3A
25398 705E           E9         03CA            br 	.FFE2
25399                                           !BCC_EOS
25400                                           ! 4331   }
25401                                           ! 4332   switch (*(((Bit8u *)&AX)+1)) {
25402                       00007061            .61C:
25403 7061           8A46         17            mov	al,$17[bp]
25404 7064           E9         0349            br 	.622
25405                                           ! 4333     case 0x00:
25406                                           ! 4334     case 0x09:
25407                       00007067            .623:
25408                                           ! 4335     case 0x0c:
25409                       00007067            .624:
25410                                           ! 4336     case 0x0d:
25411                       00007067            .625:
25412                                           ! 4337     case 0x10:
25413                       00007067            .626:
25414                                           ! 4338     case 0x11:
25415                       00007067            .627:
25416                                           ! 4339     case 0x14:
25417                       00007067            .628:
25418                                           ! 4340     case 0x16:
25419                       00007067            .629:
25420                                           ! 4341       goto int13_success;
25421                       00007067            .62A:
25422 7067           83C4                   00  add	sp,#..FFE0-..FFE1
25423 706A           E9         03E3            br 	.FFE0
25424                                           !BCC_EOS
25425                                           ! 4342       break;
25426 706D           E9         03BB            br 	.620
25427                                           !BCC_EOS
25428                                           ! 4343     case 0x03:
25429                                           ! 4344     case 0x05:
25430                       00007070            .62B:
25431                                           ! 4345       *(((Bit8u *)&AX)+1) = (0x03);
25432                       00007070            .62C:
25433                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
25434 7070           B0                     03  mov	al,*3
25435 7072           8846         17            mov	$17[bp],al
25436                                           !BCC_EOS
25437                                           ! 4346       goto int13_fail_noah;
25438 7075           83C4                   00  add	sp,#..FFDF-..FFE1
25439 7078           E9         03B5            br 	.FFDF
25440                                           !BCC_EOS
25441                                           ! 4347       break;
25442 707B           E9         03AD            br 	.620
25443                                           !BCC_EOS
25444                                           ! 4348     case 0x01:
25445                                           ! 4349       status=_read_byte(0x0074, 0x0040);
25446                       0000707E            .62D:
25447                                           ! Debug: list int = const $40 (used reg = )
25448 707E           B8                   0040  mov	ax,*$40
25449 7081           50                         push	ax
25450                                           ! Debug: list int = const $74 (used reg = )
25451 7082           B8                   0074  mov	ax,*$74
25452 7085           50                         push	ax
25453                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25454 7086           E8         9556            call	__read_byte
25455 7089           83C4                   04  add	sp,*4
25456                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$3A-4] (used reg = )
25457 708C           8846         FE            mov	-2[bp],al
25458                                           !BCC_EOS
25459                                           ! 4350       *(((Bit8u *)&AX)+1) = (status);
25460                                           ! Debug: eq unsigned char status = [S+$3A-4] to unsigned char AX = [S+$3A+$15] (used reg = )
25461 708F           8A46         FE            mov	al,-2[bp]
25462 7092           8846         17            mov	$17[bp],al
25463                                           !BCC_EOS
25464                                           ! 4351       _write_byte(0, 0x0074, 0x0040);
25465                                           ! Debug: list int = const $40 (used reg = )
25466 7095           B8                   0040  mov	ax,*$40
25467 7098           50                         push	ax
25468                                           ! Debug: list int = const $74 (used reg = )
25469 7099           B8                   0074  mov	ax,*$74
25470 709C           50                         push	ax
25471                                           ! Debug: list int = const 0 (used reg = )
25472 709D           31C0                       xor	ax,ax
25473 709F           50                         push	ax
25474                                           ! Debug: func () void = _write_byte+0 (used reg = )
25475 70A0           E8         9558            call	__write_byte
25476 70A3           83C4                   06  add	sp,*6
25477                                           !BCC_EOS
25478                                           ! 4352       if (status) goto int13_fail_nostatus;
25479 70A6           8A46         FE            mov	al,-2[bp]
25480 70A9           84C0                       test	al,al
25481 70AB           74           08            je  	.62E
25482                       000070AD            .62F:
25483 70AD           83C4                   00  add	sp,#..FFDE-..FFE1
25484 70B0           E9         0391            br 	.FFDE
25485                                           !BCC_EOS
25486                                           ! 4353       else goto int13_success_noah;
25487 70B3           EB           06            jmp .630
25488                       000070B5            .62E:
25489 70B5           83C4                   00  add	sp,#..FFDD-..FFE1
25490 70B8           E9         039A            br 	.FFDD
25491                                           !BCC_EOS
25492                                           ! 4354       break;
25493                       000070BB            .630:
25494 70BB           E9         036D            br 	.620
25495                                           !BCC_EOS
25496                                           ! 4355     case 0x02:
25497                                           ! 4356     case 0x04:
25498                       000070BE            .631:
25499                                           ! 4357       vspt = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25500                       000070BE            .632:
25501                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25502 70BE           A1         026E            mov	ax,[$26E]
25503 70C1           8946         FA            mov	-6[bp],ax
25504                                           !BCC_EOS
25505                                           ! 4358       vcylinders = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
25506                                           ! Debug: eq unsigned short = [+$26C] to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25507 70C4           A1         026C            mov	ax,[$26C]
25508 70C7           8946         F8            mov	-8[bp],ax
25509                                           !BCC_EOS
25510                                           ! 4359       vheads = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads));
25511                                           ! Debug: eq unsigned short = [+$26A] to unsigned short vheads = [S+$3A-6] (used reg = )
25512 70CA           A1         026A            mov	ax,[$26A]
25513 70CD           8946         FC            mov	-4[bp],ax
25514                                           !BCC_EOS
25515                                           ! 4360       ilba = *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba));
25516                                           ! Debug: eq unsigned long = [+$260] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25517 70D0           A1         0260            mov	ax,[$260]
25518 70D3           8B1E       0262            mov	bx,[$262]
25519 70D7           8946         E6            mov	-$1A[bp],ax
25520 70DA           895E         E8            mov	-$18[bp],bx
25521                                           !BCC_EOS
25522                                           ! 4361       sector = ( CX & 0x00ff ) & 0x003f;
25523                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25524 70DD           8A46         14            mov	al,$14[bp]
25525                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
25526 70E0           24                     3F  and	al,*$3F
25527                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$3A-$E] (used reg = )
25528 70E2           30E4                       xor	ah,ah
25529 70E4           8946         F4            mov	-$C[bp],ax
25530                                           !BCC_EOS
25531                                           ! 4362       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | *(((Bit8u *)&CX)+1);
25532                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25533 70E7           8A46         14            mov	al,$14[bp]
25534                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
25535 70EA           24                     C0  and	al,#$C0
25536                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
25537 70EC           30E4                       xor	ah,ah
25538 70EE           D1E0                       shl	ax,*1
25539 70F0           D1E0                       shl	ax,*1
25540                                           ! Debug: or unsigned char CX = [S+$3A+$13] to unsigned int = ax+0 (used reg = )
25541 70F2           0A46         15            or	al,$15[bp]
25542                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$3A-$10] (used reg = )
25543 70F5           8946         F2            mov	-$E[bp],ax
25544                                           !BCC_EOS
25545                                           ! 4363       head = *(((Bit8u *)&DX)+1);
25546                                           ! Debug: eq unsigned char DX = [S+$3A+$11] to unsigned short head = [S+$3A-$C] (used reg = )
25547 70F8           8A46         13            mov	al,$13[bp]
25548 70FB           30E4                       xor	ah,ah
25549 70FD           8946         F6            mov	-$A[bp],ax
25550                                           !BCC_EOS
25551                                           ! 4364       nbsectors = ( AX & 0x00ff );
25552                                           ! Debug: and int = const $FF to unsigned short AX = [S+$3A+$14] (used reg = )
25553 7100           8A46         16            mov	al,$16[bp]
25554                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25555 7103           30E4                       xor	ah,ah
25556 7105           8946         F0            mov	-$10[bp],ax
25557                                           !BCC_EOS
25558                                           ! 4365       segment = ES;
25559                                           ! Debug: eq unsigned short ES = [S+$3A+4] to unsigned short segment = [S+$3A-$2C] (used reg = )
25560 7108           8B46         06            mov	ax,6[bp]
25561 710B           8946         D6            mov	-$2A[bp],ax
25562                                           !BCC_EOS
25563                                           ! 4366       offset = BX;
25564                                           ! Debug: eq unsigned short BX = [S+$3A+$E] to unsigned short offset = [S+$3A-$2E] (used reg = )
25565 710E           8B46         10            mov	ax,$10[bp]
25566 7111           8946         D4            mov	-$2C[bp],ax
25567                                           !BCC_EOS
25568                                           ! 4367       if(nbsectors==0) goto int13_success;
25569                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25570 7114           8B46         F0            mov	ax,-$10[bp]
25571 7117           85C0                       test	ax,ax
25572 7119           75           06            jne 	.633
25573                       0000711B            .634:
25574 711B           83C4                   00  add	sp,#..FFE0-..FFE1
25575 711E           E9         032F            br 	.FFE0
25576                                           !BCC_EOS
25577                                           ! 4368       if ((sector > vspt)
25578                       00007121            .633:
25579                                           ! 4369        || (cylinder >= vcylinders)
25580                                           ! 4370        || (head >= vheads)) {
25581                                           ! Debug: gt unsigned short vspt = [S+$3A-8] to unsigned short sector = [S+$3A-$E] (used reg = )
25582 7121           8B46         F4            mov	ax,-$C[bp]
25583 7124           3B46         FA            cmp	ax,-6[bp]
25584 7127           77           10            ja  	.636
25585                       00007129            .638:
25586                                           ! Debug: ge unsigned short vcylinders = [S+$3A-$A] to unsigned short cylinder = [S+$3A-$10] (used reg = )
25587 7129           8B46         F2            mov	ax,-$E[bp]
25588 712C           3B46         F8            cmp	ax,-8[bp]
25589 712F           73           08            jae 	.636
25590                       00007131            .637:
25591                                           ! Debug: ge unsigned short vheads = [S+$3A-6] to unsigned short head = [S+$3A-$C] (used reg = )
25592 7131           8B46         F6            mov	ax,-$A[bp]
25593 7134           3B46         FC            cmp	ax,-4[bp]
25594 7137           72           06            jb  	.635
25595                       00007139            .636:
25596                                           ! 4371         goto int13_fail;
25597 7139           83C4                   00  add	sp,#..FFE2-..FFE1
25598 713C           E9         02EC            br 	.FFE2
25599                                           !BCC_EOS
25600                                           ! 4372       }
25601                                           ! 4373       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
25602                       0000713F            .635:
25603                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$3A+$15] (used reg = )
25604 713F           8A46         17            mov	al,$17[bp]
25605 7142           3C                     04  cmp	al,*4
25606 7144           75           06            jne 	.639
25607                       00007146            .63A:
25608 7146           83C4                   00  add	sp,#..FFE0-..FFE1
25609 7149           E9         0304            br 	.FFE0
25610                                           !BCC_EOS
25611                                           ! 4374       segment = ES+(BX / 16);
25612                       0000714C            .639:
25613                                           ! Debug: div int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25614 714C           8B46         10            mov	ax,$10[bp]
25615 714F           B1                     04  mov	cl,*4
25616 7151           D3E8                       shr	ax,cl
25617                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$3A+4] (used reg = )
25618                                           ! Debug: expression subtree swapping
25619 7153           0346         06            add	ax,6[bp]
25620                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$3A-$2C] (used reg = )
25621 7156           8946         D6            mov	-$2A[bp],ax
25622                                           !BCC_EOS
25623                                           ! 4375       offs
25624                                           ! 4375 et = BX % 16;
25625                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25626 7159           8B46         10            mov	ax,$10[bp]
25627 715C           24                     0F  and	al,*$F
25628                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$3A-$2E] (used reg = )
25629 715E           30E4                       xor	ah,ah
25630 7160           8946         D4            mov	-$2C[bp],ax
25631                                           !BCC_EOS
25632                                           ! 4376       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
25633                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$3A-$E] (used reg = )
25634 7163           8B46         F4            mov	ax,-$C[bp]
25635                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
25636 7166           48                         dec	ax
25637 7167           31DB                       xor	bx,bx
25638 7169           53                         push	bx
25639 716A           50                         push	ax
25640                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3E-8] (used reg = )
25641 716B           8B46         FA            mov	ax,-6[bp]
25642 716E           31DB                       xor	bx,bx
25643 7170           53                         push	bx
25644 7171           50                         push	ax
25645                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$42-$C] (used reg = )
25646 7172           8B46         F6            mov	ax,-$A[bp]
25647 7175           31DB                       xor	bx,bx
25648 7177           53                         push	bx
25649 7178           50                         push	ax
25650                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$46-6] (used reg = )
25651 7179           8B46         FC            mov	ax,-4[bp]
25652 717C           31DB                       xor	bx,bx
25653 717E           53                         push	bx
25654 717F           50                         push	ax
25655                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$4A-$10] (used reg = )
25656 7180           8B46         F2            mov	ax,-$E[bp]
25657 7183           31DB                       xor	bx,bx
25658                                           ! Debug: mul unsigned long (temp) = [S+$4A-$4A] to unsigned long = bx+0 (used reg = )
25659 7185           8D7E         B8            lea	di,-$E+..FFE1[bp]
25660 7188           E8         8F2F            call	lmulul
25661 718B           83C4                   04  add	sp,*4
25662                                           ! Debug: add unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
25663 718E           8D7E         BC            lea	di,-$A+..FFE1[bp]
25664 7191           E8         8F00            call	laddul
25665 7194           83C4                   04  add	sp,*4
25666                                           ! Debug: mul unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
25667 7197           8D7E         C0            lea	di,-6+..FFE1[bp]
25668 719A           E8         8F1D            call	lmulul
25669 719D           83C4                   04  add	sp,*4
25670                                           ! Debug: add unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
25671 71A0           8D7E         C4            lea	di,-2+..FFE1[bp]
25672 71A3           E8         8EEE            call	laddul
25673 71A6           83C4                   04  add	sp,*4
25674                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25675 71A9           8946         EA            mov	-$16[bp],ax
25676 71AC           895E         EC            mov	-$14[bp],bx
25677                                           !BCC_EOS
25678                                           ! 4377       *((Bit8u *)&AX) = (nbsectors);
25679                                           ! Debug: eq unsigned short nbsectors = [S+$3A-$12] to unsigned char AX = [S+$3A+$14] (used reg = )
25680 71AF           8A46         F0            mov	al,-$10[bp]
25681 71B2           8846         16            mov	$16[bp],al
25682                                           !BCC_EOS
25683                                           ! 4378       slba = (Bit32u)vlba/4;
25684                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$3A-$18] (used reg = )
25685 71B5           B8                   0004  mov	ax,*4
25686 71B8           31DB                       xor	bx,bx
25687 71BA           53                         push	bx
25688 71BB           50                         push	ax
25689 71BC           8B46         EA            mov	ax,-$16[bp]
25690 71BF           8B5E         EC            mov	bx,-$14[bp]
25691 71C2           8D7E         C4            lea	di,-2+..FFE1[bp]
25692 71C5           E8         8F77            call	ldivul
25693 71C8           83C4                   04  add	sp,*4
25694                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$3A-$20] (used reg = )
25695 71CB           8946         E2            mov	-$1E[bp],ax
25696 71CE           895E         E4            mov	-$1C[bp],bx
25697                                           !BCC_EOS
25698                                           ! 4379       before= (Bit16u)vlba%4;
25699                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$3A-$18] (used reg = )
25700 71D1           8B46         EA            mov	ax,-$16[bp]
25701 71D4           24                     03  and	al,*3
25702                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$3A-$2A] (used reg = )
25703 71D6           30E4                       xor	ah,ah
25704 71D8           8946         D8            mov	-$28[bp],ax
25705                                           !BCC_EOS
25706                                           ! 4380       elba = (Bit32u)(vlba+nbsectors-1)/4;
25707                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25708 71DB           8B46         F0            mov	ax,-$10[bp]
25709 71DE           31DB                       xor	bx,bx
25710                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25711                                           ! Debug: expression subtree swapping
25712 71E0           8D7E         EA            lea	di,-$16[bp]
25713 71E3           E8         8EAE            call	laddul
25714                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
25715 71E6           53                         push	bx
25716 71E7           50                         push	ax
25717 71E8           B8                   0001  mov	ax,*1
25718 71EB           31DB                       xor	bx,bx
25719 71ED           53                         push	bx
25720 71EE           50                         push	ax
25721 71EF           8B46         C4            mov	ax,-2+..FFE1[bp]
25722 71F2           8B5E         C6            mov	bx,0+..FFE1[bp]
25723 71F5           8D7E         C0            lea	di,-6+..FFE1[bp]
25724 71F8           E8         8EB7            call	lsubul
25725 71FB           83C4                   08  add	sp,*8
25726                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
25727                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
25728 71FE           53                         push	bx
25729 71FF           50                         push	ax
25730 7200           B8                   0004  mov	ax,*4
25731 7203           31DB                       xor	bx,bx
25732 7205           53                         push	bx
25733 7206           50                         push	ax
25734 7207           8B46         C4            mov	ax,-2+..FFE1[bp]
25735 720A           8B5E         C6            mov	bx,0+..FFE1[bp]
25736 720D           8D7E         C0            lea	di,-6+..FFE1[bp]
25737 7210           E8         8F2C            call	ldivul
25738 7213           83C4                   08  add	sp,*8
25739                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$3A-$24] (used reg = )
25740 7216           8946         DE            mov	-$22[bp],ax
25741 7219           895E         E0            mov	-$20[bp],bx
25742                                           !BCC_EOS
25743                                           ! 4381       _memsetb(0,atacmd,get_SS(),12);
25744                                           ! Debug: list int = const $C (used reg = )
25745 721C           B8                   000C  mov	ax,*$C
25746 721F           50                         push	ax
25747                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25748 7220           E8         9437            call	_get_SS
25749                                           ! Debug: list unsigned short = ax+0 (used reg = )
25750 7223           50                         push	ax
25751                                           ! Debug: list * unsigned char atacmd = S+$3E-$3A (used reg = )
25752 7224           8D5E         C8            lea	bx,-$38[bp]
25753 7227           53                         push	bx
25754                                           ! Debug: list int = const 0 (used reg = )
25755 7228           31C0                       xor	ax,ax
25756 722A           50                         push	ax
25757                                           ! Debug: func () void = _memsetb+0 (used reg = )
25758 722B           E8         8DD2            call	__memsetb
25759 722E           83C4                   08  add	sp,*8
25760                                           !BCC_EOS
25761                                           ! 4382       atacmd[0]=0x28;
25762                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$3A-$3A] (used reg = )
25763 7231           B0                     28  mov	al,*$28
25764 7233           8846         C8            mov	-$38[bp],al
25765                                           !BCC_EOS
25766                                           ! 4383       count = (Bit16u)(elba-slba)+1;
25767                                           ! Debug: sub unsigned long slba = [S+$3A-$20] to unsigned long elba = [S+$3A-$24] (used reg = )
25768 7236           8B46         DE            mov	ax,-$22[bp]
25769 7239           8B5E         E0            mov	bx,-$20[bp]
25770 723C           8D7E         E2            lea	di,-$1E[bp]
25771 723F           E8         8E70            call	lsubul
25772                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
25773                                           ! Debug: add int = const 1 to unsigned short = ax+0 (used reg = )
25774                                           ! Debug: eq unsigned int = ax+1 to unsigned short count = [S+$3A-$14] (used reg = )
25775 7242           40                         inc	ax
25776 7243           8946         EE            mov	-$12[bp],ax
25777                                           !BCC_EOS
25778                                           ! 4384       atacmd[7]=*(((Bit8u *)&count)+1);
25779                                           ! Debug: eq unsigned char count = [S+$3A-$13] to unsigned char atacmd = [S+$3A-$33] (used reg = )
25780 7246           8A46         EF            mov	al,-$11[bp]
25781 7249           8846         CF            mov	-$31[bp],al
25782                                           !BCC_EOS
25783                                           ! 4385       atacmd[8]=*((Bit8u *)&count);
25784                                           ! Debug: eq unsigned char count = [S+$3A-$14] to unsigned char atacmd = [S+$3A-$32] (used reg = )
25785 724C           8A46         EE            mov	al,-$12[bp]
25786 724F           8846         D0            mov	-$30[bp],al
25787                                           !BCC_EOS
25788                                           ! 4386       lba = ilba+slba;
25789                                           ! Debug: add unsigned long slba = [S+$3A-$20] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25790 7252           8B46         E6            mov	ax,-$1A[bp]
25791 7255           8B5E         E8            mov	bx,-$18[bp]
25792 7258           8D7E         E2            lea	di,-$1E[bp]
25793 725B           E8         8E36            call	laddul
25794                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$3A-$28] (used reg = )
25795 725E           8946         DA            mov	-$26[bp],ax
25796 7261           895E         DC            mov	-$24[bp],bx
25797                                           !BCC_EOS
25798                                           ! 4387       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
25799                                           ! Debug: eq unsigned char lba = [S+$3A-$25] to unsigned char atacmd = [S+$3A-$38] (used reg = )
25800 7264           8A46         DD            mov	al,-$23[bp]
25801 7267           8846         CA            mov	-$36[bp],al
25802                                           !BCC_EOS
25803                                           ! 4388       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
25804                                           ! Debug: eq unsigned char lba = [S+$3A-$26] to unsigned char atacmd = [S+$3A-$37] (used reg = )
25805 726A           8A46         DC            mov	al,-$24[bp]
25806 726D           8846         CB            mov	-$35[bp],al
25807                                           !BCC_EOS
25808                                           ! 4389       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
25809                                           ! Debug: eq unsigned char lba = [S+$3A-$27] to unsigned char atacmd = [S+$3A-$36] (used reg = )
25810 7270           8A46         DB            mov	al,-$25[bp]
25811 7273           8846         CC            mov	-$34[bp],al
25812                                           !BCC_EOS
25813                                           ! 4390       atacmd[5]=*((Bit8u *)&lba);
25814                                           ! Debug: eq unsigned char lba = [S+$3A-$28] to unsigned char atacmd = [S+$3A-$35] (used reg = )
25815 7276           8A46         DA            mov	al,-$26[bp]
25816 7279           8846         CD            mov	-$33[bp],al
25817                                           !BCC_EOS
25818                                           ! 4391       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
25819                                           ! Debug: list unsigned short offset = [S+$3A-$2E] (used reg = )
25820 727C           FF76         D4            push	-$2C[bp]
25821                                           ! Debug: list unsigned short segment = [S+$3C-$2C] (used reg = )
25822 727F           FF76         D6            push	-$2A[bp]
25823                                           ! Debug: list int = const 1 (used reg = )
25824 7282           B8                   0001  mov	ax,*1
25825 7285           50                         push	ax
25826                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$40-$12] (used reg = )
25827 7286           8B46         F0            mov	ax,-$10[bp]
25828 7289           31DB                       xor	bx,bx
25829                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
25830 728B           53                         push	bx
25831 728C           50                         push	ax
25832 728D           B8                   0200  mov	ax,#$200
25833 7290           31DB                       xor	bx,bx
25834 7292           53                         push	bx
25835 7293           50                         push	ax
25836 7294           8B46         BE            mov	ax,-8+..FFE1[bp]
25837 7297           8B5E         C0            mov	bx,-6+..FFE1[bp]
25838 729A           8D7E         BA            lea	di,-$C+..FFE1[bp]
25839 729D           E8         8E1A            call	lmulul
25840 72A0           83C4                   08  add	sp,*8
25841                                           ! Debug: list unsigned long = bx+0 (used reg = )
25842 72A3           53                         push	bx
25843 72A4           50                         push	ax
25844                                           ! Debug: mul int = const $200 to unsigned short before = [S+$44-$2A] (used reg = )
25845 72A5           8B46         D8            mov	ax,-$28[bp]
25846 72A8           B9                   0200  mov	cx,#$200
25847 72AB           F7E9                       imul	cx
25848                                           ! Debug: list unsigned int = ax+0 (used reg = )
25849 72AD           50                         push	ax
25850                                           ! Debug: list * unsigned char atacmd = S+$46-$3A (used reg = )
25851 72AE           8D5E         C8            lea	bx,-$38[bp]
25852 72B1           53                         push	bx
25853                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25854 72B2           E8         93A5            call	_get_SS
25855                                           ! Debug: list unsigned short = ax+0 (used reg = )
25856 72B5           50                         push	ax
25857                                           ! Debug: list int = const $C (used reg = )
25858 72B6           B8                   000C  mov	ax,*$C
25859 72B9           50                         push	ax
25860                                           ! Debug: list unsigned char device = [S+$4C-3] (used reg = )
25861 72BA           8A46         FF            mov	al,-1[bp]
25862 72BD           30E4                       xor	ah,ah
25863 72BF           50                         push	ax
25864                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
25865 72C0           E8         BA82            call	_ata_cmd_packet
25866 72C3           83C4                   14  add	sp,*$14
25867                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$3A-4] (used reg = )
25868 72C6           8846         FE            mov	-2[bp],al
25869                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
25870 72C9           84C0                       test	al,al
25871 72CB           74           2A            je  	.63B
25872                       000072CD            .63C:
25873                                           ! 4392         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
25874                                           ! Debug: list unsigned char status = [S+$3A-4] (used reg = )
25875 72CD           8A46         FE            mov	al,-2[bp]
25876 72D0           30E4                       xor	ah,ah
25877 72D2           50                         push	ax
25878                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25879 72D3           8A46         17            mov	al,$17[bp]
25880 72D6           30E4                       xor	ah,ah
25881 72D8           50                         push	ax
25882                                           ! Debug: list * char = .63D+0 (used reg = )
25883 72D9           BB                   CE91  mov	bx,#.63D
25884 72DC           53                         push	bx
25885                                           ! Debug: list int = const 4 (used reg = )
25886 72DD           B8                   0004  mov	ax,*4
25887 72E0           50                         push	ax
25888                                           ! Debug: func () void = bios_printf+0 (used reg = )
25889 72E1           E8         9655            call	_bios_printf
25890 72E4           83C4                   08  add	sp,*8
25891                                           !BCC_EOS
25892                                           ! 4393         *(((Bit8u *)&AX)+1) = (0x02);
25893                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$3A+$15] (used reg = )
25894 72E7           B0                     02  mov	al,*2
25895 72E9           8846         17            mov	$17[bp],al
25896                                           !BCC_EOS
25897                                           ! 4394         *((Bit8u *)&AX) = (0);
25898                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25899 72EC           30C0                       xor	al,al
25900 72EE           8846         16            mov	$16[bp],al
25901                                           !BCC_EOS
25902                                           ! 4395         goto int13_fail_noah;
25903 72F1           83C4                   00  add	sp,#..FFDF-..FFE1
25904 72F4           E9         0139            br 	.FFDF
25905                                           !BCC_EOS
25906                                           ! 4396       }
25907                                           ! 4397       goto int13_success;
25908                       000072F7            .63B:
25909 72F7           83C4                   00  add	sp,#..FFE0-..FFE1
25910 72FA           E9         0153            br 	.FFE0
25911                                           !BCC_EOS
25912                                           ! 4398       break;
25913 72FD           E9         012B            br 	.620
25914                                           !BCC_EOS
25915                                           ! 4399     case 0x08:
25916                                           ! 4400       vspt=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25917                       00007300            .63E:
25918                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25919 7300           A1         026E            mov	ax,[$26E]
25920 7303           8946         FA            mov	-6[bp],ax
25921                                           !BCC_EOS
25922                                           ! 4401       vcylinders=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) - 1;
25923                                           ! Debug: sub int = const 1 to unsigned short = [+$26C] (used reg = )
25924 7306           A1         026C            mov	ax,[$26C]
25925                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25926 7309           48                         dec	ax
25927 730A           8946         F8            mov	-8[bp],ax
25928                                           !BCC_EOS
25929                                           ! 4402       vheads=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) - 1;
25930                                           ! Debug: sub int = const 1 to unsigned short = [+$26A] (used reg = )
25931 730D           A1         026A            mov	ax,[$26A]
25932                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$3A-6] (used reg = )
25933 7310           48                         dec	ax
25934 7311           8946         FC            mov	-4[bp],ax
25935                                           !BCC_EOS
25936                                           ! 4403       *((Bit8u *)&AX) = (0x00);
25937                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25938 7314           30C0                       xor	al,al
25939 7316           8846         16            mov	$16[bp],al
25940                                           !BCC_EOS
25941                                           ! 4404       *((Bit8u *)&BX) = (0x00);
25942                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$3A+$E] (used reg = )
25943 7319           30C0                       xor	al,al
25944 731B           8846         10            mov	$10[bp],al
25945                                           !BCC_EOS
25946                                           ! 4405       *(((Bit8u *)&CX)+1) = (vcylinders & 0xff);
25947                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25948 731E           8A46         F8            mov	al,-8[bp]
25949                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$13] (used reg = )
25950 7321           8846         15            mov	$15[bp],al
25951                                           !BCC_EOS
25952                                           ! 4406       *((Bit8u *)&CX) = (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f));
25953                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$3A-8] (used reg = )
25954 7324           8A46         FA            mov	al,-6[bp]
25955 7327           24                     3F  and	al,*$3F
25956 7329           50                         push	ax
25957                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$3C-$A] (used reg = )
25958 732A           8B46         F8            mov	ax,-8[bp]
25959 732D           D1E8                       shr	ax,*1
25960 732F           D1E8                       shr	ax,*1
25961                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
25962 7331           24                     C0  and	al,#$C0
25963                                           ! Debug: or unsigned char (temp) = [S+$3C-$3C] to unsigned char = al+0 (used reg = )
25964 7333           0A46         C6            or	al,0+..FFE1[bp]
25965 7336           44                         inc	sp
25966 7337           44                         inc	sp
25967                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$12] (used reg = )
25968 7338           8846         14            mov	$14[bp],al
25969                                           !BCC_EOS
25970                                           ! 4407       *(((Bit8u *)&DX)+1) = (vheads);
25971                                           ! Debug: eq unsigned short vheads = [S+$3A-6] to unsigned char DX = [S+$3A+$11] (used reg = )
25972 733B           8A46         FC            mov	al,-4[bp]
25973 733E           8846         13            mov	$13[bp],al
25974                                           !BCC_EOS
25975                                           ! 4408       *((Bit8u *)&DX) = (0x02);
25976                                           ! Debug: eq int = const 2 to unsigned char DX = [S+$3A+$10] (used reg = )
25977 7341           B0                     02  mov	al,*2
25978 7343           8846         12            mov	$12[bp],al
25979                                           !BCC_EOS
25980                                           ! 4409       switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
25981 7346           A0         025B            mov	al,[$25B]
25982 7349           EB           17            jmp .641
25983                                           ! 4410         case 0x01: *((Bit8u *)&BX) = (0x02); break;
25984                       0000734B            .642:
25985                                           ! Debug: eq int = const 2 to unsigned char BX = [S+$3A+$E] (used reg = )
25986 734B           B0                     02  mov	al,*2
25987 734D           8846         10            mov	$10[bp],al
25988                                           !BCC_EOS
25989 7350           EB           1C            jmp .63F
25990                                           !BCC_EOS
25991                                           ! 4411         case 0x02: *((Bit8u *)&BX) = (0x04); break;
25992                       00007352            .643:
25993                                           ! Debug: eq int = const 4 to unsigned char BX = [S+$3A+$E] (used reg = )
25994 7352           B0                     04  mov	al,*4
25995 7354           8846         10            mov	$10[bp],al
25996                                           !BCC_EOS
25997 7357           EB           15            jmp .63F
25998                                           !BCC_EOS
25999                                           ! 4412         case 0x03: *((Bit8u *)&BX) = (0x06); break;
26000                       00007359            .644:
26001                                           ! Debug: eq int = const 6 to unsigned char BX = [S+$3A+$E] (used reg = )
26002 7359           B0                     06  mov	al,*6
26003 735B           8846         10            mov	$10[bp],al
26004                                           !BCC_EOS
26005 735E           EB           0E            jmp .63F
26006                                           !BCC_EOS
26007                                           ! 4413     }
26008                                           ! 4414 #asm
26009 7360           EB           0C            jmp .63F
26010                       00007362            .641:
26011 7362           2C                     01  sub	al,*1
26012 7364           74           E5            je 	.642
26013 7366           2C                     01  sub	al,*1
26014 7368           74           E8            je 	.643
26015 736A           2C                     01  sub	al,*1
26016 736C           74           EB            je 	.644
26017                       0000736E            .63F:
26018                                           !BCC_EOS
26019                                           !BCC_ASM
26020                       00000044            _int13_cdemu.BP	set	$44
26021                       0000000C            .int13_cdemu.BP	set	$C
26022                       00000052            _int13_cdemu.CS	set	$52
26023                       0000001A            .int13_cdemu.CS	set	$1A
26024                       00000028            _int13_cdemu.nbsectors	set	$28
26025                       FFFFFFF0            .int13_cdemu.nbsectors	set	-$10
26026                       00000026            _int13_cdemu.count	set	$26
26027                       FFFFFFEE            .int13_cdemu.count	set	-$12
26028                       0000004C            _int13_cdemu.CX	set	$4C
26029                       00000014            .int13_cdemu.CX	set	$14
26030                       00000016            _int13_cdemu.elba	set	$16
26031                       FFFFFFDE            .int13_cdemu.elba	set	-$22
26032                       0000000E            _int13_cdemu.segment	set	$E
26033                       FFFFFFD6            .int13_cdemu.segment	set	-$2A
26034                       00000040            _int13_cdemu.DI	set	$40
26035                       00000008            .int13_cdemu.DI	set	8
26036                       00000054            _int13_cdemu.FLAGS	set	$54
26037                       0000001C            .int13_cdemu.FLAGS	set	$1C
26038                       00000030            _int13_cdemu.vcylinders	set	$30
26039                       FFFFFFF8            .int13_cdemu.vcylinders	set	-8
26040                       0000002C            _int13_cdemu.sector	set	$2C
26041                       FFFFFFF4            .int13_cdemu.sector	set	-$C
26042                       0000003C            _int13_cdemu.DS	set	$3C
26043                       00000004            .int13_cdemu.DS	set	4
26044                       0000002E            _int13_cdemu.head	set	$2E
26045                       FFFFFFF6            .int13_cdemu.head	set	-$A
26046                       0000002A            _int13_cdemu.cylinder	set	$2A
26047                       FFFFFFF2            .int13_cdemu.cylinder	set	-$E
26048                       0000004A            _int13_cdemu.DX	set	$4A
26049                       00000012            .int13_cdemu.DX	set	$12
26050                       00000037            _int13_cdemu.device	set	$37
26051                       FFFFFFFF            .int13_cdemu.device	set	-1
26052                       0000003E            _int13_cdemu.ES	set	$3E
26053                       00000006            .int13_cdemu.ES	set	6
26054                       00000032            _int13_cdemu.vspt	set	$32
26055                       FFFFFFFA            .int13_cdemu.vspt	set	-6
26056                       00000022            _int13_cdemu.vlba	set	$22
26057                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
26058                       00000042            _int13_cdemu.SI	set	$42
26059                       0000000A            .int13_cdemu.SI	set	$A
26060                       00000050            _int13_cdemu.IP	set	$50
26061                       00000018            .int13_cdemu.IP	set	$18
26062                       00000012            _int13_cdemu.lba	set	$12
26063                       FFFFFFDA            .int13_cdemu.lba	set	-$26
26064                       00000036            _int13_cdemu.status	set	$36
26065                       FFFFFFFE            .int13_cdemu.status	set	-2
26066                       00000000            _int13_cdemu.atacmd	set	0
26067                       FFFFFFC8            .int13_cdemu.atacmd	set	-$38
26068                       0000004E            _int13_cdemu.AX	set	$4E
26069                       00000016            .int13_cdemu.AX	set	$16
26070                       0000001E            _int13_cdemu.ilba	set	$1E
26071                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
26072                       00000010            _int13_cdemu.before	set	$10
26073                       FFFFFFD8            .int13_cdemu.before	set	-$28
26074                       0000000C            _int13_cdemu.offset	set	$C
26075                       FFFFFFD4            .int13_cdemu.offset	set	-$2C
26076                       0000001A            _int13_cdemu.slba	set	$1A
26077                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
26078                       00000046            _int13_cdemu.SP	set	$46
26079                       0000000E            .int13_cdemu.SP	set	$E
26080                       00000034            _int13_cdemu.vheads	set	$34
26081                       FFFFFFFC            .int13_cdemu.vheads	set	-4
26082                       00000048            _int13_cdemu.BX	set	$48
26083                       00000010            .int13_cdemu.BX	set	$10
26084 736E           55                               push bp
26085 736F           89E5                             mov bp, sp
26086 7371           B8                   EFDE        mov ax, #diskette_param_table2
26087 7374           8946         42                  mov _int13_cdemu.DI+2[bp], ax
26088 7377           8C4E         40                  mov _int13_cdemu.ES+2[bp], cs
26089 737A           5D                               pop bp
26090                                           ! 4421 endasm
26091                                           !BCC_ENDASM
26092                                           !BCC_EOS
26093                                           ! 4422       goto int13_success;
26094 737B           83C4                   00  add	sp,#..FFE0-..FFE1
26095 737E           E9         00CF            br 	.FFE0
26096                                           !BCC_EOS
26097                                           ! 4423       break;
26098 7381           E9         00A7            br 	.620
26099                                           !BCC_EOS
26100                                           ! 4424     case 0x15:
26101                                           ! 4425       *(((Bit8u *)&AX)+1) = (0x03);
26102                       00007384            .645:
26103                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
26104 7384           B0                     03  mov	al,*3
26105 7386           8846         17            mov	$17[bp],al
26106                                           !BCC_EOS
26107                                           ! 4426       goto int13_success_noah;
26108 7389           83C4                   00  add	sp,#..FFDD-..FFE1
26109 738C           E9         00C6            br 	.FFDD
26110                                           !BCC_EOS
26111                                           ! 4427       break;
26112 738F           E9         0099            br 	.620
26113                                           !BCC_EOS
26114                                           ! 4428     case 0x0a:
26115                                           ! 4429     case
26116                                           ! 4429  0x0b:
26117                       00007392            .646:
26118                                           ! 4430     case 0x18:
26119                       00007392            .647:
26120                                           ! 4431     case 0x41:
26121                       00007392            .648:
26122                                           ! 4432     case 0x42:
26123                       00007392            .649:
26124                                           ! 4433     case 0x43:
26125                       00007392            .64A:
26126                                           ! 4434     case 0x44:
26127                       00007392            .64B:
26128                                           ! 4435     case 0x45:
26129                       00007392            .64C:
26130                                           ! 4436     case 0x46:
26131                       00007392            .64D:
26132                                           ! 4437     case 0x47:
26133                       00007392            .64E:
26134                                           ! 4438     case 0x48:
26135                       00007392            .64F:
26136                                           ! 4439     case 0x49:
26137                       00007392            .650:
26138                                           ! 4440     case 0x4e:
26139                       00007392            .651:
26140                                           ! 4441     case 0x50:
26141                       00007392            .652:
26142                                           ! 4442     default:
26143                       00007392            .653:
26144                                           ! 4443       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
26145                       00007392            .654:
26146                                           ! Debug: list unsigned char AX = [S+$3A+$15] (used reg = )
26147 7392           8A46         17            mov	al,$17[bp]
26148 7395           30E4                       xor	ah,ah
26149 7397           50                         push	ax
26150                                           ! Debug: list * char = .655+0 (used reg = )
26151 7398           BB                   CE59  mov	bx,#.655
26152 739B           53                         push	bx
26153                                           ! Debug: list int = const 4 (used reg = )
26154 739C           B8                   0004  mov	ax,*4
26155 739F           50                         push	ax
26156                                           ! Debug: func () void = bios_printf+0 (used reg = )
26157 73A0           E8         9596            call	_bios_printf
26158 73A3           83C4                   06  add	sp,*6
26159                                           !BCC_EOS
26160                                           ! 4444       goto int13_fail;
26161 73A6           83C4                   00  add	sp,#..FFE2-..FFE1
26162 73A9           E9         007F            jmp .FFE2
26163                                           !BCC_EOS
26164                                           ! 4445       break;
26165 73AC           EB           7D            jmp .620
26166                                           !BCC_EOS
26167                                           ! 4446   }
26168                                           ! 4447 int13_fail:
26169 73AE           EB           7B            jmp .620
26170                       000073B0            .622:
26171 73B0           2C                     00  sub	al,*0
26172 73B2           72           DE            jb 	.654
26173 73B4           3C                     18  cmp	al,*$18
26174 73B6           77           3D            ja  	.656
26175 73B8           30E4                       xor	ah,ah
26176 73BA           D1E0                       shl	ax,*1
26177 73BC           89C3                       mov	bx,ax
26178 73BE           2E                         seg	cs
26179 73BF           FFA7       73C3            br	.657[bx]
26180                       000073C3            .657:
26181 73C3                      7067            .word	.623
26182 73C5                      707E            .word	.62D
26183 73C7                      70BE            .word	.631
26184 73C9                      7070            .word	.62B
26185 73CB                      70BE            .word	.632
26186 73CD                      7070            .word	.62C
26187 73CF                      7392            .word	.654
26188 73D1                      7392            .word	.654
26189 73D3                      7300            .word	.63E
26190 73D5                      7067            .word	.624
26191 73D7                      7392            .word	.646
26192 73D9                      7392            .word	.647
26193 73DB                      7067            .word	.625
26194 73DD                      7067            .word	.626
26195 73DF                      7392            .word	.654
26196 73E1                      7392            .word	.654
26197 73E3                      7067            .word	.627
26198 73E5                      7067            .word	.628
26199 73E7                      7392            .word	.654
26200 73E9                      7392            .word	.654
26201 73EB                      7067            .word	.629
26202 73ED                      7384            .word	.645
26203 73EF                      7067            .word	.62A
26204 73F1                      7392            .word	.654
26205 73F3                      7392            .word	.648
26206                       000073F5            .656:
26207 73F5           2C                     41  sub	al,*$41
26208 73F7           72           99            jb 	.654
26209 73F9           3C                     0F  cmp	al,*$F
26210 73FB           77           2B            ja  	.658
26211 73FD           30E4                       xor	ah,ah
26212 73FF           D1E0                       shl	ax,*1
26213 7401           89C3                       mov	bx,ax
26214 7403           2E                         seg	cs
26215 7404           FFA7       7408            br	.659[bx]
26216                       00007408            .659:
26217 7408                      7392            .word	.649
26218 740A                      7392            .word	.64A
26219 740C                      7392            .word	.64B
26220 740E                      7392            .word	.64C
26221 7410                      7392            .word	.64D
26222 7412                      7392            .word	.64E
26223 7414                      7392            .word	.64F
26224 7416                      7392            .word	.650
26225 7418                      7392            .word	.651
26226 741A                      7392            .word	.654
26227 741C                      7392            .word	.654
26228 741E                      7392            .word	.654
26229 7420                      7392            .word	.654
26230 7422                      7392            .word	.652
26231 7424                      7392            .word	.654
26232 7426                      7392            .word	.653
26233                       00007428            .658:
26234 7428           E9         FF67            br 	.654
26235                       0000742B            .620:
26236                       FFFFFFC6            ..FFE1	=	-$3A
26237                       0000742B            .FFE2:
26238                       FFFFFFC6            ..FFE2	=	-$3A
26239                                           ! 4448   *(((Bit8u *)&AX)+1) = (0x01);
26240                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$3A+$15] (used reg = )
26241 742B           B0                     01  mov	al,*1
26242 742D           8846         17            mov	$17[bp],al
26243                                           !BCC_EOS
26244                                           ! 4449 int13_fail_noah:
26245                       00007430            .FFDF:
26246                       FFFFFFC6            ..FFDF	=	-$3A
26247                                           ! 4450   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
26248                                           ! Debug: list int = const $40 (used reg = )
26249 7430           B8                   0040  mov	ax,*$40
26250 7433           50                         push	ax
26251                                           ! Debug: list int = const $74 (used reg = )
26252 7434           B8                   0074  mov	ax,*$74
26253 7437           50                         push	ax
26254                                           ! Debug: list unsigned char AX = [S+$3E+$15] (used reg = )
26255 7438           8A46         17            mov	al,$17[bp]
26256 743B           30E4                       xor	ah,ah
26257 743D           50                         push	ax
26258                                           ! Debug: func () void = _write_byte+0 (used reg = )
26259 743E           E8         91BA            call	__write_byte
26260 7441           83C4                   06  add	sp,*6
26261                                           !BCC_EOS
26262                                           ! 4451 int13_fail_nostatus:
26263                       00007444            .FFDE:
26264                       FFFFFFC6            ..FFDE	=	-$3A
26265                                           ! 4452   FLAGS |= 0x0001;
26266                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26267 7444           8B46         1C            mov	ax,$1C[bp]
26268 7447           0C                     01  or	al,*1
26269 7449           8946         1C            mov	$1C[bp],ax
26270                                           !BCC_EOS
26271                                           ! 4453   return;
26272 744C           89EC                       mov	sp,bp
26273 744E           5D                         pop	bp
26274 744F           C3                         ret
26275                                           !BCC_EOS
26276                                           ! 4454 int13_success:
26277                       00007450            .FFE0:
26278                       FFFFFFC6            ..FFE0	=	-$3A
26279                                           ! 4455   *(((Bit8u *)&AX)+1) = (0x00);
26280                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$15] (used reg = )
26281 7450           30C0                       xor	al,al
26282 7452           8846         17            mov	$17[bp],al
26283                                           !BCC_EOS
26284                                           ! 4456 int13_success_noah:
26285                       00007455            .FFDD:
26286                       FFFFFFC6            ..FFDD	=	-$3A
26287                                           ! 4457   _write_byte(0x00, 0x0074, 0x0040);
26288                                           ! Debug: list int = const $40 (used reg = )
26289 7455           B8                   0040  mov	ax,*$40
26290 7458           50                         push	ax
26291                                           ! Debug: list int = const $74 (used reg = )
26292 7459           B8                   0074  mov	ax,*$74
26293 745C           50                         push	ax
26294                                           ! Debug: list int = const 0 (used reg = )
26295 745D           31C0                       xor	ax,ax
26296 745F           50                         push	ax
26297                                           ! Debug: func () void = _write_byte+0 (used reg = )
26298 7460           E8         9198            call	__write_byte
26299 7463           83C4                   06  add	sp,*6
26300                                           !BCC_EOS
26301                                           ! 4458   FLAGS &= 0xfffe;
26302                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26303 7466           8B46         1C            mov	ax,$1C[bp]
26304 7469           24                     FE  and	al,#$FE
26305 746B           8946         1C            mov	$1C[bp],ax
26306                                           !BCC_EOS
26307                                           ! 4459 }
26308 746E           89EC                       mov	sp,bp
26309 7470           5D                         pop	bp
26310 7471           C3                         ret
26311                                           ! 4460 void floppy_reset_controller()
26312                                           ! Register BX used in function int13_cdemu
26313                                           ! 4461 {
26314                                           export	_floppy_reset_controller
26315                       00007472            _floppy_reset_controller:
26316                                           ! 4462   Bit8u val8;
26317                                           !BCC_EOS
26318                                           ! 4463   val8 = inb(0x03f2);
26319 7472           55                         push	bp
26320 7473           89E5                       mov	bp,sp
26321 7475           4C                         dec	sp
26322 7476           4C                         dec	sp
26323                                           ! Debug: list int = const $3F2 (used reg = )
26324 7477           B8                   03F2  mov	ax,#$3F2
26325 747A           50                         push	ax
26326                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26327 747B           E8         90AB            call	_inb
26328 747E           44                         inc	sp
26329 747F           44                         inc	sp
26330                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26331 7480           8846         FF            mov	-1[bp],al
26332                                           !BCC_EOS
26333                                           ! 4464   outb(0x03f2, val8 & ~0x04);
26334                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
26335 7483           8A46         FF            mov	al,-1[bp]
26336 7486           24                     FB  and	al,#$FB
26337                                           ! Debug: list unsigned char = al+0 (used reg = )
26338 7488           30E4                       xor	ah,ah
26339 748A           50                         push	ax
26340                                           ! Debug: list int = const $3F2 (used reg = )
26341 748B           B8                   03F2  mov	ax,#$3F2
26342 748E           50                         push	ax
26343                                           ! Debug: func () void = outb+0 (used reg = )
26344 748F           E8         90AD            call	_outb
26345 7492           83C4                   04  add	sp,*4
26346                                           !BCC_EOS
26347                                           ! 4465   outb(0x03f2, val8 | 0x04);
26348                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
26349 7495           8A46         FF            mov	al,-1[bp]
26350 7498           0C                     04  or	al,*4
26351                                           ! Debug: list unsigned char = al+0 (used reg = )
26352 749A           30E4                       xor	ah,ah
26353 749C           50                         push	ax
26354                                           ! Debug: list int = const $3F2 (used reg = )
26355 749D           B8                   03F2  mov	ax,#$3F2
26356 74A0           50                         push	ax
26357                                           ! Debug: func () void = outb+0 (used reg = )
26358 74A1           E8         909B            call	_outb
26359 74A4           83C4                   04  add	sp,*4
26360                                           !BCC_EOS
26361                                           ! 4466   do {
26362                       000074A7            .65C:
26363                                           ! 4467     val8 = inb(0x03f4);
26364                                           ! Debug: list int = const $3F4 (used reg = )
26365 74A7           B8                   03F4  mov	ax,#$3F4
26366 74AA           50                         push	ax
26367                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26368 74AB           E8         907B            call	_inb
26369 74AE           44                         inc	sp
26370 74AF           44                         inc	sp
26371                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26372 74B0           8846         FF            mov	-1[bp],al
26373                                           !BCC_EOS
26374                                           ! 4468   } while ((val8 & 0xc0) != 0x80);
26375                       000074B3            .65B:
26376                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
26377 74B3           8A46         FF            mov	al,-1[bp]
26378 74B6           24                     C0  and	al,#$C0
26379                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26380 74B8           3C                     80  cmp	al,#$80
26381 74BA           75           EB            jne	.65C
26382                       000074BC            .65D:
26383                                           !BCC_EOS
26384                                           ! 4469 }
26385                       000074BC            .65A:
26386 74BC           89EC                       mov	sp,bp
26387 74BE           5D                         pop	bp
26388 74BF           C3                         ret
26389                                           ! 4470 void floppy_prepare_controller(drive)
26390                                           ! 4471   Bit16u drive;
26391                                           export	_floppy_prepare_controller
26392                       000074C0            _floppy_prepare_controller:
26393                                           !BCC_EOS
26394                                           ! 4472 {
26395                                           ! 4473   Bit8u val8, dor, prev_reset;
26396                                           !BCC_EOS
26397                                           ! 4474   val8 = *((Bit8u *)(0x003e));
26398 74C0           55                         push	bp
26399 74C1           89E5                       mov	bp,sp
26400 74C3           83C4                   FC  add	sp,*-4
26401                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26402 74C6           A0         003E            mov	al,[$3E]
26403 74C9           8846         FF            mov	-1[bp],al
26404                                           !BCC_EOS
26405                                           ! 4475   val8 &= 0x7f;
26406                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26407 74CC           8A46         FF            mov	al,-1[bp]
26408 74CF           24                     7F  and	al,*$7F
26409 74D1           8846         FF            mov	-1[bp],al
26410                                           !BCC_EOS
26411                                           ! 4476   *((Bit8u *)(0x003e)) = (val8);
26412                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26413 74D4           8A46         FF            mov	al,-1[bp]
26414 74D7           A2         003E            mov	[$3E],al
26415                                           !BCC_EOS
26416                                           ! 4477   prev_reset = inb(0x03f2) & 0x04;
26417                                           ! Debug: list int = const $3F2 (used reg = )
26418 74DA           B8                   03F2  mov	ax,#$3F2
26419 74DD           50                         push	ax
26420                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26421 74DE           E8         9048            call	_inb
26422 74E1           44                         inc	sp
26423 74E2           44                         inc	sp
26424                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
26425 74E3           24                     04  and	al,*4
26426                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
26427 74E5           8846         FD            mov	-3[bp],al
26428                                           !BCC_EOS
26429                                           ! 4478   if (drive)
26430 74E8           8B46         04            mov	ax,4[bp]
26431 74EB           85C0                       test	ax,ax
26432 74ED           74           07            je  	.65E
26433                       000074EF            .65F:
26434                                           ! 4479     dor = 0x20;
26435                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
26436 74EF           B0                     20  mov	al,*$20
26437 74F1           8846         FE            mov	-2[bp],al
26438                                           !BCC_EOS
26439                                           ! 4480   else
26440                                           ! 4481     dor = 0x10;
26441 74F4           EB           05            jmp .660
26442                       000074F6            .65E:
26443                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
26444 74F6           B0                     10  mov	al,*$10
26445 74F8           8846         FE            mov	-2[bp],al
26446                                           !BCC_EOS
26447                                           ! 4482   dor |= 0x0c;
26448                       000074FB            .660:
26449                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
26450 74FB           8A46         FE            mov	al,-2[bp]
26451 74FE           0C                     0C  or	al,*$C
26452 7500           8846         FE            mov	-2[bp],al
26453                                           !BCC_EOS
26454                                           ! 4483   dor |= drive;
26455                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
26456 7503           8B46         04            mov	ax,4[bp]
26457 7506           0A46         FE            or	al,-2[bp]
26458 7509           8846         FE            mov	-2[bp],al
26459                                           !BCC_EOS
26460                                           ! 4484   outb(0x03f2, dor);
26461                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
26462 750C           8A46         FE            mov	al,-2[bp]
26463 750F           30E4                       xor	ah,ah
26464 7511           50                         push	ax
26465                                           ! Debug: list int = const $3F2 (used reg = )
26466 7512           B8                   03F2  mov	ax,#$3F2
26467 7515           50                         push	ax
26468                                           ! Debug: func () void = outb+0 (used reg = )
26469 7516           E8         9026            call	_outb
26470 7519           83C4                   04  add	sp,*4
26471                                           !BCC_EOS
26472                                           ! 4485   *((Bit8u *)(0x40)) = (37);
26473                                           ! Debug: eq int = const $25 to unsigned char = [+$40] (used reg = )
26474 751C           B0                     25  mov	al,*$25
26475 751E           A2         0040            mov	[$40],al
26476                                           !BCC_EOS
26477                                           ! 4486   do {
26478                       00007521            .663:
26479                                           ! 4487     val8 = inb(0x03f4);
26480                                           ! Debug: list int = const $3F4 (used reg = )
26481 7521           B8                   03F4  mov	ax,#$3F4
26482 7524           50                         push	ax
26483                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26484 7525           E8         9001            call	_inb
26485 7528           44                         inc	sp
26486 7529           44                         inc	sp
26487                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26488 752A           8846         FF            mov	-1[bp],al
26489                                           !BCC_EOS
26490                                           ! 4488   } while ( (val8 & 0xc0) != 0x80 );
26491                       0000752D            .662:
26492                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
26493 752D           8A46         FF            mov	al,-1[bp]
26494 7530           24                     C0  and	al,#$C0
26495                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26496 7532           3C                     80  cmp	al,#$80
26497 7534           75           EB            jne	.663
26498                       00007536            .664:
26499                                           !BCC_EOS
26500                                           ! 4489   if (prev_reset == 0) {
26501                       00007536            .661:
26502                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
26503 7536           8A46         FD            mov	al,-3[bp]
26504 7539           84C0                       test	al,al
26505 753B           75           1F            jne 	.665
26506                       0000753D            .666:
26507                                           ! 4490 #asm
26508                                           !BCC_EOS
26509                                           !BCC_ASM
26510                       00000002            _floppy_prepare_controller.dor	set	2
26511                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26512                       00000001            _floppy_prepare_controller.prev_reset	set	1
26513                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26514                       00000003            _floppy_prepare_controller.val8	set	3
26515                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26516                       00000008            _floppy_prepare_controller.drive	set	8
26517                       00000004            .floppy_prepare_controller.drive	set	4
26518 753D           FB                             sti
26519                                           ! 4492 endasm
26520                                           !BCC_ENDASM
26521                                           !BCC_EOS
26522                                           ! 4493     do {
26523                       0000753E            .669:
26524                                           ! 4494       val8 = *((Bit8u *)(0x003e));
26525                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26526 753E           A0         003E            mov	al,[$3E]
26527 7541           8846         FF            mov	-1[bp],al
26528                                           !BCC_EOS
26529                                           ! 4495     } while ( (val8 & 0x80) == 0 );
26530                       00007544            .668:
26531                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
26532 7544           8A46         FF            mov	al,-1[bp]
26533 7547           24                     80  and	al,#$80
26534                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26535 7549           84C0                       test	al,al
26536 754B           74           F1            je 	.669
26537                       0000754D            .66A:
26538                                           !BCC_EOS
26539                                           ! 4496     val8 &= 0x7f;
26540                       0000754D            .667:
26541                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26542 754D           8A46         FF            mov	al,-1[bp]
26543 7550           24                     7F  and	al,*$7F
26544 7552           8846         FF            mov	-1[bp],al
26545                                           !BCC_EOS
26546                                           ! 4497 #asm
26547                                           !BCC_EOS
26548                                           !BCC_ASM
26549                       00000002            _floppy_prepare_controller.dor	set	2
26550                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26551                       00000001            _floppy_prepare_controller.prev_reset	set	1
26552                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26553                       00000003            _floppy_prepare_controller.val8	set	3
26554                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26555                       00000008            _floppy_prepare_controller.drive	set	8
26556                       00000004            .floppy_prepare_controller.drive	set	4
26557 7555           FA                             cli
26558                                           ! 4499 endasm
26559                                           !BCC_ENDASM
26560                                           !BCC_EOS
26561                                           ! 4500     *((Bit8u *)(0x003e)) = (val8);
26562                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26563 7556           8A46         FF            mov	al,-1[bp]
26564 7559           A2         003E            mov	[$3E],al
26565                                           !BCC_EOS
26566                                           ! 4501   }
26567                                           ! 4502 }
26568                       0000755C            .665:
26569 755C           89EC                       mov	sp,bp
26570 755E           5D                         pop	bp
26571 755F           C3                         ret
26572                                           ! 4503   bx_bool
26573                                           ! 4504 floppy_media_known(drive)
26574                                           ! 4505   Bit16u drive;
26575                                           export	_floppy_media_known
26576                       00007560            _floppy_media_known:
26577                                           !BCC_EOS
26578                                           ! 4506 {
26579                                           ! 4507   Bit8u val8;
26580                                           !BCC_EOS
26581                                           ! 4508   Bit16u media_state_offset;
26582                                           !BCC_EOS
26583                                           ! 4509   val8 = *((Bit8u *)(0x003e));
26584 7560           55                         push	bp
26585 7561           89E5                       mov	bp,sp
26586 7563           83C4                   FC  add	sp,*-4
26587                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26588 7566           A0         003E            mov	al,[$3E]
26589 7569           8846         FF            mov	-1[bp],al
26590                                           !BCC_EOS
26591                                           ! 4510   if (drive)
26592 756C           8B46         04            mov	ax,4[bp]
26593 756F           85C0                       test	ax,ax
26594 7571           74           0A            je  	.66B
26595                       00007573            .66C:
26596                                           ! 4511     val8 >>= 1;
26597                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26598 7573           8A46         FF            mov	al,-1[bp]
26599 7576           30E4                       xor	ah,ah
26600 7578           D1E8                       shr	ax,*1
26601 757A           8846         FF            mov	-1[bp],al
26602                                           !BCC_EOS
26603                                           ! 4512   val8 &= 0x01;
26604                       0000757D            .66B:
26605                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26606 757D           8A46         FF            mov	al,-1[bp]
26607 7580           24                     01  and	al,*1
26608 7582           8846         FF            mov	-1[bp],al
26609                                           !BCC_EOS
26610                                           ! 4513   if (val8 == 0)
26611                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26612 7585           8A46         FF            mov	al,-1[bp]
26613 7588           84C0                       test	al,al
26614 758A           75           06            jne 	.66D
26615                       0000758C            .66E:
26616                                           ! 4514     return(0);
26617 758C           31C0                       xor	ax,ax
26618 758E           89EC                       mov	sp,bp
26619 7590           5D                         pop	bp
26620 7591           C3                         ret
26621                                           !BCC_EOS
26622                                           ! 4515   media_state_offset = 0x0090;
26623                       00007592            .66D:
26624                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
26625 7592           B8                   0090  mov	ax,#$90
26626 7595           8946         FC            mov	-4[bp],ax
26627                                           !BCC_EOS
26628                                           ! 4516   if (drive)
26629 7598           8B46         04            mov	ax,4[bp]
26630 759B           85C0                       test	ax,ax
26631 759D           74           07            je  	.66F
26632                       0000759F            .670:
26633                                           ! 4517     media_state_offset += 1;
26634                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
26635 759F           8B46         FC            mov	ax,-4[bp]
26636 75A2           40                         inc	ax
26637 75A3           8946         FC            mov	-4[bp],ax
26638                                           !BCC_EOS
26639                                           ! 4518   val8 = *((Bit8u *)(media_state_offset));
26640                       000075A6            .66F:
26641 75A6           8B5E         FC            mov	bx,-4[bp]
26642                                           ! Debug: eq unsigned char = [bx+0] to unsigned char val8 = [S+6-3] (used reg = )
26643 75A9           8A07                       mov	al,[bx]
26644 75AB           8846         FF            mov	-1[bp],al
26645                                           !BCC_EOS
26646                                           ! 4519   val8 = (val8 >> 4) & 0x01;
26647                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
26648 75AE           8A46         FF            mov	al,-1[bp]
26649 75B1           30E4                       xor	ah,ah
26650 75B3           B1                     04  mov	cl,*4
26651 75B5           D3E8                       shr	ax,cl
26652                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
26653 75B7           24                     01  and	al,*1
26654                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26655 75B9           8846         FF            mov	-1[bp],al
26656                                           !BCC_EOS
26657                                           ! 4520   if (val8 == 0)
26658                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26659 75BC           8A46         FF            mov	al,-1[bp]
26660 75BF           84C0                       test	al,al
26661 75C1           75           06            jne 	.671
26662                       000075C3            .672:
26663                                           ! 4521     return(0);
26664 75C3           31C0                       xor	ax,ax
26665 75C5           89EC                       mov	sp,bp
26666 75C7           5D                         pop	bp
26667 75C8           C3                         ret
26668                                           !BCC_EOS
26669                                           ! 4522   return(1);
26670                       000075C9            .671:
26671 75C9           B8                   0001  mov	ax,*1
26672 75CC           89EC                       mov	sp,bp
26673 75CE           5D                         pop	bp
26674 75CF           C3                         ret
26675                                           !BCC_EOS
26676                                           ! 4523 }
26677                                           ! 4524   bx_bool
26678                                           ! Register BX used in function floppy_media_known
26679                                           ! 4525 floppy_media_sense(drive)
26680                                           ! 4526   Bit16u drive;
26681                                           export	_floppy_media_sense
26682                       000075D0            _floppy_media_sense:
26683                                           !BCC_EOS
26684                                           ! 4527 {
26685                                           ! 4528   bx_bool retval;
26686                                           !BCC_EOS
26687                                           ! 4529   Bit16u media_state_offset;
26688                                           !BCC_EOS
26689                                           ! 4530   Bit8u drive_type, config_data, media_state;
26690                                           !BCC_EOS
26691                                           ! 4531   if (floppy_drive_recal(drive) == 0) {
26692 75D0           55                         push	bp
26693 75D1           89E5                       mov	bp,sp
26694 75D3           83C4                   F8  add	sp,*-8
26695                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
26696 75D6           FF76         04            push	4[bp]
26697                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
26698 75D9           E8         00E4            call	_floppy_drive_recal
26699 75DC           44                         inc	sp
26700 75DD           44                         inc	sp
26701                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
26702 75DE           85C0                       test	ax,ax
26703 75E0           75           06            jne 	.673
26704                       000075E2            .674:
26705                                           ! 4532     return(0);
26706 75E2           31C0                       xor	ax,ax
26707 75E4           89EC                       mov	sp,bp
26708 75E6           5D                         pop	bp
26709 75E7           C3                         ret
26710                                           !BCC_EOS
26711                                           ! 4533   }
26712                                           ! 4534   drive_t
26713                                           ! 4534 ype = inb_cmos(0x10);
26714                       000075E8            .673:
26715                                           ! Debug: list int = const $10 (used reg = )
26716 75E8           B8                   0010  mov	ax,*$10
26717 75EB           50                         push	ax
26718                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
26719 75EC           E8         8F7F            call	_inb_cmos
26720 75EF           44                         inc	sp
26721 75F0           44                         inc	sp
26722                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
26723 75F1           8846         FB            mov	-5[bp],al
26724                                           !BCC_EOS
26725                                           ! 4535   if (drive == 0)
26726                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26727 75F4           8B46         04            mov	ax,4[bp]
26728 75F7           85C0                       test	ax,ax
26729 75F9           75           0E            jne 	.675
26730                       000075FB            .676:
26731                                           ! 4536     drive_type >>= 4;
26732                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
26733 75FB           8A46         FB            mov	al,-5[bp]
26734 75FE           30E4                       xor	ah,ah
26735 7600           B1                     04  mov	cl,*4
26736 7602           D3E8                       shr	ax,cl
26737 7604           8846         FB            mov	-5[bp],al
26738                                           !BCC_EOS
26739                                           ! 4537   else
26740                                           ! 4538     drive_type &= 0x0f;
26741 7607           EB           08            jmp .677
26742                       00007609            .675:
26743                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
26744 7609           8A46         FB            mov	al,-5[bp]
26745 760C           24                     0F  and	al,*$F
26746 760E           8846         FB            mov	-5[bp],al
26747                                           !BCC_EOS
26748                                           ! 4539   switch(drive_type) {
26749                       00007611            .677:
26750 7611           8A46         FB            mov	al,-5[bp]
26751 7614           EB           5B            jmp .67A
26752                                           ! 4540     case 1:
26753                                           ! 4541     case 2:
26754                       00007616            .67B:
26755                                           ! 4542       config_data = 0x00;
26756                       00007616            .67C:
26757                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26758 7616           30C0                       xor	al,al
26759 7618           8846         FA            mov	-6[bp],al
26760                                           !BCC_EOS
26761                                           ! 4543       media_state = 0x25;
26762                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
26763 761B           B0                     25  mov	al,*$25
26764 761D           8846         F9            mov	-7[bp],al
26765                                           !BCC_EOS
26766                                           ! 4544       retval = 1;
26767                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26768 7620           B8                   0001  mov	ax,*1
26769 7623           8946         FE            mov	-2[bp],ax
26770                                           !BCC_EOS
26771                                           ! 4545       break;
26772 7626           EB           6E            jmp .678
26773                                           !BCC_EOS
26774                                           ! 4546     case 3:
26775                                           ! 4547     case 4:
26776                       00007628            .67D:
26777                                           ! 4548       config_data = 0x00;
26778                       00007628            .67E:
26779                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26780 7628           30C0                       xor	al,al
26781 762A           8846         FA            mov	-6[bp],al
26782                                           !BCC_EOS
26783                                           ! 4549       media_state = 0x17;
26784                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
26785 762D           B0                     17  mov	al,*$17
26786 762F           8846         F9            mov	-7[bp],al
26787                                           !BCC_EOS
26788                                           ! 4550       retval = 1;
26789                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26790 7632           B8                   0001  mov	ax,*1
26791 7635           8946         FE            mov	-2[bp],ax
26792                                           !BCC_EOS
26793                                           ! 4551       break;
26794 7638           EB           5C            jmp .678
26795                                           !BCC_EOS
26796                                           ! 4552     case 5:
26797                                           ! 4553       config_data = 0xCC;
26798                       0000763A            .67F:
26799                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
26800 763A           B0                     CC  mov	al,#$CC
26801 763C           8846         FA            mov	-6[bp],al
26802                                           !BCC_EOS
26803                                           ! 4554       media_state = 0xD7;
26804                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
26805 763F           B0                     D7  mov	al,#$D7
26806 7641           8846         F9            mov	-7[bp],al
26807                                           !BCC_EOS
26808                                           ! 4555       retval = 1;
26809                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26810 7644           B8                   0001  mov	ax,*1
26811 7647           8946         FE            mov	-2[bp],ax
26812                                           !BCC_EOS
26813                                           ! 4556       break;
26814 764A           EB           4A            jmp .678
26815                                           !BCC_EOS
26816                                           ! 4557     case 6:
26817                                           ! 4558     case 7:
26818                       0000764C            .680:
26819                                           ! 4559     case 8:
26820                       0000764C            .681:
26821                                           ! 4560       config_data = 0x00;
26822                       0000764C            .682:
26823                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26824 764C           30C0                       xor	al,al
26825 764E           8846         FA            mov	-6[bp],al
26826                                           !BCC_EOS
26827                                           ! 4561       media_state = 0x27;
26828                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
26829 7651           B0                     27  mov	al,*$27
26830 7653           8846         F9            mov	-7[bp],al
26831                                           !BCC_EOS
26832                                           ! 4562       retval = 1;
26833                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26834 7656           B8                   0001  mov	ax,*1
26835 7659           8946         FE            mov	-2[bp],ax
26836                                           !BCC_EOS
26837                                           ! 4563       break;
26838 765C           EB           38            jmp .678
26839                                           !BCC_EOS
26840                                           ! 4564     default:
26841                                           ! 4565       config_data = 0x00;
26842                       0000765E            .683:
26843                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26844 765E           30C0                       xor	al,al
26845 7660           8846         FA            mov	-6[bp],al
26846                                           !BCC_EOS
26847                                           ! 4566       media_state = 0x00;
26848                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
26849 7663           30C0                       xor	al,al
26850 7665           8846         F9            mov	-7[bp],al
26851                                           !BCC_EOS
26852                                           ! 4567       retval = 0;
26853                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
26854 7668           31C0                       xor	ax,ax
26855 766A           8946         FE            mov	-2[bp],ax
26856                                           !BCC_EOS
26857                                           ! 4568       break;
26858 766D           EB           27            jmp .678
26859                                           !BCC_EOS
26860                                           ! 4569   }
26861                                           ! 4570   if (drive == 0)
26862 766F           EB           25            jmp .678
26863                       00007671            .67A:
26864 7671           2C                     01  sub	al,*1
26865 7673           72           E9            jb 	.683
26866 7675           3C                     07  cmp	al,*7
26867 7677           77           1B            ja  	.684
26868 7679           30E4                       xor	ah,ah
26869 767B           D1E0                       shl	ax,*1
26870 767D           89C3                       mov	bx,ax
26871 767F           2E                         seg	cs
26872 7680           FFA7       7684            br	.685[bx]
26873                       00007684            .685:
26874 7684                      7616            .word	.67B
26875 7686                      7616            .word	.67C
26876 7688                      7628            .word	.67D
26877 768A                      7628            .word	.67E
26878 768C                      763A            .word	.67F
26879 768E                      764C            .word	.680
26880 7690                      764C            .word	.681
26881 7692                      764C            .word	.682
26882                       00007694            .684:
26883 7694           EB           C8            jmp	.683
26884                       00007696            .678:
26885                       FFFFFFF6            ..FFDC	=	-$A
26886                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26887 7696           8B46         04            mov	ax,4[bp]
26888 7699           85C0                       test	ax,ax
26889 769B           75           08            jne 	.686
26890                       0000769D            .687:
26891                                           ! 4571     media_state_offset = 0x90;
26892                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26893 769D           B8                   0090  mov	ax,#$90
26894 76A0           8946         FC            mov	-4[bp],ax
26895                                           !BCC_EOS
26896                                           ! 4572   else
26897                                           ! 4573     media_state_offset = 0x91;
26898 76A3           EB           06            jmp .688
26899                       000076A5            .686:
26900                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26901 76A5           B8                   0091  mov	ax,#$91
26902 76A8           8946         FC            mov	-4[bp],ax
26903                                           !BCC_EOS
26904                                           ! 4574   *((Bit8u *)(0x008B)) = (config_data);
26905                       000076AB            .688:
26906                                           ! Debug: eq unsigned char config_data = [S+$A-8] to unsigned char = [+$8B] (used reg = )
26907 76AB           8A46         FA            mov	al,-6[bp]
26908 76AE           A2         008B            mov	[$8B],al
26909                                           !BCC_EOS
26910                                           ! 4575   *((Bit8u *)(media_state_offset)) = (media_state);
26911 76B1           8B5E         FC            mov	bx,-4[bp]
26912                                           ! Debug: eq unsigned char media_state = [S+$A-9] to unsigned char = [bx+0] (used reg = )
26913 76B4           8A46         F9            mov	al,-7[bp]
26914 76B7           8807                       mov	[bx],al
26915                                           !BCC_EOS
26916                                           ! 4576   return(retval);
26917 76B9           8B46         FE            mov	ax,-2[bp]
26918 76BC           89EC                       mov	sp,bp
26919 76BE           5D                         pop	bp
26920 76BF           C3                         ret
26921                                           !BCC_EOS
26922                                           ! 4577 }
26923                                           ! 4578   bx_bool
26924                                           ! Register BX used in function floppy_media_sense
26925                                           ! 4579 floppy_drive_recal(drive)
26926                                           ! 4580   Bit16u drive;
26927                                           export	_floppy_drive_recal
26928                       000076C0            _floppy_drive_recal:
26929                                           !BCC_EOS
26930                                           ! 4581 {
26931                                           ! 4582   Bit8u val8;
26932                                           !BCC_EOS
26933                                           ! 4583   Bit16u curr_cyl_offset;
26934                                           !BCC_EOS
26935                                           ! 4584   floppy_prepare_controller(drive);
26936 76C0           55                         push	bp
26937 76C1           89E5                       mov	bp,sp
26938 76C3           83C4                   FC  add	sp,*-4
26939                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
26940 76C6           FF76         04            push	4[bp]
26941                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
26942 76C9           E8         FDF4            call	_floppy_prepare_controller
26943 76CC           44                         inc	sp
26944 76CD           44                         inc	sp
26945                                           !BCC_EOS
26946                                           ! 4585   outb(0x03f5, 0x07);
26947                                           ! Debug: list int = const 7 (used reg = )
26948 76CE           B8                   0007  mov	ax,*7
26949 76D1           50                         push	ax
26950                                           ! Debug: list int = const $3F5 (used reg = )
26951 76D2           B8                   03F5  mov	ax,#$3F5
26952 76D5           50                         push	ax
26953                                           ! Debug: func () void = outb+0 (used reg = )
26954 76D6           E8         8E66            call	_outb
26955 76D9           83C4                   04  add	sp,*4
26956                                           !BCC_EOS
26957                                           ! 4586   outb(0x03f5, drive);
26958                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
26959 76DC           FF76         04            push	4[bp]
26960                                           ! Debug: list int = const $3F5 (used reg = )
26961 76DF           B8                   03F5  mov	ax,#$3F5
26962 76E2           50                         push	ax
26963                                           ! Debug: func () void = outb+0 (used reg = )
26964 76E3           E8         8E59            call	_outb
26965 76E6           83C4                   04  add	sp,*4
26966                                           !BCC_EOS
26967                                           ! 4587 #asm
26968                                           !BCC_EOS
26969                                           !BCC_ASM
26970                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
26971                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
26972                       00000003            _floppy_drive_recal.val8	set	3
26973                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
26974                       00000008            _floppy_drive_recal.drive	set	8
26975                       00000004            .floppy_drive_recal.drive	set	4
26976 76E9           FB                           sti
26977                                           ! 4589 endasm
26978                                           !BCC_ENDASM
26979                                           !BCC_EOS
26980                                           ! 4590   do {
26981                       000076EA            .68B:
26982                                           ! 4591     val8 = (*((Bit8u *)(0x003e)) & 0x80);
26983                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
26984 76EA           A0         003E            mov	al,[$3E]
26985 76ED           24                     80  and	al,#$80
26986                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26987 76EF           8846         FF            mov	-1[bp],al
26988                                           !BCC_EOS
26989                                           ! 4592   } while ( val8 == 0 );
26990                       000076F2            .68A:
26991                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26992 76F2           8A46         FF            mov	al,-1[bp]
26993 76F5           84C0                       test	al,al
26994 76F7           74           F1            je 	.68B
26995                       000076F9            .68C:
26996                                           !BCC_EOS
26997                                           ! 4593   val8 = 0;
26998                       000076F9            .689:
26999                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27000 76F9           30C0                       xor	al,al
27001 76FB           8846         FF            mov	-1[bp],al
27002                                           !BCC_EOS
27003                                           ! 4594 #asm
27004                                           !BCC_EOS
27005                                           !BCC_ASM
27006                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
27007                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
27008                       00000003            _floppy_drive_recal.val8	set	3
27009                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27010                       00000008            _floppy_drive_recal.drive	set	8
27011                       00000004            .floppy_drive_recal.drive	set	4
27012 76FE           FA                           cli
27013                                           ! 4596 endasm
27014                                           !BCC_ENDASM
27015                                           !BCC_EOS
27016                                           ! 4597   val8 = *((Bit8u *)(0x003e));
27017                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
27018 76FF           A0         003E            mov	al,[$3E]
27019 7702           8846         FF            mov	-1[bp],al
27020                                           !BCC_EOS
27021                                           ! 4598   val8 &= 0x7f;
27022                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
27023 7705           8A46         FF            mov	al,-1[bp]
27024 7708           24                     7F  and	al,*$7F
27025 770A           8846         FF            mov	-1[bp],al
27026                                           !BCC_EOS
27027                                           ! 4599   if (drive) {
27028 770D           8B46         04            mov	ax,4[bp]
27029 7710           85C0                       test	ax,ax
27030 7712           74           10            je  	.68D
27031                       00007714            .68E:
27032                                           ! 4600     val8 |= 0x02;
27033                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
27034 7714           8A46         FF            mov	al,-1[bp]
27035 7717           0C                     02  or	al,*2
27036 7719           8846         FF            mov	-1[bp],al
27037                                           !BCC_EOS
27038                                           ! 4601     curr_cyl_offset = 0x0095;
27039                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27040 771C           B8                   0095  mov	ax,#$95
27041 771F           8946         FC            mov	-4[bp],ax
27042                                           !BCC_EOS
27043                                           ! 4602   } else {
27044 7722           EB           0E            jmp .68F
27045                       00007724            .68D:
27046                                           ! 4603     val8 |= 0x01;
27047                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27048 7724           8A46         FF            mov	al,-1[bp]
27049 7727           0C                     01  or	al,*1
27050 7729           8846         FF            mov	-1[bp],al
27051                                           !BCC_EOS
27052                                           ! 4604     curr_cyl_offset = 0x0094;
27053                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27054 772C           B8                   0094  mov	ax,#$94
27055 772F           8946         FC            mov	-4[bp],ax
27056                                           !BCC_EOS
27057                                           ! 4605   }
27058                                           ! 4606   *((Bit8u *)(0x003e)) = (val8);
27059                       00007732            .68F:
27060                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
27061 7732           8A46         FF            mov	al,-1[bp]
27062 7735           A2         003E            mov	[$3E],al
27063                                           !BCC_EOS
27064                                           ! 4607   *((Bit8u *)(curr_cyl_offset)) = (0);
27065 7738           8B5E         FC            mov	bx,-4[bp]
27066                                           ! Debug: eq int = const 0 to unsigned char = [bx+0] (used reg = )
27067 773B           30C0                       xor	al,al
27068 773D           8807                       mov	[bx],al
27069                                           !BCC_EOS
27070                                           ! 4608   return(1);
27071 773F           B8                   0001  mov	ax,*1
27072 7742           89EC                       mov	sp,bp
27073 7744           5D                         pop	bp
27074 7745           C3                         ret
27075                                           !BCC_EOS
27076                                           ! 4609 }
27077                                           ! 4610   bx_bool
27078                                           ! Register BX used in function floppy_drive_recal
27079                                           ! 4611 floppy_drive_exists(drive)
27080                                           ! 4612   Bit16u drive;
27081                                           export	_floppy_drive_exists
27082                       00007746            _floppy_drive_exists:
27083                                           !BCC_EOS
27084                                           ! 4613 {
27085                                           ! 4614   Bit8u drive_type;
27086                                           !BCC_EOS
27087                                           ! 4615   drive_type = inb_cmos(0x10);
27088 7746           55                         push	bp
27089 7747           89E5                       mov	bp,sp
27090 7749           4C                         dec	sp
27091 774A           4C                         dec	sp
27092                                           ! Debug: list int = const $10 (used reg = )
27093 774B           B8                   0010  mov	ax,*$10
27094 774E           50                         push	ax
27095                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27096 774F           E8         8E1C            call	_inb_cmos
27097 7752           44                         inc	sp
27098 7753           44                         inc	sp
27099                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
27100 7754           8846         FF            mov	-1[bp],al
27101                                           !BCC_EOS
27102                                           ! 4616   if (drive == 0)
27103                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
27104 7757           8B46         04            mov	ax,4[bp]
27105 775A           85C0                       test	ax,ax
27106 775C           75           0E            jne 	.690
27107                       0000775E            .691:
27108                                           ! 4617     drive_type >>= 4;
27109                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
27110 775E           8A46         FF            mov	al,-1[bp]
27111 7761           30E4                       xor	ah,ah
27112 7763           B1                     04  mov	cl,*4
27113 7765           D3E8                       shr	ax,cl
27114 7767           8846         FF            mov	-1[bp],al
27115                                           !BCC_EOS
27116                                           ! 4618   else
27117                                           ! 4619     drive_type &= 0x0f;
27118 776A           EB           08            jmp .692
27119                       0000776C            .690:
27120                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
27121 776C           8A46         FF            mov	al,-1[bp]
27122 776F           24                     0F  and	al,*$F
27123 7771           8846         FF            mov	-1[bp],al
27124                                           !BCC_EOS
27125                                           ! 4620   if ( drive_type == 0 )
27126                       00007774            .692:
27127                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
27128 7774           8A46         FF            mov	al,-1[bp]
27129 7777           84C0                       test	al,al
27130 7779           75           08            jne 	.693
27131                       0000777B            .694:
27132                                           ! 4621     return(0);
27133 777B           31C0                       xor	ax,ax
27134 777D           89EC                       mov	sp,bp
27135 777F           5D                         pop	bp
27136 7780           C3                         ret
27137                                           !BCC_EOS
27138                                           ! 4622   else
27139                                           ! 4623     return(1);
27140 7781           EB           07            jmp .695
27141                       00007783            .693:
27142 7783           B8                   0001  mov	ax,*1
27143 7786           89EC                       mov	sp,bp
27144 7788           5D                         pop	bp
27145 7789           C3                         ret
27146                                           !BCC_EOS
27147                                           ! 4624 }
27148                       0000778A            .695:
27149 778A           89EC                       mov	sp,bp
27150 778C           5D                         pop	bp
27151 778D           C3                         ret
27152                                           ! 4625   void
27153                                           ! 4626 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
27154                                           ! 4627   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
27155                                           export	_int13_diskette_function
27156                       0000778E            _int13_diskette_function:
27157                                           !BCC_EOS
27158                                           ! 4628 {
27159                                           ! 4629   Bit8u drive, num_sectors, track, sector, head, status;
27160                                           !BCC_EOS
27161                                           ! 4630   Bit16u base_address, base_count, base_es;
27162                                           !BCC_EOS
27163                                           ! 4631   Bit8u page, mode_register, val8, dor;
27164                                           !BCC_EOS
27165                                           ! 4632   Bit8u return_status[7];
27166                                           !BCC_EOS
27167                                           ! 4633   Bit8u drive_type, num_floppies, ah, spt;
27168                                           !BCC_EOS
27169                                           ! 4634   Bit16u es, last_addr, maxCyl;
27170                                           !BCC_EOS
27171                                           ! 4635   ;
27172 778E           55                         push	bp
27173 778F           89E5                       mov	bp,sp
27174 7791           83C4                   DE  add	sp,*-$22
27175                                           !BCC_EOS
27176                                           ! 4636   a
27177                                           ! 4636 h = *(((Bit8u *)&AX)+1);
27178                                           ! Debug: eq unsigned char AX = [S+$24+$15] to unsigned char ah = [S+$24-$1C] (used reg = )
27179 7794           8A46         17            mov	al,$17[bp]
27180 7797           8846         E6            mov	-$1A[bp],al
27181                                           !BCC_EOS
27182                                           ! 4637   switch ( ah ) {
27183 779A           8A46         E6            mov	al,-$1A[bp]
27184 779D           E9         0E5B            br 	.698
27185                                           ! 4638     case 0x00:
27186                                           ! 4639 ;
27187                       000077A0            .699:
27188                                           !BCC_EOS
27189                                           ! 4640       drive = ( ELDX & 0x00ff );
27190                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27191 77A0           8A46         0E            mov	al,$E[bp]
27192                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27193 77A3           8846         FF            mov	-1[bp],al
27194                                           !BCC_EOS
27195                                           ! 4641       if (drive > 1) {
27196                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27197 77A6           8A46         FF            mov	al,-1[bp]
27198 77A9           3C                     01  cmp	al,*1
27199 77AB           76           1A            jbe 	.69A
27200                       000077AD            .69B:
27201                                           ! 4642         *(((Bit8u *)&AX)+1) = (1);
27202                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27203 77AD           B0                     01  mov	al,*1
27204 77AF           8846         17            mov	$17[bp],al
27205                                           !BCC_EOS
27206                                           ! 4643         set_diskette_ret_status(1);
27207                                           ! Debug: list int = const 1 (used reg = )
27208 77B2           B8                   0001  mov	ax,*1
27209 77B5           50                         push	ax
27210                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27211 77B6           E8         0E85            call	_set_diskette_ret_status
27212 77B9           44                         inc	sp
27213 77BA           44                         inc	sp
27214                                           !BCC_EOS
27215                                           ! 4644         FLAGS |= 0x0001;
27216                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27217 77BB           8B46         1C            mov	ax,$1C[bp]
27218 77BE           0C                     01  or	al,*1
27219 77C0           8946         1C            mov	$1C[bp],ax
27220                                           !BCC_EOS
27221                                           ! 4645         return;
27222 77C3           89EC                       mov	sp,bp
27223 77C5           5D                         pop	bp
27224 77C6           C3                         ret
27225                                           !BCC_EOS
27226                                           ! 4646       }
27227                                           ! 4647       drive_type = inb_cmos(0x10);
27228                       000077C7            .69A:
27229                                           ! Debug: list int = const $10 (used reg = )
27230 77C7           B8                   0010  mov	ax,*$10
27231 77CA           50                         push	ax
27232                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27233 77CB           E8         8DA0            call	_inb_cmos
27234 77CE           44                         inc	sp
27235 77CF           44                         inc	sp
27236                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27237 77D0           8846         E8            mov	-$18[bp],al
27238                                           !BCC_EOS
27239                                           ! 4648       if (drive == 0)
27240                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
27241 77D3           8A46         FF            mov	al,-1[bp]
27242 77D6           84C0                       test	al,al
27243 77D8           75           0E            jne 	.69C
27244                       000077DA            .69D:
27245                                           ! 4649         drive_type >>= 4;
27246                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27247 77DA           8A46         E8            mov	al,-$18[bp]
27248 77DD           30E4                       xor	ah,ah
27249 77DF           B1                     04  mov	cl,*4
27250 77E1           D3E8                       shr	ax,cl
27251 77E3           8846         E8            mov	-$18[bp],al
27252                                           !BCC_EOS
27253                                           ! 4650       else
27254                                           ! 4651         drive_type &= 0x0f;
27255 77E6           EB           08            jmp .69E
27256                       000077E8            .69C:
27257                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
27258 77E8           8A46         E8            mov	al,-$18[bp]
27259 77EB           24                     0F  and	al,*$F
27260 77ED           8846         E8            mov	-$18[bp],al
27261                                           !BCC_EOS
27262                                           ! 4652       if (drive_type == 0) {
27263                       000077F0            .69E:
27264                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27265 77F0           8A46         E8            mov	al,-$18[bp]
27266 77F3           84C0                       test	al,al
27267 77F5           75           1A            jne 	.69F
27268                       000077F7            .6A0:
27269                                           ! 4653         *(((Bit8u *)&AX)+1) = (0x80);
27270                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27271 77F7           B0                     80  mov	al,#$80
27272 77F9           8846         17            mov	$17[bp],al
27273                                           !BCC_EOS
27274                                           ! 4654         set_diskette_ret_status(0x80);
27275                                           ! Debug: list int = const $80 (used reg = )
27276 77FC           B8                   0080  mov	ax,#$80
27277 77FF           50                         push	ax
27278                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27279 7800           E8         0E3B            call	_set_diskette_ret_status
27280 7803           44                         inc	sp
27281 7804           44                         inc	sp
27282                                           !BCC_EOS
27283                                           ! 4655         FLAGS |= 0x0001;
27284                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27285 7805           8B46         1C            mov	ax,$1C[bp]
27286 7808           0C                     01  or	al,*1
27287 780A           8946         1C            mov	$1C[bp],ax
27288                                           !BCC_EOS
27289                                           ! 4656         return;
27290 780D           89EC                       mov	sp,bp
27291 780F           5D                         pop	bp
27292 7810           C3                         ret
27293                                           !BCC_EOS
27294                                           ! 4657       }
27295                                           ! 4658       *(((Bit8u *)&AX)+1) = (0);
27296                       00007811            .69F:
27297                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
27298 7811           30C0                       xor	al,al
27299 7813           8846         17            mov	$17[bp],al
27300                                           !BCC_EOS
27301                                           ! 4659       set_diskette_ret_status(0);
27302                                           ! Debug: list int = const 0 (used reg = )
27303 7816           31C0                       xor	ax,ax
27304 7818           50                         push	ax
27305                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27306 7819           E8         0E22            call	_set_diskette_ret_status
27307 781C           44                         inc	sp
27308 781D           44                         inc	sp
27309                                           !BCC_EOS
27310                                           ! 4660       FLAGS &= 0xfffe;
27311                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27312 781E           8B46         1C            mov	ax,$1C[bp]
27313 7821           24                     FE  and	al,#$FE
27314 7823           8946         1C            mov	$1C[bp],ax
27315                                           !BCC_EOS
27316                                           ! 4661       set_diskette_current_cyl(drive, 0);
27317                                           ! Debug: list int = const 0 (used reg = )
27318 7826           31C0                       xor	ax,ax
27319 7828           50                         push	ax
27320                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
27321 7829           8A46         FF            mov	al,-1[bp]
27322 782C           30E4                       xor	ah,ah
27323 782E           50                         push	ax
27324                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
27325 782F           E8         0E24            call	_set_diskette_current_cyl
27326 7832           83C4                   04  add	sp,*4
27327                                           !BCC_EOS
27328                                           ! 4662       return;
27329 7835           89EC                       mov	sp,bp
27330 7837           5D                         pop	bp
27331 7838           C3                         ret
27332                                           !BCC_EOS
27333                                           ! 4663     case 0x01:
27334                                           ! 4664       FLAGS &= 0xfffe;
27335                       00007839            .6A1:
27336                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27337 7839           8B46         1C            mov	ax,$1C[bp]
27338 783C           24                     FE  and	al,#$FE
27339 783E           8946         1C            mov	$1C[bp],ax
27340                                           !BCC_EOS
27341                                           ! 4665       val8 = *((Bit8u *)(0x0041));
27342                                           ! Debug: eq unsigned char = [+$41] to unsigned char val8 = [S+$24-$11] (used reg = )
27343 7841           A0         0041            mov	al,[$41]
27344 7844           8846         F1            mov	-$F[bp],al
27345                                           !BCC_EOS
27346                                           ! 4666       *(((Bit8u *)&AX)+1) = (val8);
27347                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char AX = [S+$24+$15] (used reg = )
27348 7847           8A46         F1            mov	al,-$F[bp]
27349 784A           8846         17            mov	$17[bp],al
27350                                           !BCC_EOS
27351                                           ! 4667       if (val8) {
27352 784D           8A46         F1            mov	al,-$F[bp]
27353 7850           84C0                       test	al,al
27354 7852           74           08            je  	.6A2
27355                       00007854            .6A3:
27356                                           ! 4668         FLAGS |= 0x0001;
27357                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27358 7854           8B46         1C            mov	ax,$1C[bp]
27359 7857           0C                     01  or	al,*1
27360 7859           8946         1C            mov	$1C[bp],ax
27361                                           !BCC_EOS
27362                                           ! 4669       }
27363                                           ! 4670       return;
27364                       0000785C            .6A2:
27365 785C           89EC                       mov	sp,bp
27366 785E           5D                         pop	bp
27367 785F           C3                         ret
27368                                           !BCC_EOS
27369                                           ! 4671     case 0x02:
27370                                           ! 4672     case 0x03:
27371                       00007860            .6A4:
27372                                           ! 4673     case 0x04:
27373                       00007860            .6A5:
27374                                           ! 4674       num_sectors = ( AX & 0x00ff );
27375                       00007860            .6A6:
27376                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
27377 7860           8A46         16            mov	al,$16[bp]
27378                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27379 7863           8846         FE            mov	-2[bp],al
27380                                           !BCC_EOS
27381                                           ! 4675       track = *(((Bit8u *)&CX)+1);
27382                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
27383 7866           8A46         15            mov	al,$15[bp]
27384 7869           8846         FD            mov	-3[bp],al
27385                                           !BCC_EOS
27386                                           ! 4676       sector = ( CX & 0x00ff );
27387                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
27388 786C           8A46         14            mov	al,$14[bp]
27389                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$24-6] (used reg = )
27390 786F           8846         FC            mov	-4[bp],al
27391                                           !BCC_EOS
27392                                           ! 4677       head = *(((Bit8u *)&DX)+1);
27393                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
27394 7872           8A46         13            mov	al,$13[bp]
27395 7875           8846         FB            mov	-5[bp],al
27396                                           !BCC_EOS
27397                                           ! 4678       drive = ( ELDX & 0x00ff );
27398                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27399 7878           8A46         0E            mov	al,$E[bp]
27400                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27401 787B           8846         FF            mov	-1[bp],al
27402                                           !BCC_EOS
27403                                           ! 4679       if ((drive > 1) || (head > 1) || (sector == 0) ||
27404                                           ! 4680           (num_sectors == 0) || (num_sectors > 72)) {
27405                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27406 787E           8A46         FF            mov	al,-1[bp]
27407 7881           3C                     01  cmp	al,*1
27408 7883           77           1C            ja  	.6A8
27409                       00007885            .6AC:
27410                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
27411 7885           8A46         FB            mov	al,-5[bp]
27412 7888           3C                     01  cmp	al,*1
27413 788A           77           15            ja  	.6A8
27414                       0000788C            .6AB:
27415                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$24-6] (used reg = )
27416 788C           8A46         FC            mov	al,-4[bp]
27417 788F           84C0                       test	al,al
27418 7891           74           0E            je  	.6A8
27419                       00007893            .6AA:
27420                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27421 7893           8A46         FE            mov	al,-2[bp]
27422 7896           84C0                       test	al,al
27423 7898           74           07            je  	.6A8
27424                       0000789A            .6A9:
27425                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$24-4] (used reg = )
27426 789A           8A46         FE            mov	al,-2[bp]
27427 789D           3C                     48  cmp	al,*$48
27428 789F           76           2D            jbe 	.6A7
27429                       000078A1            .6A8:
27430                                           ! 4681         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
27431                                           ! Debug: list * char = .6AD+0 (used reg = )
27432 78A1           BB                   CE1E  mov	bx,#.6AD
27433 78A4           53                         push	bx
27434                                           ! Debug: list int = const 4 (used reg = )
27435 78A5           B8                   0004  mov	ax,*4
27436 78A8           50                         push	ax
27437                                           ! Debug: func () void = bios_printf+0 (used reg = )
27438 78A9           E8         908D            call	_bios_printf
27439 78AC           83C4                   04  add	sp,*4
27440                                           !BCC_EOS
27441                                           ! 4682         *(((Bit8u *)&AX)+1) = (1);
27442                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27443 78AF           B0                     01  mov	al,*1
27444 78B1           8846         17            mov	$17[bp],al
27445                                           !BCC_EOS
27446                                           ! 4683         set_diskette_ret_status(1);
27447                                           ! Debug: list int = const 1 (used reg = )
27448 78B4           B8                   0001  mov	ax,*1
27449 78B7           50                         push	ax
27450                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27451 78B8           E8         0D83            call	_set_diskette_ret_status
27452 78BB           44                         inc	sp
27453 78BC           44                         inc	sp
27454                                           !BCC_EOS
27455                                           ! 4684         *((Bit8u *)&AX) = (0);
27456                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27457 78BD           30C0                       xor	al,al
27458 78BF           8846         16            mov	$16[bp],al
27459                                           !BCC_EOS
27460                                           ! 4685         FLAGS |= 0x0001;
27461                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27462 78C2           8B46         1C            mov	ax,$1C[bp]
27463 78C5           0C                     01  or	al,*1
27464 78C7           8946         1C            mov	$1C[bp],ax
27465                                           !BCC_EOS
27466                                           ! 4686         return;
27467 78CA           89EC                       mov	sp,bp
27468 78CC           5D                         pop	bp
27469 78CD           C3                         ret
27470                                           !BCC_EOS
27471                                           ! 4687       }
27472                                           ! 4688       if (floppy_drive_exists(drive) == 0) {
27473                       000078CE            .6A7:
27474                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27475 78CE           8A46         FF            mov	al,-1[bp]
27476 78D1           30E4                       xor	ah,ah
27477 78D3           50                         push	ax
27478                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
27479 78D4           E8         FE6F            call	_floppy_drive_exists
27480 78D7           44                         inc	sp
27481 78D8           44                         inc	sp
27482                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27483 78D9           85C0                       test	ax,ax
27484 78DB           75           1F            jne 	.6AE
27485                       000078DD            .6AF:
27486                                           ! 4689         *(((Bit8u *)&AX)+1) = (0x80);
27487                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27488 78DD           B0                     80  mov	al,#$80
27489 78DF           8846         17            mov	$17[bp],al
27490                                           !BCC_EOS
27491                                           ! 4690         set_diskette_ret_status(0x80);
27492                                           ! Debug: list int = const $80 (used reg = )
27493 78E2           B8                   0080  mov	ax,#$80
27494 78E5           50                         push	ax
27495                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27496 78E6           E8         0D55            call	_set_diskette_ret_status
27497 78E9           44                         inc	sp
27498 78EA           44                         inc	sp
27499                                           !BCC_EOS
27500                                           ! 4691         *((Bit8u *)&AX) = (0);
27501                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27502 78EB           30C0                       xor	al,al
27503 78ED           8846         16            mov	$16[bp],al
27504                                           !BCC_EOS
27505                                           ! 4692         FLAGS |= 0x0001;
27506                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27507 78F0           8B46         1C            mov	ax,$1C[bp]
27508 78F3           0C                     01  or	al,*1
27509 78F5           8946         1C            mov	$1C[bp],ax
27510                                           !BCC_EOS
27511                                           ! 4693         return;
27512 78F8           89EC                       mov	sp,bp
27513 78FA           5D                         pop	bp
27514 78FB           C3                         ret
27515                                           !BCC_EOS
27516                                           ! 4694       }
27517                                           ! 4695       if (floppy_media_known(drive) == 0) {
27518                       000078FC            .6AE:
27519                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27520 78FC           8A46         FF            mov	al,-1[bp]
27521 78FF           30E4                       xor	ah,ah
27522 7901           50                         push	ax
27523                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
27524 7902           E8         FC5B            call	_floppy_media_known
27525 7905           44                         inc	sp
27526 7906           44                         inc	sp
27527                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27528 7907           85C0                       test	ax,ax
27529 7909           75           2E            jne 	.6B0
27530                       0000790B            .6B1:
27531                                           ! 4696         if (floppy_media_sense(drive) == 0) {
27532                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27533 790B           8A46         FF            mov	al,-1[bp]
27534 790E           30E4                       xor	ah,ah
27535 7910           50                         push	ax
27536                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
27537 7911           E8         FCBC            call	_floppy_media_sense
27538 7914           44                         inc	sp
27539 7915           44                         inc	sp
27540                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27541 7916           85C0                       test	ax,ax
27542 7918           75           1F            jne 	.6B2
27543                       0000791A            .6B3:
27544                                           ! 4697           *(((Bit8u *)&AX)+1) = (0x0C);
27545                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
27546 791A           B0                     0C  mov	al,*$C
27547 791C           8846         17            mov	$17[bp],al
27548                                           !BCC_EOS
27549                                           ! 4698           set_diskette_ret_status(0x0C);
27550                                           ! Debug: list int = const $C (used reg = )
27551 791F           B8                   000C  mov	ax,*$C
27552 7922           50                         push	ax
27553                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27554 7923           E8         0D18            call	_set_diskette_ret_status
27555 7926           44                         inc	sp
27556 7927           44                         inc	sp
27557                                           !BCC_EOS
27558                                           ! 4699           *((Bit8u *)&AX) = (0);
27559                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27560 7928           30C0                       xor	al,al
27561 792A           8846         16            mov	$16[bp],al
27562                                           !BCC_EOS
27563                                           ! 4700           FLAGS |= 0x0001;
27564                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27565 792D           8B46         1C            mov	ax,$1C[bp]
27566 7930           0C                     01  or	al,*1
27567 7932           8946         1C            mov	$1C[bp],ax
27568                                           !BCC_EOS
27569                                           ! 4701           return;
27570 7935           89EC                       mov	sp,bp
27571 7937           5D                         pop	bp
27572 7938           C3                         ret
27573                                           !BCC_EOS
27574                                           ! 4702         }
27575                                           ! 4703       }
27576                       00007939            .6B2:
27577                                           ! 4704       if(ah == 0x04) {
27578                       00007939            .6B0:
27579                                           ! Debug: logeq int = const 4 to unsigned char ah = [S+$24-$1C] (used reg = )
27580 7939           8A46         E6            mov	al,-$1A[bp]
27581 793C           3C                     04  cmp	al,*4
27582 793E           75           06            jne 	.6B4
27583                       00007940            .6B5:
27584                                           ! 4705         goto floppy_return_success;
27585 7940           83C4                   00  add	sp,#..FFDA-..FFDB
27586 7943           E9         034C            br 	.FFDA
27587                                           !BCC_EOS
27588                                           ! 4706       }
27589                                           ! 4707       page = (ES >> 12);
27590                       00007946            .6B4:
27591                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
27592 7946           8B46         06            mov	ax,6[bp]
27593 7949           88E0                       mov	al,ah
27594 794B           30E4                       xor	ah,ah
27595 794D           B1                     04  mov	cl,*4
27596 794F           D3E8                       shr	ax,cl
27597                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
27598 7951           8846         F3            mov	-$D[bp],al
27599                                           !BCC_EOS
27600                                           ! 4708       base_es = (ES << 4);
27601                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
27602 7954           8B46         06            mov	ax,6[bp]
27603 7957           B1                     04  mov	cl,*4
27604 7959           D3E0                       shl	ax,cl
27605                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
27606 795B           8946         F4            mov	-$C[bp],ax
27607                                           !BCC_EOS
27608                                           ! 4709       base_address = base_es + BX;
27609                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
27610 795E           8B46         F4            mov	ax,-$C[bp]
27611 7961           0346         10            add	ax,$10[bp]
27612                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
27613 7964           8946         F8            mov	-8[bp],ax
27614                                           !BCC_EOS
27615                                           ! 4710       if ( base_address < ba
27616                                           ! 4710 se_es ) {
27617                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
27618 7967           8B46         F8            mov	ax,-8[bp]
27619 796A           3B46         F4            cmp	ax,-$C[bp]
27620 796D           73           07            jae 	.6B6
27621                       0000796F            .6B7:
27622                                           ! 4711         page++;
27623                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
27624 796F           8A46         F3            mov	al,-$D[bp]
27625 7972           40                         inc	ax
27626 7973           8846         F3            mov	-$D[bp],al
27627                                           !BCC_EOS
27628                                           ! 4712       }
27629                                           ! 4713       base_count = (num_sectors * 512) - 1;
27630                       00007976            .6B6:
27631                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$24-4] (used reg = )
27632 7976           8A46         FE            mov	al,-2[bp]
27633 7979           30E4                       xor	ah,ah
27634 797B           B9                   0200  mov	cx,#$200
27635 797E           F7E9                       imul	cx
27636                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27637                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
27638 7980           48                         dec	ax
27639 7981           8946         F6            mov	-$A[bp],ax
27640                                           !BCC_EOS
27641                                           ! 4714       last_addr = base_address + base_count;
27642                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
27643 7984           8B46         F8            mov	ax,-8[bp]
27644 7987           0346         F6            add	ax,-$A[bp]
27645                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
27646 798A           8946         E0            mov	-$20[bp],ax
27647                                           !BCC_EOS
27648                                           ! 4715       if (last_addr < base_address) {
27649                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
27650 798D           8B46         E0            mov	ax,-$20[bp]
27651 7990           3B46         F8            cmp	ax,-8[bp]
27652 7993           73           1F            jae 	.6B8
27653                       00007995            .6B9:
27654                                           ! 4716         *(((Bit8u *)&AX)+1) = (0x09);
27655                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
27656 7995           B0                     09  mov	al,*9
27657 7997           8846         17            mov	$17[bp],al
27658                                           !BCC_EOS
27659                                           ! 4717         set_diskette_ret_status(0x09);
27660                                           ! Debug: list int = const 9 (used reg = )
27661 799A           B8                   0009  mov	ax,*9
27662 799D           50                         push	ax
27663                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27664 799E           E8         0C9D            call	_set_diskette_ret_status
27665 79A1           44                         inc	sp
27666 79A2           44                         inc	sp
27667                                           !BCC_EOS
27668                                           ! 4718         *((Bit8u *)&AX) = (0);
27669                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27670 79A3           30C0                       xor	al,al
27671 79A5           8846         16            mov	$16[bp],al
27672                                           !BCC_EOS
27673                                           ! 4719         FLAGS |= 0x0001;
27674                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27675 79A8           8B46         1C            mov	ax,$1C[bp]
27676 79AB           0C                     01  or	al,*1
27677 79AD           8946         1C            mov	$1C[bp],ax
27678                                           !BCC_EOS
27679                                           ! 4720         return;
27680 79B0           89EC                       mov	sp,bp
27681 79B2           5D                         pop	bp
27682 79B3           C3                         ret
27683                                           !BCC_EOS
27684                                           ! 4721       }
27685                                           ! 4722       ;
27686                       000079B4            .6B8:
27687                                           !BCC_EOS
27688                                           ! 4723       outb(0x000a, 0x06);
27689                                           ! Debug: list int = const 6 (used reg = )
27690 79B4           B8                   0006  mov	ax,*6
27691 79B7           50                         push	ax
27692                                           ! Debug: list int = const $A (used reg = )
27693 79B8           B8                   000A  mov	ax,*$A
27694 79BB           50                         push	ax
27695                                           ! Debug: func () void = outb+0 (used reg = )
27696 79BC           E8         8B80            call	_outb
27697 79BF           83C4                   04  add	sp,*4
27698                                           !BCC_EOS
27699                                           ! 4724   ;
27700                                           !BCC_EOS
27701                                           ! 4725       outb(0x000c, 0x00);
27702                                           ! Debug: list int = const 0 (used reg = )
27703 79C2           31C0                       xor	ax,ax
27704 79C4           50                         push	ax
27705                                           ! Debug: list int = const $C (used reg = )
27706 79C5           B8                   000C  mov	ax,*$C
27707 79C8           50                         push	ax
27708                                           ! Debug: func () void = outb+0 (used reg = )
27709 79C9           E8         8B73            call	_outb
27710 79CC           83C4                   04  add	sp,*4
27711                                           !BCC_EOS
27712                                           ! 4726       outb(0x0004, base_address);
27713                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
27714 79CF           FF76         F8            push	-8[bp]
27715                                           ! Debug: list int = const 4 (used reg = )
27716 79D2           B8                   0004  mov	ax,*4
27717 79D5           50                         push	ax
27718                                           ! Debug: func () void = outb+0 (used reg = )
27719 79D6           E8         8B66            call	_outb
27720 79D9           83C4                   04  add	sp,*4
27721                                           !BCC_EOS
27722                                           ! 4727       outb(0x0004, *(((Bit8u *)&base_address)+1));
27723                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
27724 79DC           8A46         F9            mov	al,-7[bp]
27725 79DF           30E4                       xor	ah,ah
27726 79E1           50                         push	ax
27727                                           ! Debug: list int = const 4 (used reg = )
27728 79E2           B8                   0004  mov	ax,*4
27729 79E5           50                         push	ax
27730                                           ! Debug: func () void = outb+0 (used reg = )
27731 79E6           E8         8B56            call	_outb
27732 79E9           83C4                   04  add	sp,*4
27733                                           !BCC_EOS
27734                                           ! 4728   ;
27735                                           !BCC_EOS
27736                                           ! 4729       outb(0x000c, 0x00);
27737                                           ! Debug: list int = const 0 (used reg = )
27738 79EC           31C0                       xor	ax,ax
27739 79EE           50                         push	ax
27740                                           ! Debug: list int = const $C (used reg = )
27741 79EF           B8                   000C  mov	ax,*$C
27742 79F2           50                         push	ax
27743                                           ! Debug: func () void = outb+0 (used reg = )
27744 79F3           E8         8B49            call	_outb
27745 79F6           83C4                   04  add	sp,*4
27746                                           !BCC_EOS
27747                                           ! 4730       outb(0x0005, base_count);
27748                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
27749 79F9           FF76         F6            push	-$A[bp]
27750                                           ! Debug: list int = const 5 (used reg = )
27751 79FC           B8                   0005  mov	ax,*5
27752 79FF           50                         push	ax
27753                                           ! Debug: func () void = outb+0 (used reg = )
27754 7A00           E8         8B3C            call	_outb
27755 7A03           83C4                   04  add	sp,*4
27756                                           !BCC_EOS
27757                                           ! 4731       outb(0x0005, *(((Bit8u *)&base_count)+1));
27758                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
27759 7A06           8A46         F7            mov	al,-9[bp]
27760 7A09           30E4                       xor	ah,ah
27761 7A0B           50                         push	ax
27762                                           ! Debug: list int = const 5 (used reg = )
27763 7A0C           B8                   0005  mov	ax,*5
27764 7A0F           50                         push	ax
27765                                           ! Debug: func () void = outb+0 (used reg = )
27766 7A10           E8         8B2C            call	_outb
27767 7A13           83C4                   04  add	sp,*4
27768                                           !BCC_EOS
27769                                           ! 4732       if (ah == 0x02) {
27770                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
27771 7A16           8A46         E6            mov	al,-$1A[bp]
27772 7A19           3C                     02  cmp	al,*2
27773 7A1B           75           5C            jne 	.6BA
27774                       00007A1D            .6BB:
27775                                           ! 4733         mode_register = 0x46;
27776                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$24-$10] (used reg = )
27777 7A1D           B0                     46  mov	al,*$46
27778 7A1F           8846         F2            mov	-$E[bp],al
27779                                           !BCC_EOS
27780                                           ! 4734   ;
27781                                           !BCC_EOS
27782                                           ! 4735         outb(0x000b, mode_register);
27783                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27784 7A22           8A46         F2            mov	al,-$E[bp]
27785 7A25           30E4                       xor	ah,ah
27786 7A27           50                         push	ax
27787                                           ! Debug: list int = const $B (used reg = )
27788 7A28           B8                   000B  mov	ax,*$B
27789 7A2B           50                         push	ax
27790                                           ! Debug: func () void = outb+0 (used reg = )
27791 7A2C           E8         8B10            call	_outb
27792 7A2F           83C4                   04  add	sp,*4
27793                                           !BCC_EOS
27794                                           ! 4736   ;
27795                                           !BCC_EOS
27796                                           ! 4737         outb(0x0081, page);
27797                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27798 7A32           8A46         F3            mov	al,-$D[bp]
27799 7A35           30E4                       xor	ah,ah
27800 7A37           50                         push	ax
27801                                           ! Debug: list int = const $81 (used reg = )
27802 7A38           B8                   0081  mov	ax,#$81
27803 7A3B           50                         push	ax
27804                                           ! Debug: func () void = outb+0 (used reg = )
27805 7A3C           E8         8B00            call	_outb
27806 7A3F           83C4                   04  add	sp,*4
27807                                           !BCC_EOS
27808                                           ! 4738   ;
27809                                           !BCC_EOS
27810                                           ! 4739         outb(0x000a, 0x02);
27811                                           ! Debug: list int = const 2 (used reg = )
27812 7A42           B8                   0002  mov	ax,*2
27813 7A45           50                         push	ax
27814                                           ! Debug: list int = const $A (used reg = )
27815 7A46           B8                   000A  mov	ax,*$A
27816 7A49           50                         push	ax
27817                                           ! Debug: func () void = outb+0 (used reg = )
27818 7A4A           E8         8AF2            call	_outb
27819 7A4D           83C4                   04  add	sp,*4
27820                                           !BCC_EOS
27821                                           ! 4740         ;
27822                                           !BCC_EOS
27823                                           ! 4741         outb(0x000a, 0x02);
27824                                           ! Debug: list int = const 2 (used reg = )
27825 7A50           B8                   0002  mov	ax,*2
27826 7A53           50                         push	ax
27827                                           ! Debug: list int = const $A (used reg = )
27828 7A54           B8                   000A  mov	ax,*$A
27829 7A57           50                         push	ax
27830                                           ! Debug: func () void = outb+0 (used reg = )
27831 7A58           E8         8AE4            call	_outb
27832 7A5B           83C4                   04  add	sp,*4
27833                                           !BCC_EOS
27834                                           ! 4742         floppy_prepare_controller(drive);
27835                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27836 7A5E           8A46         FF            mov	al,-1[bp]
27837 7A61           30E4                       xor	ah,ah
27838 7A63           50                         push	ax
27839                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27840 7A64           E8         FA59            call	_floppy_prepare_controller
27841 7A67           44                         inc	sp
27842 7A68           44                         inc	sp
27843                                           !BCC_EOS
27844                                           ! 4743         outb(0x03f5, 0xe6);
27845                                           ! Debug: list int = const $E6 (used reg = )
27846 7A69           B8                   00E6  mov	ax,#$E6
27847 7A6C           50                         push	ax
27848                                           ! Debug: list int = const $3F5 (used reg = )
27849 7A6D           B8                   03F5  mov	ax,#$3F5
27850 7A70           50                         push	ax
27851                                           ! Debug: func () void = outb+0 (used reg = )
27852 7A71           E8         8ACB            call	_outb
27853 7A74           83C4                   04  add	sp,*4
27854                                           !BCC_EOS
27855                                           ! 4744       } else {
27856 7A77           EB           4C            jmp .6BC
27857                       00007A79            .6BA:
27858                                           ! 4745         mode_register = 0x4a;
27859                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
27860 7A79           B0                     4A  mov	al,*$4A
27861 7A7B           8846         F2            mov	-$E[bp],al
27862                                           !BCC_EOS
27863                                           ! 4746         outb(0x000b, mode_register);
27864                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27865 7A7E           8A46         F2            mov	al,-$E[bp]
27866 7A81           30E4                       xor	ah,ah
27867 7A83           50                         push	ax
27868                                           ! Debug: list int = const $B (used reg = )
27869 7A84           B8                   000B  mov	ax,*$B
27870 7A87           50                         push	ax
27871                                           ! Debug: func () void = outb+0 (used reg = )
27872 7A88           E8         8AB4            call	_outb
27873 7A8B           83C4                   04  add	sp,*4
27874                                           !BCC_EOS
27875                                           ! 4747         outb(0x0081, page);
27876                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27877 7A8E           8A46         F3            mov	al,-$D[bp]
27878 7A91           30E4                       xor	ah,ah
27879 7A93           50                         push	ax
27880                                           ! Debug: list int = const $81 (used reg = )
27881 7A94           B8                   0081  mov	ax,#$81
27882 7A97           50                         push	ax
27883                                           ! Debug: func () void = outb+0 (used reg = )
27884 7A98           E8         8AA4            call	_outb
27885 7A9B           83C4                   04  add	sp,*4
27886                                           !BCC_EOS
27887                                           ! 4748         ;
27888                                           !BCC_EOS
27889                                           ! 4749         outb(0x000a, 0x02);
27890                                           ! Debug: list int = const 2 (used reg = )
27891 7A9E           B8                   0002  mov	ax,*2
27892 7AA1           50                         push	ax
27893                                           ! Debug: list int = const $A (used reg = )
27894 7AA2           B8                   000A  mov	ax,*$A
27895 7AA5           50                         push	ax
27896                                           ! Debug: func () void = outb+0 (used reg = )
27897 7AA6           E8         8A96            call	_outb
27898 7AA9           83C4                   04  add	sp,*4
27899                                           !BCC_EOS
27900                                           ! 4750         floppy_prepare_controller(drive);
27901                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27902 7AAC           8A46         FF            mov	al,-1[bp]
27903 7AAF           30E4                       xor	ah,ah
27904 7AB1           50                         push	ax
27905                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27906 7AB2           E8         FA0B            call	_floppy_prepare_controller
27907 7AB5           44                         inc	sp
27908 7AB6           44                         inc	sp
27909                                           !BCC_EOS
27910                                           ! 4751         outb(0x03f5, 0xc5);
27911                                           ! Debug: list int = const $C5 (used reg = )
27912 7AB7           B8                   00C5  mov	ax,#$C5
27913 7ABA           50                         push	ax
27914                                           ! Debug: list int = const $3F5 (used reg = )
27915 7ABB           B8                   03F5  mov	ax,#$3F5
27916 7ABE           50                         push	ax
27917                                           ! Debug: func () void = outb+0 (used reg = )
27918 7ABF           E8         8A7D            call	_outb
27919 7AC2           83C4                   04  add	sp,*4
27920                                           !BCC_EOS
27921                                           ! 4752       }
27922                                           ! 4753       outb(0x03f5, (head << 2) | drive);
27923                       00007AC5            .6BC:
27924                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
27925 7AC5           8A46         FB            mov	al,-5[bp]
27926 7AC8           30E4                       xor	ah,ah
27927 7ACA           D1E0                       shl	ax,*1
27928 7ACC           D1E0                       shl	ax,*1
27929                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
27930 7ACE           0A46         FF            or	al,-1[bp]
27931                                           ! Debug: list unsigned int = ax+0 (used reg = )
27932 7AD1           50                         push	ax
27933                                           ! Debug: list int = const $3F5 (used reg = )
27934 7AD2           B8                   03F5  mov	ax,#$3F5
27935 7AD5           50                         push	ax
27936                                           ! Debug: func () void = outb+0 (used reg = )
27937 7AD6           E8         8A66            call	_outb
27938 7AD9           83C4                   04  add	sp,*4
27939                                           !BCC_EOS
27940                                           ! 4754       outb(0x03f5, track);
27941                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
27942 7ADC           8A46         FD            mov	al,-3[bp]
27943 7ADF           30E4                       xor	ah,ah
27944 7AE1           50                         push	ax
27945                                           ! Debug: list int = const $3F5 (used reg = )
27946 7AE2           B8                   03F5  mov	ax,#$3F5
27947 7AE5           50                         push	ax
27948                                           ! Debug: func () void = outb+0 (used reg = )
27949 7AE6           E8         8A56            call	_outb
27950 7AE9           83C4                   04  add	sp,*4
27951                                           !BCC_EOS
27952                                           ! 4755       outb(0x03f5, head);
27953                                           ! Debug: list unsigned char head = [S+$24-7] (used reg = )
27954 7AEC           8A46         FB            mov	al,-5[bp]
27955 7AEF           30E4                       xor	ah,ah
27956 7AF1           50                         push	ax
27957                                           ! Debug: list int = const $3F5 (used reg = )
27958 7AF2           B8                   03F5  mov	ax,#$3F5
27959 7AF5           50                         push	ax
27960                                           ! Debug: func () void = outb+0 (used reg = )
27961 7AF6           E8         8A46            call	_outb
27962 7AF9           83C4                   04  add	sp,*4
27963                                           !BCC_EOS
27964                                           ! 4756       outb(0x03f5, sector);
27965                                           ! Debug: list unsigned char sector = [S+$24-6] (used reg = )
27966 7AFC           8A46         FC            mov	al,-4[bp]
27967 7AFF           30E4                       xor	ah,ah
27968 7B01           50                         push	ax
27969                                           ! Debug: list int = const $3F5 (used reg = )
27970 7B02           B8                   03F5  mov	ax,#$3F5
27971 7B05           50                         push	ax
27972                                           ! Debug: func () void = outb+0 (used reg = )
27973 7B06           E8         8A36            call	_outb
27974 7B09           83C4                   04  add	sp,*4
27975                                           !BCC_EOS
27976                                           ! 4757       outb(0x03f5, 2);
27977                                           ! Debug: list int = const 2 (used reg = )
27978 7B0C           B8                   0002  mov	ax,*2
27979 7B0F           50                         push	ax
27980                                           ! Debug: list int = const $3F5 (used reg = )
27981 7B10           B8                   03F5  mov	ax,#$3F5
27982 7B13           50                         push	ax
27983                                           ! Debug: func () void = outb+0 (used reg = )
27984 7B14           E8         8A28            call	_outb
27985 7B17           83C4                   04  add	sp,*4
27986                                           !BCC_EOS
27987                                           ! 4758       outb(0x03f5, sector + num_sectors - 1);
27988                                           ! Debug: add unsigned char num_sectors = [S+$24-4] to unsigned char sector = [S+$24-6] (used reg = )
27989 7B1A           8A46         FC            mov	al,-4[bp]
27990 7B1D           30E4                       xor	ah,ah
27991 7B1F           0246         FE            add	al,-2[bp]
27992 7B22           80D4                   00  adc	ah,*0
27993                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27994                                           ! Debug: list unsigned int = ax-1 (used reg = )
27995 7B25           48                         dec	ax
27996 7B26           50                         push	ax
27997                                           ! Debug: list int = const $3F5 (used reg = )
27998 7B27           B8                   03F5  mov	ax,#$3F5
27999 7B2A           50                         push	ax
28000                                           ! Debug: func () void = outb+0 (used reg = )
28001 7B2B           E8         8A11            call	_outb
28002 7B2E           83C4                   04  add	sp,*4
28003                                           !BCC_EOS
28004                                           ! 4759       outb(0x03f5, 0);
28005                                           ! Debug: list int = const 0 (used reg = )
28006 7B31           31C0                       xor	ax,ax
28007 7B33           50                         push	ax
28008                                           ! Debug: list int = const $3F5 (used reg = )
28009 7B34           B8                   03F5  mov	ax,#$3F5
28010 7B37           50                         push	ax
28011                                           ! Debug: func () void = outb+0 (used reg = )
28012 7B38           E8         8A04            call	_outb
28013 7B3B           83C4                   04  add	sp,*4
28014                                           !BCC_EOS
28015                                           ! 4760       outb(0x03f5, 0xff);
28016                                           ! Debug: list int = const $FF (used reg = )
28017 7B3E           B8                   00FF  mov	ax,#$FF
28018 7B41           50                         push	ax
28019                                           ! Debug: list int = const $3F5 (used reg = )
28020 7B42           B8                   03F5  mov	ax,#$3F5
28021 7B45           50                         push	ax
28022                                           ! Debug: func () void = outb+0 (used reg = )
28023 7B46           E8         89F6            call	_outb
28024 7B49           83C4                   04  add	sp,*4
28025                                           !BCC_EOS
28026                                           ! 4761 #asm
28027                                           !BCC_EOS
28028                                           !BCC_ASM
28029                       0000002E            _int13_diskette_function.BP	set	$2E
28030                       0000000C            .int13_diskette_function.BP	set	$C
28031                       0000003C            _int13_diskette_function.CS	set	$3C
28032                       0000001A            .int13_diskette_function.CS	set	$1A
28033                       00000036            _int13_diskette_function.CX	set	$36
28034                       00000014            .int13_diskette_function.CX	set	$14
28035                       0000001A            _int13_diskette_function.base_address	set	$1A
28036                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28037                       0000002A            _int13_diskette_function.DI	set	$2A
28038                       00000008            .int13_diskette_function.DI	set	8
28039                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28040                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28041                       00000018            _int13_diskette_function.base_count	set	$18
28042                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28043                       0000001E            _int13_diskette_function.sector	set	$1E
28044                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28045                       00000026            _int13_diskette_function.DS	set	$26
28046                       00000004            .int13_diskette_function.DS	set	4
28047                       0000001D            _int13_diskette_function.head	set	$1D
28048                       FFFFFFFB            .int13_diskette_function.head	set	-5
28049                       00000030            _int13_diskette_function.ELDX	set	$30
28050                       0000000E            .int13_diskette_function.ELDX	set	$E
28051                       00000012            _int13_diskette_function.dor	set	$12
28052                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28053                       00000034            _int13_diskette_function.DX	set	$34
28054                       00000012            .int13_diskette_function.DX	set	$12
28055                       0000000B            _int13_diskette_function.return_status	set	$B
28056                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28057                       00000004            _int13_diskette_function.es	set	4
28058                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28059                       00000014            _int13_diskette_function.mode_register	set	$14
28060                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28061                       00000028            _int13_diskette_function.ES	set	$28
28062                       00000006            .int13_diskette_function.ES	set	6
28063                       00000016            _int13_diskette_function.base_es	set	$16
28064                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28065                       0000001F            _int13_diskette_function.track	set	$1F
28066                       FFFFFFFD            .int13_diskette_function.track	set	-3
28067                       0000002C            _int13_diskette_function.SI	set	$2C
28068                       0000000A            .int13_diskette_function.SI	set	$A
28069                       0000000A            _int13_diskette_function.drive_type	set	$A
28070                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28071                       00000020            _int13_diskette_function.num_sectors	set	$20
28072                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28073                       0000003A            _int13_diskette_function.IP	set	$3A
28074                       00000018            .int13_diskette_function.IP	set	$18
28075                       00000007            _int13_diskette_function.spt	set	7
28076                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28077                       0000001C            _int13_diskette_function.status	set	$1C
28078                       FFFFFFFA            .int13_diskette_function.status	set	-6
28079                       00000000            _int13_diskette_function.maxCyl	set	0
28080                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28081                       00000038            _int13_diskette_function.AX	set	$38
28082                       00000016            .int13_diskette_function.AX	set	$16
28083                       00000013            _int13_diskette_function.val8	set	$13
28084                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28085                       00000002            _int13_diskette_function.last_addr	set	2
28086                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28087                       00000015            _int13_diskette_function.page	set	$15
28088                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28089                       00000008            _int13_diskette_function.ah	set	8
28090                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28091                       00000021            _int13_diskette_function.drive	set	$21
28092                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28093                       00000009            _int13_diskette_function.num_floppies	set	9
28094                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28095                       00000032            _int13_diskette_function.BX	set	$32
28096                       00000010            .int13_diskette_function.BX	set	$10
28097 7B4C           FB                               sti
28098                                           ! 4763 endasm
28099                                           !BCC_ENDASM
28100                                           !BCC_EOS
28101                                           ! 4764       do {
28102                       00007B4D            .6BF:
28103                                           ! 4765         val8 = *((Bit8u *)(0x0040));
28104                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
28105 7B4D           A0         0040            mov	al,[$40]
28106 7B50           8846         F1            mov	-$F[bp],al
28107                                           !BCC_EOS
28108                                           ! 4766         if (val8 == 0) {
28109                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28110 7B53           8A46         F1            mov	al,-$F[bp]
28111 7B56           84C0                       test	al,al
28112 7B58           75           22            jne 	.6C0
28113                       00007B5A            .6C1:
28114                                           ! 4767           floppy_reset_controller();
28115                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
28116 7B5A           E8         F915            call	_floppy_reset_controller
28117                                           !BCC_EOS
28118                                           ! 4768           *(((Bit8u *)&AX)+1) = (0x80);
28119                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28120 7B5D           B0                     80  mov	al,#$80
28121 7B5F           8846         17            mov	$17[bp],al
28122                                           !BCC_EOS
28123                                           ! 4769           set_diskette_ret_status(0x80);
28124                                           ! Debug: list int = const $80 (used reg = )
28125 7B62           B8                   0080  mov	ax,#$80
28126 7B65           50                         push	ax
28127                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28128 7B66           E8         0AD5            call	_set_diskette_ret_status
28129 7B69           44                         inc	sp
28130 7B6A           44                         inc	sp
28131                                           !BCC_EOS
28132                                           ! 4770           *((Bit8u *)&AX) = (0);
28133                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28134 7B6B           30C0                       xor	al,al
28135 7B6D           8846         16            mov	$16[bp],al
28136                                           !BCC_EOS
28137                                           ! 4771           FLAGS |= 0x0001;
28138                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28139 7B70           8B46         1C            mov	ax,$1C[bp]
28140 7B73           0C                     01  or	al,*1
28141 7B75           8946         1C            mov	$1C[bp],ax
28142                                           !BCC_EOS
28143                                           ! 4772           return;
28144 7B78           89EC                       mov	sp,bp
28145 7B7A           5D                         pop	bp
28146 7B7B           C3                         ret
28147                                           !BCC_EOS
28148                                           ! 4773         }
28149                                           ! 4774         val8 = (*((Bit8u *)(0x003e)) & 0x80);
28150                       00007B7C            .6C0:
28151                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
28152 7B7C           A0         003E            mov	al,[$3E]
28153 7B7F           24                     80  and	al,#$80
28154                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28155 7B81           8846         F1            mov	-$F[bp],al
28156                                           !BCC_EOS
28157                                           ! 4775       } while ( val8 == 0 );
28158                       00007B84            .6BE:
28159                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28160 7B84           8A46         F1            mov	al,-$F[bp]
28161 7B87           84C0                       test	al,al
28162 7B89           74           C2            je 	.6BF
28163                       00007B8B            .6C2:
28164                                           !BCC_EOS
28165                                           ! 4776       val8 = 0;
28166                       00007B8B            .6BD:
28167                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28168 7B8B           30C0                       xor	al,al
28169 7B8D           8846         F1            mov	-$F[bp],al
28170                                           !BCC_EOS
28171                                           ! 4777 #asm
28172                                           !BCC_EOS
28173                                           !BCC_ASM
28174                       0000002E            _int13_diskette_function.BP	set	$2E
28175                       0000000C            .int13_diskette_function.BP	set	$C
28176                       0000003C            _int13_diskette_function.CS	set	$3C
28177                       0000001A            .int13_diskette_function.CS	set	$1A
28178                       00000036            _int13_diskette_function.CX	set	$36
28179                       00000014            .int13_diskette_function.CX	set	$14
28180                       0000001A            _int13_diskette_function.base_address	set	$1A
28181                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28182                       0000002A            _int13_diskette_function.DI	set	$2A
28183                       00000008            .int13_diskette_function.DI	set	8
28184                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28185                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28186                       00000018            _int13_diskette_function.base_count	set	$18
28187                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28188                       0000001E            _int13_diskette_function.sector	set	$1E
28189                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28190                       00000026            _int13_diskette_function.DS	set	$26
28191                       00000004            .int13_diskette_function.DS	set	4
28192                       0000001D            _int13_diskette_function.head	set	$1D
28193                       FFFFFFFB            .int13_diskette_function.head	set	-5
28194                       00000030            _int13_diskette_function.ELDX	set	$30
28195                       0000000E            .int13_diskette_function.ELDX	set	$E
28196                       00000012            _int13_diskette_function.dor	set	$12
28197                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28198                       00000034            _int13_diskette_function.DX	set	$34
28199                       00000012            .int13_diskette_function.DX	set	$12
28200                       0000000B            _int13_diskette_function.return_status	set	$B
28201                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28202                       00000004            _int13_diskette_function.es	set	4
28203                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28204                       00000014            _int13_diskette_function.mode_register	set	$14
28205                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28206                       00000028            _int13_diskette_function.ES	set	$28
28207                       00000006            .int13_diskette_function.ES	set	6
28208                       00000016            _int13_diskette_function.base_es	set	$16
28209                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28210                       0000001F            _int13_diskette_function.track	set	$1F
28211                       FFFFFFFD            .int13_diskette_function.track	set	-3
28212                       0000002C            _int13_diskette_function.SI	set	$2C
28213                       0000000A            .int13_diskette_function.SI	set	$A
28214                       0000000A            _int13_diskette_function.drive_type	set	$A
28215                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28216                       00000020            _int13_diskette_function.num_sectors	set	$20
28217                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28218                       0000003A            _int13_diskette_function.IP	set	$3A
28219                       00000018            .int13_diskette_function.IP	set	$18
28220                       00000007            _int13_diskette_function.spt	set	7
28221                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28222                       0000001C            _int13_diskette_function.status	set	$1C
28223                       FFFFFFFA            .int13_diskette_function.status	set	-6
28224                       00000000            _int13_diskette_function.maxCyl	set	0
28225                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28226                       00000038            _int13_diskette_function.AX	set	$38
28227                       00000016            .int13_diskette_function.AX	set	$16
28228                       00000013            _int13_diskette_function.val8	set	$13
28229                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28230                       00000002            _int13_diskette_function.last_addr	set	2
28231                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28232                       00000015            _int13_diskette_function.page	set	$15
28233                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28234                       00000008            _int13_diskette_function.ah	set	8
28235                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28236                       00000021            _int13_diskette_function.drive	set	$21
28237                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28238                       00000009            _int13_diskette_function.num_floppies	set	9
28239                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28240                       00000032            _int13_diskette_function.BX	set	$32
28241                       00000010            .int13_diskette_function.BX	set	$10
28242 7B90           FA                               cli
28243                                           ! 4779 endasm
28244                                           !BCC_ENDASM
28245                                           !BCC_EOS
28246                                           ! 4780       val8 = *((Bit8u *)(0x003e));
28247                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
28248 7B91           A0         003E            mov	al,[$3E]
28249 7B94           8846         F1            mov	-$F[bp],al
28250                                           !BCC_EOS
28251                                           ! 4781       val8 &= 0x7f;
28252                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
28253 7B97           8A46         F1            mov	al,-$F[bp]
28254 7B9A           24                     7F  and	al,*$7F
28255 7B9C           8846         F1            mov	-$F[bp],al
28256                                           !BCC_EOS
28257                                           ! 4782       *((Bit8u *)(0x003e)) = (val8);
28258                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
28259 7B9F           8A46         F1            mov	al,-$F[bp]
28260 7BA2           A2         003E            mov	[$3E],al
28261                                           !BCC_EOS
28262                                           ! 4783       val8 = inb(0x03f4);
28263                                           ! Debug: list int = const $3F4 (used reg = )
28264 7BA5           B8                   03F4  mov	ax,#$3F4
28265 7BA8           50                         push	ax
28266                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28267 7BA9           E8         897D            call	_inb
28268 7BAC           44                         inc	sp
28269 7BAD           44                         inc	sp
28270                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28271 7BAE           8846         F1            mov	-$F[bp],al
28272                                           !BCC_EOS
28273                                           ! 4784       if ( (val8 & 0xc0) != 0xc0 )
28274                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
28275 7BB1           8A46         F1            mov	al,-$F[bp]
28276 7BB4           24                     C0  and	al,#$C0
28277                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
28278 7BB6           3C                     C0  cmp	al,#$C0
28279 7BB8           74           0E            je  	.6C3
28280                       00007BBA            .6C4:
28281                                           ! 4785         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
28282                                           ! Debug: list * char = .6C5+0 (used reg = )
28283 7BBA           BB                   CDFE  mov	bx,#.6C5
28284 7BBD           53                         push	bx
28285                                           ! Debug: list int = const 7 (used reg = )
28286 7BBE           B8                   0007  mov	ax,*7
28287 7BC1           50                         push	ax
28288                                           ! Debug: func () void = bios_printf+0 (used reg = )
28289 7BC2           E8         8D74            call	_bios_printf
28290 7BC5           83C4                   04  add	sp,*4
28291                                           !BCC_EOS
28292                                           ! 4786       return_status[0] = inb(0x03f5);
28293                       00007BC8            .6C3:
28294                                           ! Debug: list int = const $3F5 (used reg = )
28295 7BC8           B8                   03F5  mov	ax,#$3F5
28296 7BCB           50                         push	ax
28297                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28298 7BCC           E8         895A            call	_inb
28299 7BCF           44                         inc	sp
28300 7BD0           44                         inc	sp
28301                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
28302 7BD1           8846         E9            mov	-$17[bp],al
28303                                           !BCC_EOS
28304                                           ! 4787       return_status[1] = inb(0x03f5);
28305                                           ! Debug: list int = const $3F5 (used reg = )
28306 7BD4           B8                   03F5  mov	ax,#$3F5
28307 7BD7           50                         push	ax
28308                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28309 7BD8           E8         894E            call	_inb
28310 7BDB           44                         inc	sp
28311 7BDC           44                         inc	sp
28312                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
28313 7BDD           8846         EA            mov	-$16[bp],al
28314                                           !BCC_EOS
28315                                           ! 4788       return_status[2]
28316                                           ! 4788  = inb(0x03f5);
28317                                           ! Debug: list int = const $3F5 (used reg = )
28318 7BE0           B8                   03F5  mov	ax,#$3F5
28319 7BE3           50                         push	ax
28320                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28321 7BE4           E8         8942            call	_inb
28322 7BE7           44                         inc	sp
28323 7BE8           44                         inc	sp
28324                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
28325 7BE9           8846         EB            mov	-$15[bp],al
28326                                           !BCC_EOS
28327                                           ! 4789       return_status[3] = inb(0x03f5);
28328                                           ! Debug: list int = const $3F5 (used reg = )
28329 7BEC           B8                   03F5  mov	ax,#$3F5
28330 7BEF           50                         push	ax
28331                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28332 7BF0           E8         8936            call	_inb
28333 7BF3           44                         inc	sp
28334 7BF4           44                         inc	sp
28335                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
28336 7BF5           8846         EC            mov	-$14[bp],al
28337                                           !BCC_EOS
28338                                           ! 4790       return_status[4] = inb(0x03f5);
28339                                           ! Debug: list int = const $3F5 (used reg = )
28340 7BF8           B8                   03F5  mov	ax,#$3F5
28341 7BFB           50                         push	ax
28342                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28343 7BFC           E8         892A            call	_inb
28344 7BFF           44                         inc	sp
28345 7C00           44                         inc	sp
28346                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
28347 7C01           8846         ED            mov	-$13[bp],al
28348                                           !BCC_EOS
28349                                           ! 4791       return_status[5] = inb(0x03f5);
28350                                           ! Debug: list int = const $3F5 (used reg = )
28351 7C04           B8                   03F5  mov	ax,#$3F5
28352 7C07           50                         push	ax
28353                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28354 7C08           E8         891E            call	_inb
28355 7C0B           44                         inc	sp
28356 7C0C           44                         inc	sp
28357                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
28358 7C0D           8846         EE            mov	-$12[bp],al
28359                                           !BCC_EOS
28360                                           ! 4792       return_status[6] = inb(0x03f5);
28361                                           ! Debug: list int = const $3F5 (used reg = )
28362 7C10           B8                   03F5  mov	ax,#$3F5
28363 7C13           50                         push	ax
28364                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28365 7C14           E8         8912            call	_inb
28366 7C17           44                         inc	sp
28367 7C18           44                         inc	sp
28368                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
28369 7C19           8846         EF            mov	-$11[bp],al
28370                                           !BCC_EOS
28371                                           ! 4793       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
28372                                           ! Debug: list int = const 7 (used reg = )
28373 7C1C           B8                   0007  mov	ax,*7
28374 7C1F           50                         push	ax
28375                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
28376 7C20           E8         8A37            call	_get_SS
28377                                           ! Debug: list unsigned short = ax+0 (used reg = )
28378 7C23           50                         push	ax
28379                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
28380 7C24           8D5E         E9            lea	bx,-$17[bp]
28381 7C27           53                         push	bx
28382                                           ! Debug: list int = const $40 (used reg = )
28383 7C28           B8                   0040  mov	ax,*$40
28384 7C2B           50                         push	ax
28385                                           ! Debug: list int = const $42 (used reg = )
28386 7C2C           B8                   0042  mov	ax,*$42
28387 7C2F           50                         push	ax
28388                                           ! Debug: func () void = _memcpyb+0 (used reg = )
28389 7C30           E8         83E8            call	__memcpyb
28390 7C33           83C4                   0A  add	sp,*$A
28391                                           !BCC_EOS
28392                                           ! 4794       if ( (return_status[0] & 0xc0) != 0 ) {
28393                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
28394 7C36           8A46         E9            mov	al,-$17[bp]
28395 7C39           24                     C0  and	al,#$C0
28396                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28397 7C3B           84C0                       test	al,al
28398 7C3D           74           53            je  	.6C6
28399                       00007C3F            .6C7:
28400                                           ! 4795         if (ah == 0x02) {
28401                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
28402 7C3F           8A46         E6            mov	al,-$1A[bp]
28403 7C42           3C                     02  cmp	al,*2
28404 7C44           75           21            jne 	.6C8
28405                       00007C46            .6C9:
28406                                           ! 4796           *(((Bit8u *)&AX)+1) = (0x20);
28407                                           ! Debug: eq int = const $20 to unsigned char AX = [S+$24+$15] (used reg = )
28408 7C46           B0                     20  mov	al,*$20
28409 7C48           8846         17            mov	$17[bp],al
28410                                           !BCC_EOS
28411                                           ! 4797           set_diskette_ret_status(0x20);
28412                                           ! Debug: list int = const $20 (used reg = )
28413 7C4B           B8                   0020  mov	ax,*$20
28414 7C4E           50                         push	ax
28415                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28416 7C4F           E8         09EC            call	_set_diskette_ret_status
28417 7C52           44                         inc	sp
28418 7C53           44                         inc	sp
28419                                           !BCC_EOS
28420                                           ! 4798           *((Bit8u *)&AX) = (0);
28421                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28422 7C54           30C0                       xor	al,al
28423 7C56           8846         16            mov	$16[bp],al
28424                                           !BCC_EOS
28425                                           ! 4799           FLAGS |= 0x0001;
28426                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28427 7C59           8B46         1C            mov	ax,$1C[bp]
28428 7C5C           0C                     01  or	al,*1
28429 7C5E           8946         1C            mov	$1C[bp],ax
28430                                           !BCC_EOS
28431                                           ! 4800           return;
28432 7C61           89EC                       mov	sp,bp
28433 7C63           5D                         pop	bp
28434 7C64           C3                         ret
28435                                           !BCC_EOS
28436                                           ! 4801         } else {
28437 7C65           EB           2B            jmp .6CA
28438                       00007C67            .6C8:
28439                                           ! 4802           if ( (return_status[1] & 0x02) != 0 ) {
28440                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
28441 7C67           8A46         EA            mov	al,-$16[bp]
28442 7C6A           24                     02  and	al,*2
28443                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28444 7C6C           84C0                       test	al,al
28445 7C6E           74           14            je  	.6CB
28446                       00007C70            .6CC:
28447                                           ! 4803             AX = 0x0300;
28448                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
28449 7C70           B8                   0300  mov	ax,#$300
28450 7C73           8946         16            mov	$16[bp],ax
28451                                           !BCC_EOS
28452                                           ! 4804             FLAGS |= 0x0001;
28453                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28454 7C76           8B46         1C            mov	ax,$1C[bp]
28455 7C79           0C                     01  or	al,*1
28456 7C7B           8946         1C            mov	$1C[bp],ax
28457                                           !BCC_EOS
28458                                           ! 4805             return;
28459 7C7E           89EC                       mov	sp,bp
28460 7C80           5D                         pop	bp
28461 7C81           C3                         ret
28462                                           !BCC_EOS
28463                                           ! 4806           } else {
28464 7C82           EB           0E            jmp .6CD
28465                       00007C84            .6CB:
28466                                           ! 4807             bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
28467                                           ! Debug: list * char = .6CE+0 (used reg = )
28468 7C84           BB                   CDD8  mov	bx,#.6CE
28469 7C87           53                         push	bx
28470                                           ! Debug: list int = const 7 (used reg = )
28471 7C88           B8                   0007  mov	ax,*7
28472 7C8B           50                         push	ax
28473                                           ! Debug: func () void = bios_printf+0 (used reg = )
28474 7C8C           E8         8CAA            call	_bios_printf
28475 7C8F           83C4                   04  add	sp,*4
28476                                           !BCC_EOS
28477                                           ! 4808           }
28478                                           ! 4809         }
28479                       00007C92            .6CD:
28480                                           ! 4810       }
28481                       00007C92            .6CA:
28482                                           ! 4811 floppy_return_success:
28483                       00007C92            .6C6:
28484                       00007C92            .FFDA:
28485                                           ! 4812       set_diskette_current_cyl(drive, track);
28486                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
28487 7C92           8A46         FD            mov	al,-3[bp]
28488 7C95           30E4                       xor	ah,ah
28489 7C97           50                         push	ax
28490                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
28491 7C98           8A46         FF            mov	al,-1[bp]
28492 7C9B           30E4                       xor	ah,ah
28493 7C9D           50                         push	ax
28494                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
28495 7C9E           E8         09B5            call	_set_diskette_current_cyl
28496 7CA1           83C4                   04  add	sp,*4
28497                                           !BCC_EOS
28498                                           ! 4813       *(((Bit8u *)&AX)+1) = (0x00);
28499                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
28500 7CA4           30C0                       xor	al,al
28501 7CA6           8846         17            mov	$17[bp],al
28502                                           !BCC_EOS
28503                                           ! 4814       FLAGS &= 0xfffe;
28504                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28505 7CA9           8B46         1C            mov	ax,$1C[bp]
28506 7CAC           24                     FE  and	al,#$FE
28507 7CAE           8946         1C            mov	$1C[bp],ax
28508                                           !BCC_EOS
28509                                           ! 4815       break;
28510 7CB1           E9         0986            br 	.696
28511                                           !BCC_EOS
28512                                           ! 4816     case 0x05:
28513                                           ! 4817 ;
28514                       00007CB4            .6CF:
28515                                           !BCC_EOS
28516                                           ! 4818       num_sectors = ( AX & 0x00ff );
28517                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
28518 7CB4           8A46         16            mov	al,$16[bp]
28519                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28520 7CB7           8846         FE            mov	-2[bp],al
28521                                           !BCC_EOS
28522                                           ! 4819       track = *(((Bit8u *)&CX)+1);
28523                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
28524 7CBA           8A46         15            mov	al,$15[bp]
28525 7CBD           8846         FD            mov	-3[bp],al
28526                                           !BCC_EOS
28527                                           ! 4820       head = *(((Bit8u *)&DX)+1);
28528                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
28529 7CC0           8A46         13            mov	al,$13[bp]
28530 7CC3           8846         FB            mov	-5[bp],al
28531                                           !BCC_EOS
28532                                           ! 4821       drive = ( ELDX & 0x00ff );
28533                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
28534 7CC6           8A46         0E            mov	al,$E[bp]
28535                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
28536 7CC9           8846         FF            mov	-1[bp],al
28537                                           !BCC_EOS
28538                                           ! 4822       if ((drive > 1) || (head > 1) || (track > 79) ||
28539                                           ! 4823           (num_sectors == 0) || (num_sectors > 18)) {
28540                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
28541 7CCC           8A46         FF            mov	al,-1[bp]
28542 7CCF           3C                     01  cmp	al,*1
28543 7CD1           77           1C            ja  	.6D1
28544                       00007CD3            .6D5:
28545                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
28546 7CD3           8A46         FB            mov	al,-5[bp]
28547 7CD6           3C                     01  cmp	al,*1
28548 7CD8           77           15            ja  	.6D1
28549                       00007CDA            .6D4:
28550                                           ! Debug: gt int = const $4F to unsigned char track = [S+$24-5] (used reg = )
28551 7CDA           8A46         FD            mov	al,-3[bp]
28552 7CDD           3C                     4F  cmp	al,*$4F
28553 7CDF           77           0E            ja  	.6D1
28554                       00007CE1            .6D3:
28555                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28556 7CE1           8A46         FE            mov	al,-2[bp]
28557 7CE4           84C0                       test	al,al
28558 7CE6           74           07            je  	.6D1
28559                       00007CE8            .6D2:
28560                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$24-4] (used reg = )
28561 7CE8           8A46         FE            mov	al,-2[bp]
28562 7CEB           3C                     12  cmp	al,*$12
28563 7CED           76           16            jbe 	.6D0
28564                       00007CEF            .6D1:
28565                                           ! 4824         *(((Bit8u *)&AX)+1) = (1);
28566                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
28567 7CEF           B0                     01  mov	al,*1
28568 7CF1           8846         17            mov	$17[bp],al
28569                                           !BCC_EOS
28570                                           ! 4825         set_diskette_ret_status(1);
28571                                           ! Debug: list int = const 1 (used reg = )
28572 7CF4           B8                   0001  mov	ax,*1
28573 7CF7           50                         push	ax
28574                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28575 7CF8           E8         0943            call	_set_diskette_ret_status
28576 7CFB           44                         inc	sp
28577 7CFC           44                         inc	sp
28578                                           !BCC_EOS
28579                                           ! 4826         FLAGS |= 0x0001;
28580                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28581 7CFD           8B46         1C            mov	ax,$1C[bp]
28582 7D00           0C                     01  or	al,*1
28583 7D02           8946         1C            mov	$1C[bp],ax
28584                                           !BCC_EOS
28585                                           ! 4827       }
28586                                           ! 4828       if (floppy_drive_exists(drive) == 0) {
28587                       00007D05            .6D0:
28588                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28589 7D05           8A46         FF            mov	al,-1[bp]
28590 7D08           30E4                       xor	ah,ah
28591 7D0A           50                         push	ax
28592                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
28593 7D0B           E8         FA38            call	_floppy_drive_exists
28594 7D0E           44                         inc	sp
28595 7D0F           44                         inc	sp
28596                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28597 7D10           85C0                       test	ax,ax
28598 7D12           75           1A            jne 	.6D6
28599                       00007D14            .6D7:
28600                                           ! 4829         *(((Bit8u *)&AX)+1) = (0x80);
28601                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28602 7D14           B0                     80  mov	al,#$80
28603 7D16           8846         17            mov	$17[bp],al
28604                                           !BCC_EOS
28605                                           ! 4830         set_diskette_ret_status(0x80);
28606                                           ! Debug: list int = const $80 (used reg = )
28607 7D19           B8                   0080  mov	ax,#$80
28608 7D1C           50                         push	ax
28609                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28610 7D1D           E8         091E            call	_set_diskette_ret_status
28611 7D20           44                         inc	sp
28612 7D21           44                         inc	sp
28613                                           !BCC_EOS
28614                                           ! 4831         FLAGS |= 0x0001;
28615                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28616 7D22           8B46         1C            mov	ax,$1C[bp]
28617 7D25           0C                     01  or	al,*1
28618 7D27           8946         1C            mov	$1C[bp],ax
28619                                           !BCC_EOS
28620                                           ! 4832         return;
28621 7D2A           89EC                       mov	sp,bp
28622 7D2C           5D                         pop	bp
28623 7D2D           C3                         ret
28624                                           !BCC_EOS
28625                                           ! 4833       }
28626                                           ! 4834       if (floppy_media_known(drive) == 0) {
28627                       00007D2E            .6D6:
28628                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28629 7D2E           8A46         FF            mov	al,-1[bp]
28630 7D31           30E4                       xor	ah,ah
28631 7D33           50                         push	ax
28632                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
28633 7D34           E8         F829            call	_floppy_media_known
28634 7D37           44                         inc	sp
28635 7D38           44                         inc	sp
28636                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28637 7D39           85C0                       test	ax,ax
28638 7D3B           75           2E            jne 	.6D8
28639                       00007D3D            .6D9:
28640                                           ! 4835         if (floppy_media_sense(drive) == 0) {
28641                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28642 7D3D           8A46         FF            mov	al,-1[bp]
28643 7D40           30E4                       xor	ah,ah
28644 7D42           50                         push	ax
28645                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
28646 7D43           E8         F88A            call	_floppy_media_sense
28647 7D46           44                         inc	sp
28648 7D47           44                         inc	sp
28649                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28650 7D48           85C0                       test	ax,ax
28651 7D4A           75           1F            jne 	.6DA
28652                       00007D4C            .6DB:
28653                                           ! 4836           *(((Bit8u *)&AX)+1) = (0x0C);
28654                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
28655 7D4C           B0                     0C  mov	al,*$C
28656 7D4E           8846         17            mov	$17[bp],al
28657                                           !BCC_EOS
28658                                           ! 4837           set_diskette_ret_status(0x0C);
28659                                           ! Debug: list int = const $C (used reg = )
28660 7D51           B8                   000C  mov	ax,*$C
28661 7D54           50                         push	ax
28662                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28663 7D55           E8         08E6            call	_set_diskette_ret_status
28664 7D58           44                         inc	sp
28665 7D59           44                         inc	sp
28666                                           !BCC_EOS
28667                                           ! 4838           *((Bit8u *)&AX) = (0);
28668                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28669 7D5A           30C0                       xor	al,al
28670 7D5C           8846         16            mov	$16[bp],al
28671                                           !BCC_EOS
28672                                           ! 4839           FLAGS |= 0x0001;
28673                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28674 7D5F           8B46         1C            mov	ax,$1C[bp]
28675 7D62           0C                     01  or	al,*1
28676 7D64           8946         1C            mov	$1C[bp],ax
28677                                           !BCC_EOS
28678                                           ! 4840           return;
28679 7D67           89EC                       mov	sp,bp
28680 7D69           5D                         pop	bp
28681 7D6A           C3                         ret
28682                                           !BCC_EOS
28683                                           ! 4841         }
28684                                           ! 4842       }
28685                       00007D6B            .6DA:
28686                                           ! 4843       page = (ES >> 12);
28687                       00007D6B            .6D8:
28688                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
28689 7D6B           8B46         06            mov	ax,6[bp]
28690 7D6E           88E0                       mov	al,ah
28691 7D70           30E4                       xor	ah,ah
28692 7D72           B1                     04  mov	cl,*4
28693 7D74           D3E8                       shr	ax,cl
28694                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
28695 7D76           8846         F3            mov	-$D[bp],al
28696                                           !BCC_EOS
28697                                           ! 4844       base_es = (ES << 4);
28698                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
28699 7D79           8B46         06            mov	ax,6[bp]
28700 7D7C           B1                     04  mov	cl,*4
28701 7D7E           D3E0                       shl	ax,cl
28702                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
28703 7D80           8946         F4            mov	-$C[bp],ax
28704                                           !BCC_EOS
28705                                           ! 4845       base_address = base_es + BX;
28706                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
28707 7D83           8B46         F4            mov	ax,-$C[bp]
28708 7D86           0346         10            add	ax,$10[bp]
28709                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
28710 7D89           8946         F8            mov	-8[bp],ax
28711                                           !BCC_EOS
28712                                           ! 4846       if ( base_address < base_es ) {
28713                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
28714 7D8C           8B46         F8            mov	ax,-8[bp]
28715 7D8F           3B46         F4            cmp	ax,-$C[bp]
28716 7D92           73           07            jae 	.6DC
28717                       00007D94            .6DD:
28718                                           ! 4847         page++;
28719                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
28720 7D94           8A46         F3            mov	al,-$D[bp]
28721 7D97           40                         inc	ax
28722 7D98           8846         F3            mov	-$D[bp],al
28723                                           !BCC_EOS
28724                                           ! 4848       }
28725                                           ! 4849       base_count = (num_sectors * 4) - 1;
28726                       00007D9B            .6DC:
28727                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$24-4] (used reg = )
28728 7D9B           8A46         FE            mov	al,-2[bp]
28729 7D9E           30E4                       xor	ah,ah
28730 7DA0           D1E0                       shl	ax,*1
28731 7DA2           D1E0                       shl	ax,*1
28732                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28733                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
28734 7DA4           48                         dec	ax
28735 7DA5           8946         F6            mov	-$A[bp],ax
28736                                           !BCC_EOS
28737                                           ! 4850       last_addr = base_address + base_count;
28738                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
28739 7DA8           8B46         F8            mov	ax,-8[bp]
28740 7DAB           0346         F6            add	ax,-$A[bp]
28741                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
28742 7DAE           8946         E0            mov	-$20[bp],ax
28743                                           !BCC_EOS
28744                                           ! 4851       if (last_addr < base_address) {
28745                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
28746 7DB1           8B46         E0            mov	ax,-$20[bp]
28747 7DB4           3B46         F8            cmp	ax,-8[bp]
28748 7DB7           73           1F            jae 	.6DE
28749                       00007DB9            .6DF:
28750                                           ! 4852         *(((Bit8u *)&AX)+1) = (0x09);
28751                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
28752 7DB9           B0                     09  mov	al,*9
28753 7DBB           8846         17            mov	$17[bp],al
28754                                           !BCC_EOS
28755                                           ! 4853         set_diskette_ret_status(0x09);
28756                                           ! Debug: list int = const 9 (used reg = )
28757 7DBE           B8                   0009  mov	ax,*9
28758 7DC1           50                         push	ax
28759                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28760 7DC2           E8         0879            call	_set_diskette_ret_status
28761 7DC5           44                         inc	sp
28762 7DC6           44                         inc	sp
28763                                           !BCC_EOS
28764                                           ! 4854         *((Bit8u *)&AX) 
28765                                           ! 4854 = (0);
28766                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28767 7DC7           30C0                       xor	al,al
28768 7DC9           8846         16            mov	$16[bp],al
28769                                           !BCC_EOS
28770                                           ! 4855         FLAGS |= 0x0001;
28771                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28772 7DCC           8B46         1C            mov	ax,$1C[bp]
28773 7DCF           0C                     01  or	al,*1
28774 7DD1           8946         1C            mov	$1C[bp],ax
28775                                           !BCC_EOS
28776                                           ! 4856         return;
28777 7DD4           89EC                       mov	sp,bp
28778 7DD6           5D                         pop	bp
28779 7DD7           C3                         ret
28780                                           !BCC_EOS
28781                                           ! 4857       }
28782                                           ! 4858       outb(0x000a, 0x06);
28783                       00007DD8            .6DE:
28784                                           ! Debug: list int = const 6 (used reg = )
28785 7DD8           B8                   0006  mov	ax,*6
28786 7DDB           50                         push	ax
28787                                           ! Debug: list int = const $A (used reg = )
28788 7DDC           B8                   000A  mov	ax,*$A
28789 7DDF           50                         push	ax
28790                                           ! Debug: func () void = outb+0 (used reg = )
28791 7DE0           E8         875C            call	_outb
28792 7DE3           83C4                   04  add	sp,*4
28793                                           !BCC_EOS
28794                                           ! 4859       outb(0x000c, 0x00);
28795                                           ! Debug: list int = const 0 (used reg = )
28796 7DE6           31C0                       xor	ax,ax
28797 7DE8           50                         push	ax
28798                                           ! Debug: list int = const $C (used reg = )
28799 7DE9           B8                   000C  mov	ax,*$C
28800 7DEC           50                         push	ax
28801                                           ! Debug: func () void = outb+0 (used reg = )
28802 7DED           E8         874F            call	_outb
28803 7DF0           83C4                   04  add	sp,*4
28804                                           !BCC_EOS
28805                                           ! 4860       outb(0x0004, base_address);
28806                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
28807 7DF3           FF76         F8            push	-8[bp]
28808                                           ! Debug: list int = const 4 (used reg = )
28809 7DF6           B8                   0004  mov	ax,*4
28810 7DF9           50                         push	ax
28811                                           ! Debug: func () void = outb+0 (used reg = )
28812 7DFA           E8         8742            call	_outb
28813 7DFD           83C4                   04  add	sp,*4
28814                                           !BCC_EOS
28815                                           ! 4861       outb(0x0004, *(((Bit8u *)&base_address)+1));
28816                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
28817 7E00           8A46         F9            mov	al,-7[bp]
28818 7E03           30E4                       xor	ah,ah
28819 7E05           50                         push	ax
28820                                           ! Debug: list int = const 4 (used reg = )
28821 7E06           B8                   0004  mov	ax,*4
28822 7E09           50                         push	ax
28823                                           ! Debug: func () void = outb+0 (used reg = )
28824 7E0A           E8         8732            call	_outb
28825 7E0D           83C4                   04  add	sp,*4
28826                                           !BCC_EOS
28827                                           ! 4862       outb(0x000c, 0x00);
28828                                           ! Debug: list int = const 0 (used reg = )
28829 7E10           31C0                       xor	ax,ax
28830 7E12           50                         push	ax
28831                                           ! Debug: list int = const $C (used reg = )
28832 7E13           B8                   000C  mov	ax,*$C
28833 7E16           50                         push	ax
28834                                           ! Debug: func () void = outb+0 (used reg = )
28835 7E17           E8         8725            call	_outb
28836 7E1A           83C4                   04  add	sp,*4
28837                                           !BCC_EOS
28838                                           ! 4863       outb(0x0005, base_count);
28839                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
28840 7E1D           FF76         F6            push	-$A[bp]
28841                                           ! Debug: list int = const 5 (used reg = )
28842 7E20           B8                   0005  mov	ax,*5
28843 7E23           50                         push	ax
28844                                           ! Debug: func () void = outb+0 (used reg = )
28845 7E24           E8         8718            call	_outb
28846 7E27           83C4                   04  add	sp,*4
28847                                           !BCC_EOS
28848                                           ! 4864       outb(0x0005, *(((Bit8u *)&base_count)+1));
28849                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
28850 7E2A           8A46         F7            mov	al,-9[bp]
28851 7E2D           30E4                       xor	ah,ah
28852 7E2F           50                         push	ax
28853                                           ! Debug: list int = const 5 (used reg = )
28854 7E30           B8                   0005  mov	ax,*5
28855 7E33           50                         push	ax
28856                                           ! Debug: func () void = outb+0 (used reg = )
28857 7E34           E8         8708            call	_outb
28858 7E37           83C4                   04  add	sp,*4
28859                                           !BCC_EOS
28860                                           ! 4865       mode_register = 0x4a;
28861                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
28862 7E3A           B0                     4A  mov	al,*$4A
28863 7E3C           8846         F2            mov	-$E[bp],al
28864                                           !BCC_EOS
28865                                           ! 4866       outb(0x000b, mode_register);
28866                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
28867 7E3F           8A46         F2            mov	al,-$E[bp]
28868 7E42           30E4                       xor	ah,ah
28869 7E44           50                         push	ax
28870                                           ! Debug: list int = const $B (used reg = )
28871 7E45           B8                   000B  mov	ax,*$B
28872 7E48           50                         push	ax
28873                                           ! Debug: func () void = outb+0 (used reg = )
28874 7E49           E8         86F3            call	_outb
28875 7E4C           83C4                   04  add	sp,*4
28876                                           !BCC_EOS
28877                                           ! 4867       outb(0x0081, page);
28878                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
28879 7E4F           8A46         F3            mov	al,-$D[bp]
28880 7E52           30E4                       xor	ah,ah
28881 7E54           50                         push	ax
28882                                           ! Debug: list int = const $81 (used reg = )
28883 7E55           B8                   0081  mov	ax,#$81
28884 7E58           50                         push	ax
28885                                           ! Debug: func () void = outb+0 (used reg = )
28886 7E59           E8         86E3            call	_outb
28887 7E5C           83C4                   04  add	sp,*4
28888                                           !BCC_EOS
28889                                           ! 4868       outb(0x000a, 0x02);
28890                                           ! Debug: list int = const 2 (used reg = )
28891 7E5F           B8                   0002  mov	ax,*2
28892 7E62           50                         push	ax
28893                                           ! Debug: list int = const $A (used reg = )
28894 7E63           B8                   000A  mov	ax,*$A
28895 7E66           50                         push	ax
28896                                           ! Debug: func () void = outb+0 (used reg = )
28897 7E67           E8         86D5            call	_outb
28898 7E6A           83C4                   04  add	sp,*4
28899                                           !BCC_EOS
28900                                           ! 4869       floppy_prepare_controller(drive);
28901                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28902 7E6D           8A46         FF            mov	al,-1[bp]
28903 7E70           30E4                       xor	ah,ah
28904 7E72           50                         push	ax
28905                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
28906 7E73           E8         F64A            call	_floppy_prepare_controller
28907 7E76           44                         inc	sp
28908 7E77           44                         inc	sp
28909                                           !BCC_EOS
28910                                           ! 4870       outb(0x03f5, 0x4d);
28911                                           ! Debug: list int = const $4D (used reg = )
28912 7E78           B8                   004D  mov	ax,*$4D
28913 7E7B           50                         push	ax
28914                                           ! Debug: list int = const $3F5 (used reg = )
28915 7E7C           B8                   03F5  mov	ax,#$3F5
28916 7E7F           50                         push	ax
28917                                           ! Debug: func () void = outb+0 (used reg = )
28918 7E80           E8         86BC            call	_outb
28919 7E83           83C4                   04  add	sp,*4
28920                                           !BCC_EOS
28921                                           ! 4871       outb(0x03f5, (head << 2) | drive);
28922                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
28923 7E86           8A46         FB            mov	al,-5[bp]
28924 7E89           30E4                       xor	ah,ah
28925 7E8B           D1E0                       shl	ax,*1
28926 7E8D           D1E0                       shl	ax,*1
28927                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
28928 7E8F           0A46         FF            or	al,-1[bp]
28929                                           ! Debug: list unsigned int = ax+0 (used reg = )
28930 7E92           50                         push	ax
28931                                           ! Debug: list int = const $3F5 (used reg = )
28932 7E93           B8                   03F5  mov	ax,#$3F5
28933 7E96           50                         push	ax
28934                                           ! Debug: func () void = outb+0 (used reg = )
28935 7E97           E8         86A5            call	_outb
28936 7E9A           83C4                   04  add	sp,*4
28937                                           !BCC_EOS
28938                                           ! 4872       outb(0x03f5, 2);
28939                                           ! Debug: list int = const 2 (used reg = )
28940 7E9D           B8                   0002  mov	ax,*2
28941 7EA0           50                         push	ax
28942                                           ! Debug: list int = const $3F5 (used reg = )
28943 7EA1           B8                   03F5  mov	ax,#$3F5
28944 7EA4           50                         push	ax
28945                                           ! Debug: func () void = outb+0 (used reg = )
28946 7EA5           E8         8697            call	_outb
28947 7EA8           83C4                   04  add	sp,*4
28948                                           !BCC_EOS
28949                                           ! 4873       outb(0x03f5, num_sectors);
28950                                           ! Debug: list unsigned char num_sectors = [S+$24-4] (used reg = )
28951 7EAB           8A46         FE            mov	al,-2[bp]
28952 7EAE           30E4                       xor	ah,ah
28953 7EB0           50                         push	ax
28954                                           ! Debug: list int = const $3F5 (used reg = )
28955 7EB1           B8                   03F5  mov	ax,#$3F5
28956 7EB4           50                         push	ax
28957                                           ! Debug: func () void = outb+0 (used reg = )
28958 7EB5           E8         8687            call	_outb
28959 7EB8           83C4                   04  add	sp,*4
28960                                           !BCC_EOS
28961                                           ! 4874       outb(0x03f5, 0);
28962                                           ! Debug: list int = const 0 (used reg = )
28963 7EBB           31C0                       xor	ax,ax
28964 7EBD           50                         push	ax
28965                                           ! Debug: list int = const $3F5 (used reg = )
28966 7EBE           B8                   03F5  mov	ax,#$3F5
28967 7EC1           50                         push	ax
28968                                           ! Debug: func () void = outb+0 (used reg = )
28969 7EC2           E8         867A            call	_outb
28970 7EC5           83C4                   04  add	sp,*4
28971                                           !BCC_EOS
28972                                           ! 4875       outb(0x03f5, 0xf6);
28973                                           ! Debug: list int = const $F6 (used reg = )
28974 7EC8           B8                   00F6  mov	ax,#$F6
28975 7ECB           50                         push	ax
28976                                           ! Debug: list int = const $3F5 (used reg = )
28977 7ECC           B8                   03F5  mov	ax,#$3F5
28978 7ECF           50                         push	ax
28979                                           ! Debug: func () void = outb+0 (used reg = )
28980 7ED0           E8         866C            call	_outb
28981 7ED3           83C4                   04  add	sp,*4
28982                                           !BCC_EOS
28983                                           ! 4876 #asm
28984                                           !BCC_EOS
28985                                           !BCC_ASM
28986                       0000002E            _int13_diskette_function.BP	set	$2E
28987                       0000000C            .int13_diskette_function.BP	set	$C
28988                       0000003C            _int13_diskette_function.CS	set	$3C
28989                       0000001A            .int13_diskette_function.CS	set	$1A
28990                       00000036            _int13_diskette_function.CX	set	$36
28991                       00000014            .int13_diskette_function.CX	set	$14
28992                       0000001A            _int13_diskette_function.base_address	set	$1A
28993                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28994                       0000002A            _int13_diskette_function.DI	set	$2A
28995                       00000008            .int13_diskette_function.DI	set	8
28996                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28997                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28998                       00000018            _int13_diskette_function.base_count	set	$18
28999                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29000                       0000001E            _int13_diskette_function.sector	set	$1E
29001                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29002                       00000026            _int13_diskette_function.DS	set	$26
29003                       00000004            .int13_diskette_function.DS	set	4
29004                       0000001D            _int13_diskette_function.head	set	$1D
29005                       FFFFFFFB            .int13_diskette_function.head	set	-5
29006                       00000030            _int13_diskette_function.ELDX	set	$30
29007                       0000000E            .int13_diskette_function.ELDX	set	$E
29008                       00000012            _int13_diskette_function.dor	set	$12
29009                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29010                       00000034            _int13_diskette_function.DX	set	$34
29011                       00000012            .int13_diskette_function.DX	set	$12
29012                       0000000B            _int13_diskette_function.return_status	set	$B
29013                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29014                       00000004            _int13_diskette_function.es	set	4
29015                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29016                       00000014            _int13_diskette_function.mode_register	set	$14
29017                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29018                       00000028            _int13_diskette_function.ES	set	$28
29019                       00000006            .int13_diskette_function.ES	set	6
29020                       00000016            _int13_diskette_function.base_es	set	$16
29021                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29022                       0000001F            _int13_diskette_function.track	set	$1F
29023                       FFFFFFFD            .int13_diskette_function.track	set	-3
29024                       0000002C            _int13_diskette_function.SI	set	$2C
29025                       0000000A            .int13_diskette_function.SI	set	$A
29026                       0000000A            _int13_diskette_function.drive_type	set	$A
29027                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29028                       00000020            _int13_diskette_function.num_sectors	set	$20
29029                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29030                       0000003A            _int13_diskette_function.IP	set	$3A
29031                       00000018            .int13_diskette_function.IP	set	$18
29032                       00000007            _int13_diskette_function.spt	set	7
29033                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29034                       0000001C            _int13_diskette_function.status	set	$1C
29035                       FFFFFFFA            .int13_diskette_function.status	set	-6
29036                       00000000            _int13_diskette_function.maxCyl	set	0
29037                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29038                       00000038            _int13_diskette_function.AX	set	$38
29039                       00000016            .int13_diskette_function.AX	set	$16
29040                       00000013            _int13_diskette_function.val8	set	$13
29041                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29042                       00000002            _int13_diskette_function.last_addr	set	2
29043                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29044                       00000015            _int13_diskette_function.page	set	$15
29045                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29046                       00000008            _int13_diskette_function.ah	set	8
29047                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29048                       00000021            _int13_diskette_function.drive	set	$21
29049                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29050                       00000009            _int13_diskette_function.num_floppies	set	9
29051                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29052                       00000032            _int13_diskette_function.BX	set	$32
29053                       00000010            .int13_diskette_function.BX	set	$10
29054 7ED6           FB                               sti
29055                                           ! 4878 endasm
29056                                           !BCC_ENDASM
29057                                           !BCC_EOS
29058                                           ! 4879       do {
29059                       00007ED7            .6E2:
29060                                           ! 4880         val8 = *((Bit8u *)(0x0040));
29061                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
29062 7ED7           A0         0040            mov	al,[$40]
29063 7EDA           8846         F1            mov	-$F[bp],al
29064                                           !BCC_EOS
29065                                           ! 4881         if (val8 == 0) {
29066                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29067 7EDD           8A46         F1            mov	al,-$F[bp]
29068 7EE0           84C0                       test	al,al
29069 7EE2           75           1D            jne 	.6E3
29070                       00007EE4            .6E4:
29071                                           ! 4882           floppy_reset_controller();
29072                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
29073 7EE4           E8         F58B            call	_floppy_reset_controller
29074                                           !BCC_EOS
29075                                           ! 4883           *(((Bit8u *)&AX)+1) = (0x80);
29076                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
29077 7EE7           B0                     80  mov	al,#$80
29078 7EE9           8846         17            mov	$17[bp],al
29079                                           !BCC_EOS
29080                                           ! 4884           set_diskette_ret_status(0x80);
29081                                           ! Debug: list int = const $80 (used reg = )
29082 7EEC           B8                   0080  mov	ax,#$80
29083 7EEF           50                         push	ax
29084                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29085 7EF0           E8         074B            call	_set_diskette_ret_status
29086 7EF3           44                         inc	sp
29087 7EF4           44                         inc	sp
29088                                           !BCC_EOS
29089                                           ! 4885           FLAGS |= 0x0001;
29090                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29091 7EF5           8B46         1C            mov	ax,$1C[bp]
29092 7EF8           0C                     01  or	al,*1
29093 7EFA           8946         1C            mov	$1C[bp],ax
29094                                           !BCC_EOS
29095                                           ! 4886           return;
29096 7EFD           89EC                       mov	sp,bp
29097 7EFF           5D                         pop	bp
29098 7F00           C3                         ret
29099                                           !BCC_EOS
29100                                           ! 4887         }
29101                                           ! 4888         val8 = (*((Bit8u *)(0x003e)) & 0x80);
29102                       00007F01            .6E3:
29103                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
29104 7F01           A0         003E            mov	al,[$3E]
29105 7F04           24                     80  and	al,#$80
29106                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29107 7F06           8846         F1            mov	-$F[bp],al
29108                                           !BCC_EOS
29109                                           ! 4889       } while ( val8 == 0 );
29110                       00007F09            .6E1:
29111                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29112 7F09           8A46         F1            mov	al,-$F[bp]
29113 7F0C           84C0                       test	al,al
29114 7F0E           74           C7            je 	.6E2
29115                       00007F10            .6E5:
29116                                           !BCC_EOS
29117                                           ! 4890       val8 = 0;
29118                       00007F10            .6E0:
29119                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29120 7F10           30C0                       xor	al,al
29121 7F12           8846         F1            mov	-$F[bp],al
29122                                           !BCC_EOS
29123                                           ! 4891 #asm
29124                                           !BCC_EOS
29125                                           !BCC_ASM
29126                       0000002E            _int13_diskette_function.BP	set	$2E
29127                       0000000C            .int13_diskette_function.BP	set	$C
29128                       0000003C            _int13_diskette_function.CS	set	$3C
29129                       0000001A            .int13_diskette_function.CS	set	$1A
29130                       00000036            _int13_diskette_function.CX	set	$36
29131                       00000014            .int13_diskette_function.CX	set	$14
29132                       0000001A            _int13_diskette_function.base_address	set	$1A
29133                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29134                       0000002A            _int13_diskette_function.DI	set	$2A
29135                       00000008            .int13_diskette_function.DI	set	8
29136                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29137                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29138                       00000018            _int13_diskette_function.base_count	set	$18
29139                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29140                       0000001E            _int13_diskette_function.sector	set	$1E
29141                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29142                       00000026            _int13_diskette_function.DS	set	$26
29143                       00000004            .int13_diskette_function.DS	set	4
29144                       0000001D            _int13_diskette_function.head	set	$1D
29145                       FFFFFFFB            .int13_diskette_function.head	set	-5
29146                       00000030            _int13_diskette_function.ELDX	set	$30
29147                       0000000E            .int13_diskette_function.ELDX	set	$E
29148                       00000012            _int13_diskette_function.dor	set	$12
29149                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29150                       00000034            _int13_diskette_function.DX	set	$34
29151                       00000012            .int13_diskette_function.DX	set	$12
29152                       0000000B            _int13_diskette_function.return_status	set	$B
29153                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29154                       00000004            _int13_diskette_function.es	set	4
29155                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29156                       00000014            _int13_diskette_function.mode_register	set	$14
29157                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29158                       00000028            _int13_diskette_function.ES	set	$28
29159                       00000006            .int13_diskette_function.ES	set	6
29160                       00000016            _int13_diskette_function.base_es	set	$16
29161                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29162                       0000001F            _int13_diskette_function.track	set	$1F
29163                       FFFFFFFD            .int13_diskette_function.track	set	-3
29164                       0000002C            _int13_diskette_function.SI	set	$2C
29165                       0000000A            .int13_diskette_function.SI	set	$A
29166                       0000000A            _int13_diskette_function.drive_type	set	$A
29167                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29168                       00000020            _int13_diskette_function.num_sectors	set	$20
29169                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29170                       0000003A            _int13_diskette_function.IP	set	$3A
29171                       00000018            .int13_diskette_function.IP	set	$18
29172                       00000007            _int13_diskette_function.spt	set	7
29173                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29174                       0000001C            _int13_diskette_function.status	set	$1C
29175                       FFFFFFFA            .int13_diskette_function.status	set	-6
29176                       00000000            _int13_diskette_function.maxCyl	set	0
29177                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29178                       00000038            _int13_diskette_function.AX	set	$38
29179                       00000016            .int13_diskette_function.AX	set	$16
29180                       00000013            _int13_diskette_function.val8	set	$13
29181                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29182                       00000002            _int13_diskette_function.last_addr	set	2
29183                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29184                       00000015            _int13_diskette_function.page	set	$15
29185                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29186                       00000008            _int13_diskette_function.ah	set	8
29187                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29188                       00000021            _int13_diskette_function.drive	set	$21
29189                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29190                       00000009            _int13_diskette_function.num_floppies	set	9
29191                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29192                       00000032            _int13_diskette_function.BX	set	$32
29193                       00000010            .int13_diskette_function.BX	set	$10
29194 7F15           FA                               cli
29195                                           ! 4893 endasm
29196                                           !BCC_ENDASM
29197                                           !BCC_EOS
29198                                           ! 4894       val8 = *((Bit8u *)(0x003e));
29199                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
29200 7F16           A0         003E            mov	al,[$3E]
29201 7F19           8846         F1            mov	-$F[bp],al
29202                                           !BCC_EOS
29203                                           ! 4895       val8 &= 0x7f;
29204                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
29205 7F1C           8A46         F1            mov	al,-$F[bp]
29206 7F1F           24                     7F  and	al,*$7F
29207 7F21           8846         F1            mov	-$F[bp],al
29208                                           !BCC_EOS
29209                                           ! 4896       *((Bit8u *)(0x003e)) = (val8);
29210                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
29211 7F24           8A46         F1            mov	al,-$F[bp]
29212 7F27           A2         003E            mov	[$3E],al
29213                                           !BCC_EOS
29214                                           ! 4897       val8 = inb(0x03f4);
29215                                           ! Debug: list int = const $3F4 (used reg = )
29216 7F2A           B8                   03F4  mov	ax,#$3F4
29217 7F2D           50                         push	ax
29218                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29219 7F2E           E8         85F8            call	_inb
29220 7F31           44                         inc	sp
29221 7F32           44                         inc	sp
29222                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29223 7F33           8846         F1            mov	-$F[bp],al
29224                                           !BCC_EOS
29225                                           ! 4898       if ( (val8 & 0xc0) != 0xc0 )
29226                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
29227 7F36           8A46         F1            mov	al,-$F[bp]
29228 7F39           24                     C0  and	al,#$C0
29229                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
29230 7F3B           3C                     C0  cmp	al,#$C0
29231 7F3D           74           0E            je  	.6E6
29232                       00007F3F            .6E7:
29233                                           ! 4899         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
29234                                           ! Debug: list * char = .6E8+0 (used reg = )
29235 7F3F           BB                   CDB8  mov	bx,#.6E8
29236 7F42           53                         push	bx
29237                                           ! Debug: list int = const 7 (used reg = )
29238 7F43           B8                   0007  mov	ax,*7
29239 7F46           50                         push	ax
29240                                           ! Debug: func () void = bios_printf+0 (used reg = )
29241 7F47           E8         89EF            call	_bios_printf
29242 7F4A           83C4                   04  add	sp,*4
29243                                           !BCC_EOS
29244                                           ! 4900       return_status[0] = inb(0x03f5);
29245                       00007F4D            .6E6:
29246                                           ! Debug: list int = const $3F5 (used reg = )
29247 7F4D           B8                   03F5  mov	ax,#$3F5
29248 7F50           50                         push	ax
29249                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29250 7F51           E8         85D5            call	_inb
29251 7F54           44                         inc	sp
29252 7F55           44                         inc	sp
29253                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
29254 7F56           8846         E9            mov	-$17[bp],al
29255                                           !BCC_EOS
29256                                           ! 4901       return_status[1] = inb(0x03f5);
29257                                           ! Debug: list int = const $3F5 (used reg = )
29258 7F59           B8                   03F5  mov	ax,#$3F5
29259 7F5C           50                         push	ax
29260                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29261 7F5D           E8         85C9            call	_inb
29262 7F60           44                         inc	sp
29263 7F61           44                         inc	sp
29264                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
29265 7F62           8846         EA            mov	-$16[bp],al
29266                                           !BCC_EOS
29267                                           ! 4902       return_status[2] = inb(0x03f5);
29268                                           ! Debug: list int = const $3F5 (used reg = )
29269 7F65           B8                   03F5  mov	ax,#$3F5
29270 7F68           50                         push	ax
29271                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29272 7F69           E8         85BD            call	_inb
29273 7F6C           44                         inc	sp
29274 7F6D           44                         inc	sp
29275                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
29276 7F6E           8846         EB            mov	-$15[bp],al
29277                                           !BCC_EOS
29278                                           ! 4903       return_status[3] = inb(0x03f5);
29279                                           ! Debug: list int = const $3F5 (used reg = )
29280 7F71           B8                   03F5  mov	ax,#$3F5
29281 7F74           50                         push	ax
29282                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29283 7F75           E8         85B1            call	_inb
29284 7F78           44                         inc	sp
29285 7F79           44                         inc	sp
29286                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
29287 7F7A           8846         EC            mov	-$14[bp],al
29288                                           !BCC_EOS
29289                                           ! 4904       return_status[4] = inb(0x03f5);
29290                                           ! Debug: list int = const $3F5 (used reg = )
29291 7F7D           B8                   03F5  mov	ax,#$3F5
29292 7F80           50                         push	ax
29293                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29294 7F81           E8         85A5            call	_inb
29295 7F84           44                         inc	sp
29296 7F85           44                         inc	sp
29297                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
29298 7F86           8846         ED            mov	-$13[bp],al
29299                                           !BCC_EOS
29300                                           ! 4905       return_status[5] = inb(0x03f5);
29301                                           ! Debug: list int = const $3F5 (used reg = )
29302 7F89           B8                   03F5  mov	ax,#$3F5
29303 7F8C           50                         push	ax
29304                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29305 7F8D           E8         8599            call	_inb
29306 7F90           44                         inc	sp
29307 7F91           44                         inc	sp
29308                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
29309 7F92           8846         EE            mov	-$12[bp],al
29310                                           !BCC_EOS
29311                                           ! 4906       return_status[6] = inb(0x03f5);
29312                                           ! Debug: list int = const $3F5 (used reg = )
29313 7F95           B8                   03F5  mov	ax,#$3F5
29314 7F98           50                         push	ax
29315                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29316 7F99           E8         858D            call	_inb
29317 7F9C           44                         inc	sp
29318 7F9D           44                         inc	sp
29319                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
29320 7F9E           8846         EF            mov	-$11[bp],al
29321                                           !BCC_EOS
29322                                           ! 4907       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
29323                                           ! Debug: list int = const 7 (used reg = )
29324 7FA1           B8                   0007  mov	ax,*7
29325 7FA4           50                         push	ax
29326                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29327 7FA5           E8         86B2            call	_get_SS
29328                                           ! Debug: list unsigned short = ax+0 (used reg = )
29329 7FA8           50                         push	ax
29330                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
29331 7FA9           8D5E         E9            lea	bx,-$17[bp]
29332 7FAC           53                         push	bx
29333                                           ! Debug: list int = const $40 (used reg = )
29334 7FAD           B8                   0040  mov	ax,*$40
29335 7FB0           50                         push	ax
29336                                           ! Debug: list int = const $42 (used reg = )
29337 7FB1           B8                   0042  mov	ax,*$42
29338 7FB4           50                         push	ax
29339                                           ! Debug: func () void = _memcpyb+0 (used reg = )
29340 7FB5           E8         8063            call	__memcpyb
29341 7FB8           83C4                   0A  add	sp,*$A
29342                                           !BCC_EOS
29343                                           ! 4908       if ( (return_status[0] & 0xc0) != 0 ) {
29344                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
29345 7FBB           8A46         E9            mov	al,-$17[bp]
29346 7FBE           24                     C0  and	al,#$C0
29347                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29348 7FC0           84C0                       test	al,al
29349 7FC2           74           2B            je  	.6E9
29350                       00007FC4            .6EA:
29351                                           ! 4909         if ( (return_status[1] & 0x02) != 0 ) {
29352                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
29353 7FC4           8A46         EA            mov	al,-$16[bp]
29354 7FC7           24                     02  and	al,*2
29355                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29356 7FC9           84C0                       test	al,al
29357 7FCB           74           14            je  	.6EB
29358                       00007FCD            .6EC:
29359                                           ! 4910           AX = 0x0300;
29360                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
29361 7FCD           B8                   0300  mov	ax,#$300
29362 7FD0           8946         16            mov	$16[bp],ax
29363                                           !BCC_EOS
29364                                           ! 4911           FLAGS |= 0x0001;
29365                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29366 7FD3           8B46         1C            mov	ax,$1C[bp]
29367 7FD6           0C                     01  or	al,*1
29368 7FD8           8946         1C            mov	$1C[bp],ax
29369                                           !BCC_EOS
29370                                           ! 4912           return;
29371 7FDB           89EC                       mov	sp,bp
29372 7FDD           5D                         pop	bp
29373 7FDE           C3                         ret
29374                                           !BCC_EOS
29375                                           ! 4913         } else {
29376 7FDF           EB           0E            jmp .6ED
29377                       00007FE1            .6EB:
29378                                           ! 4914           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
29379                                           ! Debug: list * char = .6EE+0 (used reg = )
29380 7FE1           BB                   CD92  mov	bx,#.6EE
29381 7FE4           53                         push	bx
29382                                           ! Debug: list int = const 7 (used reg = )
29383 7FE5           B8                   0007  mov	ax,*7
29384 7FE8           50                         push	ax
29385                                           ! Debug: func () void = bios_printf+0 (used reg = )
29386 7FE9           E8         894D            call	_bios_printf
29387 7FEC           83C4                   04  add	sp,*4
29388                                           !BCC_EOS
29389                                           ! 4915         }
29390                                           ! 4916       }
29391                       00007FEF            .6ED:
29392                                           ! 4917       *(((Bit8u *)&AX)+1) = (0);
29393                       00007FEF            .6E9:
29394                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29395 7FEF           30C0                       xor	al,al
29396 7FF1           8846         17            mov	$17[bp],al
29397                                           !BCC_EOS
29398                                           ! 4918       set_diskette_ret_status(0);
29399                                           ! Debug: list int = const 0 (used reg = )
29400 7FF4           31C0                       xor	ax,ax
29401 7FF6           50                         push	ax
29402                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29403 7FF7           E8         0644            call	_set_diskette_ret_status
29404 7FFA           44                         inc	sp
29405 7FFB           44                         inc	sp
29406                                           !BCC_EOS
29407                                           ! 4919       set_diskette_current_cyl(drive, 0);
29408                                           ! Debug: list int = const 0 (used reg = )
29409 7FFC           31C0                       xor	ax,ax
29410 7FFE           50                         push	ax
29411                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
29412 7FFF           8A46         FF            mov	al,-1[bp]
29413 8002           30E4                       xor	ah,ah
29414 8004           50                         push	ax
29415                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
29416 8005           E8         064E            call	_set_diskette_current_cyl
29417 8008           83C4                   04  add	sp,*4
29418                                           !BCC_EOS
29419                                           ! 4920       FLAGS &= 0xfffe;
29420                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29421 800B           8B46         1C            mov	ax,$1C[bp]
29422 800E           24                     FE  and	al,#$FE
29423 8010           8946         1C            mov	$1C[bp],ax
29424                                           !BCC_EOS
29425                                           ! 4921       return;
29426 8013           89EC                       mov	sp,bp
29427 8015           5D                         pop	bp
29428 8016           C3                         ret
29429                                           !BCC_EOS
29430                                           ! 4922     case 0x08:
29431                                           ! 4923 ;
29432                       00008017            .6EF:
29433                                           !BCC_EOS
29434                                           ! 4924       drive = ( ELDX & 0x00ff );
29435                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29436 8017           8A46         0E            mov	al,$E[bp]
29437                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29438 801A           8846         FF            mov	-1[bp],al
29439                                           !BCC_EOS
29440                                           ! 4925       if (drive > 1) {
29441                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29442 801D           8A46         FF            mov	al,-1[bp]
29443 8020           3C                     01  cmp	al,*1
29444 8022           76           30            jbe 	.6F0
29445                       00008024            .6F1:
29446                                           ! 4925 
29447                                           ! 4926         AX = 0;
29448                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$24+$14] (used reg = )
29449 8024           31C0                       xor	ax,ax
29450 8026           8946         16            mov	$16[bp],ax
29451                                           !BCC_EOS
29452                                           ! 4927         BX = 0;
29453                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$24+$E] (used reg = )
29454 8029           31C0                       xor	ax,ax
29455 802B           8946         10            mov	$10[bp],ax
29456                                           !BCC_EOS
29457                                           ! 4928         CX = 0;
29458                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29459 802E           31C0                       xor	ax,ax
29460 8030           8946         14            mov	$14[bp],ax
29461                                           !BCC_EOS
29462                                           ! 4929         DX = 0;
29463                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$24+$10] (used reg = )
29464 8033           31C0                       xor	ax,ax
29465 8035           8946         12            mov	$12[bp],ax
29466                                           !BCC_EOS
29467                                           ! 4930         ES = 0;
29468                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$24+4] (used reg = )
29469 8038           31C0                       xor	ax,ax
29470 803A           8946         06            mov	6[bp],ax
29471                                           !BCC_EOS
29472                                           ! 4931         DI = 0;
29473                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$24+6] (used reg = )
29474 803D           31C0                       xor	ax,ax
29475 803F           8946         08            mov	8[bp],ax
29476                                           !BCC_EOS
29477                                           ! 4932         *((Bit8u *)&DX) = (num_floppies);
29478                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29479 8042           8A46         E7            mov	al,-$19[bp]
29480 8045           8846         12            mov	$12[bp],al
29481                                           !BCC_EOS
29482                                           ! 4933         FLAGS |= 0x0001;
29483                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29484 8048           8B46         1C            mov	ax,$1C[bp]
29485 804B           0C                     01  or	al,*1
29486 804D           8946         1C            mov	$1C[bp],ax
29487                                           !BCC_EOS
29488                                           ! 4934         return;
29489 8050           89EC                       mov	sp,bp
29490 8052           5D                         pop	bp
29491 8053           C3                         ret
29492                                           !BCC_EOS
29493                                           ! 4935       }
29494                                           ! 4936       drive_type = inb_cmos(0x10);
29495                       00008054            .6F0:
29496                                           ! Debug: list int = const $10 (used reg = )
29497 8054           B8                   0010  mov	ax,*$10
29498 8057           50                         push	ax
29499                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29500 8058           E8         8513            call	_inb_cmos
29501 805B           44                         inc	sp
29502 805C           44                         inc	sp
29503                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29504 805D           8846         E8            mov	-$18[bp],al
29505                                           !BCC_EOS
29506                                           ! 4937       num_floppies = 0;
29507                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$24-$1B] (used reg = )
29508 8060           30C0                       xor	al,al
29509 8062           8846         E7            mov	-$19[bp],al
29510                                           !BCC_EOS
29511                                           ! 4938       if (drive_type & 0xf0)
29512                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29513 8065           8A46         E8            mov	al,-$18[bp]
29514 8068           24                     F0  and	al,#$F0
29515 806A           84C0                       test	al,al
29516 806C           74           07            je  	.6F2
29517                       0000806E            .6F3:
29518                                           ! 4939         num_floppies++;
29519                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29520 806E           8A46         E7            mov	al,-$19[bp]
29521 8071           40                         inc	ax
29522 8072           8846         E7            mov	-$19[bp],al
29523                                           !BCC_EOS
29524                                           ! 4940       if (drive_type & 0x0f)
29525                       00008075            .6F2:
29526                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29527 8075           8A46         E8            mov	al,-$18[bp]
29528 8078           24                     0F  and	al,*$F
29529 807A           84C0                       test	al,al
29530 807C           74           07            je  	.6F4
29531                       0000807E            .6F5:
29532                                           ! 4941         num_floppies++;
29533                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29534 807E           8A46         E7            mov	al,-$19[bp]
29535 8081           40                         inc	ax
29536 8082           8846         E7            mov	-$19[bp],al
29537                                           !BCC_EOS
29538                                           ! 4942       if (drive == 0)
29539                       00008085            .6F4:
29540                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29541 8085           8A46         FF            mov	al,-1[bp]
29542 8088           84C0                       test	al,al
29543 808A           75           0E            jne 	.6F6
29544                       0000808C            .6F7:
29545                                           ! 4943         drive_type >>= 4;
29546                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29547 808C           8A46         E8            mov	al,-$18[bp]
29548 808F           30E4                       xor	ah,ah
29549 8091           B1                     04  mov	cl,*4
29550 8093           D3E8                       shr	ax,cl
29551 8095           8846         E8            mov	-$18[bp],al
29552                                           !BCC_EOS
29553                                           ! 4944       else
29554                                           ! 4945         drive_type &= 0x0f;
29555 8098           EB           08            jmp .6F8
29556                       0000809A            .6F6:
29557                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29558 809A           8A46         E8            mov	al,-$18[bp]
29559 809D           24                     0F  and	al,*$F
29560 809F           8846         E8            mov	-$18[bp],al
29561                                           !BCC_EOS
29562                                           ! 4946       *(((Bit8u *)&BX)+1) = (0);
29563                       000080A2            .6F8:
29564                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$24+$F] (used reg = )
29565 80A2           30C0                       xor	al,al
29566 80A4           8846         11            mov	$11[bp],al
29567                                           !BCC_EOS
29568                                           ! 4947       *((Bit8u *)&BX) = (drive_type);
29569                                           ! Debug: eq unsigned char drive_type = [S+$24-$1A] to unsigned char BX = [S+$24+$E] (used reg = )
29570 80A7           8A46         E8            mov	al,-$18[bp]
29571 80AA           8846         10            mov	$10[bp],al
29572                                           !BCC_EOS
29573                                           ! 4948       *(((Bit8u *)&AX)+1) = (0);
29574                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29575 80AD           30C0                       xor	al,al
29576 80AF           8846         17            mov	$17[bp],al
29577                                           !BCC_EOS
29578                                           ! 4949       *((Bit8u *)&AX) = (0);
29579                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
29580 80B2           30C0                       xor	al,al
29581 80B4           8846         16            mov	$16[bp],al
29582                                           !BCC_EOS
29583                                           ! 4950       *((Bit8u *)&DX) = (num_floppies);
29584                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29585 80B7           8A46         E7            mov	al,-$19[bp]
29586 80BA           8846         12            mov	$12[bp],al
29587                                           !BCC_EOS
29588                                           ! 4951       switch (drive_type) {
29589 80BD           8A46         E8            mov	al,-$18[bp]
29590 80C0           E9         0087            br 	.6FB
29591                                           ! 4952         case 0:
29592                                           ! 4953           CX = 0;
29593                       000080C3            .6FC:
29594                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29595 80C3           31C0                       xor	ax,ax
29596 80C5           8946         14            mov	$14[bp],ax
29597                                           !BCC_EOS
29598                                           ! 4954           *(((Bit8u *)&DX)+1) = (0);
29599                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29600 80C8           30C0                       xor	al,al
29601 80CA           8846         13            mov	$13[bp],al
29602                                           !BCC_EOS
29603                                           ! 4955           break;
29604 80CD           E9         00A1            br 	.6F9
29605                                           !BCC_EOS
29606                                           ! 4956         case 1:
29607                                           ! 4957           CX = 0x2709;
29608                       000080D0            .6FD:
29609                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29610 80D0           B8                   2709  mov	ax,#$2709
29611 80D3           8946         14            mov	$14[bp],ax
29612                                           !BCC_EOS
29613                                           ! 4958           *(((Bit8u *)&DX)+1) = (1);
29614                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29615 80D6           B0                     01  mov	al,*1
29616 80D8           8846         13            mov	$13[bp],al
29617                                           !BCC_EOS
29618                                           ! 4959           break;
29619 80DB           E9         0093            br 	.6F9
29620                                           !BCC_EOS
29621                                           ! 4960         case 2:
29622                                           ! 4961           CX = 0x4f0f;
29623                       000080DE            .6FE:
29624                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$24+$12] (used reg = )
29625 80DE           B8                   4F0F  mov	ax,#$4F0F
29626 80E1           8946         14            mov	$14[bp],ax
29627                                           !BCC_EOS
29628                                           ! 4962           *(((Bit8u *)&DX)+1) = (1);
29629                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29630 80E4           B0                     01  mov	al,*1
29631 80E6           8846         13            mov	$13[bp],al
29632                                           !BCC_EOS
29633                                           ! 4963           break;
29634 80E9           E9         0085            br 	.6F9
29635                                           !BCC_EOS
29636                                           ! 4964         case 3:
29637                                           ! 4965           CX = 0x4f09;
29638                       000080EC            .6FF:
29639                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$24+$12] (used reg = )
29640 80EC           B8                   4F09  mov	ax,#$4F09
29641 80EF           8946         14            mov	$14[bp],ax
29642                                           !BCC_EOS
29643                                           ! 4966           *(((Bit8u *)&DX)+1) = (1);
29644                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29645 80F2           B0                     01  mov	al,*1
29646 80F4           8846         13            mov	$13[bp],al
29647                                           !BCC_EOS
29648                                           ! 4967           break;
29649 80F7           EB           78            jmp .6F9
29650                                           !BCC_EOS
29651                                           ! 4968         case 4:
29652                                           ! 4969           CX = 0x4f12;
29653                       000080F9            .700:
29654                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$24+$12] (used reg = )
29655 80F9           B8                   4F12  mov	ax,#$4F12
29656 80FC           8946         14            mov	$14[bp],ax
29657                                           !BCC_EOS
29658                                           ! 4970           *(((Bit8u *)&DX)+1) = (1);
29659                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29660 80FF           B0                     01  mov	al,*1
29661 8101           8846         13            mov	$13[bp],al
29662                                           !BCC_EOS
29663                                           ! 4971           break;
29664 8104           EB           6B            jmp .6F9
29665                                           !BCC_EOS
29666                                           ! 4972         case 5:
29667                                           ! 4973           CX = 0x4f24;
29668                       00008106            .701:
29669                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$24+$12] (used reg = )
29670 8106           B8                   4F24  mov	ax,#$4F24
29671 8109           8946         14            mov	$14[bp],ax
29672                                           !BCC_EOS
29673                                           ! 4974           *(((Bit8u *)&DX)+1) = (1);
29674                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29675 810C           B0                     01  mov	al,*1
29676 810E           8846         13            mov	$13[bp],al
29677                                           !BCC_EOS
29678                                           ! 4975           break;
29679 8111           EB           5E            jmp .6F9
29680                                           !BCC_EOS
29681                                           ! 4976         case 6:
29682                                           ! 4977           CX = 0x2708;
29683                       00008113            .702:
29684                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29685 8113           B8                   2708  mov	ax,#$2708
29686 8116           8946         14            mov	$14[bp],ax
29687                                           !BCC_EOS
29688                                           ! 4978           *(((Bit8u *)&DX)+1) = (0);
29689                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29690 8119           30C0                       xor	al,al
29691 811B           8846         13            mov	$13[bp],al
29692                                           !BCC_EOS
29693                                           ! 4979           break;
29694 811E           EB           51            jmp .6F9
29695                                           !BCC_EOS
29696                                           ! 4980         case 7:
29697                                           ! 4981           CX = 0x2709;
29698                       00008120            .703:
29699                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29700 8120           B8                   2709  mov	ax,#$2709
29701 8123           8946         14            mov	$14[bp],ax
29702                                           !BCC_EOS
29703                                           ! 4982           *(((Bit8u *)&DX)+1) = (0);
29704                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29705 8126           30C0                       xor	al,al
29706 8128           8846         13            mov	$13[bp],al
29707                                           !BCC_EOS
29708                                           ! 4983           break;
29709 812B           EB           44            jmp .6F9
29710                                           !BCC_EOS
29711                                           ! 4984         case 8:
29712                                           ! 4985           CX = 0x2708;
29713                       0000812D            .704:
29714                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29715 812D           B8                   2708  mov	ax,#$2708
29716 8130           8946         14            mov	$14[bp],ax
29717                                           !BCC_EOS
29718                                           ! 4986           *(((Bit8u *)&DX)+1) = (1);
29719                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29720 8133           B0                     01  mov	al,*1
29721 8135           8846         13            mov	$13[bp],al
29722                                           !BCC_EOS
29723                                           ! 4987           break;
29724 8138           EB           37            jmp .6F9
29725                                           !BCC_EOS
29726                                           ! 4988         default:
29727                                           ! 4989           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
29728                       0000813A            .705:
29729                                           ! Debug: list * char = .706+0 (used reg = )
29730 813A           BB                   CD72  mov	bx,#.706
29731 813D           53                         push	bx
29732                                           ! Debug: list int = const 7 (used reg = )
29733 813E           B8                   0007  mov	ax,*7
29734 8141           50                         push	ax
29735                                           ! Debug: func () void = bios_printf+0 (used reg = )
29736 8142           E8         87F4            call	_bios_printf
29737 8145           83C4                   04  add	sp,*4
29738                                           !BCC_EOS
29739                                           ! 4990         }
29740                                           ! 4991 #asm
29741 8148           EB           27            jmp .6F9
29742                       0000814A            .6FB:
29743 814A           2C                     00  sub	al,*0
29744 814C           72           EC            jb 	.705
29745 814E           3C                     08  cmp	al,*8
29746 8150           77           1D            ja  	.707
29747 8152           30E4                       xor	ah,ah
29748 8154           D1E0                       shl	ax,*1
29749 8156           89C3                       mov	bx,ax
29750 8158           2E                         seg	cs
29751 8159           FFA7       815D            br	.708[bx]
29752                       0000815D            .708:
29753 815D                      80C3            .word	.6FC
29754 815F                      80D0            .word	.6FD
29755 8161                      80DE            .word	.6FE
29756 8163                      80EC            .word	.6FF
29757 8165                      80F9            .word	.700
29758 8167                      8106            .word	.701
29759 8169                      8113            .word	.702
29760 816B                      8120            .word	.703
29761 816D                      812D            .word	.704
29762                       0000816F            .707:
29763 816F           EB           C9            jmp	.705
29764                       00008171            .6F9:
29765                                           !BCC_EOS
29766                                           !BCC_ASM
29767                       0000002E            _int13_diskette_function.BP	set	$2E
29768                       0000000C            .int13_diskette_function.BP	set	$C
29769                       0000003C            _int13_diskette_function.CS	set	$3C
29770                       0000001A            .int13_diskette_function.CS	set	$1A
29771                       00000036            _int13_diskette_function.CX	set	$36
29772                       00000014            .int13_diskette_function.CX	set	$14
29773                       0000001A            _int13_diskette_function.base_address	set	$1A
29774                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29775                       0000002A            _int13_diskette_function.DI	set	$2A
29776                       00000008            .int13_diskette_function.DI	set	8
29777                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29778                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29779                       00000018            _int13_diskette_function.base_count	set	$18
29780                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29781                       0000001E            _int13_diskette_function.sector	set	$1E
29782                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29783                       00000026            _int13_diskette_function.DS	set	$26
29784                       00000004            .int13_diskette_function.DS	set	4
29785                       0000001D            _int13_diskette_function.head	set	$1D
29786                       FFFFFFFB            .int13_diskette_function.head	set	-5
29787                       00000030            _int13_diskette_function.ELDX	set	$30
29788                       0000000E            .int13_diskette_function.ELDX	set	$E
29789                       00000012            _int13_diskette_function.dor	set	$12
29790                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29791                       00000034            _int13_diskette_function.DX	set	$34
29792                       00000012            .int13_diskette_function.DX	set	$12
29793                       0000000B            _int13_diskette_function.return_status	set	$B
29794                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29795                       00000004            _int13_diskette_function.es	set	4
29796                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29797                       00000014            _int13_diskette_function.mode_register	set	$14
29798                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29799                       00000028            _int13_diskette_function.ES	set	$28
29800                       00000006            .int13_diskette_function.ES	set	6
29801                       00000016            _int13_diskette_function.base_es	set	$16
29802                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29803                       0000001F            _int13_diskette_function.track	set	$1F
29804                       FFFFFFFD            .int13_diskette_function.track	set	-3
29805                       0000002C            _int13_diskette_function.SI	set	$2C
29806                       0000000A            .int13_diskette_function.SI	set	$A
29807                       0000000A            _int13_diskette_function.drive_type	set	$A
29808                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29809                       00000020            _int13_diskette_function.num_sectors	set	$20
29810                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29811                       0000003A            _int13_diskette_function.IP	set	$3A
29812                       00000018            .int13_diskette_function.IP	set	$18
29813                       00000007            _int13_diskette_function.spt	set	7
29814                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29815                       0000001C            _int13_diskette_function.status	set	$1C
29816                       FFFFFFFA            .int13_diskette_function.status	set	-6
29817                       00000000            _int13_diskette_function.maxCyl	set	0
29818                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29819                       00000038            _int13_diskette_function.AX	set	$38
29820                       00000016            .int13_diskette_function.AX	set	$16
29821                       00000013            _int13_diskette_function.val8	set	$13
29822                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29823                       00000002            _int13_diskette_function.last_addr	set	2
29824                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29825                       00000015            _int13_diskette_function.page	set	$15
29826                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29827                       00000008            _int13_diskette_function.ah	set	8
29828                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29829                       00000021            _int13_diskette_function.drive	set	$21
29830                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29831                       00000009            _int13_diskette_function.num_floppies	set	9
29832                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29833                       00000032            _int13_diskette_function.BX	set	$32
29834                       00000010            .int13_diskette_function.BX	set	$10
29835 8171           55                               push bp
29836 8172           89E5                             mov bp, sp
29837 8174           B8                   EFDE        mov ax, #diskette_param_table2
29838 8177           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
29839 817A           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
29840 817D           5D                               pop bp
29841                                           ! 4998 endasm
29842                                           !BCC_ENDASM
29843                                           !BCC_EOS
29844                                           ! 4999       FLAGS &= 0xfffe;
29845                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29846 817E           8B46         1C            mov	ax,$1C[bp]
29847 8181           24                     FE  and	al,#$FE
29848 8183           8946         1C            mov	$1C[bp],ax
29849                                           !BCC_EOS
29850                                           ! 5000       return;
29851 8186           89EC                       mov	sp,bp
29852 8188           5D                         pop	bp
29853 8189           C3                         ret
29854                                           !BCC_EOS
29855                                           ! 5001     case 0x15:
29856                                           ! 5002 ;
29857                       0000818A            .709:
29858                                           !BCC_EOS
29859                                           ! 5003       drive = ( ELDX & 0x00ff );
29860                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29861 818A           8A46         0E            mov	al,$E[bp]
29862                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29863 818D           8846         FF            mov	-1[bp],al
29864                                           !BCC_EOS
29865                                           ! 5004       if (drive > 1) {
29866                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29867 8190           8A46         FF            mov	al,-1[bp]
29868 8193           3C                     01  cmp	al,*1
29869 8195           76           11            jbe 	.70A
29870                       00008197            .70B:
29871                                           ! 5005         *(((Bit8u *)&AX)+1) = (0);
29872                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29873 8197           30C0                       xor	al,al
29874 8199           8846         17            mov	$17[bp],al
29875                                           !BCC_EOS
29876                                           ! 5006         FLAGS |= 0x0001;
29877                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29878 819C           8B46         1C            mov	ax,$1C[bp]
29879 819F           0C                     01  or	al,*1
29880 81A1           8946         1C            mov	$1C[bp],ax
29881                                           !BCC_EOS
29882                                           ! 5007         return;
29883 81A4           89EC                       mov	sp,bp
29884 81A6           5D                         pop	bp
29885 81A7           C3                         ret
29886                                           !BCC_EOS
29887                                           ! 5008       }
29888                                           ! 5009       drive_type = inb_cmos(0x10);
29889                       000081A8            .70A:
29890                                           ! Debug: list int = const $10 (used reg = )
29891 81A8           B8                   0010  mov	ax,*$10
29892 81AB           50                         push	ax
29893                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29894 81AC           E8         83BF            call	_inb_cmos
29895 81AF           44                         inc	sp
29896 81B0           44                         inc	sp
29897                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29898 81B1           8846         E8            mov	-$18[bp],al
29899                                           !BCC_EOS
29900                                           ! 5010       if (drive == 0)
29901                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29902 81B4           8A46         FF            mov	al,-1[bp]
29903 81B7           84C0                       test	al,al
29904 81B9           75           0E            jne 	.70C
29905                       000081BB            .70D:
29906                                           ! 5011         drive_type >>= 4;
29907                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29908 81BB           8A46         E8            mov	al,-$18[bp]
29909 81BE           30E4                       xor	ah,ah
29910 81C0           B1                     04  mov	cl,*4
29911 81C2           D3E8                       shr	ax,cl
29912 81C4           8846         E8            mov	-$18[bp],al
29913                                           !BCC_EOS
29914                                           ! 5012       els
29915                                           ! 5012 e
29916                                           ! 5013         drive_type &= 0x0f;
29917 81C7           EB           08            jmp .70E
29918                       000081C9            .70C:
29919                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29920 81C9           8A46         E8            mov	al,-$18[bp]
29921 81CC           24                     0F  and	al,*$F
29922 81CE           8846         E8            mov	-$18[bp],al
29923                                           !BCC_EOS
29924                                           ! 5014       FLAGS &= 0xfffe;
29925                       000081D1            .70E:
29926                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29927 81D1           8B46         1C            mov	ax,$1C[bp]
29928 81D4           24                     FE  and	al,#$FE
29929 81D6           8946         1C            mov	$1C[bp],ax
29930                                           !BCC_EOS
29931                                           ! 5015       if (drive_type==0) {
29932                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29933 81D9           8A46         E8            mov	al,-$18[bp]
29934 81DC           84C0                       test	al,al
29935 81DE           75           07            jne 	.70F
29936                       000081E0            .710:
29937                                           ! 5016         *(((Bit8u *)&AX)+1) = (0);
29938                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29939 81E0           30C0                       xor	al,al
29940 81E2           8846         17            mov	$17[bp],al
29941                                           !BCC_EOS
29942                                           ! 5017       }
29943                                           ! 5018       else {
29944 81E5           EB           05            jmp .711
29945                       000081E7            .70F:
29946                                           ! 5019         *(((Bit8u *)&AX)+1) = (1);
29947                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
29948 81E7           B0                     01  mov	al,*1
29949 81E9           8846         17            mov	$17[bp],al
29950                                           !BCC_EOS
29951                                           ! 5020       }
29952                                           ! 5021       return;
29953                       000081EC            .711:
29954 81EC           89EC                       mov	sp,bp
29955 81EE           5D                         pop	bp
29956 81EF           C3                         ret
29957                                           !BCC_EOS
29958                                           ! 5022     case 0x16:
29959                                           ! 5023 ;
29960                       000081F0            .712:
29961                                           !BCC_EOS
29962                                           ! 5024       drive = ( ELDX & 0x00ff );
29963                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29964 81F0           8A46         0E            mov	al,$E[bp]
29965                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29966 81F3           8846         FF            mov	-1[bp],al
29967                                           !BCC_EOS
29968                                           ! 5025       if (drive > 1) {
29969                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29970 81F6           8A46         FF            mov	al,-1[bp]
29971 81F9           3C                     01  cmp	al,*1
29972 81FB           76           1A            jbe 	.713
29973                       000081FD            .714:
29974                                           ! 5026         *(((Bit8u *)&AX)+1) = (0x01);
29975                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
29976 81FD           B0                     01  mov	al,*1
29977 81FF           8846         17            mov	$17[bp],al
29978                                           !BCC_EOS
29979                                           ! 5027         set_diskette_ret_status(0x01);
29980                                           ! Debug: list int = const 1 (used reg = )
29981 8202           B8                   0001  mov	ax,*1
29982 8205           50                         push	ax
29983                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29984 8206           E8         0435            call	_set_diskette_ret_status
29985 8209           44                         inc	sp
29986 820A           44                         inc	sp
29987                                           !BCC_EOS
29988                                           ! 5028         FLAGS |= 0x0001;
29989                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29990 820B           8B46         1C            mov	ax,$1C[bp]
29991 820E           0C                     01  or	al,*1
29992 8210           8946         1C            mov	$1C[bp],ax
29993                                           !BCC_EOS
29994                                           ! 5029         return;
29995 8213           89EC                       mov	sp,bp
29996 8215           5D                         pop	bp
29997 8216           C3                         ret
29998                                           !BCC_EOS
29999                                           ! 5030       }
30000                                           ! 5031       *(((Bit8u *)&AX)+1) = (0x06);
30001                       00008217            .713:
30002                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$24+$15] (used reg = )
30003 8217           B0                     06  mov	al,*6
30004 8219           8846         17            mov	$17[bp],al
30005                                           !BCC_EOS
30006                                           ! 5032       set_diskette_ret_status(0x06);
30007                                           ! Debug: list int = const 6 (used reg = )
30008 821C           B8                   0006  mov	ax,*6
30009 821F           50                         push	ax
30010                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30011 8220           E8         041B            call	_set_diskette_ret_status
30012 8223           44                         inc	sp
30013 8224           44                         inc	sp
30014                                           !BCC_EOS
30015                                           ! 5033       FLAGS |= 0x0001;
30016                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30017 8225           8B46         1C            mov	ax,$1C[bp]
30018 8228           0C                     01  or	al,*1
30019 822A           8946         1C            mov	$1C[bp],ax
30020                                           !BCC_EOS
30021                                           ! 5034       return;
30022 822D           89EC                       mov	sp,bp
30023 822F           5D                         pop	bp
30024 8230           C3                         ret
30025                                           !BCC_EOS
30026                                           ! 5035     case 0x17:
30027                                           ! 5036 ;
30028                       00008231            .715:
30029                                           !BCC_EOS
30030                                           ! 5037       drive = ( ELDX & 0x00ff );
30031                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30032 8231           8A46         0E            mov	al,$E[bp]
30033                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30034 8234           8846         FF            mov	-1[bp],al
30035                                           !BCC_EOS
30036                                           ! 5038       drive_type = ( AX & 0x00ff );
30037                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
30038 8237           8A46         16            mov	al,$16[bp]
30039                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30040 823A           8846         E8            mov	-$18[bp],al
30041                                           !BCC_EOS
30042                                           ! 5039       if (drive > 1) {
30043                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30044 823D           8A46         FF            mov	al,-1[bp]
30045 8240           3C                     01  cmp	al,*1
30046 8242           76           1A            jbe 	.716
30047                       00008244            .717:
30048                                           ! 5040         *(((Bit8u *)&AX)+1) = (0x01);
30049                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30050 8244           B0                     01  mov	al,*1
30051 8246           8846         17            mov	$17[bp],al
30052                                           !BCC_EOS
30053                                           ! 5041         set_diskette_ret_status(1);
30054                                           ! Debug: list int = const 1 (used reg = )
30055 8249           B8                   0001  mov	ax,*1
30056 824C           50                         push	ax
30057                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30058 824D           E8         03EE            call	_set_diskette_ret_status
30059 8250           44                         inc	sp
30060 8251           44                         inc	sp
30061                                           !BCC_EOS
30062                                           ! 5042         FLAGS |= 0x0001;
30063                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30064 8252           8B46         1C            mov	ax,$1C[bp]
30065 8255           0C                     01  or	al,*1
30066 8257           8946         1C            mov	$1C[bp],ax
30067                                           !BCC_EOS
30068                                           ! 5043         return;
30069 825A           89EC                       mov	sp,bp
30070 825C           5D                         pop	bp
30071 825D           C3                         ret
30072                                           !BCC_EOS
30073                                           ! 5044       }
30074                                           ! 5045       if (floppy_drive_exists(drive) == 0) {
30075                       0000825E            .716:
30076                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30077 825E           8A46         FF            mov	al,-1[bp]
30078 8261           30E4                       xor	ah,ah
30079 8263           50                         push	ax
30080                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30081 8264           E8         F4DF            call	_floppy_drive_exists
30082 8267           44                         inc	sp
30083 8268           44                         inc	sp
30084                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30085 8269           85C0                       test	ax,ax
30086 826B           75           1A            jne 	.718
30087                       0000826D            .719:
30088                                           ! 5046         *(((Bit8u *)&AX)+1) = (0x80);
30089                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30090 826D           B0                     80  mov	al,#$80
30091 826F           8846         17            mov	$17[bp],al
30092                                           !BCC_EOS
30093                                           ! 5047         set_diskette_ret_status(0x80);
30094                                           ! Debug: list int = const $80 (used reg = )
30095 8272           B8                   0080  mov	ax,#$80
30096 8275           50                         push	ax
30097                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30098 8276           E8         03C5            call	_set_diskette_ret_status
30099 8279           44                         inc	sp
30100 827A           44                         inc	sp
30101                                           !BCC_EOS
30102                                           ! 5048         FLAGS |= 0x0001;
30103                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30104 827B           8B46         1C            mov	ax,$1C[bp]
30105 827E           0C                     01  or	al,*1
30106 8280           8946         1C            mov	$1C[bp],ax
30107                                           !BCC_EOS
30108                                           ! 5049         return;
30109 8283           89EC                       mov	sp,bp
30110 8285           5D                         pop	bp
30111 8286           C3                         ret
30112                                           !BCC_EOS
30113                                           ! 5050       }
30114                                           ! 5051       base_address = (drive) ? 0x0091 : 0x0090;
30115                       00008287            .718:
30116 8287           8A46         FF            mov	al,-1[bp]
30117 828A           84C0                       test	al,al
30118 828C           74           04            je  	.71A
30119                       0000828E            .71B:
30120 828E           B0                     91  mov	al,#$91
30121 8290           EB           02            jmp .71C
30122                       00008292            .71A:
30123 8292           B0                     90  mov	al,#$90
30124                       00008294            .71C:
30125                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30126 8294           30E4                       xor	ah,ah
30127 8296           8946         F8            mov	-8[bp],ax
30128                                           !BCC_EOS
30129                                           ! 5052       status = *((Bit8u *)(base_address));
30130 8299           8B5E         F8            mov	bx,-8[bp]
30131                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30132 829C           8A07                       mov	al,[bx]
30133 829E           8846         FA            mov	-6[bp],al
30134                                           !BCC_EOS
30135                                           ! 5053       val8 = status & 0x0f;
30136                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30137 82A1           8A46         FA            mov	al,-6[bp]
30138 82A4           24                     0F  and	al,*$F
30139                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30140 82A6           8846         F1            mov	-$F[bp],al
30141                                           !BCC_EOS
30142                                           ! 5054       switch(drive_type) {
30143 82A9           8A46         E8            mov	al,-$18[bp]
30144 82AC           EB           6A            jmp .71F
30145                                           ! 5055         case 1:
30146                                           ! 5056           val8 |= 0x90;
30147                       000082AE            .720:
30148                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30149 82AE           8A46         F1            mov	al,-$F[bp]
30150 82B1           0C                     90  or	al,#$90
30151 82B3           8846         F1            mov	-$F[bp],al
30152                                           !BCC_EOS
30153                                           ! 5057           break;
30154 82B6           EB           72            jmp .71D
30155                                           !BCC_EOS
30156                                           ! 5058         case 2:
30157                                           ! 5059           val8 |= 0x70;
30158                       000082B8            .721:
30159                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30160 82B8           8A46         F1            mov	al,-$F[bp]
30161 82BB           0C                     70  or	al,*$70
30162 82BD           8846         F1            mov	-$F[bp],al
30163                                           !BCC_EOS
30164                                           ! 5060           break;
30165 82C0           EB           68            jmp .71D
30166                                           !BCC_EOS
30167                                           ! 5061         case 3:
30168                                           ! 5062           val8 |= 0x10;
30169                       000082C2            .722:
30170                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30171 82C2           8A46         F1            mov	al,-$F[bp]
30172 82C5           0C                     10  or	al,*$10
30173 82C7           8846         F1            mov	-$F[bp],al
30174                                           !BCC_EOS
30175                                           ! 5063           break;
30176 82CA           EB           5E            jmp .71D
30177                                           !BCC_EOS
30178                                           ! 5064         case 4:
30179                                           ! 5065           if (((status >> 4) & 0x01) && ((status >> 1) & 0x01))
30180                       000082CC            .723:
30181                                           ! Debug: sr int = const 4 to unsigned char status = [S+$24-8] (used reg = )
30182 82CC           8A46         FA            mov	al,-6[bp]
30183 82CF           30E4                       xor	ah,ah
30184 82D1           B1                     04  mov	cl,*4
30185 82D3           D3E8                       shr	ax,cl
30186                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30187 82D5           24                     01  and	al,*1
30188 82D7           84C0                       test	al,al
30189 82D9           74           17            je  	.724
30190                       000082DB            .726:
30191                                           ! Debug: sr int = const 1 to unsigned char status = [S+$24-8] (used reg = )
30192 82DB           8A46         FA            mov	al,-6[bp]
30193 82DE           30E4                       xor	ah,ah
30194 82E0           D1E8                       shr	ax,*1
30195                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30196 82E2           24                     01  and	al,*1
30197 82E4           84C0                       test	al,al
30198 82E6           74           0A            je  	.724
30199                       000082E8            .725:
30200                                           ! 5066           {
30201                                           ! 5067             val8 |= 0x50;
30202                                           ! Debug: orab int = const $50 to unsigned char val8 = [S+$24-$11] (used reg = )
30203 82E8           8A46         F1            mov	al,-$F[bp]
30204 82EB           0C                     50  or	al,*$50
30205 82ED           8846         F1            mov	-$F[bp],al
30206                                           !BCC_EOS
30207                                           ! 5068           }
30208                                           ! 5069           else
30209                                           ! 5070           {
30210 82F0           EB           08            jmp .727
30211                       000082F2            .724:
30212                                           ! 5071             val8 |= 0x90;
30213                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30214 82F2           8A46         F1            mov	al,-$F[bp]
30215 82F5           0C                     90  or	al,#$90
30216 82F7           8846         F1            mov	-$F[bp],al
30217                                           !BCC_EOS
30218                                           ! 5072           }
30219                                           ! 5073           break;
30220                       000082FA            .727:
30221 82FA           EB           2E            jmp .71D
30222                                           !BCC_EOS
30223                                           ! 5074         default:
30224                                           ! 5075           *(((Bit8u *)&AX)+1) = (0x01);
30225                       000082FC            .728:
30226                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30227 82FC           B0                     01  mov	al,*1
30228 82FE           8846         17            mov	$17[bp],al
30229                                           !BCC_EOS
30230                                           ! 5076           set_diskette_ret_status(1);
30231                                           ! Debug: list int = const 1 (used reg = )
30232 8301           B8                   0001  mov	ax,*1
30233 8304           50                         push	ax
30234                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30235 8305           E8         0336            call	_set_diskette_ret_status
30236 8308           44                         inc	sp
30237 8309           44                         inc	sp
30238                                           !BCC_EOS
30239                                           ! 5077           FLAGS |= 0x0001;
30240                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30241 830A           8B46         1C            mov	ax,$1C[bp]
30242 830D           0C                     01  or	al,*1
30243 830F           8946         1C            mov	$1C[bp],ax
30244                                           !BCC_EOS
30245                                           ! 5078           return;
30246 8312           89EC                       mov	sp,bp
30247 8314           5D                         pop	bp
30248 8315           C3                         ret
30249                                           !BCC_EOS
30250                                           ! 5079       }
30251                                           ! 5080 ;
30252 8316           EB           12            jmp .71D
30253                       00008318            .71F:
30254 8318           2C                     01  sub	al,*1
30255 831A           74           92            je 	.720
30256 831C           2C                     01  sub	al,*1
30257 831E           74           98            je 	.721
30258 8320           2C                     01  sub	al,*1
30259 8322           74           9E            je 	.722
30260 8324           2C                     01  sub	al,*1
30261 8326           74           A4            je 	.723
30262 8328           EB           D2            jmp	.728
30263                       0000832A            .71D:
30264                                           !BCC_EOS
30265                                           ! 5081       *((Bit8u *)(base_address)) = (val8);
30266 832A           8B5E         F8            mov	bx,-8[bp]
30267                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30268 832D           8A46         F1            mov	al,-$F[bp]
30269 8330           8807                       mov	[bx],al
30270                                           !BCC_EOS
30271                                           ! 5082       *(((Bit8u *)&AX)+1) = (0);
30272                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30273 8332           30C0                       xor	al,al
30274 8334           8846         17            mov	$17[bp],al
30275                                           !BCC_EOS
30276                                           ! 5083       set_diskette_ret_status(0);
30277                                           ! Debug: list int = const 0 (used reg = )
30278 8337           31C0                       xor	ax,ax
30279 8339           50                         push	ax
30280                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30281 833A           E8         0301            call	_set_diskette_ret_status
30282 833D           44                         inc	sp
30283 833E           44                         inc	sp
30284                                           !BCC_EOS
30285                                           ! 5084       FLAGS &= 0xfffe;
30286                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30287 833F           8B46         1C            mov	ax,$1C[bp]
30288 8342           24                     FE  and	al,#$FE
30289 8344           8946         1C            mov	$1C[bp],ax
30290                                           !BCC_EOS
30291                                           ! 5085       return;
30292 8347           89EC                       mov	sp,bp
30293 8349           5D                         pop	bp
30294 834A           C3                         ret
30295                                           !BCC_EOS
30296                                           ! 5086     case 0x18:
30297                                           ! 5087 ;
30298                       0000834B            .729:
30299                                           !BCC_EOS
30300                                           ! 5088       drive = ( ELDX & 0x00ff );
30301                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30302 834B           8A46         0E            mov	al,$E[bp]
30303                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30304 834E           8846         FF            mov	-1[bp],al
30305                                           !BCC_EOS
30306                                           ! 5089       val8 = ( CX & 0x00ff );
30307                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
30308 8351           8A46         14            mov	al,$14[bp]
30309                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30310 8354           8846         F1            mov	-$F[bp],al
30311                                           !BCC_EOS
30312                                           ! 5090       spt = val8 & 0x3f;
30313                                           ! Debug: and int = const $3F to unsigned char val8 = [S+$24-$11] (used reg = )
30314 8357           8A46         F1            mov	al,-$F[bp]
30315 835A           24                     3F  and	al,*$3F
30316                                           ! Debug: eq unsigned char = al+0 to unsigned char spt = [S+$24-$1D] (used reg = )
30317 835C           8846         E5            mov	-$1B[bp],al
30318                                           !BCC_EOS
30319                                           ! 5091       maxCyl = ((val8 >> 6) << 8) + *(((Bit8u *)&CX)+1);
30320                                           ! Debug: sr int = const 6 to unsigned char val8 = [S+$24-$11] (used reg = )
30321 835F           8A46         F1            mov	al,-$F[bp]
30322 8362           30E4                       xor	ah,ah
30323 8364           B1                     06  mov	cl,*6
30324 8366           D3E8                       shr	ax,cl
30325                                           ! Debug: sl int = const 8 to unsigned int = ax+0 (used reg = )
30326 8368           88C4                       mov	ah,al
30327 836A           30C0                       xor	al,al
30328                                           ! Debug: add unsigned char CX = [S+$24+$13] to unsigned int = ax+0 (used reg = )
30329 836C           0246         15            add	al,$15[bp]
30330 836F           80D4                   00  adc	ah,*0
30331                                           ! Debug: eq unsigned int = ax+0 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30332 8372           8946         DE            mov	-$22[bp],ax
30333                                           !BCC_EOS
30334                                           ! 5092 ;
30335                                           !BCC_EOS
30336                                           ! 5093       if (drive > 1) {
30337                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30338 8375           8A46         FF            mov	al,-1[bp]
30339 8378           3C                     01  cmp	al,*1
30340 837A           76           1A            jbe 	.72A
30341                       0000837C            .72B:
30342                                           ! 5094         *(((Bit8u *)&AX)+1) = (0x01);
30343                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30344 837C           B0                     01  mov	al,*1
30345 837E           8846         17            mov	$17[bp],al
30346                                           !BCC_EOS
30347                                           ! 5095         set_diskette_ret_status(1);
30348                                           ! Debug: list int = const 1 (used reg = )
30349 8381           B8                   0001  mov	ax,*1
30350 8384           50                         push	ax
30351                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30352 8385           E8         02B6            call	_set_diskette_ret_status
30353 8388           44                         inc	sp
30354 8389           44                         inc	sp
30355                                           !BCC_EOS
30356                                           ! 5096         FLAGS |= 0x0001;
30357                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30358 838A           8B46         1C            mov	ax,$1C[bp]
30359 838D           0C                     01  or	al,*1
30360 838F           8946         1C            mov	$1C[bp],ax
30361                                           !BCC_EOS
30362                                           ! 5097         return;
30363 8392           89EC                       mov	sp,bp
30364 8394           5D                         pop	bp
30365 8395           C3                         ret
30366                                           !BCC_EOS
30367                                           ! 5098       }
30368                                           ! 5099       i
30369                                           ! 5099 f (floppy_drive_exists(drive) == 0) {
30370                       00008396            .72A:
30371                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30372 8396           8A46         FF            mov	al,-1[bp]
30373 8399           30E4                       xor	ah,ah
30374 839B           50                         push	ax
30375                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30376 839C           E8         F3A7            call	_floppy_drive_exists
30377 839F           44                         inc	sp
30378 83A0           44                         inc	sp
30379                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30380 83A1           85C0                       test	ax,ax
30381 83A3         0F85         001A            bne 	.72C
30382                       000083A7            .72D:
30383                                           ! 5100         *(((Bit8u *)&AX)+1) = (0x80);
30384                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30385 83A7           B0                     80  mov	al,#$80
30386 83A9           8846         17            mov	$17[bp],al
30387                                           !BCC_EOS
30388                                           ! 5101         set_diskette_ret_status(0x80);
30389                                           ! Debug: list int = const $80 (used reg = )
30390 83AC           B8                   0080  mov	ax,#$80
30391 83AF           50                         push	ax
30392                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30393 83B0           E8         028B            call	_set_diskette_ret_status
30394 83B3           44                         inc	sp
30395 83B4           44                         inc	sp
30396                                           !BCC_EOS
30397                                           ! 5102         FLAGS |= 0x0001;
30398                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30399 83B5           8B46         1C            mov	ax,$1C[bp]
30400 83B8           0C                     01  or	al,*1
30401 83BA           8946         1C            mov	$1C[bp],ax
30402                                           !BCC_EOS
30403                                           ! 5103         return;
30404 83BD           89EC                       mov	sp,bp
30405 83BF           5D                         pop	bp
30406 83C0           C3                         ret
30407                                           !BCC_EOS
30408                                           ! 5104       }
30409                                           ! 5105       if (floppy_media_known(drive) == 0) {
30410                       000083C1            .72C:
30411                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30412 83C1           8A46         FF            mov	al,-1[bp]
30413 83C4           30E4                       xor	ah,ah
30414 83C6           50                         push	ax
30415                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
30416 83C7           E8         F196            call	_floppy_media_known
30417 83CA           44                         inc	sp
30418 83CB           44                         inc	sp
30419                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30420 83CC           85C0                       test	ax,ax
30421 83CE           75           29            jne 	.72E
30422                       000083D0            .72F:
30423                                           ! 5106         if (floppy_media_sense(drive) == 0) {
30424                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30425 83D0           8A46         FF            mov	al,-1[bp]
30426 83D3           30E4                       xor	ah,ah
30427 83D5           50                         push	ax
30428                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
30429 83D6           E8         F1F7            call	_floppy_media_sense
30430 83D9           44                         inc	sp
30431 83DA           44                         inc	sp
30432                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30433 83DB           85C0                       test	ax,ax
30434 83DD           75           1A            jne 	.730
30435                       000083DF            .731:
30436                                           ! 5107           *(((Bit8u *)&AX)+1) = (0x0C);
30437                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30438 83DF           B0                     0C  mov	al,*$C
30439 83E1           8846         17            mov	$17[bp],al
30440                                           !BCC_EOS
30441                                           ! 5108           set_diskette_ret_status(0x0C);
30442                                           ! Debug: list int = const $C (used reg = )
30443 83E4           B8                   000C  mov	ax,*$C
30444 83E7           50                         push	ax
30445                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30446 83E8           E8         0253            call	_set_diskette_ret_status
30447 83EB           44                         inc	sp
30448 83EC           44                         inc	sp
30449                                           !BCC_EOS
30450                                           ! 5109           FLAGS |= 0x0001;
30451                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30452 83ED           8B46         1C            mov	ax,$1C[bp]
30453 83F0           0C                     01  or	al,*1
30454 83F2           8946         1C            mov	$1C[bp],ax
30455                                           !BCC_EOS
30456                                           ! 5110           return;
30457 83F5           89EC                       mov	sp,bp
30458 83F7           5D                         pop	bp
30459 83F8           C3                         ret
30460                                           !BCC_EOS
30461                                           ! 5111         }
30462                                           ! 5112       }
30463                       000083F9            .730:
30464                                           ! 5113       drive_type = inb_cmos(0x10);
30465                       000083F9            .72E:
30466                                           ! Debug: list int = const $10 (used reg = )
30467 83F9           B8                   0010  mov	ax,*$10
30468 83FC           50                         push	ax
30469                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30470 83FD           E8         816E            call	_inb_cmos
30471 8400           44                         inc	sp
30472 8401           44                         inc	sp
30473                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30474 8402           8846         E8            mov	-$18[bp],al
30475                                           !BCC_EOS
30476                                           ! 5114       if (drive == 0)
30477                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
30478 8405           8A46         FF            mov	al,-1[bp]
30479 8408           84C0                       test	al,al
30480 840A           75           0E            jne 	.732
30481                       0000840C            .733:
30482                                           ! 5115         drive_type >>= 4;
30483                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30484 840C           8A46         E8            mov	al,-$18[bp]
30485 840F           30E4                       xor	ah,ah
30486 8411           B1                     04  mov	cl,*4
30487 8413           D3E8                       shr	ax,cl
30488 8415           8846         E8            mov	-$18[bp],al
30489                                           !BCC_EOS
30490                                           ! 5116       else
30491                                           ! 5117         drive_type &= 0x0f;
30492 8418           EB           08            jmp .734
30493                       0000841A            .732:
30494                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
30495 841A           8A46         E8            mov	al,-$18[bp]
30496 841D           24                     0F  and	al,*$F
30497 841F           8846         E8            mov	-$18[bp],al
30498                                           !BCC_EOS
30499                                           ! 5118       base_address = (drive) ? 0x0091 : 0x0090;
30500                       00008422            .734:
30501 8422           8A46         FF            mov	al,-1[bp]
30502 8425           84C0                       test	al,al
30503 8427           74           04            je  	.735
30504                       00008429            .736:
30505 8429           B0                     91  mov	al,#$91
30506 842B           EB           02            jmp .737
30507                       0000842D            .735:
30508 842D           B0                     90  mov	al,#$90
30509                       0000842F            .737:
30510                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30511 842F           30E4                       xor	ah,ah
30512 8431           8946         F8            mov	-8[bp],ax
30513                                           !BCC_EOS
30514                                           ! 5119       status = *((Bit8u *)(base_address));
30515 8434           8B5E         F8            mov	bx,-8[bp]
30516                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30517 8437           8A07                       mov	al,[bx]
30518 8439           8846         FA            mov	-6[bp],al
30519                                           !BCC_EOS
30520                                           ! 5120       val8 = status & 0x0f;
30521                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30522 843C           8A46         FA            mov	al,-6[bp]
30523 843F           24                     0F  and	al,*$F
30524                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30525 8441           8846         F1            mov	-$F[bp],al
30526                                           !BCC_EOS
30527                                           ! 5121       *(((Bit8u *)&AX)+1) = (0x0C);
30528                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30529 8444           B0                     0C  mov	al,*$C
30530 8446           8846         17            mov	$17[bp],al
30531                                           !BCC_EOS
30532                                           ! 5122       switch (drive_type) {
30533 8449           8A46         E8            mov	al,-$18[bp]
30534 844C           E9         010E            br 	.73A
30535                                           ! 5123         case 0:
30536                                           ! 5124           break;
30537                       0000844F            .73B:
30538 844F           E9         0132            br 	.738
30539                                           !BCC_EOS
30540                                           ! 5125         case 1:
30541                                           ! 5126         case 6:
30542                       00008452            .73C:
30543                                           ! 5127         case 7:
30544                       00008452            .73D:
30545                                           ! 5128         case 8:
30546                       00008452            .73E:
30547                                           ! 5129           if (maxCyl == 39 && (spt == 8 || spt == 9))
30548                       00008452            .73F:
30549                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30550 8452           8B46         DE            mov	ax,-$22[bp]
30551 8455           3D                   0027  cmp	ax,*$27
30552 8458           75           1B            jne 	.740
30553                       0000845A            .742:
30554                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30555 845A           8A46         E5            mov	al,-$1B[bp]
30556 845D           3C                     08  cmp	al,*8
30557 845F           74           07            je  	.741
30558                       00008461            .743:
30559                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30560 8461           8A46         E5            mov	al,-$1B[bp]
30561 8464           3C                     09  cmp	al,*9
30562 8466           75           0D            jne 	.740
30563                       00008468            .741:
30564                                           ! 5130           {
30565                                           ! 5131             val8 |= 0x90;
30566                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30567 8468           8A46         F1            mov	al,-$F[bp]
30568 846B           0C                     90  or	al,#$90
30569 846D           8846         F1            mov	-$F[bp],al
30570                                           !BCC_EOS
30571                                           ! 5132             *(((Bit8u *)&AX)+1) = (0);
30572                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30573 8470           30C0                       xor	al,al
30574 8472           8846         17            mov	$17[bp],al
30575                                           !BCC_EOS
30576                                           ! 5133           }
30577                                           ! 5134           break;
30578                       00008475            .740:
30579 8475           E9         010C            br 	.738
30580                                           !BCC_EOS
30581                                           ! 5135         case 2:
30582                                           ! 5136           if (maxCyl == 39 && (spt == 8 || spt == 9))
30583                       00008478            .744:
30584                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30585 8478           8B46         DE            mov	ax,-$22[bp]
30586 847B           3D                   0027  cmp	ax,*$27
30587 847E           75           1D            jne 	.745
30588                       00008480            .747:
30589                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30590 8480           8A46         E5            mov	al,-$1B[bp]
30591 8483           3C                     08  cmp	al,*8
30592 8485           74           07            je  	.746
30593                       00008487            .748:
30594                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30595 8487           8A46         E5            mov	al,-$1B[bp]
30596 848A           3C                     09  cmp	al,*9
30597 848C           75           0F            jne 	.745
30598                       0000848E            .746:
30599                                           ! 5137           {
30600                                           ! 5138             val8 |= 0x70;
30601                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30602 848E           8A46         F1            mov	al,-$F[bp]
30603 8491           0C                     70  or	al,*$70
30604 8493           8846         F1            mov	-$F[bp],al
30605                                           !BCC_EOS
30606                                           ! 5139             *(((Bit8u *)&AX)+1) = (0);
30607                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30608 8496           30C0                       xor	al,al
30609 8498           8846         17            mov	$17[bp],al
30610                                           !BCC_EOS
30611                                           ! 5140           }
30612                                           ! 5141           else if (maxCyl == 79 && spt == 15)
30613 849B           EB           1C            jmp .749
30614                       0000849D            .745:
30615                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30616 849D           8B46         DE            mov	ax,-$22[bp]
30617 84A0           3D                   004F  cmp	ax,*$4F
30618 84A3           75           14            jne 	.74A
30619                       000084A5            .74C:
30620                                           ! Debug: logeq int = const $F to unsigned char spt = [S+$24-$1D] (used reg = )
30621 84A5           8A46         E5            mov	al,-$1B[bp]
30622 84A8           3C                     0F  cmp	al,*$F
30623 84AA           75           0D            jne 	.74A
30624                       000084AC            .74B:
30625                                           ! 5142           {
30626                                           ! 5143             val8 |= 0x10;
30627                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30628 84AC           8A46         F1            mov	al,-$F[bp]
30629 84AF           0C                     10  or	al,*$10
30630 84B1           8846         F1            mov	-$F[bp],al
30631                                           !BCC_EOS
30632                                           ! 5144             *(((Bit8u *)&AX)+1) = (0);
30633                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30634 84B4           30C0                       xor	al,al
30635 84B6           8846         17            mov	$17[bp],al
30636                                           !BCC_EOS
30637                                           ! 5145           }
30638                                           ! 5146           break;
30639                       000084B9            .74A:
30640                       000084B9            .749:
30641 84B9           E9         00C8            br 	.738
30642                                           !BCC_EOS
30643                                           ! 5147         case 3:
30644                                           ! 5148           if (maxCyl == 79 && spt == 9)
30645                       000084BC            .74D:
30646                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30647 84BC           8B46         DE            mov	ax,-$22[bp]
30648 84BF           3D                   004F  cmp	ax,*$4F
30649 84C2           75           14            jne 	.74E
30650                       000084C4            .750:
30651                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30652 84C4           8A46         E5            mov	al,-$1B[bp]
30653 84C7           3C                     09  cmp	al,*9
30654 84C9           75           0D            jne 	.74E
30655                       000084CB            .74F:
30656                                           ! 5149           {
30657                                           ! 5150             val8 |= 0x90;
30658                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30659 84CB           8A46         F1            mov	al,-$F[bp]
30660 84CE           0C                     90  or	al,#$90
30661 84D0           8846         F1            mov	-$F[bp],al
30662                                           !BCC_EOS
30663                                           ! 5151             *(((Bit8u *)&AX)+1) = (0);
30664                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30665 84D3           30C0                       xor	al,al
30666 84D5           8846         17            mov	$17[bp],al
30667                                           !BCC_EOS
30668                                           ! 5152           }
30669                                           ! 5153           break;
30670                       000084D8            .74E:
30671 84D8           E9         00A9            br 	.738
30672                                           !BCC_EOS
30673                                           ! 5154         case 4:
30674                                           ! 5155           if (maxCyl == 79)
30675                       000084DB            .751:
30676                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30677 84DB           8B46         DE            mov	ax,-$22[bp]
30678 84DE           3D                   004F  cmp	ax,*$4F
30679 84E1           75           2A            jne 	.752
30680                       000084E3            .753:
30681                                           ! 5156           {
30682                                           ! 5157             if (spt == 9)
30683                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30684 84E3           8A46         E5            mov	al,-$1B[bp]
30685 84E6           3C                     09  cmp	al,*9
30686 84E8           75           0F            jne 	.754
30687                       000084EA            .755:
30688                                           ! 5158             {
30689                                           ! 5159               val8 |= 0x90;
30690                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30691 84EA           8A46         F1            mov	al,-$F[bp]
30692 84ED           0C                     90  or	al,#$90
30693 84EF           8846         F1            mov	-$F[bp],al
30694                                           !BCC_EOS
30695                                           ! 5160               *(((Bit8u *)&AX)+1) = (0);
30696                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30697 84F2           30C0                       xor	al,al
30698 84F4           8846         17            mov	$17[bp],al
30699                                           !BCC_EOS
30700                                           ! 5161             }
30701                                           ! 5162             else if (spt == 18)
30702 84F7           EB           14            jmp .756
30703                       000084F9            .754:
30704                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30705 84F9           8A46         E5            mov	al,-$1B[bp]
30706 84FC           3C                     12  cmp	al,*$12
30707 84FE           75           0D            jne 	.757
30708                       00008500            .758:
30709                                           ! 5163             {
30710                                           ! 5164               val8 |= 0x10;
30711                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30712 8500           8A46         F1            mov	al,-$F[bp]
30713 8503           0C                     10  or	al,*$10
30714 8505           8846         F1            mov	-$F[bp],al
30715                                           !BCC_EOS
30716                                           ! 5165               *(((Bit8u *)&AX)+1) = (0);
30717                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30718 8508           30C0                       xor	al,al
30719 850A           8846         17            mov	$17[bp],al
30720                                           !BCC_EOS
30721                                           ! 5166             }
30722                                           ! 5167           }
30723                       0000850D            .757:
30724                       0000850D            .756:
30725                                           ! 5168           break;
30726                       0000850D            .752:
30727 850D           EB           75            jmp .738
30728                                           !BCC_EOS
30729                                           ! 5169         case 5:
30730                                           ! 5170           if (maxCyl == 79)
30731                       0000850F            .759:
30732                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30733 850F           8B46         DE            mov	ax,-$22[bp]
30734 8512           3D                   004F  cmp	ax,*$4F
30735 8515           75           40            jne 	.75A
30736                       00008517            .75B:
30737                                           ! 5171           {
30738                                           ! 5172             if (spt == 9)
30739                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30740 8517           8A46         E5            mov	al,-$1B[bp]
30741 851A           3C                     09  cmp	al,*9
30742 851C           75           0F            jne 	.75C
30743                       0000851E            .75D:
30744                                           ! 5173             {
30745                                           ! 5174               val8 |= 0x90;
30746                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30747 851E           8A46         F1            mov	al,-$F[bp]
30748 8521           0C                     90  or	al,#$90
30749 8523           8846         F1            mov	-$F[bp],al
30750                                           !BCC_EOS
30751                                           ! 5175               *(((Bit8u *)&AX)+1) = (0);
30752                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30753 8526           30C0                       xor	al,al
30754 8528           8846         17            mov	$17[bp],al
30755                                           !BCC_EOS
30756                                           ! 5176             }
30757                                           ! 5177             else if (spt == 18)
30758 852B           EB           2A            jmp .75E
30759                       0000852D            .75C:
30760                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30761 852D           8A46         E5            mov	al,-$1B[bp]
30762 8530           3C                     12  cmp	al,*$12
30763 8532           75           0F            jne 	.75F
30764                       00008534            .760:
30765                                           ! 5178             {
30766                                           ! 5179               val8 |= 0x10;
30767                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30768 8534           8A46         F1            mov	al,-$F[bp]
30769 8537           0C                     10  or	al,*$10
30770 8539           8846         F1            mov	-$F[bp],al
30771                                           !BCC_EOS
30772                                           ! 5180               *(((Bit8u *
30773                                           ! 5180 )&AX)+1) = (0);
30774                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30775 853C           30C0                       xor	al,al
30776 853E           8846         17            mov	$17[bp],al
30777                                           !BCC_EOS
30778                                           ! 5181             }
30779                                           ! 5182             else if (spt == 36)
30780 8541           EB           14            jmp .761
30781                       00008543            .75F:
30782                                           ! Debug: logeq int = const $24 to unsigned char spt = [S+$24-$1D] (used reg = )
30783 8543           8A46         E5            mov	al,-$1B[bp]
30784 8546           3C                     24  cmp	al,*$24
30785 8548           75           0D            jne 	.762
30786                       0000854A            .763:
30787                                           ! 5183             {
30788                                           ! 5184               val8 |= 0xD0;
30789                                           ! Debug: orab int = const $D0 to unsigned char val8 = [S+$24-$11] (used reg = )
30790 854A           8A46         F1            mov	al,-$F[bp]
30791 854D           0C                     D0  or	al,#$D0
30792 854F           8846         F1            mov	-$F[bp],al
30793                                           !BCC_EOS
30794                                           ! 5185               *(((Bit8u *)&AX)+1) = (0);
30795                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30796 8552           30C0                       xor	al,al
30797 8554           8846         17            mov	$17[bp],al
30798                                           !BCC_EOS
30799                                           ! 5186             }
30800                                           ! 5187           }
30801                       00008557            .762:
30802                       00008557            .761:
30803                       00008557            .75E:
30804                                           ! 5188           break;
30805                       00008557            .75A:
30806 8557           EB           2B            jmp .738
30807                                           !BCC_EOS
30808                                           ! 5189         default:
30809                                           ! 5190           break;
30810                       00008559            .764:
30811 8559           EB           29            jmp .738
30812                                           !BCC_EOS
30813                                           ! 5191       }
30814                                           ! 5192       if (0 != *(((Bit8u *)&AX)+1))
30815 855B           EB           27            jmp .738
30816                       0000855D            .73A:
30817 855D           2C                     00  sub	al,*0
30818 855F           72           F8            jb 	.764
30819 8561           3C                     08  cmp	al,*8
30820 8563           77           1D            ja  	.765
30821 8565           30E4                       xor	ah,ah
30822 8567           D1E0                       shl	ax,*1
30823 8569           89C3                       mov	bx,ax
30824 856B           2E                         seg	cs
30825 856C           FFA7       8570            br	.766[bx]
30826                       00008570            .766:
30827 8570                      844F            .word	.73B
30828 8572                      8452            .word	.73C
30829 8574                      8478            .word	.744
30830 8576                      84BC            .word	.74D
30831 8578                      84DB            .word	.751
30832 857A                      850F            .word	.759
30833 857C                      8452            .word	.73D
30834 857E                      8452            .word	.73E
30835 8580                      8452            .word	.73F
30836                       00008582            .765:
30837 8582           EB           D5            jmp	.764
30838                       00008584            .738:
30839                                           ! Debug: ne unsigned char AX = [S+$24+$15] to int = const 0 (used reg = )
30840                                           ! Debug: expression subtree swapping
30841 8584           8A46         17            mov	al,$17[bp]
30842 8587           84C0                       test	al,al
30843 8589           74           17            je  	.767
30844                       0000858B            .768:
30845                                           ! 5193       {
30846                                           ! 5194         set_diskette_ret_status(*(((Bit8u *)&AX)+1));
30847                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30848 858B           8A46         17            mov	al,$17[bp]
30849 858E           30E4                       xor	ah,ah
30850 8590           50                         push	ax
30851                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30852 8591           E8         00AA            call	_set_diskette_ret_status
30853 8594           44                         inc	sp
30854 8595           44                         inc	sp
30855                                           !BCC_EOS
30856                                           ! 5195         FLAGS |= 0x0001;
30857                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30858 8596           8B46         1C            mov	ax,$1C[bp]
30859 8599           0C                     01  or	al,*1
30860 859B           8946         1C            mov	$1C[bp],ax
30861                                           !BCC_EOS
30862                                           ! 5196         return;
30863 859E           89EC                       mov	sp,bp
30864 85A0           5D                         pop	bp
30865 85A1           C3                         ret
30866                                           !BCC_EOS
30867                                           ! 5197       }
30868                                           ! 5198 ;
30869                       000085A2            .767:
30870                                           !BCC_EOS
30871                                           ! 5199       *((Bit8u *)(base_address)) = (val8);
30872 85A2           8B5E         F8            mov	bx,-8[bp]
30873                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30874 85A5           8A46         F1            mov	al,-$F[bp]
30875 85A8           8807                       mov	[bx],al
30876                                           !BCC_EOS
30877                                           ! 5200 #asm
30878                                           !BCC_EOS
30879                                           !BCC_ASM
30880                       0000002E            _int13_diskette_function.BP	set	$2E
30881                       0000000C            .int13_diskette_function.BP	set	$C
30882                       0000003C            _int13_diskette_function.CS	set	$3C
30883                       0000001A            .int13_diskette_function.CS	set	$1A
30884                       00000036            _int13_diskette_function.CX	set	$36
30885                       00000014            .int13_diskette_function.CX	set	$14
30886                       0000001A            _int13_diskette_function.base_address	set	$1A
30887                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30888                       0000002A            _int13_diskette_function.DI	set	$2A
30889                       00000008            .int13_diskette_function.DI	set	8
30890                       0000003E            _int13_diskette_function.FLAGS	set	$3E
30891                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30892                       00000018            _int13_diskette_function.base_count	set	$18
30893                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30894                       0000001E            _int13_diskette_function.sector	set	$1E
30895                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30896                       00000026            _int13_diskette_function.DS	set	$26
30897                       00000004            .int13_diskette_function.DS	set	4
30898                       0000001D            _int13_diskette_function.head	set	$1D
30899                       FFFFFFFB            .int13_diskette_function.head	set	-5
30900                       00000030            _int13_diskette_function.ELDX	set	$30
30901                       0000000E            .int13_diskette_function.ELDX	set	$E
30902                       00000012            _int13_diskette_function.dor	set	$12
30903                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30904                       00000034            _int13_diskette_function.DX	set	$34
30905                       00000012            .int13_diskette_function.DX	set	$12
30906                       0000000B            _int13_diskette_function.return_status	set	$B
30907                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30908                       00000004            _int13_diskette_function.es	set	4
30909                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
30910                       00000014            _int13_diskette_function.mode_register	set	$14
30911                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30912                       00000028            _int13_diskette_function.ES	set	$28
30913                       00000006            .int13_diskette_function.ES	set	6
30914                       00000016            _int13_diskette_function.base_es	set	$16
30915                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30916                       0000001F            _int13_diskette_function.track	set	$1F
30917                       FFFFFFFD            .int13_diskette_function.track	set	-3
30918                       0000002C            _int13_diskette_function.SI	set	$2C
30919                       0000000A            .int13_diskette_function.SI	set	$A
30920                       0000000A            _int13_diskette_function.drive_type	set	$A
30921                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30922                       00000020            _int13_diskette_function.num_sectors	set	$20
30923                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30924                       0000003A            _int13_diskette_function.IP	set	$3A
30925                       00000018            .int13_diskette_function.IP	set	$18
30926                       00000007            _int13_diskette_function.spt	set	7
30927                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
30928                       0000001C            _int13_diskette_function.status	set	$1C
30929                       FFFFFFFA            .int13_diskette_function.status	set	-6
30930                       00000000            _int13_diskette_function.maxCyl	set	0
30931                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
30932                       00000038            _int13_diskette_function.AX	set	$38
30933                       00000016            .int13_diskette_function.AX	set	$16
30934                       00000013            _int13_diskette_function.val8	set	$13
30935                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30936                       00000002            _int13_diskette_function.last_addr	set	2
30937                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
30938                       00000015            _int13_diskette_function.page	set	$15
30939                       FFFFFFF3            .int13_diskette_function.page	set	-$D
30940                       00000008            _int13_diskette_function.ah	set	8
30941                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
30942                       00000021            _int13_diskette_function.drive	set	$21
30943                       FFFFFFFF            .int13_diskette_function.drive	set	-1
30944                       00000009            _int13_diskette_function.num_floppies	set	9
30945                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
30946                       00000032            _int13_diskette_function.BX	set	$32
30947                       00000010            .int13_diskette_function.BX	set	$10
30948 85AA           55                               push bp
30949 85AB           89E5                             mov bp, sp
30950 85AD           B8                   EFDE        mov ax, #diskette_param_table2
30951 85B0           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
30952 85B3           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
30953 85B6           5D                               pop bp
30954                                           ! 5207 endasm
30955                                           !BCC_ENDASM
30956                                           !BCC_EOS
30957                                           ! 5208       set_diskette_ret_status(0);
30958                                           ! Debug: list int = const 0 (used reg = )
30959 85B7           31C0                       xor	ax,ax
30960 85B9           50                         push	ax
30961                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30962 85BA           E8         0081            call	_set_diskette_ret_status
30963 85BD           44                         inc	sp
30964 85BE           44                         inc	sp
30965                                           !BCC_EOS
30966                                           ! 5209       FLAGS &= 0xfffe;
30967                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30968 85BF           8B46         1C            mov	ax,$1C[bp]
30969 85C2           24                     FE  and	al,#$FE
30970 85C4           8946         1C            mov	$1C[bp],ax
30971                                           !BCC_EOS
30972                                           ! 5210       return;
30973 85C7           89EC                       mov	sp,bp
30974 85C9           5D                         pop	bp
30975 85CA           C3                         ret
30976                                           !BCC_EOS
30977                                           ! 5211     default:
30978                                           ! 5212         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
30979                       000085CB            .769:
30980                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30981 85CB           8A46         17            mov	al,$17[bp]
30982 85CE           30E4                       xor	ah,ah
30983 85D0           50                         push	ax
30984                                           ! Debug: list * char = .76A+0 (used reg = )
30985 85D1           BB                   CD4D  mov	bx,#.76A
30986 85D4           53                         push	bx
30987                                           ! Debug: list int = const 4 (used reg = )
30988 85D5           B8                   0004  mov	ax,*4
30989 85D8           50                         push	ax
30990                                           ! Debug: func () void = bios_printf+0 (used reg = )
30991 85D9           E8         835D            call	_bios_printf
30992 85DC           83C4                   06  add	sp,*6
30993                                           !BCC_EOS
30994                                           ! 5213         *(((Bit8u *)&AX)+1) = (0x01);
30995                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30996 85DF           B0                     01  mov	al,*1
30997 85E1           8846         17            mov	$17[bp],al
30998                                           !BCC_EOS
30999                                           ! 5214         set_diskette_ret_status(1);
31000                                           ! Debug: list int = const 1 (used reg = )
31001 85E4           B8                   0001  mov	ax,*1
31002 85E7           50                         push	ax
31003                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31004 85E8           E8         0053            call	_set_diskette_ret_status
31005 85EB           44                         inc	sp
31006 85EC           44                         inc	sp
31007                                           !BCC_EOS
31008                                           ! 5215         FLAGS |= 0x0001;
31009                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31010 85ED           8B46         1C            mov	ax,$1C[bp]
31011 85F0           0C                     01  or	al,*1
31012 85F2           8946         1C            mov	$1C[bp],ax
31013                                           !BCC_EOS
31014                                           ! 5216         return;
31015 85F5           89EC                       mov	sp,bp
31016 85F7           5D                         pop	bp
31017 85F8           C3                         ret
31018                                           !BCC_EOS
31019                                           ! 5217     }
31020                                           ! 5218 }
31021 85F9           EB           3F            jmp .696
31022                       000085FB            .698:
31023 85FB           2C                     00  sub	al,*0
31024 85FD           72           CC            jb 	.769
31025 85FF           3C                     08  cmp	al,*8
31026 8601           77           1D            ja  	.76B
31027 8603           30E4                       xor	ah,ah
31028 8605           D1E0                       shl	ax,*1
31029 8607           89C3                       mov	bx,ax
31030 8609           2E                         seg	cs
31031 860A           FFA7       860E            br	.76C[bx]
31032                       0000860E            .76C:
31033 860E                      77A0            .word	.699
31034 8610                      7839            .word	.6A1
31035 8612                      7860            .word	.6A4
31036 8614                      7860            .word	.6A5
31037 8616                      7860            .word	.6A6
31038 8618                      7CB4            .word	.6CF
31039 861A                      85CB            .word	.769
31040 861C                      85CB            .word	.769
31041 861E                      8017            .word	.6EF
31042                       00008620            .76B:
31043 8620           2C                     15  sub	al,*$15
31044 8622         0F84         FB64            beq 	.709
31045 8626           2C                     01  sub	al,*1
31046 8628         0F84         FBC4            beq 	.712
31047 862C           2C                     01  sub	al,*1
31048 862E         0F84         FBFF            beq 	.715
31049 8632           2C                     01  sub	al,*1
31050 8634         0F84         FD13            beq 	.729
31051 8638           EB           91            jmp	.769
31052                       0000863A            .696:
31053                       FFFFFFDC            ..FFDB	=	-$24
31054                       FFFFFFDC            ..FFDA	=	-$24
31055 863A           89EC                       mov	sp,bp
31056 863C           5D                         pop	bp
31057 863D           C3                         ret
31058                                           ! 5219  void
31059                                           ! Register BX used in function int13_diskette_function
31060                                           ! 5220 set_diskette_ret_status(value)
31061                                           ! 5221   Bit8u value;
31062                                           export	_set_diskette_ret_status
31063                       0000863E            _set_diskette_ret_status:
31064                                           !BCC_EOS
31065                                           ! 5222 {
31066                                           ! 5223   _write_byte(value, 0x0041, 0x0040);
31067 863E           55                         push	bp
31068 863F           89E5                       mov	bp,sp
31069                                           ! Debug: list int = const $40 (used reg = )
31070 8641           B8                   0040  mov	ax,*$40
31071 8644           50                         push	ax
31072                                           ! Debug: list int = const $41 (used reg = )
31073 8645           B8                   0041  mov	ax,*$41
31074 8648           50                         push	ax
31075                                           ! Debug: list unsigned char value = [S+6+2] (used reg = )
31076 8649           8A46         04            mov	al,4[bp]
31077 864C           30E4                       xor	ah,ah
31078 864E           50                         push	ax
31079                                           ! Debug: func () void = _write_byte+0 (used reg = )
31080 864F           E8         7FA9            call	__write_byte
31081 8652           89EC                       mov	sp,bp
31082                                           !BCC_EOS
31083                                           ! 5224 }
31084 8654           5D                         pop	bp
31085 8655           C3                         ret
31086                                           ! 5225   void
31087                                           ! 5226 set_diskette_current_cyl(drive, cyl)
31088                                           ! 5227   Bit8u drive;
31089                                           export	_set_diskette_current_cyl
31090                       00008656            _set_diskette_current_cyl:
31091                                           !BCC_EOS
31092                                           ! 5228   Bit8u cyl;
31093                                           !BCC_EOS
31094                                           ! 5229 {
31095                                           ! 5230   if (drive > 1)
31096 8656           55                         push	bp
31097 8657           89E5                       mov	bp,sp
31098                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
31099 8659           8A46         04            mov	al,4[bp]
31100 865C           3C                     01  cmp	al,*1
31101 865E           76           0D            jbe 	.76D
31102                       00008660            .76E:
31103                                           ! 5231     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
31104                                           ! Debug: list * char = .76F+0 (used reg = )
31105 8660           BB                   CD26  mov	bx,#.76F
31106 8663           53                         push	bx
31107                                           ! Debug: list int = const 7 (used reg = )
31108 8664           B8                   0007  mov	ax,*7
31109 8667           50                         push	ax
31110                                           ! Debug: func () void = bios_printf+0 (used reg = )
31111 8668           E8         82CE            call	_bios_printf
31112 866B           89EC                       mov	sp,bp
31113                                           !BCC_EOS
31114                                           ! 5232   _write_byte(cyl, 0x0094+drive, 0x0040);
31115                       0000866D            .76D:
31116                                           ! Debug: list int = const $40 (used reg = )
31117 866D           B8                   0040  mov	ax,*$40
31118 8670           50                         push	ax
31119                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
31120                                           ! Debug: expression subtree swapping
31121 8671           8A46         04            mov	al,4[bp]
31122 8674           30E4                       xor	ah,ah
31123                                           ! Debug: list unsigned int = ax+$94 (used reg = )
31124 8676           05                   0094  add	ax,#$94
31125 8679           50                         push	ax
31126                                           ! Debug: list unsigned char cyl = [S+6+4] (used reg = )
31127 867A           8A46         06            mov	al,6[bp]
31128 867D           30E4                       xor	ah,ah
31129 867F           50                         push	ax
31130                                           ! Debug: func () void = _write_byte+0 (used reg = )
31131 8680           E8         7F78            call	__write_byte
31132 8683           89EC                       mov	sp,bp
31133                                           !BCC_EOS
31134                                           ! 5233 }
31135 8685           5D                         pop	bp
31136 8686           C3                         ret
31137                                           ! 5234   void
31138                                           ! Register BX used in function set_diskette_current_cyl
31139                                           ! 5235 determine_floppy_media(drive)
31140                                           ! 5236   Bit16u drive;
31141                                           export	_determine_floppy_media
31142                       00008687            _determine_floppy_media:
31143                                           !BCC_EOS
31144                                           ! 5237 {
31145                                           ! 5238 }
31146 8687           C3                         ret
31147                                           ! 5239   void
31148                                           ! 5240 int17_function(regs, ds, iret_addr)
31149                                           ! 5241   pusha_regs_t regs;
31150                                           export	_int17_function
31151                       00008688            _int17_function:
31152                                           !BCC_EOS
31153                                           ! 5242   Bit16u ds;
31154                                           !BCC_EOS
31155                                           ! 5243   iret_addr_t iret_addr;
31156                                           !BCC_EOS
31157                                           ! 5244 {
31158                                           ! 5245   Bit16u addr,timeout;
31159                                           !BCC_EOS
31160                                           ! 5246   Bit8u val8;
31161                                           !BCC_EOS
31162                                           ! 5247 #asm
31163 8688           55                         push	bp
31164 8689           89E5                       mov	bp,sp
31165 868B           83C4                   FA  add	sp,*-6
31166                                           !BCC_EOS
31167                                           !BCC_ASM
31168                       0000001A            _int17_function.ds	set	$1A
31169                       00000014            .int17_function.ds	set	$14
31170                       00000002            _int17_function.timeout	set	2
31171                       FFFFFFFC            .int17_function.timeout	set	-4
31172                       00000001            _int17_function.val8	set	1
31173                       FFFFFFFB            .int17_function.val8	set	-5
31174                       0000001C            _int17_function.iret_addr	set	$1C
31175                       00000016            .int17_function.iret_addr	set	$16
31176                       00000004            _int17_function.addr	set	4
31177                       FFFFFFFE            .int17_function.addr	set	-2
31178                       0000000A            _int17_function.regs	set	$A
31179                       00000004            .int17_function.regs	set	4
31180 868E           FB                           sti
31181                                           ! 5249 endasm
31182                                           !BCC_ENDASM
31183                                           !BCC_EOS
31184                                           ! 5250   addr = *((Bit16u *)(0x0400 + (regs.u.r16.dx << 1) + 8));
31185                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
31186 868F           8B46         0E            mov	ax,$E[bp]
31187 8692           D1E0                       shl	ax,*1
31188                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
31189                                           ! Debug: expression subtree swapping
31190                                           ! Debug: add int = const 8 to unsigned int = ax+$400 (used reg = )
31191                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$408 (used reg = )
31192 8694           89C3                       mov	bx,ax
31193                                           ! Debug: eq unsigned short = [bx+$408] to unsigned short addr = [S+8-4] (used reg = )
31194 8696           8B9F       0408            mov	bx,$408[bx]
31195 869A           895E         FE            mov	-2[bp],bx
31196                                           !BCC_EOS
31197                                           ! 5251   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
31198                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
31199 869D           8A46         13            mov	al,$13[bp]
31200 86A0           3C                     03  cmp	al,*3
31201 86A2         0F83         00FD            bhis	.770
31202                       000086A6            .773:
31203                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
31204 86A6           8B46         0E            mov	ax,$E[bp]
31205 86A9           3D                   0003  cmp	ax,*3
31206 86AC         0F83         00F3            bhis	.770
31207                       000086B0            .772:
31208                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
31209 86B0           8B46         FE            mov	ax,-2[bp]
31210 86B3           85C0                       test	ax,ax
31211 86B5         0F84         00EA            beq 	.770
31212                       000086B9            .771:
31213                                           ! 5252     *(((Bit8u *)&timeout)+1) = *((Bit8u *)(0x0478 + regs.u.r16.dx));
31214                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $478 (used reg = )
31215                                           ! Debug: expression subtree swapping
31216 86B9           8B46         0E            mov	ax,$E[bp]
31217                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$478 (used reg = )
31218 86BC           89C3                       mov	bx,ax
31219                                           ! Debug: eq unsigned char = [bx+$478] to unsigned char timeout = [S+8-5] (used reg = )
31220 86BE           8A87       0478            mov	al,$478[bx]
31221 86C2           8846         FD            mov	-3[bp],al
31222                                           !BCC_EOS
31223                                           ! 5253     *((Bit8u *)&timeout) = 0;
31224                                           ! Debug: eq int = const 0 to unsigned char timeout = [S+8-6] (used reg = )
31225 86C5           30C0                       xor	al,al
31226 86C7           8846         FC            mov	-4[bp],al
31227                                           !BCC_EOS
31228                                           ! 5254     if (regs.u.r8.ah == 0) {
31229                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
31230 86CA           8A46         13            mov	al,$13[bp]
31231 86CD           84C0                       test	al,al
31232 86CF           75           66            jne 	.774
31233                       000086D1            .775:
31234                                           ! 5255       outb(addr, regs.u.r8.al);
31235                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
31236 86D1           8A46         12            mov	al,$12[bp]
31237 86D4           30E4                       xor	ah,ah
31238 86D6           50                         push	ax
31239                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
31240 86D7           FF76         FE            push	-2[bp]
31241                                           ! Debug: func () void = outb+0 (used reg = )
31242 86DA           E8         7E62            call	_outb
31243 86DD           83C4                   04  add	sp,*4
31244                                           !BCC_EOS
31245                                           ! 5256       val8 = inb(addr+2);
31246                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31247 86E0           8B46         FE            mov	ax,-2[bp]
31248                                           ! Debug: list unsigned int = ax+2 (used reg = )
31249 86E3           40                         inc	ax
31250 86E4           40                         inc	ax
31251 86E5           50                         push	ax
31252                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31253 86E6           E8         7E40            call	_inb
31254 86E9           44                         inc	sp
31255 86EA           44                         inc	sp
31256                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31257 86EB           8846         FB            mov	-5[bp],al
31258                                           !BCC_EOS
31259                                           ! 5257       outb(addr+2, val8 | 0x01);
31260                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
31261 86EE           8A46         FB            mov	al,-5[bp]
31262 86F1           0C                     01  or	al,*1
31263                                           ! Debug: list unsigned char = al+0 (used reg = )
31264 86F3           30E4                       xor	ah,ah
31265 86F5           50                         push	ax
31266                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31267 86F6           8B46         FE            mov	ax,-2[bp]
31268                                           ! Debug: list unsigned int = ax+2 (used reg = )
31269 86F9           40                         inc	ax
31270 86FA           40                         inc	ax
31271 86FB           50                         push	ax
31272                                           ! Debug: func () void = outb+0 (used reg = )
31273 86FC           E8         7E40            call	_outb
31274 86FF           83C4                   04  add	sp,*4
31275                                           !BCC_EOS
31276                                           ! 5258 #asm
31277                                           !BCC_EOS
31278                                           !BCC_ASM
31279                       0000001A            _int17_function.ds	set	$1A
31280                       00000014            .int17_function.ds	set	$14
31281                       00000002            _int17_function.timeout	set	2
31282                       FFFFFFFC            .int17_function.timeout	set	-4
31283                       00000001            _int17_function.val8	set	1
31284                       FFFFFFFB            .int17_function.val8	set	-5
31285                       0000001C            _int17_function.iret_addr	set	$1C
31286                       00000016            .int17_function.iret_addr	set	$16
31287                       00000004            _int17_function.addr	set	4
31288                       FFFFFFFE            .int17_function.addr	set	-2
31289                       0000000A            _int17_function.regs	set	$A
31290                       00000004            .int17_function.regs	set	4
31291 8702           90                               nop
31292                                           ! 5260 endasm
31293                                           !BCC_ENDASM
31294                                           !BCC_EOS
31295                                           ! 5261       outb(addr+2, val8 & ~0x01);
31296                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
31297 8703           8A46         FB            mov	al,-5[bp]
31298 8706           24                     FE  and	al,#$FE
31299                                           ! Debug: list unsigned char = al+0 (used reg = )
31300 8708           30E4                       xor	ah,ah
31301 870A           50                         push	ax
31302                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31303 870B           8B46         FE            mov	ax,-2[bp]
31304                                           ! Debug: list unsigned int = ax+2 (used reg = )
31305 870E           40                         inc	ax
31306 870F           40                         inc	ax
31307 8710           50                         push	ax
31308                                           ! Debug: func () void = outb+0 (used reg = )
31309 8711           E8         7E2B            call	_outb
31310 8714           83C4                   04  add	sp,*4
31311                                           !BCC_EOS
31312                                           ! 5262       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
31313 8717           EB           07            jmp .777
31314                       00008719            .778:
31315                                           ! 5263         timeout--;
31316                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
31317 8719           8B46         FC            mov	ax,-4[bp]
31318 871C           48                         dec	ax
31319 871D           8946         FC            mov	-4[bp],ax
31320                                           !BCC_EOS
31321                                           ! 5264       }
31322                                           ! 5265     }
31323                       00008720            .777:
31324                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31325 8720           8B46         FE            mov	ax,-2[bp]
31326                                           ! Debug: list unsigned int = ax+1 (used reg = )
31327 8723           40                         inc	ax
31328 8724           50                         push	ax
31329                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31330 8725           E8         7E01            call	_inb
31331 8728           44                         inc	sp
31332 8729           44                         inc	sp
31333                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
31334 872A           24                     40  and	al,*$40
31335                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
31336 872C           3C                     40  cmp	al,*$40
31337 872E           75           07            jne 	.779
31338                       00008730            .77A:
31339 8730           8B46         FC            mov	ax,-4[bp]
31340 8733           85C0                       test	ax,ax
31341 8735           75           E2            jne	.778
31342                       00008737            .779:
31343                       00008737            .776:
31344                                           ! 5266     if (regs.u.r8.ah == 1) {
31345                       00008737            .774:
31346                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31347 8737           8A46         13            mov	al,$13[bp]
31348 873A           3C                     01  cmp	al,*1
31349 873C           75           37            jne 	.77B
31350                       0000873E            .77C:
31351                                           ! 5267       val8 = inb(addr+2);
31352                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31353 873E           8B46         FE            mov	ax,-2[bp]
31354                                           ! Debug: list unsigned int = ax+2 (used reg = )
31355 8741           40                         inc	ax
31356 8742           40                         inc	ax
31357 8743           50                         push	ax
31358                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31359 8744           E8         7DE2            call	_inb
31360 8747           44                         inc	sp
31361 8748           44                         inc	sp
31362                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31363 8749           8846         FB            mov	-5[bp],al
31364                                           !BCC_EOS
31365                                           ! 5268       outb(addr+2, val8 & ~0x04);
31366                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
31367 874C           8A46         FB            mov	al,-5[bp]
31368 874F           24                     FB  and	al,#$FB
31369                                           ! Debug: list unsigned char = al+0 (used reg = )
31370 8751           30E4                       xor	ah,ah
31371 8753           50                         push	ax
31372                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31373 8754           8B46         FE            mov	ax,-2[bp]
31374                                           ! Debug: list unsigned int = ax+2 (used reg = )
31375 8757           40                         inc	ax
31376 8758           40                         inc	ax
31377 8759           50                         push	ax
31378                                           ! Debug: func () void = outb+0 (used reg = )
31379 875A           E8         7DE2            call	_outb
31380 875D           83C4                   04  add	sp,*4
31381                                           !BCC_EOS
31382                                           ! 5269 #asm
31383                                           !BCC_EOS
31384                                           !BCC_ASM
31385                       0000001A            _int17_function.ds	set	$1A
31386                       00000014            .int17_function.ds	set	$14
31387                       00000002            _int17_function.timeout	set	2
31388                       FFFFFFFC            .int17_function.timeout	set	-4
31389                       00000001            _int17_function.val8	set	1
31390                       FFFFFFFB            .int17_function.val8	set	-5
31391                       0000001C            _int17_function.iret_addr	set	$1C
31392                       00000016            .int17_function.iret_addr	set	$16
31393                       00000004            _int17_function.addr	set	4
31394                       FFFFFFFE            .int17_function.addr	set	-2
31395                       0000000A            _int17_function.regs	set	$A
31396                       00000004            .int17_function.regs	set	4
31397 8760           90                               nop
31398                                           ! 5271 endasm
31399                                           !BCC_ENDASM
31400                                           !BCC_EOS
31401                                           ! 5272       outb(addr+2, 
31402                                           ! 5272 val8 | 0x04);
31403                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
31404 8761           8A46         FB            mov	al,-5[bp]
31405 8764           0C                     04  or	al,*4
31406                                           ! Debug: list unsigned char = al+0 (used reg = )
31407 8766           30E4                       xor	ah,ah
31408 8768           50                         push	ax
31409                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31410 8769           8B46         FE            mov	ax,-2[bp]
31411                                           ! Debug: list unsigned int = ax+2 (used reg = )
31412 876C           40                         inc	ax
31413 876D           40                         inc	ax
31414 876E           50                         push	ax
31415                                           ! Debug: func () void = outb+0 (used reg = )
31416 876F           E8         7DCD            call	_outb
31417 8772           83C4                   04  add	sp,*4
31418                                           !BCC_EOS
31419                                           ! 5273     }
31420                                           ! 5274     val8 = inb(addr+1);
31421                       00008775            .77B:
31422                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31423 8775           8B46         FE            mov	ax,-2[bp]
31424                                           ! Debug: list unsigned int = ax+1 (used reg = )
31425 8778           40                         inc	ax
31426 8779           50                         push	ax
31427                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31428 877A           E8         7DAC            call	_inb
31429 877D           44                         inc	sp
31430 877E           44                         inc	sp
31431                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31432 877F           8846         FB            mov	-5[bp],al
31433                                           !BCC_EOS
31434                                           ! 5275     regs.u.r8.ah = (val8 ^ 0x48);
31435                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
31436 8782           8A46         FB            mov	al,-5[bp]
31437 8785           34                     48  xor	al,*$48
31438                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
31439 8787           8846         13            mov	$13[bp],al
31440                                           !BCC_EOS
31441                                           ! 5276     if (!timeout) regs.u.r8.ah |= 0x01;
31442 878A           8B46         FC            mov	ax,-4[bp]
31443 878D           85C0                       test	ax,ax
31444 878F           75           08            jne 	.77D
31445                       00008791            .77E:
31446                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31447 8791           8A46         13            mov	al,$13[bp]
31448 8794           0C                     01  or	al,*1
31449 8796           8846         13            mov	$13[bp],al
31450                                           !BCC_EOS
31451                                           ! 5277     iret_addr.flags.u.r8.flagsl &= 0xfe;
31452                       00008799            .77D:
31453                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
31454 8799           8A46         1A            mov	al,$1A[bp]
31455 879C           24                     FE  and	al,#$FE
31456 879E           8846         1A            mov	$1A[bp],al
31457                                           !BCC_EOS
31458                                           ! 5278   } else {
31459 87A1           EB           08            jmp .77F
31460                       000087A3            .770:
31461                                           ! 5279     iret_addr.flags.u.r8.flagsl |= 0x01;
31462                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
31463 87A3           8A46         1A            mov	al,$1A[bp]
31464 87A6           0C                     01  or	al,*1
31465 87A8           8846         1A            mov	$1A[bp],al
31466                                           !BCC_EOS
31467                                           ! 5280   }
31468                                           ! 5281 }
31469                       000087AB            .77F:
31470 87AB           89EC                       mov	sp,bp
31471 87AD           5D                         pop	bp
31472 87AE           C3                         ret
31473                                           ! 5282 void
31474                                           ! Register BX used in function int17_function
31475                                           ! 5283 int19_function(seq_nr)
31476                                           ! 5284 Bit16u seq_nr;
31477                                           export	_int19_function
31478                       000087AF            _int19_function:
31479                                           !BCC_EOS
31480                                           ! 5285 {
31481                                           ! 5286   Bit16u ebda_seg=*((Bit16u *)(0x040E));
31482 87AF           55                         push	bp
31483 87B0           89E5                       mov	bp,sp
31484 87B2           4C                         dec	sp
31485 87B3           4C                         dec	sp
31486                                           ! Debug: eq unsigned short = [+$40E] to unsigned short ebda_seg = [S+4-4] (used reg = )
31487 87B4           A1         040E            mov	ax,[$40E]
31488 87B7           8946         FE            mov	-2[bp],ax
31489                                           !BCC_EOS
31490                                           ! 5287   Bit16u bootdev;
31491                                           !BCC_EOS
31492                                           ! 5288   Bit8u bootdrv;
31493                                           !BCC_EOS
31494                                           ! 5289   Bit8u bootchk;
31495                                           !BCC_EOS
31496                                           ! 5290   Bit16u bootseg;
31497                                           !BCC_EOS
31498                                           ! 5291   Bit16u bootip;
31499                                           !BCC_EOS
31500                                           ! 5292   Bit16u status;
31501                                           !BCC_EOS
31502                                           ! 5293   Bit16u bootfirst;
31503                                           !BCC_EOS
31504                                           ! 5294   ipl_entry_t e;
31505                                           !BCC_EOS
31506                                           ! 5295   bootdev = inb_cmos(0x3d);
31507 87BA           83C4                   E4  add	sp,*-$1C
31508                                           ! Debug: list int = const $3D (used reg = )
31509 87BD           B8                   003D  mov	ax,*$3D
31510 87C0           50                         push	ax
31511                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31512 87C1           E8         7DAA            call	_inb_cmos
31513 87C4           44                         inc	sp
31514 87C5           44                         inc	sp
31515                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31516 87C6           30E4                       xor	ah,ah
31517 87C8           8946         FC            mov	-4[bp],ax
31518                                           !BCC_EOS
31519                                           ! 5296   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
31520                                           ! Debug: list int = const $38 (used reg = )
31521 87CB           B8                   0038  mov	ax,*$38
31522 87CE           50                         push	ax
31523                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31524 87CF           E8         7D9C            call	_inb_cmos
31525 87D2           44                         inc	sp
31526 87D3           44                         inc	sp
31527                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
31528 87D4           24                     F0  and	al,#$F0
31529                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
31530 87D6           30E4                       xor	ah,ah
31531 87D8           B1                     04  mov	cl,*4
31532 87DA           D3E0                       shl	ax,cl
31533                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31534 87DC           0B46         FC            or	ax,-4[bp]
31535 87DF           8946         FC            mov	-4[bp],ax
31536                                           !BCC_EOS
31537                                           ! 5297   bootdev >>= 4 * seq_nr;
31538                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
31539                                           ! Debug: expression subtree swapping
31540 87E2           8B46         04            mov	ax,4[bp]
31541 87E5           D1E0                       shl	ax,*1
31542 87E7           D1E0                       shl	ax,*1
31543                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31544 87E9           89C3                       mov	bx,ax
31545 87EB           8B46         FC            mov	ax,-4[bp]
31546 87EE           89D9                       mov	cx,bx
31547 87F0           D3E8                       shr	ax,cl
31548 87F2           8946         FC            mov	-4[bp],ax
31549                                           !BCC_EOS
31550                                           ! 5298   bootdev &= 0xf;
31551                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
31552 87F5           8A46         FC            mov	al,-4[bp]
31553 87F8           24                     0F  and	al,*$F
31554 87FA           30E4                       xor	ah,ah
31555 87FC           8946         FC            mov	-4[bp],ax
31556                                           !BCC_EOS
31557                                           ! 5299   bootfirst = _read_word(0x0084, 0x9ff0);
31558                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31559 87FF           B8                   9FF0  mov	ax,#$9FF0
31560 8802           50                         push	ax
31561                                           ! Debug: list int = const $84 (used reg = )
31562 8803           B8                   0084  mov	ax,#$84
31563 8806           50                         push	ax
31564                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31565 8807           E8         7DE3            call	__read_word
31566 880A           83C4                   04  add	sp,*4
31567                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
31568 880D           8946         F2            mov	-$E[bp],ax
31569                                           !BCC_EOS
31570                                           ! 5300   if (bootfirst != 0xFFFF) {
31571                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
31572 8810           8B46         F2            mov	ax,-$E[bp]
31573 8813           3D                   FFFF  cmp	ax,#$FFFF
31574 8816           74           2C            je  	.780
31575                       00008818            .781:
31576                                           ! 5301     bootdev = bootfirst;
31577                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
31578 8818           8B46         F2            mov	ax,-$E[bp]
31579 881B           8946         FC            mov	-4[bp],ax
31580                                           !BCC_EOS
31581                                           ! 5302     _write_word(0xFFFF, 0x0084, 0x9ff0);
31582                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31583 881E           B8                   9FF0  mov	ax,#$9FF0
31584 8821           50                         push	ax
31585                                           ! Debug: list int = const $84 (used reg = )
31586 8822           B8                   0084  mov	ax,#$84
31587 8825           50                         push	ax
31588                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31589 8826           B8                   FFFF  mov	ax,#$FFFF
31590 8829           50                         push	ax
31591                                           ! Debug: func () void = _write_word+0 (used reg = )
31592 882A           E8         7DE1            call	__write_word
31593 882D           83C4                   06  add	sp,*6
31594                                           !BCC_EOS
31595                                           ! 5303     _write_word(0xFFFF, 0x0082, 0x9ff0);
31596                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31597 8830           B8                   9FF0  mov	ax,#$9FF0
31598 8833           50                         push	ax
31599                                           ! Debug: list int = const $82 (used reg = )
31600 8834           B8                   0082  mov	ax,#$82
31601 8837           50                         push	ax
31602                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31603 8838           B8                   FFFF  mov	ax,#$FFFF
31604 883B           50                         push	ax
31605                                           ! Debug: func () void = _write_word+0 (used reg = )
31606 883C           E8         7DCF            call	__write_word
31607 883F           83C4                   06  add	sp,*6
31608                                           !BCC_EOS
31609                                           ! 5304   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
31610 8842           EB           15            jmp .782
31611                       00008844            .780:
31612                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
31613 8844           8B46         FC            mov	ax,-4[bp]
31614 8847           85C0                       test	ax,ax
31615 8849           75           0E            jne 	.783
31616                       0000884B            .784:
31617                                           ! Debug: list * char = .785+0 (used reg = )
31618 884B           BB                   CD11  mov	bx,#.785
31619 884E           53                         push	bx
31620                                           ! Debug: list int = const 7 (used reg = )
31621 884F           B8                   0007  mov	ax,*7
31622 8852           50                         push	ax
31623                                           ! Debug: func () void = bios_printf+0 (used reg = )
31624 8853           E8         80E3            call	_bios_printf
31625 8856           83C4                   04  add	sp,*4
31626                                           !BCC_EOS
31627                                           ! 5305   bootdev -= 1;
31628                       00008859            .783:
31629                       00008859            .782:
31630                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
31631 8859           8B46         FC            mov	ax,-4[bp]
31632 885C           48                         dec	ax
31633 885D           8946         FC            mov	-4[bp],ax
31634                                           !BCC_EOS
31635                                           ! 5306   if (get_boot_vector(bootdev, &e) == 0) {
31636                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31637 8860           8D5E         E2            lea	bx,-$1E[bp]
31638 8863           53                         push	bx
31639                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
31640 8864           FF76         FC            push	-4[bp]
31641                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
31642 8867           E8         8AFF            call	_get_boot_vector
31643 886A           83C4                   04  add	sp,*4
31644                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
31645 886D           84C0                       test	al,al
31646 886F           75           15            jne 	.786
31647                       00008871            .787:
31648                                           ! 5307     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
31649                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
31650 8871           FF76         FC            push	-4[bp]
31651                                           ! Debug: list * char = .788+0 (used reg = )
31652 8874           BB                   CCF5  mov	bx,#.788
31653 8877           53                         push	bx
31654                                           ! Debug: list int = const 4 (used reg = )
31655 8878           B8                   0004  mov	ax,*4
31656 887B           50                         push	ax
31657                                           ! Debug: func () void = bios_printf+0 (used reg = )
31658 887C           E8         80BA            call	_bios_printf
31659 887F           83C4                   06  add	sp,*6
31660                                           !BCC_EOS
31661                                           ! 5308     return;
31662 8882           89EC                       mov	sp,bp
31663 8884           5D                         pop	bp
31664 8885           C3                         ret
31665                                           !BCC_EOS
31666                                           ! 5309   }
31667                                           ! 5310   print_boot_device(&e);
31668                       00008886            .786:
31669                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31670 8886           8D5E         E2            lea	bx,-$1E[bp]
31671 8889           53                         push	bx
31672                                           ! Debug: func () void = print_boot_device+0 (used reg = )
31673 888A           E8         8D25            call	_print_boot_device
31674 888D           44                         inc	sp
31675 888E           44                         inc	sp
31676                                           !BCC_EOS
31677                                           ! 5311   switch(e.type) {
31678 888F           8B46         E2            mov	ax,-$1E[bp]
31679 8892           E9         0106            br 	.78B
31680                                           ! 5312   case 0x01:
31681                                           ! 5313   case 0x02:
31682                       00008895            .78C:
31683                                           ! 5314     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
31684                       00008895            .78D:
31685                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
31686 8895           8B46         E2            mov	ax,-$1E[bp]
31687 8898           3D                   0002  cmp	ax,*2
31688 889B           75           04            jne 	.78E
31689                       0000889D            .78F:
31690 889D           B0                     80  mov	al,#$80
31691 889F           EB           02            jmp .790
31692                       000088A1            .78E:
31693 88A1           30C0                       xor	al,al
31694                       000088A3            .790:
31695                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
31696 88A3           8846         FB            mov	-5[bp],al
31697                                           !BCC_EOS
31698                                           ! 5315     bootseg = 0x07c0;
31699                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31700 88A6           B8                   07C0  mov	ax,#$7C0
31701 88A9           8946         F8            mov	-8[bp],ax
31702                                           !BCC_EOS
31703                                           ! 5316     status = 0;
31704                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31705 88AC           31C0                       xor	ax,ax
31706 88AE           8946         F4            mov	-$C[bp],ax
31707                                           !BCC_EOS
31708                                           ! 5317 #asm
31709                                           !BCC_EOS
31710                                           !BCC_ASM
31711                       00000014            _int19_function.bootip	set	$14
31712                       FFFFFFF6            .int19_function.bootip	set	-$A
31713                       00000022            _int19_function.seq_nr	set	$22
31714                       00000004            .int19_function.seq_nr	set	4
31715                       00000018            _int19_function.bootchk	set	$18
31716                       FFFFFFFA            .int19_function.bootchk	set	-6
31717                       00000016            _int19_function.bootseg	set	$16
31718                       FFFFFFF8            .int19_function.bootseg	set	-8
31719                       0000001C            _int19_function.ebda_seg	set	$1C
31720                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31721                       00000012            _int19_function.status	set	$12
31722                       FFFFFFF4            .int19_function.status	set	-$C
31723                       00000010            _int19_function.bootfirst	set	$10
31724                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31725                       00000019            _int19_function.bootdrv	set	$19
31726                       FFFFFFFB            .int19_function.bootdrv	set	-5
31727                       0000001A            _int19_function.bootdev	set	$1A
31728                       FFFFFFFC            .int19_function.bootdev	set	-4
31729                       00000000            _int19_function.e	set	0
31730                       FFFFFFE2            .int19_function.e	set	-$1E
31731 88B1           55                             push bp
31732 88B2           89E5                           mov bp, sp
31733 88B4           50                             push ax
31734 88B5           53                             push bx
31735 88B6           51                             push cx
31736 88B7           52                             push dx
31737 88B8           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
31738 88BB           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
31739 88BE           8EC0                           mov es, ax ;; segment
31740 88C0           31DB                           xor bx, bx ;; offset
31741 88C2           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
31742 88C4           B0                     01      mov al, #0x01 ;; read 1 sector
31743 88C6           B5                     00      mov ch, #0x00 ;; track 0
31744 88C8           B1                     01      mov cl, #0x01 ;; sector 1
31745 88CA           B6                     00      mov dh, #0x00 ;; head 0
31746 88CC           CD                     13      int #0x13 ;; read sector
31747 88CE           73           06                jnc int19_load_done
31748 88D0           B8                   0001      mov ax, #0x0001
31749 88D3           8946         14                mov _int19_function.status + 2[bp], ax
31750                       000088D6            int19_load_done:
31751 88D6           5A                             pop dx
31752 88D7           59                             pop cx
31753 88D8           5B                             pop bx
31754 88D9           58                             pop ax
31755 88DA           5D                             pop bp
31756                                           ! 5343 endasm
31757                                           !BCC_ENDASM
31758                                           !BCC_EOS
31759                                           ! 5344     if (status != 0) {
31760                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31761 88DB           8B46         F4            mov	ax,-$C[bp]
31762 88DE           85C0                       test	ax,ax
31763 88E0           74           11            je  	.791
31764                       000088E2            .792:
31765                                           ! 5345       print_boot_failure(e.type, 1);
31766                                           ! Debug: list int = const 1 (used reg = )
31767 88E2           B8                   0001  mov	ax,*1
31768 88E5           50                         push	ax
31769                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31770 88E6           FF76         E2            push	-$1E[bp]
31771                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31772 88E9           E8         8D90            call	_print_boot_failure
31773 88EC           83C4                   04  add	sp,*4
31774                                           !BCC_EOS
31775                                           ! 5346       return;
31776 88EF           89EC                       mov	sp,bp
31777 88F1           5D                         pop	bp
31778 88F2           C3                         ret
31779                                           !BCC_EOS
31780                                           ! 5347     }
31781                                           ! 5348     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
31782                       000088F3            .791:
31783                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
31784 88F3           8B46         E2            mov	ax,-$1E[bp]
31785 88F6           3D                   0001  cmp	ax,*1
31786 88F9           75           0F            jne 	.794
31787                       000088FB            .795:
31788                                           ! Debug: list int = const $38 (used reg = )
31789 88FB           B8                   0038  mov	ax,*$38
31790 88FE           50                         push	ax
31791                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31792 88FF           E8         7C6C            call	_inb_cmos
31793 8902           44                         inc	sp
31794 8903           44                         inc	sp
31795                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
31796 8904           24                     01  and	al,*1
31797 8906           84C0                       test	al,al
31798 8908           75           22            jne 	.793
31799                       0000890A            .794:
31800                                           ! 5349       if (_read_word(0x1fe, bootseg) != 0xaa55) {
31801                                           ! Debug: list unsigned short bootseg = [S+$20-$A] (used reg = )
31802 890A           FF76         F8            push	-8[bp]
31803                                           ! Debug: list int = const $1FE (used reg = )
31804 890D           B8                   01FE  mov	ax,#$1FE
31805 8910           50                         push	ax
31806                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31807 8911           E8         7CD9            call	__read_word
31808 8914           83C4                   04  add	sp,*4
31809                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
31810 8917           3D                   AA55  cmp	ax,#$AA55
31811 891A           74           10            je  	.796
31812                       0000891C            .797:
31813                                           ! 5350         print_boot_failure(e.type, 0);
31814                                           ! Debug: list int = const 0 (used reg = )
31815 891C           31C0                       xor	ax,ax
31816 891E           50                         push	ax
31817                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31818 891F           FF76         E2            push	-$1E[bp]
31819                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31820 8922           E8         8D57            call	_print_boot_failure
31821 8925           83C4                   04  add	sp,*4
31822                                           !BCC_EOS
31823                                           ! 5351         return;
31824 8928           89EC                       mov	sp,bp
31825 892A           5D                         pop	bp
31826 892B           C3                         ret
31827                                           !BCC_EOS
31828                                           ! 5352       }
31829                                           ! 5353     }
31830                       0000892C            .796:
31831                                           ! 5354     bootip = (bootseg & 0x0fff) << 4;
31832                       0000892C            .793:
31833                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
31834 892C           8B46         F8            mov	ax,-8[bp]
31835 892F           25                   0FFF  and	ax,#$FFF
31836                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
31837 8932           B1                     04  mov	cl,*4
31838 8934           D3E0                       shl	ax,cl
31839                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
31840 8936           8946         F6            mov	-$A[bp],ax
31841                                           !BCC_EOS
31842                                           ! 5355     bootseg &= 0xf000;
31843                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
31844 8939           8B46         F8            mov	ax,-8[bp]
31845 893C           25                   F000  and	ax,#$F000
31846 893F           8946         F8            mov	-8[bp],ax
31847                                           !BCC_EOS
31848                                           ! 5356   break;
31849 8942           EB           71            jmp .789
31850                                           !BCC_EOS
31851                                           ! 5357   case 0x03:
31852                                           ! 5358     status
31853                                           ! 5358  = cdrom_boot();
31854                       00008944            .798:
31855                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
31856 8944           E8         AC6C            call	_cdrom_boot
31857                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
31858 8947           8946         F4            mov	-$C[bp],ax
31859                                           !BCC_EOS
31860                                           ! 5359     if ( (status & 0x00ff) !=0 ) {
31861                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
31862 894A           8A46         F4            mov	al,-$C[bp]
31863                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31864 894D           84C0                       test	al,al
31865 894F           74           19            je  	.799
31866                       00008951            .79A:
31867                                           ! 5360       print_cdromboot_failure(status);
31868                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
31869 8951           FF76         F4            push	-$C[bp]
31870                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
31871 8954           E8         8D8B            call	_print_cdromboot_failure
31872 8957           44                         inc	sp
31873 8958           44                         inc	sp
31874                                           !BCC_EOS
31875                                           ! 5361       print_boot_failure(e.type, 1);
31876                                           ! Debug: list int = const 1 (used reg = )
31877 8959           B8                   0001  mov	ax,*1
31878 895C           50                         push	ax
31879                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31880 895D           FF76         E2            push	-$1E[bp]
31881                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31882 8960           E8         8D19            call	_print_boot_failure
31883 8963           83C4                   04  add	sp,*4
31884                                           !BCC_EOS
31885                                           ! 5362       return;
31886 8966           89EC                       mov	sp,bp
31887 8968           5D                         pop	bp
31888 8969           C3                         ret
31889                                           !BCC_EOS
31890                                           ! 5363     }
31891                                           ! 5364     bootdrv = *(((Bit8u *)&status)+1);
31892                       0000896A            .799:
31893                                           ! Debug: eq unsigned char status = [S+$20-$D] to unsigned char bootdrv = [S+$20-7] (used reg = )
31894 896A           8A46         F5            mov	al,-$B[bp]
31895 896D           8846         FB            mov	-5[bp],al
31896                                           !BCC_EOS
31897                                           ! 5365     bootseg = _read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg);
31898                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
31899 8970           FF76         FE            push	-2[bp]
31900                                           ! Debug: list * unsigned short = const $266 (used reg = )
31901 8973           B8                   0266  mov	ax,#$266
31902 8976           50                         push	ax
31903                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31904 8977           E8         7C73            call	__read_word
31905 897A           83C4                   04  add	sp,*4
31906                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31907 897D           8946         F8            mov	-8[bp],ax
31908                                           !BCC_EOS
31909                                           ! 5366     bootip = 0;
31910                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
31911 8980           31C0                       xor	ax,ax
31912 8982           8946         F6            mov	-$A[bp],ax
31913                                           !BCC_EOS
31914                                           ! 5367     break;
31915 8985           EB           2E            jmp .789
31916                                           !BCC_EOS
31917                                           ! 5368   case 0x80:
31918                                           ! 5369     bootseg = *(((Bit16u *)&e.vector)+1);
31919                       00008987            .79B:
31920                                           ! Debug: eq unsigned short e = [S+$20-$1A] to unsigned short bootseg = [S+$20-$A] (used reg = )
31921 8987           8B46         E8            mov	ax,-$18[bp]
31922 898A           8946         F8            mov	-8[bp],ax
31923                                           !BCC_EOS
31924                                           ! 5370     bootip = *((Bit16u *)&e.vector);
31925                                           ! Debug: eq unsigned short e = [S+$20-$1C] to unsigned short bootip = [S+$20-$C] (used reg = )
31926 898D           8B46         E6            mov	ax,-$1A[bp]
31927 8990           8946         F6            mov	-$A[bp],ax
31928                                           !BCC_EOS
31929                                           ! 5371     break;
31930 8993           EB           20            jmp .789
31931                                           !BCC_EOS
31932                                           ! 5372   default: return;
31933                       00008995            .79C:
31934 8995           89EC                       mov	sp,bp
31935 8997           5D                         pop	bp
31936 8998           C3                         ret
31937                                           !BCC_EOS
31938                                           ! 5373   }
31939                                           ! 5374   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
31940 8999           EB           1A            jmp .789
31941                       0000899B            .78B:
31942 899B           2D                   0001  sub	ax,*1
31943 899E         0F84         FEF3            beq 	.78C
31944 89A2           2D                   0001  sub	ax,*1
31945 89A5         0F84         FEEC            beq 	.78D
31946 89A9           2D                   0001  sub	ax,*1
31947 89AC           74           96            je 	.798
31948 89AE           2D                   007D  sub	ax,*$7D
31949 89B1           74           D4            je 	.79B
31950 89B3           EB           E0            jmp	.79C
31951                       000089B5            .789:
31952                       FFFFFFE0            ..FFD9	=	-$20
31953                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
31954 89B5           FF76         F6            push	-$A[bp]
31955                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
31956 89B8           FF76         F8            push	-8[bp]
31957                                           ! Debug: list * char = .79D+0 (used reg = )
31958 89BB           BB                   CCE1  mov	bx,#.79D
31959 89BE           53                         push	bx
31960                                           ! Debug: list int = const 4 (used reg = )
31961 89BF           B8                   0004  mov	ax,*4
31962 89C2           50                         push	ax
31963                                           ! Debug: func () void = bios_printf+0 (used reg = )
31964 89C3           E8         7F73            call	_bios_printf
31965 89C6           83C4                   08  add	sp,*8
31966                                           !BCC_EOS
31967                                           ! 5375 #asm
31968                                           !BCC_EOS
31969                                           !BCC_ASM
31970                       00000014            _int19_function.bootip	set	$14
31971                       FFFFFFF6            .int19_function.bootip	set	-$A
31972                       00000022            _int19_function.seq_nr	set	$22
31973                       00000004            .int19_function.seq_nr	set	4
31974                       00000018            _int19_function.bootchk	set	$18
31975                       FFFFFFFA            .int19_function.bootchk	set	-6
31976                       00000016            _int19_function.bootseg	set	$16
31977                       FFFFFFF8            .int19_function.bootseg	set	-8
31978                       0000001C            _int19_function.ebda_seg	set	$1C
31979                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31980                       00000012            _int19_function.status	set	$12
31981                       FFFFFFF4            .int19_function.status	set	-$C
31982                       00000010            _int19_function.bootfirst	set	$10
31983                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31984                       00000019            _int19_function.bootdrv	set	$19
31985                       FFFFFFFB            .int19_function.bootdrv	set	-5
31986                       0000001A            _int19_function.bootdev	set	$1A
31987                       FFFFFFFC            .int19_function.bootdev	set	-4
31988                       00000000            _int19_function.e	set	0
31989                       FFFFFFE2            .int19_function.e	set	-$1E
31990 89C9           89E5                           mov bp, sp
31991 89CB           0E                             push cs
31992 89CC           68                   8F51      push #int18_handler
31993                                               ;; Build an iret stack frame that will take us to the boot vector.
31994                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
31995 89CF           9C                             pushf
31996 89D0           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
31997 89D3           50                             push ax
31998 89D4           8B46         14                mov ax, _int19_function.bootip + 0[bp]
31999 89D7           50                             push ax
32000                                               ;; Set the magic number in ax and the boot drive in dl.
32001 89D8           B8                   AA55      mov ax, #0xaa55
32002 89DB           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
32003                                               ;; Zero some of the other registers.
32004 89DE           31DB                           xor bx, bx
32005 89E0           8EDB                           mov ds, bx
32006 89E2           8EC3                           mov es, bx
32007 89E4           89DD                           mov bp, bx
32008                                               ;; Go!
32009 89E6           CF                             iret
32010                                           ! 5396 endasm
32011                                           !BCC_ENDASM
32012                                           !BCC_EOS
32013                                           ! 5397 }
32014 89E7           89EC                       mov	sp,bp
32015 89E9           5D                         pop	bp
32016 89EA           C3                         ret
32017                                           ! 5398   void
32018                                           ! Register BX used in function int19_function
32019                                           ! 5399 int1a_function(regs, ds, iret_addr)
32020                                           ! 5400   pusha_regs_t regs;
32021                                           export	_int1a_function
32022                       000089EB            _int1a_function:
32023                                           !BCC_EOS
32024                                           ! 5401   Bit16u ds;
32025                                           !BCC_EOS
32026                                           ! 5402   iret_addr_t iret_addr;
32027                                           !BCC_EOS
32028                                           ! 5403 {
32029                                           ! 5404   Bit8u val8;
32030                                           !BCC_EOS
32031                                           ! 5405   ;
32032 89EB           55                         push	bp
32033 89EC           89E5                       mov	bp,sp
32034 89EE           4C                         dec	sp
32035 89EF           4C                         dec	sp
32036                                           !BCC_EOS
32037                                           ! 5406 #asm
32038                                           !BCC_EOS
32039                                           !BCC_ASM
32040                       00000016            _int1a_function.ds	set	$16
32041                       00000014            .int1a_function.ds	set	$14
32042                       00000001            _int1a_function.val8	set	1
32043                       FFFFFFFF            .int1a_function.val8	set	-1
32044                       00000018            _int1a_function.iret_addr	set	$18
32045                       00000016            .int1a_function.iret_addr	set	$16
32046                       00000006            _int1a_function.regs	set	6
32047                       00000004            .int1a_function.regs	set	4
32048 89F0           FB                           sti
32049                                           ! 5408 endasm
32050                                           !BCC_ENDASM
32051                                           !BCC_EOS
32052                                           ! 5409   switch (regs.u.r8.ah) {
32053 89F1           8A46         13            mov	al,$13[bp]
32054 89F4           E9         036E            br 	.7A0
32055                                           ! 5410     case 0:
32056                                           ! 5411 #asm
32057                       000089F7            .7A1:
32058                                           !BCC_EOS
32059                                           !BCC_ASM
32060                       00000016            _int1a_function.ds	set	$16
32061                       00000014            .int1a_function.ds	set	$14
32062                       00000001            _int1a_function.val8	set	1
32063                       FFFFFFFF            .int1a_function.val8	set	-1
32064                       00000018            _int1a_function.iret_addr	set	$18
32065                       00000016            .int1a_function.iret_addr	set	$16
32066                       00000006            _int1a_function.regs	set	6
32067                       00000004            .int1a_function.regs	set	4
32068 89F7           FA                               cli
32069                                           ! 5413 endasm
32070                                           !BCC_ENDASM
32071                                           !BCC_EOS
32072                                           ! 5414       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
32073                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
32074 89F8           A1         046E            mov	ax,[$46E]
32075 89FB           8946         10            mov	$10[bp],ax
32076                                           !BCC_EOS
32077                                           ! 5415       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
32078                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
32079 89FE           A1         046C            mov	ax,[$46C]
32080 8A01           8946         0E            mov	$E[bp],ax
32081                                           !BCC_EOS
32082                                           ! 5416       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
32083                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
32084 8A04           A0         0470            mov	al,[$470]
32085 8A07           8846         12            mov	$12[bp],al
32086                                           !BCC_EOS
32087                                           ! 5417       ((bios_data_t *) 0)->midnight_flag = 0;
32088                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32089 8A0A           30C0                       xor	al,al
32090 8A0C           A2         0470            mov	[$470],al
32091                                           !BCC_EOS
32092                                           ! 5418 #asm
32093                                           !BCC_EOS
32094                                           !BCC_ASM
32095                       00000016            _int1a_function.ds	set	$16
32096                       00000014            .int1a_function.ds	set	$14
32097                       00000001            _int1a_function.val8	set	1
32098                       FFFFFFFF            .int1a_function.val8	set	-1
32099                       00000018            _int1a_function.iret_addr	set	$18
32100                       00000016            .int1a_function.iret_addr	set	$16
32101                       00000006            _int1a_function.regs	set	6
32102                       00000004            .int1a_function.regs	set	4
32103 8A0F           FB                               sti
32104                                           ! 5420 endasm
32105                                           !BCC_ENDASM
32106                                           !BCC_EOS
32107                                           ! 5421       iret_addr.flags.u.r8.flagsl &= 0xfe;
32108                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32109 8A10           8A46         1A            mov	al,$1A[bp]
32110 8A13           24                     FE  and	al,#$FE
32111 8A15           8846         1A            mov	$1A[bp],al
32112                                           !BCC_EOS
32113                                           ! 5422       break;
32114 8A18           E9         0375            br 	.79E
32115                                           !BCC_EOS
32116                                           ! 5423     case 1:
32117                                           ! 5424 #asm
32118                       00008A1B            .7A2:
32119                                           !BCC_EOS
32120                                           !BCC_ASM
32121                       00000016            _int1a_function.ds	set	$16
32122                       00000014            .int1a_function.ds	set	$14
32123                       00000001            _int1a_function.val8	set	1
32124                       FFFFFFFF            .int1a_function.val8	set	-1
32125                       00000018            _int1a_function.iret_addr	set	$18
32126                       00000016            .int1a_function.iret_addr	set	$16
32127                       00000006            _int1a_function.regs	set	6
32128                       00000004            .int1a_function.regs	set	4
32129 8A1B           FA                               cli
32130                                           ! 5426 endasm
32131                                           !BCC_ENDASM
32132                                           !BCC_EOS
32133                                           ! 5427       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
32134                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
32135 8A1C           8B46         10            mov	ax,$10[bp]
32136 8A1F           A3         046E            mov	[$46E],ax
32137                                           !BCC_EOS
32138                                           ! 5428       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
32139                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
32140 8A22           8B46         0E            mov	ax,$E[bp]
32141 8A25           A3         046C            mov	[$46C],ax
32142                                           !BCC_EOS
32143                                           ! 5429       ((bios_data_t *) 0)->midnight_flag = 0;
32144                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32145 8A28           30C0                       xor	al,al
32146 8A2A           A2         0470            mov	[$470],al
32147                                           !BCC_EOS
32148                                           ! 5430 #asm
32149                                           !BCC_EOS
32150                                           !BCC_ASM
32151                       00000016            _int1a_function.ds	set	$16
32152                       00000014            .int1a_function.ds	set	$14
32153                       00000001            _int1a_function.val8	set	1
32154                       FFFFFFFF            .int1a_function.val8	set	-1
32155                       00000018            _int1a_function.iret_addr	set	$18
32156                       00000016            .int1a_function.iret_addr	set	$16
32157                       00000006            _int1a_function.regs	set	6
32158                       00000004            .int1a_function.regs	set	4
32159 8A2D           FB                               sti
32160                                           ! 5432 endasm
32161                                           !BCC_ENDASM
32162                                           !BCC_EOS
32163                                           ! 5433       regs.u.r8.ah = 0;
32164                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32165 8A2E           30C0                       xor	al,al
32166 8A30           8846         13            mov	$13[bp],al
32167                                           !BCC_EOS
32168                                           ! 5434       iret_addr.flags.u.r8.flagsl &= 0xfe;
32169                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32170 8A33           8A46         1A            mov	al,$1A[bp]
32171 8A36           24                     FE  and	al,#$FE
32172 8A38           8846         1A            mov	$1A[bp],al
32173                                           !BCC_EOS
32174                                           ! 5435       break;
32175 8A3B           E9         0352            br 	.79E
32176                                           !BCC_EOS
32177                                           ! 5436     case 2:
32178                                           ! 5437       if (rtc_updating()) {
32179                       00008A3E            .7A3:
32180                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32181 8A3E           E8         7B6A            call	_rtc_updating
32182 8A41           85C0                       test	ax,ax
32183 8A43           74           0B            je  	.7A4
32184                       00008A45            .7A5:
32185                                           ! 5438         iret_addr.flags.u.r8.flagsl |= 0x01;
32186                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32187 8A45           8A46         1A            mov	al,$1A[bp]
32188 8A48           0C                     01  or	al,*1
32189 8A4A           8846         1A            mov	$1A[bp],al
32190                                           !BCC_EOS
32191                                           ! 5439         break;
32192 8A4D           E9         0340            br 	.79E
32193                                           !BCC_EOS
32194                                           ! 5440       }
32195                                           ! 5441       regs.u.r8.dh = inb_cmos(0x00);
32196                       00008A50            .7A4:
32197                                           ! Debug: list int = const 0 (used reg = )
32198 8A50           31C0                       xor	ax,ax
32199 8A52           50                         push	ax
32200                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32201 8A53           E8         7B18            call	_inb_cmos
32202 8A56           44                         inc	sp
32203 8A57           44                         inc	sp
32204                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32205 8A58           8846         0F            mov	$F[bp],al
32206                                           !BCC_EOS
32207                                           ! 5442       regs.u.r8.cl = inb_cmos(0x02);
32208                                           ! Debug: list int = const 2 (used reg = )
32209 8A5B           B8                   0002  mov	ax,*2
32210 8A5E           50                         push	ax
32211                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32212 8A5F           E8         7B0C            call	_inb_cmos
32213 8A62           44                         inc	sp
32214 8A63           44                         inc	sp
32215                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32216 8A64           8846         10            mov	$10[bp],al
32217                                           !BCC_EOS
32218                                           ! 5443       regs.u.r8.ch = i
32219                                           ! 5443 nb_cmos(0x04);
32220                                           ! Debug: list int = const 4 (used reg = )
32221 8A67           B8                   0004  mov	ax,*4
32222 8A6A           50                         push	ax
32223                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32224 8A6B           E8         7B00            call	_inb_cmos
32225 8A6E           44                         inc	sp
32226 8A6F           44                         inc	sp
32227                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32228 8A70           8846         11            mov	$11[bp],al
32229                                           !BCC_EOS
32230                                           ! 5444       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
32231                                           ! Debug: list int = const $B (used reg = )
32232 8A73           B8                   000B  mov	ax,*$B
32233 8A76           50                         push	ax
32234                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32235 8A77           E8         7AF4            call	_inb_cmos
32236 8A7A           44                         inc	sp
32237 8A7B           44                         inc	sp
32238                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
32239 8A7C           24                     01  and	al,*1
32240                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32241 8A7E           8846         0E            mov	$E[bp],al
32242                                           !BCC_EOS
32243                                           ! 5445       regs.u.r8.ah = 0;
32244                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32245 8A81           30C0                       xor	al,al
32246 8A83           8846         13            mov	$13[bp],al
32247                                           !BCC_EOS
32248                                           ! 5446       regs.u.r8.al = regs.u.r8.ch;
32249                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32250 8A86           8A46         11            mov	al,$11[bp]
32251 8A89           8846         12            mov	$12[bp],al
32252                                           !BCC_EOS
32253                                           ! 5447       iret_addr.flags.u.r8.flagsl &= 0xfe;
32254                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32255 8A8C           8A46         1A            mov	al,$1A[bp]
32256 8A8F           24                     FE  and	al,#$FE
32257 8A91           8846         1A            mov	$1A[bp],al
32258                                           !BCC_EOS
32259                                           ! 5448       break;
32260 8A94           E9         02F9            br 	.79E
32261                                           !BCC_EOS
32262                                           ! 5449     case 3:
32263                                           ! 5450       if (rtc_updating()) {
32264                       00008A97            .7A6:
32265                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32266 8A97           E8         7B11            call	_rtc_updating
32267 8A9A           85C0                       test	ax,ax
32268 8A9C           74           03            je  	.7A7
32269                       00008A9E            .7A8:
32270                                           ! 5451         init_rtc();
32271                                           ! Debug: func () void = init_rtc+0 (used reg = )
32272 8A9E           E8         7AD9            call	_init_rtc
32273                                           !BCC_EOS
32274                                           ! 5452       }
32275                                           ! 5453       outb_cmos(0x00, regs.u.r8.dh);
32276                       00008AA1            .7A7:
32277                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32278 8AA1           8A46         0F            mov	al,$F[bp]
32279 8AA4           30E4                       xor	ah,ah
32280 8AA6           50                         push	ax
32281                                           ! Debug: list int = const 0 (used reg = )
32282 8AA7           31C0                       xor	ax,ax
32283 8AA9           50                         push	ax
32284                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32285 8AAA           E8         7AB2            call	_outb_cmos
32286 8AAD           83C4                   04  add	sp,*4
32287                                           !BCC_EOS
32288                                           ! 5454       outb_cmos(0x02, regs.u.r8.cl);
32289                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32290 8AB0           8A46         10            mov	al,$10[bp]
32291 8AB3           30E4                       xor	ah,ah
32292 8AB5           50                         push	ax
32293                                           ! Debug: list int = const 2 (used reg = )
32294 8AB6           B8                   0002  mov	ax,*2
32295 8AB9           50                         push	ax
32296                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32297 8ABA           E8         7AA2            call	_outb_cmos
32298 8ABD           83C4                   04  add	sp,*4
32299                                           !BCC_EOS
32300                                           ! 5455       outb_cmos(0x04, regs.u.r8.ch);
32301                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32302 8AC0           8A46         11            mov	al,$11[bp]
32303 8AC3           30E4                       xor	ah,ah
32304 8AC5           50                         push	ax
32305                                           ! Debug: list int = const 4 (used reg = )
32306 8AC6           B8                   0004  mov	ax,*4
32307 8AC9           50                         push	ax
32308                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32309 8ACA           E8         7A92            call	_outb_cmos
32310 8ACD           83C4                   04  add	sp,*4
32311                                           !BCC_EOS
32312                                           ! 5456       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
32313                                           ! Debug: expression subtree swapping
32314                                           ! Debug: list int = const $B (used reg = )
32315 8AD0           B8                   000B  mov	ax,*$B
32316 8AD3           50                         push	ax
32317                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32318 8AD4           E8         7A97            call	_inb_cmos
32319 8AD7           44                         inc	sp
32320 8AD8           44                         inc	sp
32321                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
32322 8AD9           24                     60  and	al,*$60
32323                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
32324 8ADB           0C                     02  or	al,*2
32325 8ADD           50                         push	ax
32326                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
32327 8ADE           8A46         0E            mov	al,$E[bp]
32328 8AE1           24                     01  and	al,*1
32329                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
32330 8AE3           0A46         FC            or	al,0+..FFD8[bp]
32331 8AE6           44                         inc	sp
32332 8AE7           44                         inc	sp
32333                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32334 8AE8           8846         FF            mov	-1[bp],al
32335                                           !BCC_EOS
32336                                           ! 5457       outb_cmos(0x0b, val8);
32337                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32338 8AEB           8A46         FF            mov	al,-1[bp]
32339 8AEE           30E4                       xor	ah,ah
32340 8AF0           50                         push	ax
32341                                           ! Debug: list int = const $B (used reg = )
32342 8AF1           B8                   000B  mov	ax,*$B
32343 8AF4           50                         push	ax
32344                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32345 8AF5           E8         7A67            call	_outb_cmos
32346 8AF8           83C4                   04  add	sp,*4
32347                                           !BCC_EOS
32348                                           ! 5458       regs.u.r8.ah = 0;
32349                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32350 8AFB           30C0                       xor	al,al
32351 8AFD           8846         13            mov	$13[bp],al
32352                                           !BCC_EOS
32353                                           ! 5459       regs.u.r8.al = val8;
32354                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32355 8B00           8A46         FF            mov	al,-1[bp]
32356 8B03           8846         12            mov	$12[bp],al
32357                                           !BCC_EOS
32358                                           ! 5460       iret_addr.flags.u.r8.flagsl &= 0xfe;
32359                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32360 8B06           8A46         1A            mov	al,$1A[bp]
32361 8B09           24                     FE  and	al,#$FE
32362 8B0B           8846         1A            mov	$1A[bp],al
32363                                           !BCC_EOS
32364                                           ! 5461       break;
32365 8B0E           E9         027F            br 	.79E
32366                                           !BCC_EOS
32367                                           ! 5462     case 4:
32368                                           ! 5463       regs.u.r8.ah = 0;
32369                       00008B11            .7A9:
32370                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32371 8B11           30C0                       xor	al,al
32372 8B13           8846         13            mov	$13[bp],al
32373                                           !BCC_EOS
32374                                           ! 5464       if (rtc_updating()) {
32375                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32376 8B16           E8         7A92            call	_rtc_updating
32377 8B19           85C0                       test	ax,ax
32378 8B1B           74           0B            je  	.7AA
32379                       00008B1D            .7AB:
32380                                           ! 5465         iret_addr.flags.u.r8.flagsl |= 0x01;
32381                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32382 8B1D           8A46         1A            mov	al,$1A[bp]
32383 8B20           0C                     01  or	al,*1
32384 8B22           8846         1A            mov	$1A[bp],al
32385                                           !BCC_EOS
32386                                           ! 5466         break;
32387 8B25           E9         0268            br 	.79E
32388                                           !BCC_EOS
32389                                           ! 5467       }
32390                                           ! 5468       regs.u.r8.cl = inb_cmos(0x09);
32391                       00008B28            .7AA:
32392                                           ! Debug: list int = const 9 (used reg = )
32393 8B28           B8                   0009  mov	ax,*9
32394 8B2B           50                         push	ax
32395                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32396 8B2C           E8         7A3F            call	_inb_cmos
32397 8B2F           44                         inc	sp
32398 8B30           44                         inc	sp
32399                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32400 8B31           8846         10            mov	$10[bp],al
32401                                           !BCC_EOS
32402                                           ! 5469       regs.u.r8.dh = inb_cmos(0x08);
32403                                           ! Debug: list int = const 8 (used reg = )
32404 8B34           B8                   0008  mov	ax,*8
32405 8B37           50                         push	ax
32406                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32407 8B38           E8         7A33            call	_inb_cmos
32408 8B3B           44                         inc	sp
32409 8B3C           44                         inc	sp
32410                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32411 8B3D           8846         0F            mov	$F[bp],al
32412                                           !BCC_EOS
32413                                           ! 5470       regs.u.r8.dl = inb_cmos(0x07);
32414                                           ! Debug: list int = const 7 (used reg = )
32415 8B40           B8                   0007  mov	ax,*7
32416 8B43           50                         push	ax
32417                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32418 8B44           E8         7A27            call	_inb_cmos
32419 8B47           44                         inc	sp
32420 8B48           44                         inc	sp
32421                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32422 8B49           8846         0E            mov	$E[bp],al
32423                                           !BCC_EOS
32424                                           ! 5471       regs.u.r8.ch = inb_cmos(0x32);
32425                                           ! Debug: list int = const $32 (used reg = )
32426 8B4C           B8                   0032  mov	ax,*$32
32427 8B4F           50                         push	ax
32428                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32429 8B50           E8         7A1B            call	_inb_cmos
32430 8B53           44                         inc	sp
32431 8B54           44                         inc	sp
32432                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32433 8B55           8846         11            mov	$11[bp],al
32434                                           !BCC_EOS
32435                                           ! 5472       regs.u.r8.al = regs.u.r8.ch;
32436                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32437 8B58           8A46         11            mov	al,$11[bp]
32438 8B5B           8846         12            mov	$12[bp],al
32439                                           !BCC_EOS
32440                                           ! 5473       iret_addr.flags.u.r8.flagsl &= 0xfe;
32441                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32442 8B5E           8A46         1A            mov	al,$1A[bp]
32443 8B61           24                     FE  and	al,#$FE
32444 8B63           8846         1A            mov	$1A[bp],al
32445                                           !BCC_EOS
32446                                           ! 5474       break;
32447 8B66           E9         0227            br 	.79E
32448                                           !BCC_EOS
32449                                           ! 5475     case 5:
32450                                           ! 5476       if (rtc_updating()) {
32451                       00008B69            .7AC:
32452                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32453 8B69           E8         7A3F            call	_rtc_updating
32454 8B6C           85C0                       test	ax,ax
32455 8B6E           74           0E            je  	.7AD
32456                       00008B70            .7AE:
32457                                           ! 5477         init_rtc();
32458                                           ! Debug: func () void = init_rtc+0 (used reg = )
32459 8B70           E8         7A07            call	_init_rtc
32460                                           !BCC_EOS
32461                                           ! 5478         iret_addr.flags.u.r8.flagsl |= 0x01;
32462                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32463 8B73           8A46         1A            mov	al,$1A[bp]
32464 8B76           0C                     01  or	al,*1
32465 8B78           8846         1A            mov	$1A[bp],al
32466                                           !BCC_EOS
32467                                           ! 5479         break;
32468 8B7B           E9         0212            br 	.79E
32469                                           !BCC_EOS
32470                                           ! 5480         }
32471                                           ! 5481       outb_cmos(0x09, regs.u.r8.cl);
32472                       00008B7E            .7AD:
32473                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32474 8B7E           8A46         10            mov	al,$10[bp]
32475 8B81           30E4                       xor	ah,ah
32476 8B83           50                         push	ax
32477                                           ! Debug: list int = const 9 (used reg = )
32478 8B84           B8                   0009  mov	ax,*9
32479 8B87           50                         push	ax
32480                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32481 8B88           E8         79D4            call	_outb_cmos
32482 8B8B           83C4                   04  add	sp,*4
32483                                           !BCC_EOS
32484                                           ! 5482       outb_cmos(0x08, regs.u.r8.dh);
32485                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32486 8B8E           8A46         0F            mov	al,$F[bp]
32487 8B91           30E4                       xor	ah,ah
32488 8B93           50                         push	ax
32489                                           ! Debug: list int = const 8 (used reg = )
32490 8B94           B8                   0008  mov	ax,*8
32491 8B97           50                         push	ax
32492                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32493 8B98           E8         79C4            call	_outb_cmos
32494 8B9B           83C4                   04  add	sp,*4
32495                                           !BCC_EOS
32496                                           ! 5483       outb_cmos(0x07, regs.u.r8.dl);
32497                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
32498 8B9E           8A46         0E            mov	al,$E[bp]
32499 8BA1           30E4                       xor	ah,ah
32500 8BA3           50                         push	ax
32501                                           ! Debug: list int = const 7 (used reg = )
32502 8BA4           B8                   0007  mov	ax,*7
32503 8BA7           50                         push	ax
32504                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32505 8BA8           E8         79B4            call	_outb_cmos
32506 8BAB           83C4                   04  add	sp,*4
32507                                           !BCC_EOS
32508                                           ! 5484       outb_cmos(0x32, regs.u.r8.ch);
32509                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32510 8BAE           8A46         11            mov	al,$11[bp]
32511 8BB1           30E4                       xor	ah,ah
32512 8BB3           50                         push	ax
32513                                           ! Debug: list int = const $32 (used reg = )
32514 8BB4           B8                   0032  mov	ax,*$32
32515 8BB7           50                         push	ax
32516                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32517 8BB8           E8         79A4            call	_outb_cmos
32518 8BBB           83C4                   04  add	sp,*4
32519                                           !BCC_EOS
32520                                           ! 5485       val8 = inb_cmos(0x0b) & 0x7f;
32521                                           ! Debug: list int = const $B (used reg = )
32522 8BBE           B8                   000B  mov	ax,*$B
32523 8BC1           50                         push	ax
32524                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32525 8BC2           E8         79A9            call	_inb_cmos
32526 8BC5           44                         inc	sp
32527 8BC6           44                         inc	sp
32528                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
32529 8BC7           24                     7F  and	al,*$7F
32530                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32531 8BC9           8846         FF            mov	-1[bp],al
32532                                           !BCC_EOS
32533                                           ! 5486       outb_cmos(0x0b, val8);
32534                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32535 8BCC           8A46         FF            mov	al,-1[bp]
32536 8BCF           30E4                       xor	ah,ah
32537 8BD1           50                         push	ax
32538                                           ! Debug: list int = const $B (used reg = )
32539 8BD2           B8                   000B  mov	ax,*$B
32540 8BD5           50                         push	ax
32541                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32542 8BD6           E8         7986            call	_outb_cmos
32543 8BD9           83C4                   04  add	sp,*4
32544                                           !BCC_EOS
32545                                           ! 5487       regs.u.r8.ah = 0;
32546                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32547 8BDC           30C0                       xor	al,al
32548 8BDE           8846         13            mov	$13[bp],al
32549                                           !BCC_EOS
32550                                           ! 5488       regs.u.r8.al = val8;
32551                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32552 8BE1           8A46         FF            mov	al,-1[bp]
32553 8BE4           8846         12            mov	$12[bp],al
32554                                           !BCC_EOS
32555                                           ! 5489       iret_addr.flags.u.r8.flagsl &= 0xfe;
32556                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32557 8BE7           8A46         1A            mov	al,$1A[bp]
32558 8BEA           24                     FE  and	al,#$FE
32559 8BEC           8846         1A            mov	$1A[bp],al
32560                                           !BCC_EOS
32561                                           ! 5490       break;
32562 8BEF           E9         019E            br 	.79E
32563                                           !BCC_EOS
32564                                           ! 5491     case 6:
32565                                           ! 5492       val8 = inb_cmos(0x0b);
32566                       00008BF2            .7AF:
32567                                           ! Debug: list int = const $B (used reg = )
32568 8BF2           B8                   000B  mov	ax,*$B
32569 8BF5           50                         push	ax
32570                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32571 8BF6           E8         7975            call	_inb_cmos
32572 8BF9           44                         inc	sp
32573 8BFA           44                         inc	sp
32574                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32575 8BFB           8846         FF            mov	-1[bp],al
32576                                           !BCC_EOS
32577                                           ! 5493       regs.u.r16.ax = 0;
32578                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
32579 8BFE           31C0                       xor	ax,ax
32580 8C00           8946         12            mov	$12[bp],ax
32581                                           !BCC_EOS
32582                                           ! 5494       if (val8 & 0x20) {
32583                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
32584 8C03           8A46         FF            mov	al,-1[bp]
32585 8C06           24                     20  and	al,*$20
32586 8C08           84C0                       test	al,al
32587 8C0A           74           0B            je  	.7B0
32588                       00008C0C            .7B1:
32589                                           ! 5495         iret_addr.flags.u.r8.flagsl |= 0x01;
32590                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32591 8C0C           8A46         1A            mov	al,$1A[bp]
32592 8C0F           0C                     01  or	al,*1
32593 8C11           8846         1A            mov	$1A[bp],al
32594                                           !BCC_EOS
32595                                           ! 5496         break;
32596 8C14           E9         0179            br 	.79E
32597                                           !BCC_EOS
32598                                           ! 5497       }
32599                                           ! 5498       if (rtc_updating()) {
32600                       00008C17            .7B0:
32601                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32602 8C17           E8         7991            call	_rtc_updating
32603 8C1A           85C0                       test	ax,ax
32604 8C1C           74           03            je  	.7B2
32605                       00008C1E            .7B3:
32606                                           ! 5499         init_rtc();
32607                                           ! Debug: func () void = init_rtc+0 (used reg = )
32608 8C1E           E8         7959            call	_init_rtc
32609                                           !BCC_EOS
32610                                           ! 5500       }
32611                                           ! 5501       outb_cmos(0x01, regs.u.r8.dh);
32612                       00008C21            .7B2:
32613                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32614 8C21           8A46         0F            mov	al,$F[bp]
32615 8C24           30E4                       xor	ah,ah
32616 8C26           50                         push	ax
32617                                           ! Debug: list int = const 1 (used reg = )
32618 8C27           B8                   0001  mov	ax,*1
32619 8C2A           50                         push	ax
32620                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32621 8C2B           E8         7931            call	_outb_cmos
32622 8C2E           83C4                   04  add	sp,*4
32623                                           !BCC_EOS
32624                                           ! 5502       outb_cmos(0x03, regs.u.r8.cl);
32625                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32626 8C31           8A46         10            mov	al,$10[bp]
32627 8C34           30E4                       xor	ah,ah
32628 8C36           50                         push	ax
32629                                           ! Debug: list int = const 3 (used reg = )
32630 8C37           B8                   0003  mov	ax,*3
32631 8C3A           50                         push	ax
32632                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32633 8C3B           E8         7921            call	_outb_cmos
32634 8C3E           83C4                   04  add	sp,*4
32635                                           !BCC_EOS
32636                                           ! 5503       outb_cmos(0x05, regs.u.r8.ch);
32637                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32638 8C41           8A46         11            mov	al,$11[bp]
32639 8C44           30E4                       xor	ah,ah
32640 8C46           50                         push	ax
32641                                           ! Debug: list int = const 5 (used reg = )
32642 8C47           B8                   0005  mov	ax,*5
32643 8C4A           50                         push	ax
32644                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32645 8C4B           E8         7911            call	_outb_cmos
32646 8C4E           83C4                   04  add	sp,*4
32647                                           !BCC_EOS
32648                                           ! 5504       outb(0x00a1, inb(0x00a1) & 0xfe);
32649                                           ! Debug: list int = const $A1 (used reg = )
32650 8C51           B8                   00A1  mov	ax,#$A1
32651 8C54           50                         push	ax
32652                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32653 8C55           E8         78D1            call	_inb
32654 8C58           44                         inc	sp
32655 8C59           44                         inc	sp
32656                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
32657 8C5A           24                     FE  and	al,#$FE
32658                                           ! Debug: list unsigned char = al+0 (used reg = )
32659 8C5C           30E4                       xor	ah,ah
32660 8C5E           50                         push	ax
32661                                           ! Debug: list int = const $A1 (used reg = )
32662 8C5F           B8                   00A1  mov	ax,#$A1
32663 8C62           50                         push	ax
32664                                           ! Debug: func () void = outb+0 (used reg = )
32665 8C63           E8         78D9            call	_outb
32666 8C66           83C4                   04  add	sp,*4
32667                                           !BCC_EOS
32668                                           ! 5505       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
32669                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
32670 8C69           8A46         FF            mov	al,-1[bp]
32671 8C6C           24                     7F  and	al,*$7F
32672                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
32673 8C6E           0C                     20  or	al,*$20
32674                                           ! Debug: list unsigned char = al+0 (used reg = )
32675 8C70           30E4                       xor	ah,ah
32676 8C72           50                         push	ax
32677                                           ! Debug: list int = const $B (used reg = )
32678 8C73           B8                   000B  mov	ax,*$B
32679 8C76           50                         push	ax
32680                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32681 8C77           E8         78E5            call	_outb_cmos
32682 8C7A           83C4                   04  add	sp,*4
32683                                           !BCC_EOS
32684                                           ! 5506       iret_addr.flags.u.r8.flagsl &= 0xfe;
32685                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32686 8C7D           8A46         1A            mov	al,$1A[bp]
32687 8C80           24                     FE  and	al,#$FE
32688 8C82           8846         1A            mov	$1A[bp],al
32689                                           !BCC_EOS
32690                                           ! 5507       break;
32691 8C85           E9         0108            br 	.79E
32692                                           !BCC_EOS
32693                                           ! 5508     case 7:
32694                                           ! 5509       val8 = inb_cmos(0x0b);
32695                       00008C88            .7B4:
32696                                           ! Debug: list int = const $B (used reg = )
32697 8C88           B8                   000B  mov	ax,*$B
32698 8C8B           50                         push	ax
32699                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32700 8C8C           E8         78DF            call	_inb_cmos
32701 8C8F           44                         inc	sp
32702 8C90           44                         inc	sp
32703                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32704 8C91           8846         FF            mov	-1[bp],al
32705                                           !BCC_EOS
32706                                           ! 5510       outb_cmos(0x0b, val8 & 0x57);
32707                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
32708 8C94           8A46         FF            mov	al,-1[bp]
32709 8C97           24                     57  and	al,*$57
32710                                           ! Debug: list unsigned char = al+0 (used reg = )
32711 8C99           30E4                       xor	ah,ah
32712 8C9B           50                         push	ax
32713                                           ! Debug: list int = const $B (used reg = )
32714 8C9C           B8                   000B  mov	ax,*$B
32715 8C9F           50                         push	ax
32716                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32717 8CA0           E8         78BC            call	_outb_cmos
32718 8CA3           83C4                   04  add	sp,*4
32719                                           !BCC_EOS
32720                                           ! 5511       regs.u.r8.ah = 0;
32721                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32722 8CA6           30C0                       xor	al,al
32723 8CA8           8846         13            mov	$13[bp],al
32724                                           !BCC_EOS
32725                                           ! 5512       regs.u.r8.al = val8;
32726                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32727 8CAB           8A46         FF            mov	al,-1[bp]
32728 8CAE           8846         12            mov	$12[bp],al
32729                                           !BCC_EOS
32730                                           ! 5513       iret_addr.flags.u.r8.flagsl &= 0xfe;
32731                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32732 8CB1           8A46         1A            mov	al,$1A[bp]
32733 8CB4           24                     FE  and	al,#$FE
32734 8CB6           8846         1A            mov	$1A[bp],al
32735                                           !BCC_EOS
32736                                           ! 5514       break;
32737 8CB9           E9         00D4            br 	.79E
32738                                           !BCC_EOS
32739                                           ! 5515     case 0xb1:
32740                                           ! 5516    
32741                                           ! 5516    if (regs.u.r8.bl == 0xff) {
32742                       00008CBC            .7B5:
32743                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
32744 8CBC           8A46         0C            mov	al,$C[bp]
32745 8CBF           3C                     FF  cmp	al,#$FF
32746 8CC1           75           10            jne 	.7B6
32747                       00008CC3            .7B7:
32748                                           ! 5517         bios_printf(4, "PCI BIOS: PCI not present\n");
32749                                           ! Debug: list * char = .7B8+0 (used reg = )
32750 8CC3           BB                   CCC6  mov	bx,#.7B8
32751 8CC6           53                         push	bx
32752                                           ! Debug: list int = const 4 (used reg = )
32753 8CC7           B8                   0004  mov	ax,*4
32754 8CCA           50                         push	ax
32755                                           ! Debug: func () void = bios_printf+0 (used reg = )
32756 8CCB           E8         7C6B            call	_bios_printf
32757 8CCE           83C4                   04  add	sp,*4
32758                                           !BCC_EOS
32759                                           ! 5518       } else if (regs.u.r8.bl == 0x81) {
32760 8CD1           EB           78            jmp .7B9
32761                       00008CD3            .7B6:
32762                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
32763 8CD3           8A46         0C            mov	al,$C[bp]
32764 8CD6           3C                     81  cmp	al,#$81
32765 8CD8           75           16            jne 	.7BA
32766                       00008CDA            .7BB:
32767                                           ! 5519         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
32768                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
32769 8CDA           8A46         12            mov	al,$12[bp]
32770 8CDD           30E4                       xor	ah,ah
32771 8CDF           50                         push	ax
32772                                           ! Debug: list * char = .7BC+0 (used reg = )
32773 8CE0           BB                   CCA0  mov	bx,#.7BC
32774 8CE3           53                         push	bx
32775                                           ! Debug: list int = const 4 (used reg = )
32776 8CE4           B8                   0004  mov	ax,*4
32777 8CE7           50                         push	ax
32778                                           ! Debug: func () void = bios_printf+0 (used reg = )
32779 8CE8           E8         7C4E            call	_bios_printf
32780 8CEB           83C4                   06  add	sp,*6
32781                                           !BCC_EOS
32782                                           ! 5520       } else if (regs.u.r8.bl == 0x83) {
32783 8CEE           EB           5B            jmp .7BD
32784                       00008CF0            .7BA:
32785                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
32786 8CF0           8A46         0C            mov	al,$C[bp]
32787 8CF3           3C                     83  cmp	al,#$83
32788 8CF5           75           13            jne 	.7BE
32789                       00008CF7            .7BF:
32790                                           ! 5521         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
32791                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
32792 8CF7           FF76         0E            push	$E[bp]
32793                                           ! Debug: list * char = .7C0+0 (used reg = )
32794 8CFA           BB                   CC88  mov	bx,#.7C0
32795 8CFD           53                         push	bx
32796                                           ! Debug: list int = const 4 (used reg = )
32797 8CFE           B8                   0004  mov	ax,*4
32798 8D01           50                         push	ax
32799                                           ! Debug: func () void = bios_printf+0 (used reg = )
32800 8D02           E8         7C34            call	_bios_printf
32801 8D05           83C4                   06  add	sp,*6
32802                                           !BCC_EOS
32803                                           ! 5522       } else if (regs.u.r8.bl == 0x86) {
32804 8D08           EB           41            jmp .7C1
32805                       00008D0A            .7BE:
32806                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
32807 8D0A           8A46         0C            mov	al,$C[bp]
32808 8D0D           3C                     86  cmp	al,#$86
32809 8D0F           75           3A            jne 	.7C2
32810                       00008D11            .7C3:
32811                                           ! 5523         if (regs.u.r8.al == 0x02) {
32812                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
32813 8D11           8A46         12            mov	al,$12[bp]
32814 8D14           3C                     02  cmp	al,*2
32815 8D16           75           19            jne 	.7C4
32816                       00008D18            .7C5:
32817                                           ! 5524           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
32818                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
32819 8D18           FF76         06            push	6[bp]
32820                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
32821 8D1B           FF76         10            push	$10[bp]
32822                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
32823 8D1E           FF76         0E            push	$E[bp]
32824                                           ! Debug: list * char = .7C6+0 (used reg = )
32825 8D21           BB                   CC5C  mov	bx,#.7C6
32826 8D24           53                         push	bx
32827                                           ! Debug: list int = const 4 (used reg = )
32828 8D25           B8                   0004  mov	ax,*4
32829 8D28           50                         push	ax
32830                                           ! Debug: func () void = bios_printf+0 (used reg = )
32831 8D29           E8         7C0D            call	_bios_printf
32832 8D2C           83C4                   0A  add	sp,*$A
32833                                           !BCC_EOS
32834                                           ! 5525         } else {
32835 8D2F           EB           1A            jmp .7C7
32836                       00008D31            .7C4:
32837                                           ! 5526           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
32838                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
32839 8D31           FF76         06            push	6[bp]
32840                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
32841 8D34           FF76         0E            push	$E[bp]
32842                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
32843 8D37           8A46         10            mov	al,$10[bp]
32844 8D3A           30E4                       xor	ah,ah
32845 8D3C           50                         push	ax
32846                                           ! Debug: list * char = .7C8+0 (used reg = )
32847 8D3D           BB                   CC20  mov	bx,#.7C8
32848 8D40           53                         push	bx
32849                                           ! Debug: list int = const 4 (used reg = )
32850 8D41           B8                   0004  mov	ax,*4
32851 8D44           50                         push	ax
32852                                           ! Debug: func () void = bios_printf+0 (used reg = )
32853 8D45           E8         7BF1            call	_bios_printf
32854 8D48           83C4                   0A  add	sp,*$A
32855                                           !BCC_EOS
32856                                           ! 5527         }
32857                                           ! 5528       }
32858                       00008D4B            .7C7:
32859                                           ! 5529       regs.u.r8.ah = regs.u.r8.bl;
32860                       00008D4B            .7C2:
32861                       00008D4B            .7C1:
32862                       00008D4B            .7BD:
32863                       00008D4B            .7B9:
32864                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
32865 8D4B           8A46         0C            mov	al,$C[bp]
32866 8D4E           8846         13            mov	$13[bp],al
32867                                           !BCC_EOS
32868                                           ! 5530       iret_addr.flags.u.r8.flagsl |= 0x01;
32869                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32870 8D51           8A46         1A            mov	al,$1A[bp]
32871 8D54           0C                     01  or	al,*1
32872 8D56           8846         1A            mov	$1A[bp],al
32873                                           !BCC_EOS
32874                                           ! 5531       break;
32875 8D59           EB           35            jmp .79E
32876                                           !BCC_EOS
32877                                           ! 5532     default:
32878                                           ! 5533       iret_addr.flags.u.r8.flagsl |= 0x01;
32879                       00008D5B            .7C9:
32880                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32881 8D5B           8A46         1A            mov	al,$1A[bp]
32882 8D5E           0C                     01  or	al,*1
32883 8D60           8846         1A            mov	$1A[bp],al
32884                                           !BCC_EOS
32885                                           ! 5534   }
32886                                           ! 5535 }
32887 8D63           EB           2B            jmp .79E
32888                       00008D65            .7A0:
32889 8D65           2C                     00  sub	al,*0
32890 8D67           72           F2            jb 	.7C9
32891 8D69           3C                     07  cmp	al,*7
32892 8D6B           77           1B            ja  	.7CA
32893 8D6D           30E4                       xor	ah,ah
32894 8D6F           D1E0                       shl	ax,*1
32895 8D71           89C3                       mov	bx,ax
32896 8D73           2E                         seg	cs
32897 8D74           FFA7       8D78            br	.7CB[bx]
32898                       00008D78            .7CB:
32899 8D78                      89F7            .word	.7A1
32900 8D7A                      8A1B            .word	.7A2
32901 8D7C                      8A3E            .word	.7A3
32902 8D7E                      8A97            .word	.7A6
32903 8D80                      8B11            .word	.7A9
32904 8D82                      8B69            .word	.7AC
32905 8D84                      8BF2            .word	.7AF
32906 8D86                      8C88            .word	.7B4
32907                       00008D88            .7CA:
32908 8D88           2C                     B1  sub	al,#$B1
32909 8D8A         0F84         FF2E            beq 	.7B5
32910 8D8E           EB           CB            jmp	.7C9
32911                       00008D90            .79E:
32912                       FFFFFFFC            ..FFD8	=	-4
32913 8D90           89EC                       mov	sp,bp
32914 8D92           5D                         pop	bp
32915 8D93           C3                         ret
32916                                           ! 5536   void
32917                                           ! Register BX used in function int1a_function
32918                                           ! 5537 int70_function(regs, ds, iret_addr)
32919                                           ! 5538   pusha_regs_t regs;
32920                                           export	_int70_function
32921                       00008D94            _int70_function:
32922                                           !BCC_EOS
32923                                           ! 5539   Bit16u ds;
32924                                           !BCC_EOS
32925                                           ! 5540   iret_addr_t iret_addr;
32926                                           !BCC_EOS
32927                                           ! 5541 {
32928                                           ! 5542   Bit8u registerB = 0, registerC = 0;
32929 8D94           55                         push	bp
32930 8D95           89E5                       mov	bp,sp
32931 8D97           4C                         dec	sp
32932                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
32933 8D98           30C0                       xor	al,al
32934 8D9A           8846         FF            mov	-1[bp],al
32935 8D9D           4C                         dec	sp
32936                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
32937 8D9E           30C0                       xor	al,al
32938 8DA0           8846         FE            mov	-2[bp],al
32939                                           !BCC_EOS
32940                                           ! 5543   registerB = inb_cmos( 0xB );
32941                                           ! Debug: list int = const $B (used reg = )
32942 8DA3           B8                   000B  mov	ax,*$B
32943 8DA6           50                         push	ax
32944                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32945 8DA7           E8         77C4            call	_inb_cmos
32946 8DAA           44                         inc	sp
32947 8DAB           44                         inc	sp
32948                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
32949 8DAC           8846         FF            mov	-1[bp],al
32950                                           !BCC_EOS
32951                                           ! 5544   registerC = inb_cmos( 0xC );
32952                                           ! Debug: list int = const $C (used reg = )
32953 8DAF           B8                   000C  mov	ax,*$C
32954 8DB2           50                         push	ax
32955                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32956 8DB3           E8         77B8            call	_inb_cmos
32957 8DB6           44                         inc	sp
32958 8DB7           44                         inc	sp
32959                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
32960 8DB8           8846         FE            mov	-2[bp],al
32961                                           !BCC_EOS
32962                                           ! 5545   if( ( registerB & 0x60 ) != 0 ) {
32963                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
32964 8DBB           8A46         FF            mov	al,-1[bp]
32965 8DBE           24                     60  and	al,*$60
32966                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32967 8DC0           84C0                       test	al,al
32968 8DC2         0F84         00B2            beq 	.7CC
32969                       00008DC6            .7CD:
32970                                           ! 5546     if( ( registerC & 0x20 ) != 0 ) {
32971                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
32972 8DC6           8A46         FE            mov	al,-2[bp]
32973 8DC9           24                     20  and	al,*$20
32974                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32975 8DCB           84C0                       test	al,al
32976 8DCD           74           04            je  	.7CE
32977                       00008DCF            .7CF:
32978                                           ! 5547 #asm
32979                                           !BCC_EOS
32980                                           !BCC_ASM
32981                       00000000            _int70_function.registerC	set	0
32982                       FFFFFFFE            .int70_function.registerC	set	-2
32983                       00000016            _int70_function.ds	set	$16
32984                       00000014            .int70_function.ds	set	$14
32985                       00000001            _int70_function.registerB	set	1
32986                       FFFFFFFF            .int70_function.registerB	set	-1
32987                       00000018            _int70_function.iret_addr	set	$18
32988                       00000016            .int70_function.iret_addr	set	$16
32989                       00000006            _int70_function.regs	set	6
32990                       00000004            .int70_function.regs	set	4
32991 8DCF           FB                               sti
32992 8DD0           CD                     4A        int #0x4a
32993 8DD2           FA                               cli
32994                                           ! 5551 endasm
32995                                           !BCC_ENDASM
32996                                           !BCC_EOS
32997                                           ! 5552     }
32998                                           ! 5553     if( ( registerC & 0x40 ) != 0 ) {
32999                       00008DD3            .7CE:
33000                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
33001 8DD3           8A46         FE            mov	al,-2[bp]
33002 8DD6           24                     40  and	al,*$40
33003                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33004 8DD8           84C0                       test	al,al
33005 8DDA         0F84         009A            beq 	.7D0
33006                       00008DDE            .7D1:
33007                                           ! 5554       if( *((Bit8u *)(0x4A0)) != 0 ) {
33008                                           ! Debug: ne int = const 0 to unsigned char = [+$4A0] (used reg = )
33009 8DDE           A0         04A0            mov	al,[$4A0]
33010 8DE1           84C0                       test	al,al
33011 8DE3         0F84         0091            beq 	.7D2
33012                       00008DE7            .7D3:
33013                                           ! 5555         Bit32u time, toggle;
33014                                           !BCC_EOS
33015                                           ! 5556         time = *((Bit32u *)(0x49C));
33016 8DE7           83C4                   F8  add	sp,*-8
33017                                           ! Debug: eq unsigned long = [+$49C] to unsigned long time = [S+$C-8] (used reg = )
33018 8DEA           A1         049C            mov	ax,[$49C]
33019 8DED           8B1E       049E            mov	bx,[$49E]
33020 8DF1           8946         FA            mov	-6[bp],ax
33021 8DF4           895E         FC            mov	-4[bp],bx
33022                                           !BCC_EOS
33023                                           ! 5557         if( time < 0x3D1 ) {
33024                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33025 8DF7           B8                   03D1  mov	ax,#$3D1
33026 8DFA           31DB                       xor	bx,bx
33027 8DFC           8D7E         FA            lea	di,-6[bp]
33028 8DFF           E8         729A            call	lcmpul
33029 8E02           76           48            jbe 	.7D4
33030                       00008E04            .7D5:
33031                                           ! 5558           Bit16u segment, offset;
33032                                           !BCC_EOS
33033                                           ! 5559           segment = *((Bit16u *)(0x498));
33034 8E04           83C4                   FC  add	sp,*-4
33035                                           ! Debug: eq unsigned short = [+$498] to unsigned short segment = [S+$10-$E] (used reg = )
33036 8E07           A1         0498            mov	ax,[$498]
33037 8E0A           8946         F4            mov	-$C[bp],ax
33038                                           !BCC_EOS
33039                                           ! 5560           offset = *((Bit16u *)(0x49A));
33040                                           ! Debug: eq unsigned short = [+$49A] to unsigned short offset = [S+$10-$10] (used reg = )
33041 8E0D           A1         049A            mov	ax,[$49A]
33042 8E10           8946         F2            mov	-$E[bp],ax
33043                                           !BCC_EOS
33044                                           ! 5561           *((Bit8u *)(0x4A0)) = (0);
33045                                           ! Debug: eq int = const 0 to unsigned char = [+$4A0] (used reg = )
33046 8E13           30C0                       xor	al,al
33047 8E15           A2         04A0            mov	[$4A0],al
33048                                           !BCC_EOS
33049                                           ! 5562           outb_cmos( 0xB, registerB & 0x37 );
33050                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
33051 8E18           8A46         FF            mov	al,-1[bp]
33052 8E1B           24                     37  and	al,*$37
33053                                           ! Debug: list unsigned char = al+0 (used reg = )
33054 8E1D           30E4                       xor	ah,ah
33055 8E1F           50                         push	ax
33056                                           ! Debug: list int = const $B (used reg = )
33057 8E20           B8                   000B  mov	ax,*$B
33058 8E23           50                         push	ax
33059                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33060 8E24           E8         7738            call	_outb_cmos
33061 8E27           83C4                   04  add	sp,*4
33062                                           !BCC_EOS
33063                                           ! 5563           _write_byte(_read_byte(offset, segment) | 0x80, offset, segment);
33064                                           ! Debug: list unsigned short segment = [S+$10-$E] (used reg = )
33065 8E2A           FF76         F4            push	-$C[bp]
33066                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
33067 8E2D           FF76         F2            push	-$E[bp]
33068                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
33069 8E30           FF76         F4            push	-$C[bp]
33070                                           ! Debug: list unsigned short offset = [S+$16-$10] (used reg = )
33071 8E33           FF76         F2            push	-$E[bp]
33072                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
33073 8E36           E8         77A6            call	__read_byte
33074 8E39           83C4                   04  add	sp,*4
33075                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
33076 8E3C           0C                     80  or	al,#$80
33077                                           ! Debug: list unsigned char = al+0 (used reg = )
33078 8E3E           30E4                       xor	ah,ah
33079 8E40           50                         push	ax
33080                                           ! Debug: func () void = _write_byte+0 (used reg = )
33081 8E41           E8         77B7            call	__write_byte
33082 8E44           83C4                   06  add	sp,*6
33083                                           !BCC_EOS
33084                                           ! 5564         } else {
33085 8E47           83C4                   04  add	sp,*4
33086 8E4A           EB           29            jmp .7D6
33087                       00008E4C            .7D4:
33088                                           ! 5565           time -= 0x3D1;
33089                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33090 8E4C           B8                   03D1  mov	ax,#$3D1
33091 8E4F           31DB                       xor	bx,bx
33092 8E51           53                         push	bx
33093 8E52           50                         push	ax
33094 8E53           8B46         FA            mov	ax,-6[bp]
33095 8E56           8B5E         FC            mov	bx,-4[bp]
33096 8E59           8D7E         F2            lea	di,-$E[bp]
33097 8E5C           E8         7253            call	lsubul
33098 8E5F           8946         FA            mov	-6[bp],ax
33099 8E62           895E         FC            mov	-4[bp],bx
33100 8E65           83C4                   04  add	sp,*4
33101                                           !BCC_EOS
33102                                           ! 5566           *((Bit32u *)(0x49C)) = (time);
33103                                           ! Debug: eq unsigned long time = [S+$C-8] to unsigned long = [+$49C] (used reg = )
33104 8E68           8B46         FA            mov	ax,-6[bp]
33105 8E6B           8B5E         FC            mov	bx,-4[bp]
33106 8E6E           A3         049C            mov	[$49C],ax
33107 8E71           891E       049E            mov	[$49E],bx
33108                                           !BCC_EOS
33109                                           ! 5567         }
33110                                           ! 5568       }
33111                       00008E75            .7D6:
33112 8E75           83C4                   08  add	sp,*8
33113                                           ! 5569     }
33114                       00008E78            .7D2:
33115                                           ! 5570   }
33116                       00008E78            .7D0:
33117                                           ! 5571 #asm
33118                       00008E78            .7CC:
33119                                           !BCC_EOS
33120                                           !BCC_ASM
33121                       00000000            _int70_function.registerC	set	0
33122                       FFFFFFFE            .int70_function.registerC	set	-2
33123                       00000016            _int70_function.ds	set	$16
33124                       00000014            .int70_function.ds	set	$14
33125                       00000001            _int70_function.registerB	set	1
33126                       FFFFFFFF            .int70_function.registerB	set	-1
33127                       00000018            _int70_function.iret_addr	set	$18
33128                       00000016            .int70_function.iret_addr	set	$16
33129                       00000006            _int70_function.regs	set	6
33130                       00000004            .int70_function.regs	set	4
33131 8E78           E8         042D              call eoi_both_pics
33132                                           ! 5573 endasm
33133                                           !BCC_ENDASM
33134                                           !BCC_EOS
33135                                           ! 5574 }
33136 8E7B           89EC                       mov	sp,bp
33137 8E7D           5D                         pop	bp
33138 8E7E           C3                         ret
33139                                           ! 5575 #asm
33140                                           !BCC_ASM
33141                       00000012            _int70_function.ds	set	$12
33142                       00000014            _int70_function.iret_addr	set	$14
33143                       00000002            _int70_function.regs	set	2
33144                                           ;------------------------------------------
33145                                           ;- INT74h : PS/2 mouse hardware interrupt -
33146                                           ;------------------------------------------
33147                       00008E7F            int74_handler:
33148 8E7F           FB                           sti
33149 8E80           60                           pusha
33150 8E81           1E                           push ds ;; save DS
33151 8E82           6A                     00    push #0x00
33152 8E84           1F                           pop ds
33153 8E85           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
33154 8E89           1F                           pop ds
33155 8E8A           6A                     00    push #0x00 ;; placeholder for status
33156 8E8C           6A                     00    push #0x00 ;; placeholder for X
33157 8E8E           6A                     00    push #0x00 ;; placeholder for Y
33158 8E90           6A                     00    push #0x00 ;; placeholder for Z
33159 8E92           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
33160 8E94           E8         CB6E              call _int74_function
33161 8E97           59                           pop cx ;; remove make_far_call from stack
33162 8E98           E3           04              jcxz int74_done
33163                                             ;; make far call to EBDA:0022
33164 8E9A           FF1E       0022              call far ptr[0x22]
33165                       00008E9E            int74_done:
33166 8E9E           FA                           cli
33167 8E9F           E8         0406              call eoi_both_pics
33168 8EA2           83C4                   08    add sp, #8 ;; pop status, x, y, z
33169 8EA5           1F                           pop ds ;; restore DS
33170 8EA6           61                           popa
33171 8EA7           CF                           iret
33172                                           ;; This will perform an IRET, but will retain value of current CF
33173                                           ;; by altering flags on stack. Better than RETF #02.
33174                       00008EA8            iret_modify_cf:
33175 8EA8           72           09              jc carry_set
33176 8EAA           55                           push bp
33177 8EAB           89E5                         mov bp, sp
33178 8EAD           8066         06        FE    and BYTE [bp + 0x06], #0xfe
33179 8EB1           5D                           pop bp
33180 8EB2           CF                           iret
33181                       00008EB3            carry_set:
33182 8EB3           55                           push bp
33183 8EB4           89E5                         mov bp, sp
33184 8EB6           804E         06        01    or BYTE [bp + 0x06], #0x01
33185 8EBA           5D                           pop bp
33186 8EBB           CF                           iret
33187                                           ;----------------------
33188                                           ;- INT13h (relocated) -
33189                                           ;----------------------
33190                                           ;
33191                                           ; int13_relocated is a little bit messed up since I played with it
33192                                           ; I have to rewrite it:
33193                                           ; - call a function that detect which function to call
33194                                           ; - make all called C function get the same parameters list
33195                                           ;
33196                       00008EBC            int13_relocated:
33197                                             ;; check for an eltorito function
33198 8EBC           80FC                   4A    cmp ah,#0x4a
33199 8EBF           72           0E              jb int13_not_eltorito
33200 8EC1           80FC                   4D    cmp ah,#0x4d
33201 8EC4           77           09              ja int13_not_eltorito
33202 8EC6           60                           pusha
33203 8EC7           06                           push es
33204 8EC8           1E                           push ds
33205 8EC9           68                   8F4D    push #int13_out
33206 8ECC           E9         DF2F              jmp _int13_eltorito ;; ELDX not used
33207                       00008ECF            int13_not_eltorito:
33208 8ECF           50                           push ax
33209 8ED0           53                           push bx
33210 8ED1           51                           push cx
33211 8ED2           52                           push dx
33212                                             ;; check if emulation active
33213 8ED3           E8         A687              call _cdemu_isactive
33214 8ED6           3C                     00    cmp al,#0x00
33215 8ED8           74           31              je int13_cdemu_inactive
33216                                             ;; check if access to the emulated drive
33217 8EDA           E8         A69C              call _cdemu_emulated_drive
33218 8EDD           5A                           pop dx
33219 8EDE           52                           push dx
33220 8EDF           38D0                         cmp al,dl ;; int13 on emulated drive
33221 8EE1           75           15              jne int13_nocdemu
33222 8EE3           5A                           pop dx
33223 8EE4           59                           pop cx
33224 8EE5           5B                           pop bx
33225 8EE6           58                           pop ax
33226 8EE7           60                           pusha
33227 8EE8           06                           push es
33228 8EE9           1E                           push ds
33229 8EEA           6A                     40    push #0x40
33230 8EEC           1F                           pop ds
33231 8EED           FF36       000E              push 0x000E
33232 8EF1           1F                           pop ds ;; Set DS to EBDA segment
33233 8EF2           68                   8F4D    push #int13_out
33234 8EF5           E9         E109              jmp _int13_cdemu ;; ELDX not used
33235                       00008EF8            int13_nocdemu:
33236 8EF8           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
33237 8EFB           38D0                         cmp al,dl ;; al is 0x00 or 0x80
33238 8EFD           75           0C              jne int13_cdemu_inactive ;; inactive for device class
33239 8EFF           5A                           pop dx
33240 8F00           59                           pop cx
33241 8F01           5B                           pop bx
33242 8F02           58                           pop ax
33243 8F03           50                           push ax
33244 8F04           51                           push cx
33245 8F05           52                           push dx
33246 8F06           53                           push bx
33247 8F07           FECA                         dec dl ;; real drive is dl - 1
33248 8F09           EB           08              jmp int13_legacy
33249                       00008F0B            int13_cdemu_inactive:
33250 8F0B           5A                           pop dx
33251 8F0C           59                           pop cx
33252 8F0D           5B                           pop bx
33253 8F0E           58                           pop ax
33254                       00008F0F            int13_noeltorito:
33255 8F0F           50                           push ax
33256 8F10           51                           push cx
33257 8F11           52                           push dx
33258 8F12           53                           push bx
33259                       00008F13            int13_legacy:
33260 8F13           52                           push dx ;; push eltorito value of dx instead of sp
33261 8F14           55                           push bp
33262 8F15           56                           push si
33263 8F16           57                           push di
33264 8F17           06                           push es
33265 8F18           1E                           push ds
33266 8F19           6A                     40    push #0x40
33267 8F1B           1F                           pop ds ;; Set DS to 0x40
33268                                             ;; now the 16-bit registers can be restored with:
33269                                             ;; pop ds; pop es; popa; iret
33270                                             ;; arguments passed to functions should be
33271                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
33272 8F1C           F6C2                   80    test dl, #0x80
33273 8F1F           75           06              jnz int13_notfloppy
33274 8F21           68                   8F4D    push #int13_out
33275 8F24           E9         E867              jmp _int13_diskette_function
33276                       00008F27            int13_notfloppy:
33277 8F27           FF36       000E              push 0x000E
33278 8F2B           1F                           pop ds ;; Set DS to EBDA segment
33279 8F2C           80FA                   E0    cmp dl, #0xE0
33280 8F2F           72           0F              jb int13_notcdrom
33281 8F31     66    C1EB                   10    shr ebx, #16
33282 8F35           53                           push bx
33283 8F36           E8         D9D0              call _int13_cdrom
33284 8F39           5B                           pop bx
33285 8F3A     66    C1E3                   10    shl ebx, #16
33286 8F3E           EB           0D              jmp int13_out
33287                       00008F40            int13_notcdrom:
33288                       00008F40            int13_disk:
33289                                             ;; int13_harddisk modifies high word of EAX
33290 8F40     66    C1E8                   10    shr eax, #16
33291 8F44           50                           push ax
33292 8F45           E8         D20E              call _int13_harddisk
33293 8F48           58                           pop ax
33294 8F49     66    C1E0                   10    shl eax, #16
33295                       00008F4D            int13_out:
33296 8F4D           1F                           pop ds
33297 8F4E           07                           pop es
33298 8F4F           61                           popa
33299 8F50           CF                           iret
33300                                           ;----------
33301                                           ;- INT18h -
33302                                           ;----------
33303                       00008F51            int18_handler: ;; Boot Failure recovery: try the next device.
33304                                             ;; Reset SP and SS
33305 8F51           B8                   FFFE    mov ax, #0xfffe
33306 8F54           89C4                         mov sp, ax
33307 8F56           31C0                         xor ax, ax
33308 8F58           8ED0                         mov ss, ax
33309                                             ;; Get the boot sequence number out of the IPL memory
33310 8F5A           BB                   9FF0    mov bx, #0x9ff0
33311 8F5D           8EDB                         mov ds, bx ;; Set segment
33312 8F5F           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
33313 8F63           43                           inc bx ;; ++
33314 8F64           891E       0082              mov 0x0082, bx ;; Write it back
33315 8F68           8ED8                         mov ds, ax ;; and reset the segment to zero.
33316                                             ;; Carry on in the INT 19h handler, using the new sequence number
33317 8F6A           53                           push bx
33318 8F6B           EB           17              jmp int19_next_boot
33319                                           ;----------
33320                                           ;- INT19h -
33321                                           ;----------
33322                       00008F6D            int19_relocated: ;; Boot function, relocated
33323                                             ;; int19 was beginning to be really complex, so now it
33324                                             ;; just calls a C function that does the work
33325 8F6D           55                           push bp
33326 8F6E           89E5                         mov bp, sp
33327                                             ;; Reset SS and SP
33328 8F70           B8                   FFFE    mov ax, #0xfffe
33329 8F73           89C4                         mov sp, ax
33330 8F75           31C0                         xor ax, ax
33331 8F77           8ED0                         mov ss, ax
33332                                             ;; Start from the first boot device (0, in AX)
33333 8F79           BB                   9FF0    mov bx, #0x9ff0
33334 8F7C           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
33335 8F7E           A3         0082              mov 0x0082, ax ;; Save the sequence number
33336 8F81           8ED8                         mov ds, ax ;; and reset the segment.
33337 8F83           50                           push ax
33338                       00008F84            int19_next_boot:
33339                                             ;; Call the C code for the next boot device
33340 8F84           E8         F828              call _int19_function
33341                                             ;; Boot failed: invoke the boot recovery function
33342 8F87           CD                     18    int #0x18
33343                                           ;----------------------
33344                                           ;- POST: Floppy Drive -
33345                                           ;----------------------
33346                       00008F89            floppy_drive_post:
33347 8F89           31C0                         xor ax, ax
33348 8F8B           8ED8                         mov ds, ax
33349 8F8D           B0                     00    mov al, #0x00
33350 8F8F           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
33351 8F92           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
33352 8F95           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
33353 8F98           A2         0441              mov 0x0441, al ;; diskette controller status return code
33354 8F9B           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
33355 8F9E           A2         0443              mov 0x0443, al ;; diskette controller status register 1
33356 8FA1           A2         0444              mov 0x0444, al ;; diskette controller status register 2
33357 8FA4           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
33358 8FA7           A2         0446              mov 0x0446, al ;; diskette controller head number
33359 8FAA           A2         0447              mov 0x0447, al ;; diskette controller sector number
33360 8FAD           A2         0448              mov 0x0448, al ;; diskette controller bytes written
33361 8FB0           A2         048B              mov 0x048b, al ;; diskette configuration data
33362                                             ;; -----------------------------------------------------------------
33363                                             ;; (048F) diskette controller information
33364                                             ;;
33365 8FB3           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
33366 8FB5           E6                     70    out 0x0070, AL
33367 8FB7           E4                     71    in AL, 0x0071
33368 8FB9           88C4                         mov ah, al ;; save byte to AH
33369                       00008FBB            look_drive0:
33370 8FBB           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
33371 8FBE           74           04              jz f0_missing ;; jump if no drive0
33372 8FC0           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
33373 8FC2           EB           02              jmp look_drive1
33374                       00008FC4            f0_missing:
33375 8FC4           B3                     00    mov bl, #0x00 ;; no drive0
33376                       00008FC6            look_drive1:
33377 8FC6           88E0                         mov al, ah ;; restore from AH
33378 8FC8           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
33379 8FCA           74           03              jz f1_missing ;; jump if no drive1
33380 8FCC           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
33381                       00008FCF            f1_missing:
33382                                                              ;; leave high bits in BL zerod
33383 8FCF           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
33384                                             ;; -----------------------------------------------------------------
33385 8FD3           B0                     00    mov al, #0x00
33386 8FD5           A2         0490              mov 0x0490, al ;; diskette 0 media state
33387 8FD8           A2         0491              mov 0x0491, al ;; diskette 1 media state
33388                                                              ;; diskette 0,1 operational starting state
33389                                                              ;; drive type has not been determined,
33390                                                              ;; has no changed detection line
33391 8FDB           A2         0492              mov 0x0492, al
33392 8FDE           A2         0493              mov 0x0493, al
33393 8FE1           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
33394 8FE4           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
33395 8FE7           B0                     02    mov al, #0x02
33396 8FE9           E6                     0A    out 0x000a, al ;; clear DMA-1 channel 2 mask bit
33397                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   8FEB           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   8FEE           A3         0078              mov 0x1E*4, ax
 +a   8FF1           B8                   F000    mov ax,  #0xF000
 +a   8FF4           A3         007A              mov 0x1E*4+2, ax
33398                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   8FF7           B8                   EC59    mov ax,  #int13_diskette
 +a   8FFA           A3         0100              mov 0x40*4, ax
 +a   8FFD           B8                   F000    mov ax,  #0xF000
 +a   9000           A3         0102              mov 0x40*4+2, ax
33399                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   9003           B8                   EF57    mov ax,  #int0e_handler
 +a   9006           A3         0038              mov 0x0E*4, ax
 +a   9009           B8                   F000    mov ax,  #0xF000
 +a   900C           A3         003A              mov 0x0E*4+2, ax
33400 900F           C3                           ret
33401                                           ;--------------------
33402                                           ;- POST: HARD DRIVE -
33403                                           ;--------------------
33404                                           ; relocated here because the primary POST area isnt big enough.
33405                       00009010            hard_drive_post:
33406 9010           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
33407 9012           BA                   03F6    mov dx, #0x03f6
33408 9015           EE                           out dx, al
33409 9016           31C0                         xor ax, ax
33410 9018           8ED8                         mov ds, ax
33411 901A           A2         0474              mov 0x0474, al
33412 901D           A2         0477              mov 0x0477, al
33413 9020           A2         048C              mov 0x048c, al
33414 9023           A2         048D              mov 0x048d, al
33415 9026           A2         048E              mov 0x048e, al
33416 9029           B0                     01    mov al, #0x01
33417 902B           A2         0475              mov 0x0475, al
33418 902E           B0                     C0    mov al, #0xc0
33419 9030           A2         0476              mov 0x0476, al
33420                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   9033           B8                   E3FE    mov ax,  #int13_handler
 +a   9036           A3         004C              mov 0x13*4, ax
 +a   9039           B8                   F000    mov ax,  #0xF000
 +a   903C           A3         004E              mov 0x13*4+2, ax
33421                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   903F           B8                   9316    mov ax,  #int76_handler
 +a   9042           A3         01D8              mov 0x76*4, ax
 +a   9045           B8                   F000    mov ax,  #0xF000
 +a   9048           A3         01DA              mov 0x76*4+2, ax
33422                                             ;; INT 41h: hard disk 0 configuration pointer
33423                                             ;; INT 46h: hard disk 1 configuration pointer
33424                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   904B           B8                   003D    mov ax,  #0x003D
 +a   904E           A3         0104              mov 0x41*4, ax
 +a   9051           B8                   9FC0    mov ax,  #0x9FC0
 +a   9054           A3         0106              mov 0x41*4+2, ax
33425                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   9057           B8                   004D    mov ax,  #0x004D
 +a   905A           A3         0118              mov 0x46*4, ax
 +a   905D           B8                   9FC0    mov ax,  #0x9FC0
 +a   9060           A3         011A              mov 0x46*4+2, ax
33426                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
33427 9063           B0                     12    mov al, #0x12
33428 9065           E6                     70    out 0x0070, al
33429 9067           E4                     71    in al, 0x0071
33430 9069           24                     F0    and al, #0xf0
33431 906B           3C                     F0    cmp al, #0xf0
33432 906D           74           03              je post_d0_extended
33433 906F           E9         00D4              jmp check_for_hd1
33434                       00009072            post_d0_extended:
33435 9072           B0                     19    mov al, #0x19
33436 9074           E6                     70    out 0x0070, al
33437 9076           E4                     71    in al, 0x0071
33438 9078           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
33439 907A           74           07              je post_d0_type47
33440                                             HALT(9099)
 +a   907C           BA                   0400    mov dx,#0x400
 +a   907F           B8                   238B    mov ax,#9099
 +a   9082           EF                           out dx,ax
33441                       00009083            post_d0_type47:
33442                                             ;; CMOS purpose param table offset
33443                                             ;; 1b cylinders low 0
33444                                             ;; 1c cylinders high 1
33445                                             ;; 1d heads 2
33446                                             ;; 1e write pre-comp low 5
33447                                             ;; 1f write pre-comp high 6
33448                                             ;; 20 retries/bad map/heads>8 8
33449                                             ;; 21 landing zone low C
33450                                             ;; 22 landing zone high D
33451                                             ;; 23 sectors/track E
33452 9083           B8                   9FC0    mov ax, #0x9FC0
33453 9086           8ED8                         mov ds, ax
33454                                             ;;; Filling EBDA table for hard disk 0.
33455 9088           B0                     1F    mov al, #0x1f
33456 908A           E6                     70    out 0x0070, al
33457 908C           E4                     71    in al, 0x0071
33458 908E           88C4                         mov ah, al
33459 9090           B0                     1E    mov al, #0x1e
33460 9092           E6                     70    out 0x0070, al
33461 9094           E4                     71    in al, 0x0071
33462 9096           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
33463 9099           B0                     20    mov al, #0x20
33464 909B           E6                     70    out 0x0070, al
33465 909D           E4                     71    in al, 0x0071
33466 909F           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
33467 90A2           B0                     22    mov al, #0x22
33468 90A4           E6                     70    out 0x0070, al
33469 90A6           E4                     71    in al, 0x0071
33470 90A8           88C4                         mov ah, al
33471 90AA           B0                     21    mov al, #0x21
33472 90AC           E6                     70    out 0x0070, al
33473 90AE           E4                     71    in al, 0x0071
33474 90B0           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
33475 90B3           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
33476 90B5           E6                     70    out 0x0070, al
33477 90B7           E4                     71    in al, 0x0071 ;; high byte
33478 90B9           88C4                         mov ah, al
33479 90BB           B0                     1B    mov al, #0x1b
33480 90BD           E6                     70    out 0x0070, al
33481 90BF           E4                     71    in al, 0x0071 ;; low byte
33482 90C1           89C3                         mov bx, ax ;; BX = cylinders
33483 90C3           B0                     1D    mov al, #0x1d
33484 90C5           E6                     70    out 0x0070, al
33485 90C7           E4                     71    in al, 0x0071
33486 90C9           88C1                         mov cl, al ;; CL = heads
33487 90CB           B0                     23    mov al, #0x23
33488 90CD           E6                     70    out 0x0070, al
33489 90CF           E4                     71    in al, 0x0071
33490 90D1           88C2                         mov dl, al ;; DL = sectors
33491 90D3           81FB                 0400    cmp bx, #1024
33492 90D7           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
33493                       000090D9            hd0_post_physical_chs:
33494                                             ;; no logical CHS mapping used, just physical CHS
33495                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
33496 90D9           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
33497 90DD           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
33498 90E1           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
33499 90E5           EB           5F              jmp check_for_hd1
33500                       000090E7            hd0_post_logical_chs:
33501                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
33502 90E7           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
33503 90EB           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
33504 90EF           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
33505 90F3           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
33506 90F7           B0                     A0    mov al, #0xa0
33507 90F9           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
33508 90FC           81FB                 0800    cmp bx, #2048
33509 9100           77           06              jnbe hd0_post_above_2048
33510                                             ;; 1024 < c <= 2048 cylinders
33511 9102           D1EB                         shr bx, #0x01
33512 9104           D0E1                         shl cl, #0x01
33513 9106           EB           22              jmp hd0_post_store_logical
33514                       00009108            hd0_post_above_2048:
33515 9108           81FB                 1000    cmp bx, #4096
33516 910C           77           08              jnbe hd0_post_above_4096
33517                                             ;; 2048 < c <= 4096 cylinders
33518 910E           C1EB                   02    shr bx, #0x02
33519 9111           C0E1                   02    shl cl, #0x02
33520 9114           EB           14              jmp hd0_post_store_logical
33521                       00009116            hd0_post_above_4096:
33522 9116           81FB                 2000    cmp bx, #8192
33523 911A           77           08              jnbe hd0_post_above_8192
33524                                             ;; 4096 < c <= 8192 cylinders
33525 911C           C1EB                   03    shr bx, #0x03
33526 911F           C0E1                   03    shl cl, #0x03
33527 9122           EB           06              jmp hd0_post_store_logical
33528                       00009124            hd0_post_above_8192:
33529                                             ;; 8192 < c <= 16384 cylinders
33530 9124           C1EB                   04    shr bx, #0x04
33531 9127           C0E1                   04    shl cl, #0x04
33532                       0000912A            hd0_post_store_logical:
33533 912A           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
33534 912E           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
33535                                             ;; checksum
33536 9132           B1                     0F    mov cl, #0x0f ;; repeat count
33537 9134           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
33538 9137           B0                     00    mov al, #0x00 ;; sum
33539                       00009139            hd0_post_checksum_loop:
33540 9139           0204                         add al, [si]
33541 913B           46                           inc si
33542 913C           FEC9                         dec cl
33543 913E           75           F9              jnz hd0_post_checksum_loop
33544 9140           F6D0                         not al ;; now take 2s complement
33545 9142           FEC0                         inc al
33546 9144           8804                         mov [si], al
33547                                           ;;; Done filling EBDA table for hard disk 0.
33548                       00009146            check_for_hd1:
33549                                             ;; is there really a second hard disk? if not, return now
33550 9146           B0                     12    mov al, #0x12
33551 9148           E6                     70    out 0x0070, al
33552 914A           E4                     71    in al, 0x0071
33553 914C           24                     0F    and al, #0x0f
33554 914E           75           01              jnz post_d1_exists
33555 9150           C3                           ret
33556                       00009151            post_d1_exists:
33557                                             ;; check that the hd type is really 0x0f.
33558 9151           3C                     0F    cmp al, #0x0f
33559 9153           74           07              jz post_d1_extended
33560                                             HALT(9236)
 +a   9155           BA                   0400    mov dx,#0x400
 +a   9158           B8                   2414    mov ax,#9236
 +a   915B           EF                           out dx,ax
33561                       0000915C            post_d1_extended:
33562                                             ;; check that the extended type is 47 - user definable
33563 915C           B0                     1A    mov al, #0x1a
33564 915E           E6                     70    out 0x0070, al
33565 9160           E4                     71    in al, 0x0071
33566 9162           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
33567 9164           74           07              je post_d1_type47
33568                                             HALT(9244)
 +a   9166           BA                   0400    mov dx,#0x400
 +a   9169           B8                   241C    mov ax,#9244
 +a   916C           EF                           out dx,ax
33569                       0000916D            post_d1_type47:
33570                                             ;; Table for disk1.
33571                                             ;; CMOS purpose param table offset
33572                                             ;; 0x24 cylinders low 0
33573                                             ;; 0x25 cylinders high 1
33574                                             ;; 0x26 heads 2
33575                                             ;; 0x27 write pre-comp low 5
33576                                             ;; 0x28 write pre-comp high 6
33577                                             ;; 0x29 heads>8 8
33578                                             ;; 0x2a landing zone low C
33579                                             ;; 0x2b landing zone high D
33580                                             ;; 0x2c sectors/track E
33581                                           ;;; Fill EBDA table for hard disk 1.
33582 916D           B8                   9FC0    mov ax, #0x9FC0
33583 9170           8ED8                         mov ds, ax
33584 9172           B0                     28    mov al, #0x28
33585 9174           E6                     70    out 0x0070, al
33586 9176           E4                     71    in al, 0x0071
33587 9178           88C4                         mov ah, al
33588 917A           B0                     27    mov al, #0x27
33589 917C           E6                     70    out 0x0070, al
33590 917E           E4                     71    in al, 0x0071
33591 9180           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
33592 9183           B0                     29    mov al, #0x29
33593 9185           E6                     70    out 0x0070, al
33594 9187           E4                     71    in al, 0x0071
33595 9189           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
33596 918C           B0                     2B    mov al, #0x2b
33597 918E           E6                     70    out 0x0070, al
33598 9190           E4                     71    in al, 0x0071
33599 9192           88C4                         mov ah, al
33600 9194           B0                     2A    mov al, #0x2a
33601 9196           E6                     70    out 0x0070, al
33602 9198           E4                     71    in al, 0x0071
33603 919A           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
33604 919D           B0                     25    mov al, #0x25 ;; get cylinders word in AX
33605 919F           E6                     70    out 0x0070, al
33606 91A1           E4                     71    in al, 0x0071 ;; high byte
33607 91A3           88C4                         mov ah, al
33608 91A5           B0                     24    mov al, #0x24
33609 91A7           E6                     70    out 0x0070, al
33610 91A9           E4                     71    in al, 0x0071 ;; low byte
33611 91AB           89C3                         mov bx, ax ;; BX = cylinders
33612 91AD           B0                     26    mov al, #0x26
33613 91AF           E6                     70    out 0x0070, al
33614 91B1           E4                     71    in al, 0x0071
33615 91B3           88C1                         mov cl, al ;; CL = heads
33616 91B5           B0                     2C    mov al, #0x2c
33617 91B7           E6                     70    out 0x0070, al
33618 91B9           E4                     71    in al, 0x0071
33619 91BB           88C2                         mov dl, al ;; DL = sectors
33620 91BD           81FB                 0400    cmp bx, #1024
33621 91C1           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
33622                       000091C3            hd1_post_physical_chs:
33623                                             ;; no logical CHS mapping used, just physical CHS
33624                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
33625 91C3           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
33626 91C7           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
33627 91CB           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
33628 91CF           C3                           ret
33629                       000091D0            hd1_post_logical_chs:
33630                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
33631 91D0           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
33632 91D4           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
33633 91D8           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
33634 91DC           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
33635 91E0           B0                     A0    mov al, #0xa0
33636 91E2           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
33637 91E5           81FB                 0800    cmp bx, #2048
33638 91E9           77           06              jnbe hd1_post_above_2048
33639                                             ;; 1024 < c <= 2048 cylinders
33640 91EB           D1EB                         shr bx, #0x01
33641 91ED           D0E1                         shl cl, #0x01
33642 91EF           EB           22              jmp hd1_post_store_logical
33643                       000091F1            hd1_post_above_2048:
33644 91F1           81FB                 1000    cmp bx, #4096
33645 91F5           77           08              jnbe hd1_post_above_4096
33646                                             ;; 2048 < c <= 4096 cylinders
33647 91F7           C1EB                   02    shr bx, #0x02
33648 91FA           C0E1                   02    shl cl, #0x02
33649 91FD           EB           14              jmp hd1_post_store_logical
33650                       000091FF            hd1_post_above_4096:
33651 91FF           81FB                 2000    cmp bx, #8192
33652 9203           77           08              jnbe hd1_post_above_8192
33653                                             ;; 4096 < c <= 8192 cylinders
33654 9205           C1EB                   03    shr bx, #0x03
33655 9208           C0E1                   03    shl cl, #0x03
33656 920B           EB           06              jmp hd1_post_store_logical
33657                       0000920D            hd1_post_above_8192:
33658                                             ;; 8192 < c <= 16384 cylinders
33659 920D           C1EB                   04    shr bx, #0x04
33660 9210           C0E1                   04    shl cl, #0x04
33661                       00009213            hd1_post_store_logical:
33662 9213           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
33663 9217           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
33664                                             ;; checksum
33665 921B           B1                     0F    mov cl, #0x0f ;; repeat count
33666 921D           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
33667 9220           B0                     00    mov al, #0x00 ;; sum
33668                       00009222            hd1_post_checksum_loop:
33669 9222           0204                         add al, [si]
33670 9224           46                           inc si
33671 9225           FEC9                         dec cl
33672 9227           75           F9              jnz hd1_post_checksum_loop
33673 9229           F6D0                         not al ;; now take 2s complement
33674 922B           FEC0                         inc al
33675 922D           8804                         mov [si], al
33676                                           ;;; Done filling EBDA table for hard disk 1.
33677 922F           C3                           ret
33678                                           ;--------------------
33679                                           ;- POST: EBDA segment
33680                                           ;--------------------
33681                                           ; relocated here because the primary POST area isnt big enough.
33682                       00009230            ebda_post:
33683 9230           B8                   9FC0    mov ax, #0x9FC0
33684 9233           8ED8                         mov ds, ax
33685 9235           C606       0000        01    mov byte ptr [0x0], #1
33686 923A           31C0                         xor ax, ax ; mov EBDA seg into 0x40E
33687 923C           8ED8                         mov ds, ax
33688 923E           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
33689 9244           C3                           ret;;
33690                                           ;--------------------
33691                                           ;- POST: EOI + jmp via [0x40:67)
33692                                           ;--------------------
33693                                           ; relocated here because the primary POST area isnt big enough.
33694                       00009245            eoi_jmp_post:
33695 9245           B0                     11    mov al, #0x11 ; send initialisation commands
33696 9247           E6                     20    out 0x0020, al
33697 9249           E6                     A0    out 0x00a0, al
33698 924B           B0                     08    mov al, #0x08
33699 924D           E6                     21    out 0x0021, al
33700 924F           B0                     70    mov al, #0x70
33701 9251           E6                     A1    out 0x00a1, al
33702 9253           B0                     04    mov al, #0x04
33703 9255           E6                     21    out 0x0021, al
33704 9257           B0                     02    mov al, #0x02
33705 9259           E6                     A1    out 0x00a1, al
33706 925B           B0                     01    mov al, #0x01
33707 925D           E6                     21    out 0x0021, al
33708 925F           E6                     A1    out 0x00a1, al
33709 9261           B0                     B8    mov al, #0xb8
33710 9263           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
33711 9265           B0                     8F    mov al, #0x8f
33712 9267           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
33713 9269           B0                     20    mov al, #0x20
33714 926B           E6                     A0    out 0x00a0, al ;; slave PIC EOI
33715 926D           B0                     20    mov al, #0x20
33716 926F           E6                     20    out 0x0020, al ;; master PIC EOI
33717                       00009271            jmp_post_0x467:
33718 9271           31C0                         xor ax, ax
33719 9273           8ED8                         mov ds, ax
33720 9275           FF2E       0467              jmp far ptr [0x467]
33721                       00009279            iret_post_0x467:
33722 9279           31C0                         xor ax, ax
33723 927B           8ED8                         mov ds, ax
33724 927D           8B26       0467              mov sp, [0x467]
33725 9281           8E16       0469              mov ss, [0x469]
33726 9285           CF                           iret
33727                       00009286            retf_post_0x467:
33728 9286           31C0                         xor ax, ax
33729 9288           8ED8                         mov ds, ax
33730 928A           8B26       0467              mov sp, [0x467]
33731 928E           8E16       0469              mov ss, [0x469]
33732 9292           CB                           retf
33733                       00009293            s3_post:
33734 9293           BC                   0FFE    mov sp, #0xffe
33735 9296           E8         0797              call rombios32_init
33736 9299           E8         850B              call _s3_resume
33737 929C           B3                     00    mov bl, #0x00
33738 929E           21C0                         and ax, ax
33739 92A0   7503    E9         4DFE              jz normal_post
33740 92A5           E8         7F27              call _s3_resume_panic
33741                                           ;--------------------
33742                       000092A8            eoi_both_pics:
33743 92A8           B0                     20    mov al, #0x20
33744 92AA           E6                     A0    out 0x00a0, al ;; slave PIC EOI
33745                       000092AC            eoi_master_pic:
33746 92AC           B0                     20    mov al, #0x20
33747 92AE           E6                     20    out 0x0020, al ;; master PIC EOI
33748 92B0           C3                           ret
33749                                           ;--------------------
33750                       000092B1            BcdToBin:
33751                                             ;; in: AL in BCD format
33752                                             ;; out: AL in binary format, AH will always be 0
33753                                             ;; trashes BX
33754 92B1           88C3                         mov bl, al
33755 92B3           80E3                   0F    and bl, #0x0f ;; bl has low digit
33756 92B6           C0E8                   04    shr al, #4 ;; al has high digit
33757 92B9           B7                     0A    mov bh, #10
33758 92BB           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
33759 92BD           00D8                         add al, bl ;; then add low digit
33760 92BF           C3                           ret
33761                                           ;--------------------
33762                       000092C0            timer_tick_post:
33763                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
33764                                             ;; Timer Ticks Roller Flag (0x470:byte)
33765                                             ;; The Timer Ticks Count needs to be set according to
33766                                             ;; the current CMOS time, as if ticks have been occurring
33767                                             ;; at 18.2hz since midnight up to this point. Calculating
33768                                             ;; this is a little complicated. Here are the factors I gather
33769                                             ;; regarding this. 14,318,180 hz was the original clock speed,
33770                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
33771                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
33772                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
33773                                             ;; the timer. With a maximum 16bit timer count, this is again
33774                                             ;; divided down by 65536 to 18.2hz.
33775                                             ;;
33776                                             ;; 14,318,180 Hz clock
33777                                             ;; /3 = 4,772,726 Hz fed to original 5Mhz CPU
33778                                             ;; /4 = 1,193,181 Hz fed to timer
33779                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
33780                                             ;; 1 second = 18.20650736 ticks
33781                                             ;; 1 minute = 1092.390442 ticks
33782                                             ;; 1 hour = 65543.42651 ticks
33783                                             ;;
33784                                             ;; Given the values in the CMOS clock, one could calculate
33785                                             ;; the number of ticks by the following:
33786                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
33787                                             ;; (BcdToBin(minutes) * 1092.3904)
33788                                             ;; (BcdToBin(hours) * 65543.427)
33789                                             ;; To get a little more accuracy, since Im using integer
33790                                             ;; arithmetic, I use:
33791                                             ;; ticks = (((BcdToBin(hours) * 60 + BcdToBin(minutes)) * 60 + BcdToBin(seconds)) * (18 * 4294967296 + 886942379)) / 4294967296
33792                                             ;; assuming DS=0000
33793                                             ;; get CMOS hours
33794 92C0     66    31C0                         xor eax, eax ;; clear EAX
33795 92C3           B0                     04    mov al, #0x04
33796 92C5           E6                     70    out 0x0070, al
33797 92C7           E4                     71    in al, 0x0071 ;; AL has CMOS hours in BCD
33798 92C9           E8         FFE5              call BcdToBin ;; EAX now has hours in binary
33799 92CC     66    6BC0                   3C    imul eax, #60
33800 92D0     66    89C2                         mov edx, eax
33801                                             ;; get CMOS minutes
33802 92D3     66    31C0                         xor eax, eax ;; clear EAX
33803 92D6           B0                     02    mov al, #0x02
33804 92D8           E6                     70    out 0x0070, al
33805 92DA           E4                     71    in al, 0x0071 ;; AL has CMOS minutes in BCD
33806 92DC           E8         FFD2              call BcdToBin ;; EAX now has minutes in binary
33807 92DF     66    01D0                         add eax, edx
33808 92E2     66    6BC0                   3C    imul eax, #60
33809 92E6     66    89C2                         mov edx, eax
33810                                             ;; get CMOS seconds
33811 92E9     66    31C0                         xor eax, eax ;; clear EAX
33812 92EC           B0                     00    mov al, #0x00
33813 92EE           E6                     70    out 0x0070, al
33814 92F0           E4                     71    in al, 0x0071 ;; AL has CMOS seconds in BCD
33815 92F2           E8         FFBC              call BcdToBin ;; EAX now has seconds in binary
33816 92F5     66    01D0                         add eax, edx
33817                                             ;; multiplying 18.2065073649
33818 92F8     66    89C1                         mov ecx, eax
33819 92FB     66    6BC9                   12    imul ecx, #18
33820 92FF     66    BA               34DDAAAB    mov edx, #886942379
33821 9305     66    F7E2                         mul edx
33822 9308     66    01D1                         add ecx, edx
33823 930B     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
33824 9310           30C0                         xor al, al
33825 9312           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
33826 9315           C3                           ret
33827                                           ;--------------------
33828                       00009316            int76_handler:
33829                                             ;; record completion in BIOS task complete flag
33830 9316           50                           push ax
33831 9317           1E                           push ds
33832 9318           B8                   0040    mov ax, #0x0040
33833 931B           8ED8                         mov ds, ax
33834 931D           C606       008E        FF    mov BYTE 0x008E, #0xff
33835 9322           E8         FF83              call eoi_both_pics
33836                                             ;; Notify fixed disk interrupt complete w/ int 15h, function AX=9100
33837 9325           B8                   9100    mov ax, #0x9100
33838 9328           CD                     15    int 0x15
33839 932A           1F                           pop ds
33840 932B           58                           pop ax
33841 932C           CF                           iret
33842                                           ;--------------------
33843                                           use32 386
33844                       0000932D            apm32_out_str:
33845 932D           50                           push eax
33846 932E           53                           push ebx
33847 932F           89C3                         mov ebx, eax
33848                       00009331            apm32_out_str1:
33849 9331           2E                           SEG CS
33850 9332   67      8A07                         mov al, byte ptr [bx]
33851 9335           3C                     00    cmp al, #0
33852 9337           74           04              je apm32_out_str2
33853 9339           EE                           outb dx, al
33854 933A           43                           inc ebx
33855 933B           EB           F4              jmp apm32_out_str1
33856                       0000933D            apm32_out_str2:
33857 933D           5B                           pop ebx
33858 933E           58                           pop eax
33859 933F           C3                           ret
33860                       00009340            apm32_07_poweroff_str:
33861 9340                        53              .ascii "Shutdown"
33862 9348                        00              db 0
33863                       00009349            apm32_07_suspend_str:
33864 9349                        53              .ascii "Suspend"
33865 9350                        00              db 0
33866                       00009351            apm32_07_standby_str:
33867 9351                        53              .ascii "Standby"
33868 9358                        00              db 0
33869                       00009359            _apm32_entry:
33870 9359     66    9C                           pushf
33871                                           ;-----------------
33872                                           ; APM interface disconnect
33873                       0000935B            apm32_04:
33874 935B           3C                     04    cmp al, #0x04
33875 935D           75           05              jne apm32_05
33876 935F           E9     000000A1              jmp apm32_ok
33877                                           ;-----------------
33878                                           ; APM cpu idle
33879                       00009364            apm32_05:
33880 9364           3C                     05    cmp al, #0x05
33881 9366           75           07              jne apm32_07
33882 9368           FB                           sti
33883 9369           F4                           hlt
33884 936A           E9     00000096              jmp apm32_ok
33885                                           ;-----------------
33886                                           ; APM Set Power State
33887                       0000936F            apm32_07:
33888 936F           3C                     07    cmp al, #0x07
33889 9371           75           52              jne apm32_08
33890 9373     66    83FB                   01    cmp bx, #1
33891 9377   7405    E9     00000087              jne apm32_ok
33892 937E     66    83F9                   03    cmp cx, #3
33893 9382           74           0E              je apm32_07_poweroff
33894 9384     66    83F9                   02    cmp cx, #2
33895 9388           74           19              je apm32_07_suspend
33896 938A     66    83F9                   01    cmp cx, #1
33897 938E           74           24              je apm32_07_standby
33898 9390           75           73              jne apm32_ok
33899                       00009392            apm32_07_poweroff:
33900 9392           FA                           cli
33901 9393     66    BA                   8900    mov dx, #0x8900
33902 9397     66    B8                   9340    mov ax, #apm32_07_poweroff_str
33903 939B           E8     FFFFFF8D              call apm32_out_str
33904                       000093A0            apm32_07_1:
33905 93A0           F4                           hlt
33906 93A1           EB           FD              jmp apm32_07_1
33907                       000093A3            apm32_07_suspend:
33908 93A3           52                           push edx
33909 93A4     66    BA                   8900    mov dx, #0x8900
33910 93A8     66    B8                   9349    mov ax, #apm32_07_suspend_str
33911 93AC           E8     FFFFFF7C              call apm32_out_str
33912 93B1           5A                           pop edx
33913 93B2           EB           51              jmp apm32_ok
33914                       000093B4            apm32_07_standby:
33915 93B4           52                           push edx
33916 93B5     66    BA                   8900    mov dx, #0x8900
33917 93B9     66    B8                   9351    mov ax, #apm32_07_standby_str
33918 93BD           E8     FFFFFF6B              call apm32_out_str
33919 93C2           5A                           pop edx
33920 93C3           EB           40              jmp apm32_ok
33921                                           ;-----------------
33922                                           ; APM Enable / Disable
33923                       000093C5            apm32_08:
33924 93C5           3C                     08    cmp al, #0x08
33925 93C7           75           02              jne apm32_0a
33926 93C9           EB           3A              jmp apm32_ok
33927                                           ;-----------------
33928                                           ; Get Power Status
33929                       000093CB            apm32_0a:
33930 93CB           3C                     0A    cmp al, #0x0a
33931 93CD           75           12              jne apm32_0b
33932 93CF           B7                     01    mov bh, #0x01
33933 93D1           B3                     FF    mov bl, #0xff
33934 93D3           B5                     80    mov ch, #0x80
33935 93D5           B1                     FF    mov cl, #0xff
33936 93D7     66    BA                   FFFF    mov dx, #0xffff
33937 93DB     66    BE                   0000    mov si, #0
33938 93DF           EB           24              jmp apm32_ok
33939                                           ;-----------------
33940                                           ; Get PM Event
33941                       000093E1            apm32_0b:
33942 93E1           3C                     0B    cmp al, #0x0b
33943 93E3           75           04              jne apm32_0e
33944 93E5           B4                     80    mov ah, #0x80
33945 93E7           EB           20              jmp apm32_error
33946                                           ;-----------------
33947                                           ; APM Driver Version
33948                       000093E9            apm32_0e:
33949 93E9           3C                     0E    cmp al, #0x0e
33950 93EB           75           06              jne apm32_0f
33951 93ED           B4                     01    mov ah, #1
33952 93EF           B0                     02    mov al, #2
33953 93F1           EB           12              jmp apm32_ok
33954                                           ;-----------------
33955                                           ; APM Engage / Disengage
33956                       000093F3            apm32_0f:
33957 93F3           3C                     0F    cmp al, #0x0f
33958 93F5           75           02              jne apm32_10
33959 93F7           EB           0C              jmp apm32_ok
33960                                           ;-----------------
33961                                           ; APM Get Capabilities
33962                       000093F9            apm32_10:
33963 93F9           3C                     10    cmp al, #0x10
33964 93FB           75           0C              jne apm32_unimplemented
33965 93FD           B3                     00    mov bl, #0
33966 93FF     66    B9                   0000    mov cx, #0
33967 9403           EB           00              jmp apm32_ok
33968                                           ;-----------------
33969                       00009405            apm32_ok:
33970 9405     66    9D                           popf
33971 9407           F8                           clc
33972 9408           CB                           retf
33973                       00009409            apm32_unimplemented:
33974                       00009409            apm32_error:
33975 9409     66    9D                           popf
33976 940B           F9                           stc
33977 940C           CB                           retf
33978                                           use16 386
33979                       0000940D            apm16_out_str:
33980 940D     66    50                           push eax
33981 940F     66    53                           push ebx
33982 9411     66    89C3                         mov ebx, eax
33983                       00009414            apm16_out_str1:
33984 9414           2E                           SEG CS
33985 9415           8A07                         mov al, byte ptr [bx]
33986 9417           3C                     00    cmp al, #0
33987 9419           74           05              je apm16_out_str2
33988 941B           EE                           outb dx, al
33989 941C     66    43                           inc ebx
33990 941E           EB           F4              jmp apm16_out_str1
33991                       00009420            apm16_out_str2:
33992 9420     66    5B                           pop ebx
33993 9422     66    58                           pop eax
33994 9424           C3                           ret
33995                       00009425            apm16_07_poweroff_str:
33996 9425                        53              .ascii "Shutdown"
33997 942D                        00              db 0
33998                       0000942E            apm16_07_suspend_str:
33999 942E                        53              .ascii "Suspend"
34000 9435                        00              db 0
34001                       00009436            apm16_07_standby_str:
34002 9436                        53              .ascii "Standby"
34003 943D                        00              db 0
34004                       0000943E            _apm16_entry:
34005 943E           9C                           pushf
34006                                           ;-----------------
34007                                           ; APM interface disconnect
34008                       0000943F            apm16_04:
34009 943F           3C                     04    cmp al, #0x04
34010 9441           75           03              jne apm16_05
34011 9443           E9         008B              jmp apm16_ok
34012                                           ;-----------------
34013                                           ; APM cpu idle
34014                       00009446            apm16_05:
34015 9446           3C                     05    cmp al, #0x05
34016 9448           75           05              jne apm16_07
34017 944A           FB                           sti
34018 944B           F4                           hlt
34019 944C           E9         0082              jmp apm16_ok
34020                                           ;-----------------
34021                                           ; APM Set Power State
34022                       0000944F            apm16_07:
34023 944F           3C                     07    cmp al, #0x07
34024 9451           75           41              jne apm16_08
34025 9453           83FB                   01    cmp bx, #1
34026 9456           75           79              jne apm16_ok
34027 9458           83F9                   03    cmp cx, #3
34028 945B           74           0C              je apm16_07_poweroff
34029 945D           83F9                   02    cmp cx, #2
34030 9460           74           14              je apm16_07_suspend
34031 9462           83F9                   01    cmp cx, #1
34032 9465           74           1E              je apm16_07_standby
34033 9467           75           68              jne apm16_ok
34034                       00009469            apm16_07_poweroff:
34035 9469           FA                           cli
34036 946A           BA                   8900    mov dx, #0x8900
34037 946D           B8                   9425    mov ax, #apm16_07_poweroff_str
34038 9470           E8         FF9A              call apm16_out_str
34039                       00009473            apm16_07_1:
34040 9473           F4                           hlt
34041 9474           EB           FD              jmp apm16_07_1
34042                       00009476            apm16_07_suspend:
34043 9476     66    52                           push edx
34044 9478           BA                   8900    mov dx, #0x8900
34045 947B           B8                   942E    mov ax, #apm16_07_suspend_str
34046 947E           E8         FF8C              call apm16_out_str
34047 9481     66    5A                           pop edx
34048 9483           EB           4C              jmp apm16_ok
34049                       00009485            apm16_07_standby:
34050 9485     66    52                           push edx
34051 9487           BA                   8900    mov dx, #0x8900
34052 948A           B8                   9436    mov ax, #apm16_07_standby_str
34053 948D           E8         FF7D              call apm16_out_str
34054 9490     66    5A                           pop edx
34055 9492           EB           3D              jmp apm16_ok
34056                                           ;-----------------
34057                                           ; APM Enable / Disable
34058                       00009494            apm16_08:
34059 9494           3C                     08    cmp al, #0x08
34060 9496           75           02              jne apm16_0a
34061 9498           EB           37              jmp apm16_ok
34062                                           ;-----------------
34063                                           ; Get Power Status
34064                       0000949A            apm16_0a:
34065 949A           3C                     0A    cmp al, #0x0a
34066 949C           75           10              jne apm16_0b
34067 949E           B7                     01    mov bh, #0x01
34068 94A0           B3                     FF    mov bl, #0xff
34069 94A2           B5                     80    mov ch, #0x80
34070 94A4           B1                     FF    mov cl, #0xff
34071 94A6           BA                   FFFF    mov dx, #0xffff
34072 94A9           BE                   0000    mov si, #0
34073 94AC           EB           23              jmp apm16_ok
34074                                           ;-----------------
34075                                           ; Get PM Event
34076                       000094AE            apm16_0b:
34077 94AE           3C                     0B    cmp al, #0x0b
34078 94B0           75           04              jne apm16_0e
34079 94B2           B4                     80    mov ah, #0x80
34080 94B4           EB           1E              jmp apm16_error
34081                                           ;-----------------
34082                                           ; APM Driver Version
34083                       000094B6            apm16_0e:
34084 94B6           3C                     0E    cmp al, #0x0e
34085 94B8           75           06              jne apm16_0f
34086 94BA           B4                     01    mov ah, #1
34087 94BC           B0                     02    mov al, #2
34088 94BE           EB           11              jmp apm16_ok
34089                                           ;-----------------
34090                                           ; APM Engage / Disengage
34091                       000094C0            apm16_0f:
34092 94C0           3C                     0F    cmp al, #0x0f
34093 94C2           75           02              jne apm16_10
34094 94C4           EB           0B              jmp apm16_ok
34095                                           ;-----------------
34096                                           ; APM Get Capabilities
34097                       000094C6            apm16_10:
34098 94C6           3C                     10    cmp al, #0x10
34099 94C8           75           0A              jne apm16_unimplemented
34100 94CA           B3                     00    mov bl, #0
34101 94CC           B9                   0000    mov cx, #0
34102 94CF           EB           00              jmp apm16_ok
34103                                           ;-----------------
34104                       000094D1            apm16_ok:
34105 94D1           9D                           popf
34106 94D2           F8                           clc
34107 94D3           CB                           retf
34108                       000094D4            apm16_unimplemented:
34109                       000094D4            apm16_error:
34110 94D4           9D                           popf
34111 94D5           F9                           stc
34112 94D6           CB                           retf
34113                       000094D7            apmreal_out_str:
34114 94D7     66    50                           push eax
34115 94D9     66    53                           push ebx
34116 94DB     66    89C3                         mov ebx, eax
34117                       000094DE            apmreal_out_str1:
34118 94DE           2E                           SEG CS
34119 94DF           8A07                         mov al, byte ptr [bx]
34120 94E1           3C                     00    cmp al, #0
34121 94E3           74           05              je apmreal_out_str2
34122 94E5           EE                           outb dx, al
34123 94E6     66    43                           inc ebx
34124 94E8           EB           F4              jmp apmreal_out_str1
34125                       000094EA            apmreal_out_str2:
34126 94EA     66    5B                           pop ebx
34127 94EC     66    58                           pop eax
34128 94EE           C3                           ret
34129                       000094EF            apmreal_07_poweroff_str:
34130 94EF                        53              .ascii "Shutdown"
34131 94F7                        00              db 0
34132                       000094F8            apmreal_07_suspend_str:
34133 94F8                        53              .ascii "Suspend"
34134 94FF                        00              db 0
34135                       00009500            apmreal_07_standby_str:
34136 9500                        53              .ascii "Standby"
34137 9507                        00              db 0
34138 9508           9C                           pushf
34139                       00009509            _apmreal_entry:
34140                                           ;-----------------
34141                                           ; APM installation check
34142                       00009509            apmreal_00:
34143 9509           3C                     00    cmp al, #0x00
34144 950B           75           0E              jne apmreal_01
34145 950D           B4                     01    mov ah, #1
34146 950F           B0                     02    mov al, #2
34147 9511           B7                     50    mov bh, #0x50
34148 9513           B3                     4D    mov bl, #0x4d
34149 9515           B9                   0003    mov cx, #0x3
34150 9518           E9         00CE              jmp apmreal_ok
34151                                           ;-----------------
34152                                           ; APM real mode interface connect
34153                       0000951B            apmreal_01:
34154 951B           3C                     01    cmp al, #0x01
34155 951D           75           03              jne apmreal_02
34156 951F           E9         00C7              jmp apmreal_ok
34157                                           ;-----------------
34158                                           ; APM 16 bit protected mode interface connect
34159                       00009522            apmreal_02:
34160 9522           3C                     02    cmp al, #0x02
34161 9524           75           12              jne apmreal_03
34162 9526           BB                   943E    mov bx, #_apm16_entry
34163 9529           B8                   F000    mov ax, #0xf000
34164 952C           BE                   FFF0    mov si, #0xfff0
34165 952F           B9                   F000    mov cx, #0xf000
34166 9532           BF                   FFF0    mov di, #0xfff0
34167 9535           E9         00B1              jmp apmreal_ok
34168                                           ;-----------------
34169                                           ; APM 32 bit protected mode interface connect
34170                       00009538            apmreal_03:
34171 9538           3C                     03    cmp al, #0x03
34172 953A           75           1B              jne apmreal_04
34173 953C           B8                   F000    mov ax, #0xf000
34174 953F     66    BB               00009359    mov ebx, #_apm32_entry
34175 9545           B9                   F000    mov cx, #0xf000
34176 9548     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
34177 954E           BA                   F000    mov dx, #0xf000
34178 9551           BF                   FFF0    mov di, #0xfff0
34179 9554           E9         0092              jmp apmreal_ok
34180                                           ;-----------------
34181                                           ; APM interface disconnect
34182                       00009557            apmreal_04:
34183 9557           3C                     04    cmp al, #0x04
34184 9559           75           03              jne apmreal_05
34185 955B           E9         008B              jmp apmreal_ok
34186                                           ;-----------------
34187                                           ; APM cpu idle
34188                       0000955E            apmreal_05:
34189 955E           3C                     05    cmp al, #0x05
34190 9560           75           05              jne apmreal_07
34191 9562           FB                           sti
34192 9563           F4                           hlt
34193 9564           E9         0082              jmp apmreal_ok
34194                                           ;-----------------
34195                                           ; APM Set Power State
34196                       00009567            apmreal_07:
34197 9567           3C                     07    cmp al, #0x07
34198 9569           75           41              jne apmreal_08
34199 956B           83FB                   01    cmp bx, #1
34200 956E           75           79              jne apmreal_ok
34201 9570           83F9                   03    cmp cx, #3
34202 9573           74           0C              je apmreal_07_poweroff
34203 9575           83F9                   02    cmp cx, #2
34204 9578           74           14              je apmreal_07_suspend
34205 957A           83F9                   01    cmp cx, #1
34206 957D           74           1E              je apmreal_07_standby
34207 957F           75           68              jne apmreal_ok
34208                       00009581            apmreal_07_poweroff:
34209 9581           FA                           cli
34210 9582           BA                   8900    mov dx, #0x8900
34211 9585           B8                   94EF    mov ax, #apmreal_07_poweroff_str
34212 9588           E8         FF4C              call apmreal_out_str
34213                       0000958B            apmreal_07_1:
34214 958B           F4                           hlt
34215 958C           EB           FD              jmp apmreal_07_1
34216                       0000958E            apmreal_07_suspend:
34217 958E     66    52                           push edx
34218 9590           BA                   8900    mov dx, #0x8900
34219 9593           B8                   94F8    mov ax, #apmreal_07_suspend_str
34220 9596           E8         FF3E              call apmreal_out_str
34221 9599     66    5A                           pop edx
34222 959B           EB           4C              jmp apmreal_ok
34223                       0000959D            apmreal_07_standby:
34224 959D     66    52                           push edx
34225 959F           BA                   8900    mov dx, #0x8900
34226 95A2           B8                   9500    mov ax, #apmreal_07_standby_str
34227 95A5           E8         FF2F              call apmreal_out_str
34228 95A8     66    5A                           pop edx
34229 95AA           EB           3D              jmp apmreal_ok
34230                                           ;-----------------
34231                                           ; APM Enable / Disable
34232                       000095AC            apmreal_08:
34233 95AC           3C                     08    cmp al, #0x08
34234 95AE           75           02              jne apmreal_0a
34235 95B0           EB           37              jmp apmreal_ok
34236                                           ;-----------------
34237                                           ; Get Power Status
34238                       000095B2            apmreal_0a:
34239 95B2           3C                     0A    cmp al, #0x0a
34240 95B4           75           10              jne apmreal_0b
34241 95B6           B7                     01    mov bh, #0x01
34242 95B8           B3                     FF    mov bl, #0xff
34243 95BA           B5                     80    mov ch, #0x80
34244 95BC           B1                     FF    mov cl, #0xff
34245 95BE           BA                   FFFF    mov dx, #0xffff
34246 95C1           BE                   0000    mov si, #0
34247 95C4           EB           23              jmp apmreal_ok
34248                                           ;-----------------
34249                                           ; Get PM Event
34250                       000095C6            apmreal_0b:
34251 95C6           3C                     0B    cmp al, #0x0b
34252 95C8           75           04              jne apmreal_0e
34253 95CA           B4                     80    mov ah, #0x80
34254 95CC           EB           20              jmp apmreal_error
34255                                           ;-----------------
34256                                           ; APM Driver Version
34257                       000095CE            apmreal_0e:
34258 95CE           3C                     0E    cmp al, #0x0e
34259 95D0           75           06              jne apmreal_0f
34260 95D2           B4                     01    mov ah, #1
34261 95D4           B0                     02    mov al, #2
34262 95D6           EB           11              jmp apmreal_ok
34263                                           ;-----------------
34264                                           ; APM Engage / Disengage
34265                       000095D8            apmreal_0f:
34266 95D8           3C                     0F    cmp al, #0x0f
34267 95DA           75           02              jne apmreal_10
34268 95DC           EB           0B              jmp apmreal_ok
34269                                           ;-----------------
34270                                           ; APM Get Capabilities
34271                       000095DE            apmreal_10:
34272 95DE           3C                     10    cmp al, #0x10
34273 95E0           75           0C              jne apmreal_unimplemented
34274 95E2           B3                     00    mov bl, #0
34275 95E4           B9                   0000    mov cx, #0
34276 95E7           EB           00              jmp apmreal_ok
34277                                           ;-----------------
34278                       000095E9            apmreal_ok:
34279 95E9           9D                           popf
34280 95EA           F8                           clc
34281 95EB           E9         F8BA              jmp iret_modify_cf
34282                       000095EE            apmreal_unimplemented:
34283                       000095EE            apmreal_error:
34284 95EE           9D                           popf
34285 95EF           F9                           stc
34286 95F0           E9         F8B5              jmp iret_modify_cf
34287                                           ;--------------------
34288                                           use32 386
34289 95F3                  00000010            .align 16
34290                       00009600            bios32_structure:
34291 9600                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
34292 9604                      9610              dw bios32_entry_point, 0xf ;; 32 bit physical address
34293 9608                        00              db 0 ;; revision level
34294                                             ;; length in paragraphs and checksum stored in a word to prevent errors
34295 9609                      2701              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
34296 960B                        00              db 0,0,0,0,0 ;; reserved
34297 9610                  00000010            .align 16
34298                       00009610            bios32_entry_point:
34299 9610           9C                           pushfd
34300 9611           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
34301 9616           75           3E              jne unknown_service
34302 9618           B8               80000000    mov eax, #0x80000000
34303 961D     66    BA                   0CF8    mov dx, #0x0cf8
34304 9621           EF                           out dx, eax
34305 9622     66    BA                   0CFC    mov dx, #0x0cfc
34306 9626           ED                           in eax, dx
34307 9627           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
34308 962C           74           15              je pci_found
34309 962E           3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
34310 9633           74           0E              je pci_found
34311 9635           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34312 963A           74           07              je pci_found
34313                                             ;; say ok if a device is present
34314 963C           3D               FFFFFFFF    cmp eax, #0xffffffff
34315 9641           74           13              je unknown_service
34316                       00009643            pci_found:
34317 9643           BB               000F0000    mov ebx, #0x000f0000
34318 9648           B9               00010000    mov ecx, #0x10000
34319 964D           BA               00009660    mov edx, #pcibios_protected
34320 9652           30C0                         xor al, al
34321 9654           EB           02              jmp bios32_end
34322                       00009656            unknown_service:
34323 9656           B0                     80    mov al, #0x80
34324                       00009658            bios32_end:
34325 9658           9D                           popfd
34326 9659           CB                           retf
34327 965A                  00000010            .align 16
34328                       00009660            pcibios_protected:
34329 9660           9C                           pushfd
34330 9661           FA                           cli
34331 9662           56                           push esi
34332 9663           57                           push edi
34333 9664           3C                     01    cmp al, #0x01 ;; installation check
34334 9666           75           15              jne pci_pro_f02
34335 9668     66    BB                   0210    mov bx, #0x0210
34336 966C           E8     0000012E              call pci_pro_get_max_bus ;; sets CX
34337 9671           BA               20494350    mov edx, #0x20494350 ;; "PCI "
34338 9676           B0                     01    mov al, #0x01
34339 9678           E9     0000011B              jmp pci_pro_ok
34340                       0000967D            pci_pro_f02: ;; find pci device
34341 967D           3C                     02    cmp al, #0x02
34342 967F           75           38              jne pci_pro_f03
34343 9681           C1E1                   10    shl ecx, #16
34344 9684     66    89D1                         mov cx, dx
34345 9687     66    31DB                         xor bx, bx
34346 968A     66    BF                   0000    mov di, #0x00
34347                       0000968E            pci_pro_devloop:
34348 968E           E8     0000012D              call pci_pro_select_reg
34349 9693     66    BA                   0CFC    mov dx, #0x0cfc
34350 9697           ED                           in eax, dx
34351 9698           39C8                         cmp eax, ecx
34352 969A           75           0D              jne pci_pro_nextdev
34353 969C     66    83FE                   00    cmp si, #0
34354 96A0   7505    E9     000000F1              je pci_pro_ok
34355 96A7     66    4E                           dec si
34356                       000096A9            pci_pro_nextdev:
34357 96A9     66    43                           inc bx
34358 96AB     66    81FB                 0200    cmp bx, #0x0200
34359 96B0           75           DC              jne pci_pro_devloop
34360 96B2           B4                     86    mov ah, #0x86
34361 96B4           E9     000000DA              jmp pci_pro_fail
34362                       000096B9            pci_pro_f03: ;; find class code
34363 96B9           3C                     03    cmp al, #0x03
34364 96BB           75           35              jne pci_pro_f08
34365 96BD     66    31DB                         xor bx, bx
34366 96C0     66    BF                   0008    mov di, #0x08
34367                       000096C4            pci_pro_devloop2:
34368 96C4           E8     000000F7              call pci_pro_select_reg
34369 96C9     66    BA                   0CFC    mov dx, #0x0cfc
34370 96CD           ED                           in eax, dx
34371 96CE           C1E8                   08    shr eax, #8
34372 96D1           39C8                         cmp eax, ecx
34373 96D3           75           0D              jne pci_pro_nextdev2
34374 96D5     66    83FE                   00    cmp si, #0
34375 96D9   7505    E9     000000B8              je pci_pro_ok
34376 96E0     66    4E                           dec si
34377                       000096E2            pci_pro_nextdev2:
34378 96E2     66    43                           inc bx
34379 96E4     66    81FB                 0200    cmp bx, #0x0200
34380 96E9           75           D9              jne pci_pro_devloop2
34381 96EB           B4                     86    mov ah, #0x86
34382 96ED           E9     000000A1              jmp pci_pro_fail
34383                       000096F2            pci_pro_f08: ;; read configuration byte
34384 96F2           3C                     08    cmp al, #0x08
34385 96F4           75           1B              jne pci_pro_f09
34386 96F6           E8     000000C5              call pci_pro_select_reg
34387 96FB           52                           push edx
34388 96FC     66    89FA                         mov dx, di
34389 96FF     66    83E2                   03    and dx, #0x03
34390 9703     66    81C2                 0CFC    add dx, #0x0cfc
34391 9708           EC                           in al, dx
34392 9709           5A                           pop edx
34393 970A           88C1                         mov cl, al
34394 970C           E9     00000087              jmp pci_pro_ok
34395                       00009711            pci_pro_f09: ;; read configuration word
34396 9711           3C                     09    cmp al, #0x09
34397 9713           75           1A              jne pci_pro_f0a
34398 9715           E8     000000A6              call pci_pro_select_reg
34399 971A           52                           push edx
34400 971B     66    89FA                         mov dx, di
34401 971E     66    83E2                   02    and dx, #0x02
34402 9722     66    81C2                 0CFC    add dx, #0x0cfc
34403 9727     66    ED                           in ax, dx
34404 9729           5A                           pop edx
34405 972A     66    89C1                         mov cx, ax
34406 972D           EB           69              jmp pci_pro_ok
34407                       0000972F            pci_pro_f0a: ;; read configuration dword
34408 972F           3C                     0A    cmp al, #0x0a
34409 9731           75           10              jne pci_pro_f0b
34410 9733           E8     00000088              call pci_pro_select_reg
34411 9738           52                           push edx
34412 9739     66    BA                   0CFC    mov dx, #0x0cfc
34413 973D           ED                           in eax, dx
34414 973E           5A                           pop edx
34415 973F           89C1                         mov ecx, eax
34416 9741           EB           55              jmp pci_pro_ok
34417                       00009743            pci_pro_f0b: ;; write configuration byte
34418 9743           3C                     0B    cmp al, #0x0b
34419 9745           75           18              jne pci_pro_f0c
34420 9747           E8     00000074              call pci_pro_select_reg
34421 974C           52                           push edx
34422 974D     66    89FA                         mov dx, di
34423 9750     66    83E2                   03    and dx, #0x03
34424 9754     66    81C2                 0CFC    add dx, #0x0cfc
34425 9759           88C8                         mov al, cl
34426 975B           EE                           out dx, al
34427 975C           5A                           pop edx
34428 975D           EB           39              jmp pci_pro_ok
34429                       0000975F            pci_pro_f0c: ;; write configuration word
34430 975F           3C                     0C    cmp al, #0x0c
34431 9761           75           1A              jne pci_pro_f0d
34432 9763           E8     00000058              call pci_pro_select_reg
34433 9768           52                           push edx
34434 9769     66    89FA                         mov dx, di
34435 976C     66    83E2                   02    and dx, #0x02
34436 9770     66    81C2                 0CFC    add dx, #0x0cfc
34437 9775     66    89C8                         mov ax, cx
34438 9778     66    EF                           out dx, ax
34439 977A           5A                           pop edx
34440 977B           EB           1B              jmp pci_pro_ok
34441                       0000977D            pci_pro_f0d: ;; write configuration dword
34442 977D           3C                     0D    cmp al, #0x0d
34443 977F           75           10              jne pci_pro_unknown
34444 9781           E8     0000003A              call pci_pro_select_reg
34445 9786           52                           push edx
34446 9787     66    BA                   0CFC    mov dx, #0x0cfc
34447 978B           89C8                         mov eax, ecx
34448 978D           EF                           out dx, eax
34449 978E           5A                           pop edx
34450 978F           EB           07              jmp pci_pro_ok
34451                       00009791            pci_pro_unknown:
34452 9791           B4                     81    mov ah, #0x81
34453                       00009793            pci_pro_fail:
34454 9793           5F                           pop edi
34455 9794           5E                           pop esi
34456 9795           9D                           popfd
34457 9796           F9                           stc
34458 9797           CB                           retf
34459                       00009798            pci_pro_ok:
34460 9798           30E4                         xor ah, ah
34461 979A           5F                           pop edi
34462 979B           5E                           pop esi
34463 979C           9D                           popfd
34464 979D           F8                           clc
34465 979E           CB                           retf
34466                       0000979F            pci_pro_get_max_bus:
34467 979F           50                           push eax
34468 97A0           B8               80000000    mov eax, #0x80000000
34469 97A5     66    BA                   0CF8    mov dx, #0x0cf8
34470 97A9           EF                           out dx, eax
34471 97AA     66    BA                   0CFC    mov dx, #0x0cfc
34472 97AE           ED                           in eax, dx
34473 97AF     66    B9                   0000    mov cx, #0
34474 97B3           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34475 97B8           75           04              jne pci_pro_no_i440bx
34476 97BA     66    B9                   0001    mov cx, #0x0001
34477                       000097BE            pci_pro_no_i440bx:
34478 97BE           58                           pop eax
34479 97BF           C3                           ret
34480                       000097C0            pci_pro_select_reg:
34481 97C0           52                           push edx
34482 97C1           B8               00800000    mov eax, #0x800000
34483 97C6     66    89D8                         mov ax, bx
34484 97C9           C1E0                   08    shl eax, #8
34485 97CC     66    81E7                 00FF    and di, #0xff
34486 97D1     66    09F8                         or ax, di
34487 97D4           24                     FC    and al, #0xfc
34488 97D6     66    BA                   0CF8    mov dx, #0x0cf8
34489 97DA           EF                           out dx, eax
34490 97DB           5A                           pop edx
34491 97DC           C3                           ret
34492                                           use16 386
34493                       000097DD            pcibios_real:
34494 97DD     66    50                           push eax
34495 97DF           52                           push dx
34496 97E0     66    B8               80000000    mov eax, #0x80000000
34497 97E6           BA                   0CF8    mov dx, #0x0cf8
34498 97E9     66    EF                           out dx, eax
34499 97EB           BA                   0CFC    mov dx, #0x0cfc
34500 97EE     66    ED                           in eax, dx
34501 97F0     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
34502 97F6           74           1F              je pci_present
34503 97F8     66    3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
34504 97FE           74           17              je pci_present
34505 9800     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34506 9806           74           0F              je pci_present
34507                                             ;; say ok if a device is present
34508 9808     66    3D               FFFFFFFF    cmp eax, #0xffffffff
34509 980E           75           07              jne pci_present
34510 9810           5A                           pop dx
34511 9811     66    58                           pop eax
34512 9813           B4                     FF    mov ah, #0xff
34513 9815           F9                           stc
34514 9816           C3                           ret
34515                       00009817            pci_present:
34516 9817           5A                           pop dx
34517 9818     66    58                           pop eax
34518 981A           3C                     01    cmp al, #0x01 ;; installation check
34519 981C           75           1A              jne pci_real_f02
34520 981E           B8                   0001    mov ax, #0x0001
34521 9821           BB                   0210    mov bx, #0x0210
34522 9824           E8         0145              call pci_real_get_max_bus ;; sets CX
34523 9827     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
34524 982D     66    BF               000F0000    mov edi, #0xf0000
34525 9833           BF                   9660    mov di, #pcibios_protected
34526 9836           F8                           clc
34527 9837           C3                           ret
34528                       00009838            pci_real_f02: ;; find pci device
34529 9838     66    56                           push esi
34530 983A     66    57                           push edi
34531 983C           3C                     02    cmp al, #0x02
34532 983E           75           34              jne pci_real_f03
34533 9840     66    C1E1                   10    shl ecx, #16
34534 9844           89D1                         mov cx, dx
34535 9846           31DB                         xor bx, bx
34536 9848           BF                   0000    mov di, #0x00
34537                       0000984B            pci_real_devloop:
34538 984B           E8         0141              call pci_real_select_reg
34539 984E           BA                   0CFC    mov dx, #0x0cfc
34540 9851     66    ED                           in eax, dx
34541 9853     66    39C8                         cmp eax, ecx
34542 9856           75           09              jne pci_real_nextdev
34543 9858           83FE                   00    cmp si, #0
34544 985B   7503    E9         0104              je pci_real_ok
34545 9860           4E                           dec si
34546                       00009861            pci_real_nextdev:
34547 9861           43                           inc bx
34548 9862           81FB                 0200    cmp bx, #0x0200
34549 9866           75           E3              jne pci_real_devloop
34550 9868           89CA                         mov dx, cx
34551 986A     66    C1E9                   10    shr ecx, #16
34552 986E           B8                   8602    mov ax, #0x8602
34553 9871           E9         00EA              jmp pci_real_fail
34554                       00009874            pci_real_f03: ;; find class code
34555 9874           3C                     03    cmp al, #0x03
34556 9876           75           32              jne pci_real_f08
34557 9878           31DB                         xor bx, bx
34558 987A           BF                   0008    mov di, #0x08
34559                       0000987D            pci_real_devloop2:
34560 987D           E8         010F              call pci_real_select_reg
34561 9880           BA                   0CFC    mov dx, #0x0cfc
34562 9883     66    ED                           in eax, dx
34563 9885     66    C1E8                   08    shr eax, #8
34564 9889     66    39C8                         cmp eax, ecx
34565 988C           75           09              jne pci_real_nextdev2
34566 988E           83FE                   00    cmp si, #0
34567 9891   7503    E9         00CE              je pci_real_ok
34568 9896           4E                           dec si
34569                       00009897            pci_real_nextdev2:
34570 9897           43                           inc bx
34571 9898           81FB                 0200    cmp bx, #0x0200
34572 989C           75           DF              jne pci_real_devloop2
34573 989E           89CA                         mov dx, cx
34574 98A0     66    C1E9                   10    shr ecx, #16
34575 98A4           B8                   8603    mov ax, #0x8603
34576 98A7           E9         00B4              jmp pci_real_fail
34577                       000098AA            pci_real_f08: ;; read configuration byte
34578 98AA           3C                     08    cmp al, #0x08
34579 98AC           75           14              jne pci_real_f09
34580 98AE           E8         00DE              call pci_real_select_reg
34581 98B1           52                           push dx
34582 98B2           89FA                         mov dx, di
34583 98B4           83E2                   03    and dx, #0x03
34584 98B7           81C2                 0CFC    add dx, #0x0cfc
34585 98BB           EC                           in al, dx
34586 98BC           5A                           pop dx
34587 98BD           88C1                         mov cl, al
34588 98BF           E9         00A2              jmp pci_real_ok
34589                       000098C2            pci_real_f09: ;; read configuration word
34590 98C2           3C                     09    cmp al, #0x09
34591 98C4           75           14              jne pci_real_f0a
34592 98C6           E8         00C6              call pci_real_select_reg
34593 98C9           52                           push dx
34594 98CA           89FA                         mov dx, di
34595 98CC           83E2                   02    and dx, #0x02
34596 98CF           81C2                 0CFC    add dx, #0x0cfc
34597 98D3           ED                           in ax, dx
34598 98D4           5A                           pop dx
34599 98D5           89C1                         mov cx, ax
34600 98D7           E9         008A              jmp pci_real_ok
34601                       000098DA            pci_real_f0a: ;; read configuration dword
34602 98DA           3C                     0A    cmp al, #0x0a
34603 98DC           75           0F              jne pci_real_f0b
34604 98DE           E8         00AE              call pci_real_select_reg
34605 98E1           52                           push dx
34606 98E2           BA                   0CFC    mov dx, #0x0cfc
34607 98E5     66    ED                           in eax, dx
34608 98E7           5A                           pop dx
34609 98E8     66    89C1                         mov ecx, eax
34610 98EB           EB           77              jmp pci_real_ok
34611                       000098ED            pci_real_f0b: ;; write configuration byte
34612 98ED           3C                     0B    cmp al, #0x0b
34613 98EF           75           13              jne pci_real_f0c
34614 98F1           E8         009B              call pci_real_select_reg
34615 98F4           52                           push dx
34616 98F5           89FA                         mov dx, di
34617 98F7           83E2                   03    and dx, #0x03
34618 98FA           81C2                 0CFC    add dx, #0x0cfc
34619 98FE           88C8                         mov al, cl
34620 9900           EE                           out dx, al
34621 9901           5A                           pop dx
34622 9902           EB           60              jmp pci_real_ok
34623                       00009904            pci_real_f0c: ;; write configuration word
34624 9904           3C                     0C    cmp al, #0x0c
34625 9906           75           13              jne pci_real_f0d
34626 9908           E8         0084              call pci_real_select_reg
34627 990B           52                           push dx
34628 990C           89FA                         mov dx, di
34629 990E           83E2                   02    and dx, #0x02
34630 9911           81C2                 0CFC    add dx, #0x0cfc
34631 9915           89C8                         mov ax, cx
34632 9917           EF                           out dx, ax
34633 9918           5A                           pop dx
34634 9919           EB           49              jmp pci_real_ok
34635                       0000991B            pci_real_f0d: ;; write configuration dword
34636 991B           3C                     0D    cmp al, #0x0d
34637 991D           75           0F              jne pci_real_f0e
34638 991F           E8         006D              call pci_real_select_reg
34639 9922           52                           push dx
34640 9923           BA                   0CFC    mov dx, #0x0cfc
34641 9926     66    89C8                         mov eax, ecx
34642 9929     66    EF                           out dx, eax
34643 992B           5A                           pop dx
34644 992C           EB           36              jmp pci_real_ok
34645                       0000992E            pci_real_f0e: ;; get irq routing options
34646 992E           3C                     0E    cmp al, #0x0e
34647 9930           75           2A              jne pci_real_unknown
34648 9932           50                           push ax
34649 9933           B8                   0060    mov ax, #pci_routing_table_structure_end - pci_routing_table_structure_start
34650 9936           26                           SEG ES
34651 9937           3905                         cmp word ptr [di], ax
34652 9939           72           1B              jb pci_real_too_small
34653 993B           AB                           stosw
34654 993C           9C                           pushf
34655 993D           06                           push es
34656 993E           51                           push cx
34657 993F           FC                           cld
34658 9940           BE                   99D0    mov si, #pci_routing_table_structure_start
34659 9943           0E                           push cs
34660 9944           1F                           pop ds
34661 9945           26                           SEG ES
34662 9946           C47D         02              les di, [di+2]
34663 9949           89C1                         mov cx, ax
34664 994B           F3                           rep
34665 994C           A4                               movsb
34666 994D           59                           pop cx
34667 994E           07                           pop es
34668 994F           9D                           popf
34669 9950           58                           pop ax
34670 9951           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
34671 9954           EB           0E              jmp pci_real_ok
34672                       00009956            pci_real_too_small:
34673 9956           AB                           stosw
34674 9957           58                           pop ax
34675 9958           B4                     89    mov ah, #0x89
34676 995A           EB           02              jmp pci_real_fail
34677                       0000995C            pci_real_unknown:
34678 995C           B4                     81    mov ah, #0x81
34679                       0000995E            pci_real_fail:
34680 995E     66    5F                           pop edi
34681 9960     66    5E                           pop esi
34682 9962           F9                           stc
34683 9963           C3                           ret
34684                       00009964            pci_real_ok:
34685 9964           30E4                         xor ah, ah
34686 9966     66    5F                           pop edi
34687 9968     66    5E                           pop esi
34688 996A           F8                           clc
34689 996B           C3                           ret
34690                       0000996C            pci_real_get_max_bus:
34691 996C     66    50                           push eax
34692 996E     66    B8               80000000    mov eax, #0x80000000
34693 9974           BA                   0CF8    mov dx, #0x0cf8
34694 9977     66    EF                           out dx, eax
34695 9979           BA                   0CFC    mov dx, #0x0cfc
34696 997C     66    ED                           in eax, dx
34697 997E           B9                   0000    mov cx, #0
34698 9981     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
34699 9987           75           03              jne pci_real_no_i440bx
34700 9989           B9                   0001    mov cx, #0x0001
34701                       0000998C            pci_real_no_i440bx:
34702 998C     66    58                           pop eax
34703 998E           C3                           ret
34704                       0000998F            pci_real_select_reg:
34705 998F           52                           push dx
34706 9990     66    B8               00800000    mov eax, #0x800000
34707 9996           89D8                         mov ax, bx
34708 9998     66    C1E0                   08    shl eax, #8
34709 999C           81E7                 00FF    and di, #0xff
34710 99A0           09F8                         or ax, di
34711 99A2           24                     FC    and al, #0xfc
34712 99A4           BA                   0CF8    mov dx, #0x0cf8
34713 99A7     66    EF                           out dx, eax
34714 99A9           5A                           pop dx
34715 99AA           C3                           ret
34716 99AB                  00000010            .align 16
34717                       000099B0            pci_routing_table_structure:
34718 99B0                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
34719 99B4                        00              db 0, 1 ;; version
34720 99B6                      0080              dw 32 + (6 * 16) ;; table size
34721 99B8                        00              db 0 ;; PCI interrupt router bus
34722 99B9                        08              db 0x08 ;; PCI interrupt router DevFunc
34723 99BA                      0000              dw 0x0000 ;; PCI exclusive IRQs
34724 99BC                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
34725 99BE                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
34726 99C0                      0000              dw 0,0 ;; Miniport data
34727 99C4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
34728 99CF                        37              db 0x37 ;; checksum
34729                       000099D0            pci_routing_table_structure_start:
34730                                             ;; first slot entry PCI-to-ISA (embedded)
34731 99D0                        00              db 0 ;; pci bus number
34732 99D1                        08              db 0x08 ;; pci device number (bit 7-3)
34733 99D2                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
34734 99D3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34735 99D5                        61              db 0x61 ;; link value INTB#
34736 99D6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34737 99D8                        62              db 0x62 ;; link value INTC#
34738 99D9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34739 99DB                        63              db 0x63 ;; link value INTD#
34740 99DC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34741 99DE                        00              db 0 ;; physical slot (0 = embedded)
34742 99DF                        00              db 0 ;; reserved
34743                                             ;; second slot entry: 1st PCI slot
34744 99E0                        00              db 0 ;; pci bus number
34745 99E1                        10              db 0x10 ;; pci device number (bit 7-3)
34746 99E2                        61              db 0x61 ;; link value INTA#
34747 99E3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34748 99E5                        62              db 0x62 ;; link value INTB#
34749 99E6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34750 99E8                        63              db 0x63 ;; link value INTC#
34751 99E9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34752 99EB                        60              db 0x60 ;; link value INTD#
34753 99EC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34754 99EE                        01              db 1 ;; physical slot (0 = embedded)
34755 99EF                        00              db 0 ;; reserved
34756                                             ;; third slot entry: 2nd PCI slot
34757 99F0                        00              db 0 ;; pci bus number
34758 99F1                        18              db 0x18 ;; pci device number (bit 7-3)
34759 99F2                        62              db 0x62 ;; link value INTA#
34760 99F3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34761 99F5                        63              db 0x63 ;; link value INTB#
34762 99F6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34763 99F8                        60              db 0x60 ;; link value INTC#
34764 99F9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34765 99FB                        61              db 0x61 ;; link value INTD#
34766 99FC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34767 99FE                        02              db 2 ;; physical slot (0 = embedded)
34768 99FF                        00              db 0 ;; reserved
34769                                             ;; 4th slot entry: 3rd PCI slot
34770 9A00                        00              db 0 ;; pci bus number
34771 9A01                        20              db 0x20 ;; pci device number (bit 7-3)
34772 9A02                        63              db 0x63 ;; link value INTA#
34773 9A03                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34774 9A05                        60              db 0x60 ;; link value INTB#
34775 9A06                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34776 9A08                        61              db 0x61 ;; link value INTC#
34777 9A09                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34778 9A0B                        62              db 0x62 ;; link value INTD#
34779 9A0C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34780 9A0E                        03              db 3 ;; physical slot (0 = embedded)
34781 9A0F                        00              db 0 ;; reserved
34782                                             ;; 5th slot entry: 4th PCI slot
34783 9A10                        00              db 0 ;; pci bus number
34784 9A11                        28              db 0x28 ;; pci device number (bit 7-3)
34785 9A12                        60              db 0x60 ;; link value INTA#
34786 9A13                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34787 9A15                        61              db 0x61 ;; link value INTB#
34788 9A16                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34789 9A18                        62              db 0x62 ;; link value INTC#
34790 9A19                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34791 9A1B                        63              db 0x63 ;; link value INTD#
34792 9A1C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34793 9A1E                        04              db 4 ;; physical slot (0 = embedded)
34794 9A1F                        00              db 0 ;; reserved
34795                                             ;; 6th slot entry: 5th PCI slot
34796 9A20                        00              db 0 ;; pci bus number
34797 9A21                        30              db 0x30 ;; pci device number (bit 7-3)
34798 9A22                        61              db 0x61 ;; link value INTA#
34799 9A23                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
34800 9A25                        62              db 0x62 ;; link value INTB#
34801 9A26                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
34802 9A28                        63              db 0x63 ;; link value INTC#
34803 9A29                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
34804 9A2B                        60              db 0x60 ;; link value INTD#
34805 9A2C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
34806 9A2E                        05              db 5 ;; physical slot (0 = embedded)
34807 9A2F                        00              db 0 ;; reserved
34808                       00009A30            pci_routing_table_structure_end:
34809                       00009A30            rombios32_init:
34810                                             ;; save a20 and enable it
34811 9A30           E4                     92    in al, 0x0092
34812 9A32           50                           push ax
34813 9A33           0C                     02    or al, #0x02
34814 9A35           E6                     92    out 0x0092, al
34815                                             ;; save SS:SP to the BDA
34816 9A37           31C0                         xor ax, ax
34817 9A39           8ED8                         mov ds, ax
34818 9A3B           8C16       0469              mov 0x0469, ss
34819 9A3F           8926       0467              mov 0x0467, sp
34820 9A43           2E                           SEG CS
34821 9A44         0F011E       F8AB                lidt [pmode_IDT_info]
34822 9A49           2E                           SEG CS
34823 9A4A         0F0116       9AD1                lgdt [rombios32_gdt_48]
34824                                             ;; set PE bit in CR0
34825 9A4F         0F20C0                         mov eax, cr0
34826 9A52           0C                     01    or al, #0x01
34827 9A54         0F22C0                         mov cr0, eax
34828                                             ;; start protected mode code: ljmpl 0x10:rombios32_init1
34829 9A57                        66              db 0x66, 0xea
34830 9A59                      9A5F              dw rombios32_05
34831 9A5B                      000F              dw 0x000f ;; high 16 bit address
34832 9A5D                      0010              dw 0x0010
34833                                           use32 386
34834                       00009A5F            rombios32_05:
34835                                             ;; init data segments
34836 9A5F           B8               00000018    mov eax, #0x18
34837 9A64           8ED8                         mov ds, ax
34838 9A66           8EC0                         mov es, ax
34839 9A68           8ED0                         mov ss, ax
34840 9A6A           31C0                         xor eax, eax
34841 9A6C           8EE0                         mov fs, ax
34842 9A6E           8EE8                         mov gs, ax
34843 9A70           FC                           cld
34844                                             ;; init the stack pointer to point below EBDA
34845 9A71   6766    A1         040E              mov ax, [0x040e]
34846 9A76           C1E0                   04    shl eax, #4
34847 9A79           BC               FFFFFFF0    mov esp, #-0x10
34848 9A7E           01C4                         add esp, eax
34849                                             ;; pass pointer to s3_resume_flag and s3_resume_vector to rombios32
34850 9A80           68               000004B0    push #0x04b0
34851 9A85           68               000004B2    push #0x04b2
34852                                             ;; call rombios32 code
34853 9A8A           B8               000E0000    mov eax, #0x000e0000
34854 9A8F           FFD0                         call eax
34855                                             ;; return to 16 bit protected mode first
34856 9A91                        EA              db 0xea
34857 9A92                  00009A98              dd rombios32_10
34858 9A96                      0020              dw 0x20
34859                                           use16 386
34860                       00009A98            rombios32_10:
34861                                             ;; restore data segment limits to 0xffff
34862 9A98           B8                   0028    mov ax, #0x28
34863 9A9B           8ED8                         mov ds, ax
34864 9A9D           8EC0                         mov es, ax
34865 9A9F           8ED0                         mov ss, ax
34866 9AA1           8EE0                         mov fs, ax
34867 9AA3           8EE8                         mov gs, ax
34868                                             ;; reset PE bit in CR0
34869 9AA5         0F20C0                         mov eax, cr0
34870 9AA8           24                     FE    and al, #0xFE
34871 9AAA         0F22C0                         mov cr0, eax
34872                                             ;; far jump to flush CPU queue after transition to real mode
34873                                             JMP_AP(0xf000, rombios32_real_mode)
 +a   9AAD                        EA              db 0xea
 +a   9AAE                      9AB2              dw  rombios32_real_mode
 +a   9AB0                      F000              dw 0xf000
34874                       00009AB2            rombios32_real_mode:
34875                                             ;; restore IDT to normal real-mode defaults
34876 9AB2           2E                           SEG CS
34877 9AB3         0F011E       F8B1                lidt [rmode_IDT_info]
34878 9AB8           31C0                         xor ax, ax
34879 9ABA           8ED8                         mov ds, ax
34880 9ABC           8EC0                         mov es, ax
34881 9ABE           8EE0                         mov fs, ax
34882 9AC0           8EE8                         mov gs, ax
34883                                             ;; restore SS:SP from the BDA
34884 9AC2           8E16       0469              mov ss, 0x0469
34885 9AC6     66    31E4                         xor esp, esp
34886 9AC9           8B26       0467              mov sp, 0x0467
34887                                             ;; restore a20
34888 9ACD           58                           pop ax
34889 9ACE           E6                     92    out 0x0092, al
34890 9AD0           C3                           ret
34891                       00009AD1            rombios32_gdt_48:
34892 9AD1                      0030              dw 0x30
34893 9AD3                      9AD7              dw rombios32_gdt
34894 9AD5                      000F              dw 0x000f
34895                       00009AD7            rombios32_gdt:
34896 9AD7                      0000              dw 0, 0, 0, 0
34897 9ADF                      0000              dw 0, 0, 0, 0
34898 9AE7                      FFFF              dw 0xffff, 0, 0x9b00, 0x00cf ; 32 bit flat code segment (0x10)
34899 9AEF                      FFFF              dw 0xffff, 0, 0x9300, 0x00cf ; 32 bit flat data segment (0x18)
34900 9AF7                      FFFF              dw 0xffff, 0, 0x9b0f, 0x0000 ; 16 bit code segment base=0xf0000 limit=0xffff
34901 9AFF                      FFFF              dw 0xffff, 0, 0x9300, 0x0000 ; 16 bit data segment base=0x0 limit=0xffff
34902                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
34903                       00009B07            detect_parport:
34904 9B07           52                           push dx
34905 9B08           83C2                   02    add dx, #2
34906 9B0B           EC                           in al, dx
34907 9B0C           24                     DF    and al, #0xdf ; clear input mode
34908 9B0E           EE                           out dx, al
34909 9B0F           5A                           pop dx
34910 9B10           B0                     AA    mov al, #0xaa
34911 9B12           EE                           out dx, al
34912 9B13           EC                           in al, dx
34913 9B14           3C                     AA    cmp al, #0xaa
34914 9B16           75           0D              jne no_parport
34915 9B18           53                           push bx
34916 9B19           D1E3                         shl bx, #1
34917 9B1B           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
34918 9B1F           5B                           pop bx
34919 9B20           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
34920 9B24           43                           inc bx
34921                       00009B25            no_parport:
34922 9B25           C3                           ret
34923                                           ; serial port detection: base address in DX, index in BX, timeout in CL
34924                       00009B26            detect_serial:
34925 9B26           52                           push dx
34926 9B27           42                           inc dx
34927 9B28           B0                     02    mov al, #0x02
34928 9B2A           EE                           out dx, al
34929 9B2B           EC                           in al, dx
34930 9B2C           3C                     02    cmp al, #0x02
34931 9B2E           75           19              jne no_serial
34932 9B30           42                           inc dx
34933 9B31           EC                           in al, dx
34934 9B32           3C                     02    cmp al, #0x02
34935 9B34           75           13              jne no_serial
34936 9B36           4A                           dec dx
34937 9B37           30C0                         xor al, al
34938 9B39           EE                           out dx, al
34939 9B3A           5A                           pop dx
34940 9B3B           53                           push bx
34941 9B3C           D1E3                         shl bx, #1
34942 9B3E           8997       0400              mov [bx+0x400], dx ; Serial I/O address
34943 9B42           5B                           pop bx
34944 9B43           888F       047C              mov [bx+0x47c], cl ; Serial timeout
34945 9B47           43                           inc bx
34946 9B48           C3                           ret
34947                       00009B49            no_serial:
34948 9B49           5A                           pop dx
34949 9B4A           C3                           ret
34950                       00009B4B            rom_checksum:
34951 9B4B           60                           pusha
34952 9B4C           1E                           push ds
34953 9B4D           31C0                         xor ax, ax
34954 9B4F           31DB                         xor bx, bx
34955 9B51           31C9                         xor cx, cx
34956 9B53           31D2                         xor dx, dx
34957 9B55           8A2E       0002              mov ch, [2]
34958 9B59           D1E1                         shl cx, #1
34959 9B5B           73           05              jnc checksum_loop
34960 9B5D           74           03              jz checksum_loop
34961 9B5F           87CA                         xchg dx, cx
34962 9B61           49                           dec cx
34963                       00009B62            checksum_loop:
34964 9B62           0207                         add al, [bx]
34965 9B64           43                           inc bx
34966 9B65           E2           FB              loop checksum_loop
34967 9B67           85D2                         test dx, dx
34968 9B69           74           11              je checksum_out
34969 9B6B           0207                         add al, [bx]
34970 9B6D           89D1                         mov cx, dx
34971 9B6F           8CDA                         mov dx, ds
34972 9B71           80C6                   10    add dh, #0x10
34973 9B74           8EDA                         mov ds, dx
34974 9B76           31D2                         xor dx, dx
34975 9B78           31DB                         xor bx, bx
34976 9B7A           EB           E6              jmp checksum_loop
34977                       00009B7C            checksum_out:
34978 9B7C           24                     FF    and al, #0xff
34979 9B7E           1F                           pop ds
34980 9B7F           61                           popa
34981 9B80           C3                           ret
34982 9B81                  00000010            .align 16
34983                       00009B90            pnpbios_structure:
34984 9B90                        24              .ascii "$PnP"
34985 9B94                        10              db 0x10 ;; version
34986 9B95                        21              db 0x21 ;; length
34987 9B96                      0000              dw 0x0 ;; control field
34988 9B98                        D1              db 0xd1 ;; checksum
34989 9B99                  000F0000              dd 0xf0000 ;; event notification flag address
34990 9B9D                      9BB8              dw pnpbios_real ;; real mode 16 bit offset
34991 9B9F                      F000              dw 0xf000 ;; real mode 16 bit segment
34992 9BA1                      9BB1              dw pnpbios_prot ;; 16 bit protected mode offset
34993 9BA3                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
34994 9BA7                  00000000              dd 0x0 ;; OEM device identifier
34995 9BAB                      F000              dw 0xf000 ;; real mode 16 bit data segment
34996 9BAD                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
34997                       00009BB1            pnpbios_prot:
34998 9BB1     66    55                           push ebp
34999 9BB3     66    89E5                         mov ebp, esp
35000 9BB6           EB           06              jmp pnpbios_code
35001                       00009BB8            pnpbios_real:
35002 9BB8     66    55                           push ebp
35003 9BBA     66  0FB7EC                         movzx ebp, sp
35004                       00009BBE            pnpbios_code:
35005 9BBE   67      8B45         08              mov ax, 8[ebp]
35006 9BC2           3D                   0060    cmp ax, #0x60 ;; Get Version and Installation Check
35007 9BC5           75           10              jnz pnpbios_00
35008 9BC7           06                           push es
35009 9BC8           57                           push di
35010 9BC9   67      C47D         0A              les di, 10[ebp]
35011 9BCD           B8                   0101    mov ax, #0x0101
35012 9BD0           AB                           stosw
35013 9BD1           5F                           pop di
35014 9BD2           07                           pop es
35015 9BD3           31C0                         xor ax, ax ;; SUCCESS
35016 9BD5           EB           1F              jmp pnpbios_exit
35017                       00009BD7            pnpbios_00:
35018 9BD7           3D                   0000    cmp ax, #0x00 ;; Get Number of System Device Nodes
35019 9BDA           75           17              jnz pnpbios_fail
35020 9BDC           06                           push es
35021 9BDD           57                           push di
35022 9BDE   67      C47D         0A              les di, 10[ebp]
35023 9BE2           B0                     00    mov al, #0x00
35024 9BE4           AA                           stosb
35025 9BE5   67      C47D         0E              les di, 14[ebp]
35026 9BE9           B8                   0000    mov ax, #0x0000
35027 9BEC           AB                           stosw
35028 9BED           5F                           pop di
35029 9BEE           07                           pop es
35030 9BEF           31C0                         xor ax, ax ;; SUCCESS
35031 9BF1           EB           03              jmp pnpbios_exit
35032                       00009BF3            pnpbios_fail:
35033 9BF3           B8                   0082    mov ax, #0x82 ;; FUNCTION_NOT_SUPPORTED
35034                       00009BF6            pnpbios_exit:
35035 9BF6     66    5D                           pop ebp
35036 9BF8           CB                           retf
35037                       00009BF9            rom_scan:
35038                                             ;; Scan for existence of valid expansion ROMS.
35039                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
35040                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
35041                                             ;; System ROM: only 0xE0000
35042                                             ;;
35043                                             ;; Header:
35044                                             ;; Offset Value
35045                                             ;; 0 0x55
35046                                             ;; 1 0xAA
35047                                             ;; 2 ROM length in 512-byte blocks
35048                                             ;; 3 ROM initialization entry point (FAR CALL)
35049                       00009BF9            rom_scan_loop:
35050 9BF9           50                           push ax ;; Save AX
35051 9BFA           8ED9                         mov ds, cx
35052 9BFC           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
35053 9BFF           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
35054 9C05   7403    E9         009E              jne rom_scan_increment
35055 9C0A           E8         FF3E              call rom_checksum
35056 9C0D   7403    E9         0096              jnz rom_scan_increment
35057 9C12           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
35058                                             ;; We want our increment in 512-byte quantities, rounded to
35059                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
35060 9C15           A8                     03    test al, #0x03
35061 9C17           74           04              jz block_count_rounded
35062 9C19           24                     FC    and al, #0xfc ;; needs rounding up
35063 9C1B           04                     04    add al, #0x04
35064                       00009C1D            block_count_rounded:
35065 9C1D           31DB                         xor bx, bx ;; Restore DS back to 0000:
35066 9C1F           8EDB                         mov ds, bx
35067 9C21           50                           push ax ;; Save AX
35068 9C22           57                           push di ;; Save DI
35069                                             ;; Push addr of ROM entry point
35070 9C23           51                           push cx ;; Push seg
35071 9C24           6A                     03    push #0x0003 ;; Push offset
35072                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35073                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
35074 9C26           B8                   F000    mov ax, #0xf000
35075 9C29           8EC0                         mov es, ax
35076 9C2B           8D3E       9B90              lea di, pnpbios_structure
35077 9C2F           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
35078 9C31                        FF              db 0xff ;; call_far ss:[bp+0]
35079 9C32                        5E              db 0x5e
35080 9C33                        00              db 0
35081 9C34           FA                           cli ;; In case expansion ROM BIOS turns IF on
35082 9C35           83C4                   02    add sp, #2 ;; Pop offset value
35083 9C38           59                           pop cx ;; Pop seg value (restore CX)
35084                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
35085                                             ;; to init all the ROMs and then go back and build an IPL table of
35086                                             ;; all the bootable devices, but we can get away with one pass.
35087 9C39           8ED9                         mov ds, cx ;; ROM base
35088 9C3B           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
35089 9C3F           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
35090 9C41           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
35091 9C44           75           60              jne no_bev
35092 9C46           8B47         02              mov ax, 2[bx]
35093 9C49           3D                   506E    cmp ax, #0x506e
35094 9C4C           75           58              jne no_bev
35095 9C4E           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
35096 9C51           3D                   0000    cmp ax, #0x0000
35097 9C54           74           17              je no_bcv
35098                                             ;; Option ROM has BCV. Run it now.
35099 9C56           51                           push cx ;; Push seg
35100 9C57           50                           push ax ;; Push offset
35101                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35102 9C58           BB                   F000    mov bx, #0xf000
35103 9C5B           8EC3                         mov es, bx
35104 9C5D           8D3E       9B90              lea di, pnpbios_structure
35105 9C61           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
35106 9C63                        FF              db 0xff ;; call_far ss:[bp+0]
35107 9C64                        5E              db 0x5e
35108 9C65                        00              db 0
35109 9C66           FA                           cli ;; In case expansion ROM BIOS turns IF on
35110 9C67           83C4                   02    add sp, #2 ;; Pop offset value
35111 9C6A           59                           pop cx ;; Pop seg value (restore CX)
35112 9C6B           EB           39              jmp no_bev
35113                       00009C6D            no_bcv:
35114 9C6D           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
35115 9C70           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
35116 9C73           74           31              je no_bev
35117                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
35118 9C75           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
35119 9C78           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
35120 9C7B           8EDB                         mov ds, bx
35121 9C7D           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
35122 9C81           83FB                   08    cmp bx, #8
35123 9C84           74           20              je no_bev ;; Get out if the table is full
35124 9C86           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
35125 9C89           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
35126 9C8D           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
35127 9C90           8947         04              mov 4[bx], ax ;; and the offset
35128 9C93           83FF                   00    cmp di, #0x0000
35129 9C96           74           06              je no_prod_str
35130 9C98           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
35131 9C9B           897F         08              mov 8[bx], di ;; and the offset
35132                       00009C9E            no_prod_str:
35133 9C9E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
35134 9CA1           43                           inc bx ;; We have one more entry now
35135 9CA2           891E       0080              mov 0x0080, bx ;; Remember that.
35136                       00009CA6            no_bev:
35137 9CA6           5F                           pop di ;; Restore DI
35138 9CA7           58                           pop ax ;; Restore AX
35139                       00009CA8            rom_scan_increment:
35140 9CA8           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
35141                                                           ;; because the segment selector is shifted left 4 bits.
35142 9CAB           01C1                         add cx, ax
35143 9CAD           58                           pop ax ;; Restore AX
35144 9CAE           39C1                         cmp cx, ax
35145 9CB0   7703    E9         FF44              jbe rom_scan_loop
35146 9CB5           31C0                         xor ax, ax ;; Restore DS back to 0000:
35147 9CB7           8ED8                         mov ds, ax
35148 9CB9           C3                           ret
35149                       00009CBA            post_init_pic:
35150 9CBA           B0                     11    mov al, #0x11 ; send initialisation commands
35151 9CBC           E6                     20    out 0x0020, al
35152 9CBE           E6                     A0    out 0x00a0, al
35153 9CC0           B0                     08    mov al, #0x08
35154 9CC2           E6                     21    out 0x0021, al
35155 9CC4           B0                     70    mov al, #0x70
35156 9CC6           E6                     A1    out 0x00a1, al
35157 9CC8           B0                     04    mov al, #0x04
35158 9CCA           E6                     21    out 0x0021, al
35159 9CCC           B0                     02    mov al, #0x02
35160 9CCE           E6                     A1    out 0x00a1, al
35161 9CD0           B0                     01    mov al, #0x01
35162 9CD2           E6                     21    out 0x0021, al
35163 9CD4           E6                     A1    out 0x00a1, al
35164 9CD6           B0                     B8    mov al, #0xb8
35165 9CD8           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
35166 9CDA           B0                     8F    mov al, #0x8f
35167 9CDC           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
35168 9CDE           C3                           ret
35169                       00009CDF            post_init_ivt:
35170                                             ;; set first 120 interrupts to default handler
35171 9CDF           31FF                         xor di, di ;; offset index
35172 9CE1           B9                   0078    mov cx, #0x0078 ;; counter (120 interrupts)
35173 9CE4           B8                   F000    mov ax, #0xF000
35174 9CE7     66    C1E0                   10    shl eax, #16
35175 9CEB           B8                   FF53    mov ax, #dummy_iret_handler
35176 9CEE           FC                           cld
35177 9CEF           F3                           rep
35178 9CF0     66    AB                             stosd
35179                                             ;; Master PIC vector
35180 9CF2           BB                   0020    mov bx, #0x0020
35181 9CF5           B1                     08    mov cl, #0x08
35182 9CF7           B8                   E9E6    mov ax, #dummy_master_pic_irq_handler
35183                       00009CFA            post_default_master_pic_ints:
35184 9CFA           8907                         mov [bx], ax
35185 9CFC           83C3                   04    add bx, #4
35186 9CFF           E2           F9              loop post_default_master_pic_ints
35187                                             ;; Slave PIC vector
35188 9D01           81C3                 0180    add bx, #0x0180
35189 9D05           B1                     08    mov cl, #0x08
35190 9D07           B8                   E9EC    mov ax, #dummy_slave_pic_irq_handler
35191                       00009D0A            post_default_slave_pic_ints:
35192 9D0A           8907                         mov [bx], ax
35193 9D0C           83C3                   04    add bx, #4
35194 9D0F           E2           F9              loop post_default_slave_pic_ints
35195                                             ;; Printer Services vector
35196                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   9D11           B8                   EFD2    mov ax,  #int17_handler
 +a   9D14           A3         005C              mov 0x17*4, ax
 +a   9D17           B8                   F000    mov ax,  #0xF000
 +a   9D1A           A3         005E              mov 0x17*4+2, ax
35197                                             ;; Bootstrap failure vector
35198                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   9D1D           B8                   8F51    mov ax,  #int18_handler
 +a   9D20           A3         0060              mov 0x18*4, ax
 +a   9D23           B8                   F000    mov ax,  #0xF000
 +a   9D26           A3         0062              mov 0x18*4+2, ax
35199                                             ;; Bootstrap Loader vector
35200                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   9D29           B8                   E6F2    mov ax,  #int19_handler
 +a   9D2C           A3         0064              mov 0x19*4, ax
 +a   9D2F           B8                   F000    mov ax,  #0xF000
 +a   9D32           A3         0066              mov 0x19*4+2, ax
35201                                             ;; Memory Size Check vector
35202                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   9D35           B8                   F841    mov ax,  #int12_handler
 +a   9D38           A3         0048              mov 0x12*4, ax
 +a   9D3B           B8                   F000    mov ax,  #0xF000
 +a   9D3E           A3         004A              mov 0x12*4+2, ax
35203                                             ;; Equipment Configuration Check vector
35204                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   9D41           B8                   F84D    mov ax,  #int11_handler
 +a   9D44           A3         0044              mov 0x11*4, ax
 +a   9D47           B8                   F000    mov ax,  #0xF000
 +a   9D4A           A3         0046              mov 0x11*4+2, ax
35205                                             ;; System Services
35206                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   9D4D           B8                   F859    mov ax,  #int15_handler
 +a   9D50           A3         0054              mov 0x15*4, ax
 +a   9D53           B8                   F000    mov ax,  #0xF000
 +a   9D56           A3         0056              mov 0x15*4+2, ax
35207                                             ;; MDA/CGA Video Parameter Table is not available
35208                                             SET_INT_VECTOR(0x1D, #0, #0)
 +a   9D59           B8                   0000    mov ax,  #0
 +a   9D5C           A3         0074              mov 0x1D*4, ax
 +a   9D5F           B8                   0000    mov ax,  #0
 +a   9D62           A3         0076              mov 0x1D*4+2, ax
35209                                             ;; Character Font for upper 128 characters is not available
35210                                             SET_INT_VECTOR(0x1F, #0, #0)
 +a   9D65           B8                   0000    mov ax,  #0
 +a   9D68           A3         007C              mov 0x1F*4, ax
 +a   9D6B           B8                   0000    mov ax,  #0
 +a   9D6E           A3         007E              mov 0x1F*4+2, ax
35211                                             ;; set vectors 0x60 - 0x67h to zero (0:180..0:19f)
35212 9D71           31C0                         xor ax, ax
35213 9D73           B9                   0010    mov cx, #0x0010 ;; 16 words
35214 9D76           BF                   0180    mov di, #0x0180
35215 9D79           FC                           cld
35216 9D7A           F3                           rep
35217 9D7B           AB                             stosw
35218                                             ;; set vector 0x78 and above to zero
35219 9D7C     66    31C0                         xor eax, eax
35220 9D7F           B1                     88    mov cl, #0x88 ;; 136 dwords
35221 9D81           BF                   01E0    mov di, #0x1e0
35222 9D84           F3                           rep
35223 9D85     66    AB                             stosd
35224 9D87           C3                           ret
35225                                           ;; the following area can be used to write dynamically generated tables
35226 9D88                  00000010              .align 16
35227                       00009D90            bios_table_area_start:
35228 9D90                  AAFB4442              dd 0xaafb4442
35229 9D94                  00002E68              dd bios_table_area_end - bios_table_area_start - 8;
35230                                           ;--------
35231                                           ;- POST -
35232                                           ;--------
35233 E05B                                      .org 0xe05b ; POST Entry Point
35234                       0000E05B            post:
35235 E05B           31C0                         xor ax, ax
35236                                             ;; first reset the DMA controllers
35237 E05D           E6                     0D    out 0x000d,al
35238 E05F           E6                     DA    out 0x00da,al
35239                                             ;; then initialize the DMA controllers
35240 E061           B0                     C0    mov al, #0xC0
35241 E063           E6                     D6    out 0x00d6, al ; cascade mode of channel 4 enabled
35242 E065           B0                     00    mov al, #0x00
35243 E067           E6                     D4    out 0x00d4, al ; unmask channel 4
35244                                             ;; Examine CMOS shutdown status.
35245 E069           B0                     0F    mov AL, #0x0f
35246 E06B           E6                     70    out 0x0070, AL
35247 E06D           E4                     71    in AL, 0x0071
35248                                             ;; backup status
35249 E06F           88C3                         mov bl, al
35250                                             ;; Reset CMOS shutdown status.
35251 E071           B0                     0F    mov AL, #0x0f
35252 E073           E6                     70    out 0x0070, AL ; select CMOS register Fh
35253 E075           B0                     00    mov AL, #0x00
35254 E077           E6                     71    out 0x0071, AL ; set shutdown action to normal
35255                                             ;; Examine CMOS shutdown status.
35256 E079           88D8                         mov al, bl
35257                                             ;; 0x00, 0x0D+ = normal startup
35258 E07B           3C                     00    cmp AL, #0x00
35259 E07D           74           24              jz normal_post
35260 E07F           3C                     0D    cmp AL, #0x0d
35261 E081           73           20              jae normal_post
35262                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
35263 E083           3C                     05    cmp al, #0x05
35264 E085   7503    E9         B1BB              je eoi_jmp_post
35265                                             ;; 0x0A = jmp via [0x40:0x67] jump
35266 E08A           3C                     0A    cmp al, #0x0a
35267 E08C   7503    E9         B1E0              je jmp_post_0x467
35268                                             ;; 0x0B = iret via [0x40:0x67]
35269 E091           3C                     0B    cmp al, #0x0b
35270 E093   7503    E9         B1E1              je iret_post_0x467
35271                                             ;; 0x0C = retf via [0x40:0x67]
35272 E098           3C                     0C    cmp al, #0x0c
35273 E09A   7503    E9         B1E7              je retf_post_0x467
35274                                             ;; Examine CMOS shutdown status.
35275                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
35276 E09F           53                           push bx
35277 E0A0           E8         3114              call _shutdown_status_panic
35278                       0000E0A3            normal_post:
35279                                             ; case 0: normal startup
35280 E0A3           FA                           cli
35281 E0A4           B8                   FFFE    mov ax, #0xfffe
35282 E0A7           89C4                         mov sp, ax
35283 E0A9           31C0                         xor ax, ax
35284 E0AB           8ED8                         mov ds, ax
35285 E0AD           8ED0                         mov ss, ax
35286                                             ;; Save shutdown status
35287 E0AF           881E       04B0              mov 0x04b0, bl
35288 E0B3           80FB                   FE    cmp bl, #0xfe
35289 E0B6   7503    E9         B1D8              jz s3_post
35290                                             ;; zero out BIOS data area (40:00..40:ff)
35291 E0BB           8EC0                         mov es, ax
35292 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
35293 E0C0           BF                   0400    mov di, #0x0400
35294 E0C3           FC                           cld
35295 E0C4           F3                           rep
35296 E0C5           AB                             stosw
35297 E0C6           E8         3652              call _log_bios_start
35298 E0C9           E8         BC13              call post_init_ivt
35299                                             ;; base memory in K 40:13 (word)
35300 E0CC           B8                   027F    mov ax, #(640 - 1)
35301 E0CF           A3         0413              mov 0x0413, ax
35302                                             ;; Manufacturing Test 40:12
35303                                             ;; zerod out above
35304                                             ;; Warm Boot Flag 0040:0072
35305                                             ;; value of 1234h = skip memory checks
35306                                             ;; zerod out above
35307                                             ;; EBDA setup
35308 E0D2           E8         B15B              call ebda_post
35309                                             ;; PIT setup
35310                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E0D5           B8                   FEA5    mov ax,  #int08_handler
 +a   E0D8           A3         0020              mov 0x08*4, ax
 +a   E0DB           B8                   F000    mov ax,  #0xF000
 +a   E0DE           A3         0022              mov 0x08*4+2, ax
35311                                             ;; int 1C already points at dummy_iret_handler (above)
35312 E0E1           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
35313 E0E3           E6                     43    out 0x0043, al
35314 E0E5           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
35315 E0E7           E6                     40    out 0x0040, al
35316 E0E9           E6                     40    out 0x0040, al
35317                                             ;; Keyboard
35318                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E0EB           B8                   E987    mov ax,  #int09_handler
 +a   E0EE           A3         0024              mov 0x09*4, ax
 +a   E0F1           B8                   F000    mov ax,  #0xF000
 +a   E0F4           A3         0026              mov 0x09*4+2, ax
35319                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E0F7           B8                   E82E    mov ax,  #int16_handler
 +a   E0FA           A3         0058              mov 0x16*4, ax
 +a   E0FD           B8                   F000    mov ax,  #0xF000
 +a   E100           A3         005A              mov 0x16*4+2, ax
35320 E103           31C0                         xor ax, ax
35321 E105           8ED8                         mov ds, ax
35322 E107           A2         0417              mov 0x0417, al
35323 E10A           A2         0418              mov 0x0418, al
35324 E10D           A2         0419              mov 0x0419, al
35325 E110           A2         0471              mov 0x0471, al
35326 E113           A2         0497              mov 0x0497, al
35327 E116           B0                     10    mov al, #0x10
35328 E118           A2         0496              mov 0x0496, al
35329 E11B           BB                   001E    mov bx, #0x001E
35330 E11E           891E       041A              mov 0x041A, bx
35331 E122           891E       041C              mov 0x041C, bx
35332 E126           BB                   001E    mov bx, #0x001E
35333 E129           891E       0480              mov 0x0480, bx
35334 E12D           BB                   003E    mov bx, #0x003E
35335 E130           891E       0482              mov 0x0482, bx
35336 E134           E8         2B27              call _keyboard_init
35337                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
35338 E137           A1         0410              mov ax, 0x0410
35339 E13A           B0                     14    mov al, #0x14
35340 E13C           E6                     70    out 0x0070, al
35341 E13E           E4                     71    in al, 0x0071
35342 E140           A3         0410              mov 0x0410, ax
35343                                             ;; Parallel setup
35344 E143           31C0                         xor ax, ax
35345 E145           8ED8                         mov ds, ax
35346 E147           31DB                         xor bx, bx
35347 E149           B1                     14    mov cl, #0x14 ; timeout value
35348 E14B           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
35349 E14E           E8         B9B6              call detect_parport
35350 E151           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
35351 E154           E8         B9B0              call detect_parport
35352 E157           C1E3                   0E    shl bx, #0x0e
35353 E15A           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determine # parallel ports
35354 E15D           25                   3FFF    and ax, #0x3fff
35355 E160           09D8                         or ax, bx ; set number of parallel ports
35356 E162           A3         0410              mov 0x410, ax
35357                                             ;; Serial setup
35358                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E165           B8                   E739    mov ax,  #int14_handler
 +a   E168           A3         0050              mov 0x14*4, ax
 +a   E16B           B8                   F000    mov ax,  #0xF000
 +a   E16E           A3         0052              mov 0x14*4+2, ax
35359 E171           31DB                         xor bx, bx
35360 E173           B1                     0A    mov cl, #0x0a ; timeout value
35361 E175           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
35362 E178           E8         B9AB              call detect_serial
35363 E17B           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
35364 E17E           E8         B9A5              call detect_serial
35365 E181           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
35366 E184           E8         B99F              call detect_serial
35367 E187           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
35368 E18A           E8         B999              call detect_serial
35369 E18D           C1E3                   09    shl bx, #0x09
35370 E190           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determine # serial ports
35371 E193           25                   F1FF    and ax, #0xf1ff
35372 E196           09D8                         or ax, bx ; set number of serial port
35373 E198           A3         0410              mov 0x410, ax
35374                                             ;; CMOS RTC
35375                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E19B           B8                   FE6E    mov ax,  #int1a_handler
 +a   E19E           A3         0068              mov 0x1A*4, ax
 +a   E1A1           B8                   F000    mov ax,  #0xF000
 +a   E1A4           A3         006A              mov 0x1A*4+2, ax
35376                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E1A7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1AA           A3         0128              mov 0x4A*4, ax
 +a   E1AD           B8                   F000    mov ax,  #0xF000
 +a   E1B0           A3         012A              mov 0x4A*4+2, ax
35377                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E1B3           B8                   FE93    mov ax,  #int70_handler
 +a   E1B6           A3         01C0              mov 0x70*4, ax
 +a   E1B9           B8                   F000    mov ax,  #0xF000
 +a   E1BC           A3         01C2              mov 0x70*4+2, ax
35378                                             ;; BIOS DATA AREA 0x4CE ???
35379 E1BF           E8         B0FE              call timer_tick_post
35380                                             ;; IRQ9 (IRQ2 redirect) setup
35381                                             SET_INT_VECTOR(0x71, #0xF000, #int71_handler)
 +a   E1C2           B8                   E9DD    mov ax,  #int71_handler
 +a   E1C5           A3         01C4              mov 0x71*4, ax
 +a   E1C8           B8                   F000    mov ax,  #0xF000
 +a   E1CB           A3         01C6              mov 0x71*4+2, ax
35382                                             ;; PS/2 mouse setup
35383                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E1CE           B8                   8E7F    mov ax,  #int74_handler
 +a   E1D1           A3         01D0              mov 0x74*4, ax
 +a   E1D4           B8                   F000    mov ax,  #0xF000
 +a   E1D7           A3         01D2              mov 0x74*4+2, ax
35384                                             ;; IRQ13 (FPU exception) setup
35385                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E1DA           B8                   E2C7    mov ax,  #int75_handler
 +a   E1DD           A3         01D4              mov 0x75*4, ax
 +a   E1E0           B8                   F000    mov ax,  #0xF000
 +a   E1E3           A3         01D6              mov 0x75*4+2, ax
35386                                             ;; Video setup
35387                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E1E6           B8                   F065    mov ax,  #int10_handler
 +a   E1E9           A3         0040              mov 0x10*4, ax
 +a   E1EC           B8                   F000    mov ax,  #0xF000
 +a   E1EF           A3         0042              mov 0x10*4+2, ax
35388                                             ;; PIC
35389 E1F2           E8         BAC5              call post_init_pic
35390 E1F5           E8         B838              call rombios32_init
35391 E1F8           B9                   C000    mov cx, #0xc000 ;; init vga bios
35392 E1FB           B8                   C780    mov ax, #0xc780
35393 E1FE           E8         B9F8              call rom_scan
35394                                             ;; Hack fix: SeaVGABIOS does not setup a video mode
35395 E201           BA                   03D4    mov dx, #0x03d4
35396 E204           B0                     00    mov al, #0x00
35397 E206           EE                           out dx, al
35398 E207           42                           inc dx
35399 E208           EC                           in al, dx
35400 E209           84C0                         test al, al
35401 E20B           75           05              jnz vga_init_ok
35402 E20D           B8                   0003    mov ax, #0x0003
35403 E210           CD                     10    int #0x10
35404                       0000E212            vga_init_ok:
35405 E212           E8         2FCC              call _print_bios_banner
35406                                             ;;
35407                                             ;; Floppy setup
35408                                             ;;
35409 E215           E8         AD71              call floppy_drive_post
35410                                             ;;
35411                                             ;; Hard Drive setup
35412                                             ;;
35413 E218           E8         ADF5              call hard_drive_post
35414                                             ;;
35415                                             ;; ATA/ATAPI driver setup
35416                                             ;;
35417 E21B           E8         362A              call _ata_init
35418 E21E           E8         3969              call _ata_detect
35419                                             ;;
35420                                             ;;
35421                                             ;; eltorito floppy/harddisk emulation from cd
35422                                             ;;
35423 E221           E8         531A              call _cdemu_init
35424                                             ;;
35425 E224           E8         3013              call _init_boot_vectors
35426 E227           B9                   C800    mov cx, #0xc800 ;; init option roms
35427 E22A           B8                   E000    mov ax, #0xe000
35428 E22D           E8         B9C9              call rom_scan
35429 E230           E8         3183              call _interactive_bootkey
35430 E233           FB                           sti ;; enable interrupts
35431 E234           CD                     19    int #0x19
35432 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
35433                       0000E2C3            nmi:
35434                                             ;; FIXME the NMI handler should not panic
35435                                             ;; but iret when called from int75 (fpu exception)
35436 E2C3           E8         3431              call _nmi_handler_msg
35437 E2C6           CF                           iret
35438                       0000E2C7            int75_handler:
35439 E2C7           E6                     F0    out 0xf0, al
35440 E2C9           E8         AFDC              call eoi_both_pics
35441 E2CC           CD                     02    int 2
35442 E2CE           CF                           iret
35443                                           ;-------------------------------------------
35444                                           ;- INT 13h Fixed Disk Services Entry Point -
35445                                           ;-------------------------------------------
35446 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
35447                       0000E3FE            int13_handler:
35448 E3FE           E9         AABB              jmp int13_relocated
35449 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
35450                                           ;----------
35451                                           ;- INT19h -
35452                                           ;----------
35453 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
35454                       0000E6F2            int19_handler:
35455 E6F2           E9         A878              jmp int19_relocated
35456                                           ;-------------------------------------------
35457                                           ;- System BIOS Configuration Data Table
35458                                           ;-------------------------------------------
35459 E6F5                                      .org 0xe6f5
35460 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
35461 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
35462 E6F7                        FC            db 0xFC
35463 E6F8                        00            db 0x00
35464 E6F9                        01            db 1
35465                                           ; Feature byte 1
35466                                           ; b7: 1=DMA channel 3 used by hard disk
35467                                           ; b6: 1=2 interrupt controllers present
35468                                           ; b5: 1=RTC present
35469                                           ; b4: 1=BIOS calls int 15h/4Fh every key
35470                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
35471                                           ; b2: 1=extended BIOS data area used
35472                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
35473                                           ; b0: 1=Dual bus (MicroChannel + ISA)
35474 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
35475                                           ; Feature byte 2
35476                                           ; b7: 1=32-bit DMA supported
35477                                           ; b6: 1=int16h, function 9 supported
35478                                           ; b5: 1=int15h/C6h (get POS data) supported
35479                                           ; b4: 1=int15h/C7h (get mem map info) supported
35480                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
35481                                           ; b2: 1=non-8042 kb controller
35482                                           ; b1: 1=data streaming supported
35483                                           ; b0: reserved
35484 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
35485                                           ; Feature byte 3
35486                                           ; b7: not used
35487                                           ; b6: reserved
35488                                           ; b5: reserved
35489                                           ; b4: POST supports ROM-to-RAM enable/disable
35490                                           ; b3: SCSI on system board
35491                                           ; b2: info panel installed
35492                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
35493                                           ; b0: SCSI supported in IML
35494 E6FC                        00            db 0x00
35495                                           ; Feature byte 4
35496                                           ; b7: IBM private
35497                                           ; b6: EEPROM present
35498                                           ; b5-3: ABIOS presence (011 = not supported)
35499                                           ; b2: private
35500                                           ; b1: memory split above 16Mb supported
35501                                           ; b0: POSTEXT directly supported by POST
35502 E6FD                        00            db 0x00
35503                                           ; Feature byte 5 (IBM)
35504                                           ; b1: enhanced mouse
35505                                           ; b0: flash EPROM
35506 E6FE                        00            db 0x00
35507 E729                                      .org 0xe729 ; Baud Rate Generator Table
35508                                           ;----------
35509                                           ;- INT14h -
35510                                           ;----------
35511 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
35512                       0000E739            int14_handler:
35513 E739           1E                           push ds
35514 E73A           60                           pusha
35515 E73B           31C0                         xor ax, ax
35516 E73D           8ED8                         mov ds, ax
35517 E73F           E8         5350              call _int14_function
35518 E742           61                           popa
35519 E743           1F                           pop ds
35520 E744           CF                           iret
35521                                           ;----------------------------------------
35522                                           ;- INT 16h Keyboard Service Entry Point -
35523                                           ;----------------------------------------
35524 E82E                                      .org 0xe82e
35525                       0000E82E            int16_handler:
35526 E82E           FB                           sti
35527 E82F           1E                           push ds
35528 E830           9C                           pushf
35529 E831           60                           pusha
35530 E832           6A                     40    push #0x40
35531 E834           1F                           pop ds
35532 E835           80FC                   00    cmp ah, #0x00
35533 E838           74           1F              je int16_F00
35534 E83A           80FC                   10    cmp ah, #0x10
35535 E83D           74           1A              je int16_F00
35536 E83F           E8         654E              call _int16_function
35537 E842           61                           popa
35538 E843           9D                           popf
35539 E844           1F                           pop ds
35540 E845           74           09              jz int16_zero_set
35541                       0000E847            int16_zero_clear:
35542 E847           55                           push bp
35543 E848           89E5                         mov bp, sp
35544 E84A           8066         06        BF    and BYTE [bp + 0x06], #0xbf
35545 E84E           5D                           pop bp
35546 E84F           CF                           iret
35547                       0000E850            int16_zero_set:
35548 E850           55                           push bp
35549 E851           89E5                         mov bp, sp
35550 E853           804E         06        40    or BYTE [bp + 0x06], #0x40
35551 E857           5D                           pop bp
35552 E858           CF                           iret
35553                       0000E859            int16_F00:
35554 E859           FA                           cli
35555 E85A           A1         001A              mov ax, 0x001a
35556 E85D           3B06       001C              cmp ax, 0x001c
35557 E861           75           13              jne int16_key_found
35558 E863           FB                           sti
35559                                             ;; no key yet, call int 15h, function AX=9002
35560 E864           B8                   9002    mov ax, #0x9002
35561 E867           CD                     15    int #0x15
35562                       0000E869            int16_wait_for_key:
35563 E869           FA                           cli
35564 E86A           A1         001A              mov ax, 0x001a
35565 E86D           3B06       001C              cmp ax, 0x001c
35566 E871           75           03              jne int16_key_found
35567 E873           FB                           sti
35568 E874           EB           F3              jmp int16_wait_for_key
35569                       0000E876            int16_key_found:
35570 E876           E8         6517              call _int16_function
35571 E879           61                           popa
35572 E87A           9D                           popf
35573 E87B           1F                           pop ds
35574 E87C           CF                           iret
35575                                           ;-------------------------------------------------
35576                                           ;- INT09h : Keyboard Hardware Service Entry Point -
35577                                           ;-------------------------------------------------
35578 E987                                      .org 0xe987
35579                       0000E987            int09_handler:
35580 E987           FA                           cli
35581 E988           50                           push ax
35582 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
35583 E98B           E6                     64    out 0x0064, al
35584 E98D           B0                     0B    mov al, #0x0B
35585 E98F           E6                     20    out 0x0020, al
35586 E991           E4                     20    in al, 0x0020
35587 E993           24                     02    and al, #0x02
35588 E995           74           40              jz int09_finish
35589 E997           E4                     60    in al, 0x0060 ;;read key from keyboard controller
35590 E999           FB                           sti
35591 E99A           1E                           push ds
35592 E99B           60                           pusha
35593 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
35594 E99E           F9                           stc
35595 E99F           CD                     15    int #0x15
35596 E9A1           55                           push bp
35597 E9A2           89E5                         mov bp, sp
35598 E9A4           8846         10              mov [bp + 0x10], al
35599 E9A7           5D                           pop bp
35600 E9A8           73           22              jnc int09_done
35601                                             ;; check for extended key
35602 E9AA           6A                     40    push #0x40
35603 E9AC           1F                           pop ds
35604 E9AD           3C                     E0    cmp al, #0xe0
35605 E9AF           75           0A              jne int09_check_pause
35606 E9B1           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x02
35607 E9B4           0C                     02    or al, #0x02
35608 E9B6           A2         0096              mov BYTE [0x96], al
35609 E9B9           EB           11              jmp int09_done
35610                       0000E9BB            int09_check_pause: ;; check for pause key
35611 E9BB           3C                     E1    cmp al, #0xe1
35612 E9BD           75           0A              jne int09_process_key
35613 E9BF           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x01
35614 E9C2           0C                     01    or al, #0x01
35615 E9C4           A2         0096              mov BYTE [0x96], al
35616 E9C7           EB           03              jmp int09_done
35617                       0000E9C9            int09_process_key:
35618 E9C9           E8         6A43              call _int09_function
35619                       0000E9CC            int09_done:
35620 E9CC           61                           popa
35621 E9CD           1F                           pop ds
35622 E9CE           FA                           cli
35623 E9CF           E8         A8DA              call eoi_master_pic
35624                                             ;; Notify keyboard interrupt complete w/ int 15h, function AX=9102
35625 E9D2           B8                   9102    mov ax, #0x9102
35626 E9D5           CD                     15    int #0x15
35627                       0000E9D7            int09_finish:
35628 E9D7           B0                     AE    mov al, #0xAE ;;enable keyboard
35629 E9D9           E6                     64    out 0x0064, al
35630 E9DB           58                           pop ax
35631 E9DC           CF                           iret
35632                                           ; IRQ9 handler(Redirect to IRQ2)
35633                                           ;--------------------
35634                       0000E9DD            int71_handler:
35635 E9DD           50                           push ax
35636 E9DE           B0                     20    mov al, #0x20
35637 E9E0           E6                     A0    out 0x00a0, al ;; slave PIC EOI
35638 E9E2           58                           pop ax
35639 E9E3           CD                     0A    int #0x0A
35640 E9E5           CF                           iret
35641                                           ;--------------------
35642                       0000E9E6            dummy_master_pic_irq_handler:
35643 E9E6           50                           push ax
35644 E9E7           E8         A8C2              call eoi_master_pic
35645 E9EA           58                           pop ax
35646 E9EB           CF                           iret
35647                                           ;--------------------
35648                       0000E9EC            dummy_slave_pic_irq_handler:
35649 E9EC           50                           push ax
35650 E9ED           E8         A8B8              call eoi_both_pics
35651 E9F0           58                           pop ax
35652 E9F1           CF                           iret
35653                                           ;----------------------------------------
35654                                           ;- INT 13h Diskette Service Entry Point -
35655                                           ;----------------------------------------
35656 EC59                                      .org 0xec59
35657                       0000EC59            int13_diskette:
35658 EC59           E9         A2B3              jmp int13_noeltorito
35659                                           ;---------------------------------------------
35660                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
35661                                           ;---------------------------------------------
35662 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
35663                       0000EF57            int0e_handler:
35664 EF57           50                           push ax
35665 EF58           52                           push dx
35666 EF59           BA                   03F4    mov dx, #0x03f4
35667 EF5C           EC                           in al, dx
35668 EF5D           24                     C0    and al, #0xc0
35669 EF5F           3C                     C0    cmp al, #0xc0
35670 EF61           74           1E              je int0e_normal
35671 EF63           BA                   03F5    mov dx, #0x03f5
35672 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
35673 EF68           EE                           out dx, al
35674                       0000EF69            int0e_loop1:
35675 EF69           BA                   03F4    mov dx, #0x03f4
35676 EF6C           EC                           in al, dx
35677 EF6D           24                     C0    and al, #0xc0
35678 EF6F           3C                     C0    cmp al, #0xc0
35679 EF71           75           F6              jne int0e_loop1
35680                       0000EF73            int0e_loop2:
35681 EF73           BA                   03F5    mov dx, #0x03f5
35682 EF76           EC                           in al, dx
35683 EF77           BA                   03F4    mov dx, #0x03f4
35684 EF7A           EC                           in al, dx
35685 EF7B           24                     C0    and al, #0xc0
35686 EF7D           3C                     C0    cmp al, #0xc0
35687 EF7F           74           F2              je int0e_loop2
35688                       0000EF81            int0e_normal:
35689 EF81           1E                           push ds
35690 EF82           31C0                         xor ax, ax ;; segment 0000
35691 EF84           8ED8                         mov ds, ax
35692 EF86           E8         A323              call eoi_master_pic
35693 EF89           A0         043E              mov al, 0x043e
35694 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
35695 EF8E           A2         043E              mov 0x043e, al
35696 EF91           1F                           pop ds
35697                                             ;; Notify diskette interrupt complete w/ int 15h, function AX=9101
35698 EF92           B8                   9101    mov ax, #0x9101
35699 EF95           CD                     15    int #0x15
35700 EF97           5A                           pop dx
35701 EF98           58                           pop ax
35702 EF99           CF                           iret
35703 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
35704                       0000EFC7            diskette_param_table:
35705                                           ;; Since no provisions are made for multiple drive types, most
35706                                           ;; values in this table are ignored. I set parameters for 1.44M
35707                                           ;; floppy here
35708 EFC7                        AF            db 0xAF
35709 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
35710 EFC9                        25            db 0x25
35711 EFCA                        02            db 0x02
35712 EFCB                        12            db 18
35713 EFCC                        1B            db 0x1B
35714 EFCD                        FF            db 0xFF
35715 EFCE                        6C            db 0x6C
35716 EFCF                        F6            db 0xF6
35717 EFD0                        0F            db 0x0F
35718 EFD1                        08            db 0x08
35719                                           ;----------------------------------------
35720                                           ;- INT17h : Printer Service Entry Point -
35721                                           ;----------------------------------------
35722 EFD2                                      .org 0xefd2
35723                       0000EFD2            int17_handler:
35724 EFD2           1E                           push ds
35725 EFD3           60                           pusha
35726 EFD4           31C0                         xor ax, ax
35727 EFD6           8ED8                         mov ds, ax
35728 EFD8           E8         96AD              call _int17_function
35729 EFDB           61                           popa
35730 EFDC           1F                           pop ds
35731 EFDD           CF                           iret
35732                       0000EFDE            diskette_param_table2:
35733                                           ;; New diskette parameter table adding 3 parameters from IBM
35734                                           ;; Since no provisions are made for multiple drive types, most
35735                                           ;; values in this table are ignored. I set parameters for 1.44M
35736                                           ;; floppy here
35737 EFDE                        AF            db 0xAF
35738 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
35739 EFE0                        25            db 0x25
35740 EFE1                        02            db 0x02
35741 EFE2                        12            db 18
35742 EFE3                        1B            db 0x1B
35743 EFE4                        FF            db 0xFF
35744 EFE5                        6C            db 0x6C
35745 EFE6                        F6            db 0xF6
35746 EFE7                        0F            db 0x0F
35747 EFE8                        08            db 0x08
35748 EFE9                        4F            db 79 ;; maximum track
35749 EFEA                        00            db 0 ;; data transfer rate
35750 EFEB                        04            db 4 ;; drive type in cmos
35751 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
35752                                             HALT(11527)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2D07    mov ax,#11527
 +a   F04B           EF                           out dx,ax
35753 F04C           CF                           iret
35754                                           ;----------
35755                                           ;- INT10h -
35756                                           ;----------
35757 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
35758                       0000F065            int10_handler:
35759                                             ;; dont do anything, since the VGA BIOS handles int10h requests
35760 F065           CF                           iret
35761 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
35762                                           ;----------
35763                                           ;- INT12h -
35764                                           ;----------
35765 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
35766                                           ; ??? different for Pentium (machine check)?
35767                       0000F841            int12_handler:
35768 F841           1E                           push ds
35769 F842           B8                   0040    mov ax, #0x0040
35770 F845           8ED8                         mov ds, ax
35771 F847           A1         0013              mov ax, 0x0013
35772 F84A           1F                           pop ds
35773 F84B           CF                           iret
35774                                           ;----------
35775                                           ;- INT11h -
35776                                           ;----------
35777 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
35778                       0000F84D            int11_handler:
35779 F84D           1E                           push ds
35780 F84E           B8                   0040    mov ax, #0x0040
35781 F851           8ED8                         mov ds, ax
35782 F853           A1         0010              mov ax, 0x0010
35783 F856           1F                           pop ds
35784 F857           CF                           iret
35785                                           ;----------
35786                                           ;- INT15h -
35787                                           ;----------
35788 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
35789                       0000F859            int15_handler:
35790 F859           80FC                   80    cmp ah, #0x80 ; Device open
35791 F85C           74           39              je int15_stub
35792 F85E           80FC                   81    cmp ah, #0x81 ; Device close
35793 F861           74           34              je int15_stub
35794 F863           80FC                   82    cmp ah, #0x82 ; Program termination
35795 F866           74           2F              je int15_stub
35796 F868           80FC                   90    cmp ah, #0x90 ; Device busy interrupt. Called by Int 16h when no key available
35797 F86B           74           2A              je int15_stub
35798 F86D           80FC                   91    cmp ah, #0x91 ; Interrupt complete. Called by IRQ handlers
35799 F870           74           25              je int15_stub
35800 F872           9C                           pushf
35801 F873           80FC                   53    cmp ah, #0x53
35802 F876           74           1C              je apm_call
35803 F878           1E                           push ds
35804 F879           06                           push es
35805 F87A           80FC                   86    cmp ah, #0x86
35806 F87D           74           23              je int15_handler32
35807 F87F           80FC                   E8    cmp ah, #0xE8
35808 F882           74           1E              je int15_handler32
35809 F884           60                           pusha
35810 F885           80FC                   C2    cmp ah, #0xC2
35811 F888           74           13              je int15_handler_mouse
35812 F88A           E8         4432              call _int15_function
35813                       0000F88D            int15_handler_mouse_ret:
35814 F88D           61                           popa
35815                       0000F88E            int15_handler32_ret:
35816 F88E           07                           pop es
35817 F88F           1F                           pop ds
35818 F890           9D                           popf
35819 F891           E9         9614              jmp iret_modify_cf
35820                       0000F894            apm_call:
35821 F894           E9         9C72              jmp _apmreal_entry
35822                       0000F897            int15_stub:
35823 F897           30E4                         xor ah, ah ; "operation success"
35824 F899           F8                           clc
35825 F89A           E9         960B              jmp iret_modify_cf
35826                       0000F89D            int15_handler_mouse:
35827 F89D           E8         4903              call _int15_function_mouse
35828 F8A0           EB           EB              jmp int15_handler_mouse_ret
35829                       0000F8A2            int15_handler32:
35830 F8A2     66    60                           pushad
35831 F8A4           E8         5024              call _int15_function32
35832 F8A7     66    61                           popad
35833 F8A9           EB           E3              jmp int15_handler32_ret
35834                                           ;; Protected mode IDT descriptor
35835                                           ;;
35836                                           ;; I just make the limit 0, so the machine will shutdown
35837                                           ;; if an exception occurs during protected mode memory
35838                                           ;; transfers.
35839                                           ;;
35840                                           ;; Set base to f0000 to correspond to beginning of BIOS,
35841                                           ;; in case I actually define an IDT later
35842                                           ;; Set limit to 0
35843                       0000F8AB            pmode_IDT_info:
35844 F8AB                      0000            dw 0x0000 ;; limit 15:00
35845 F8AD                      0000            dw 0x0000 ;; base 15:00
35846 F8AF                        0F            db 0x0f ;; base 23:16
35847 F8B0                        00            db 0x00 ;; base 31:24
35848                                           ;; Real mode IDT descriptor
35849                                           ;;
35850                                           ;; Set to typical real-mode values.
35851                                           ;; base = 000000
35852                                           ;; limit = 03ff
35853                       0000F8B1            rmode_IDT_info:
35854 F8B1                      03FF            dw 0x03ff ;; limit 15:00
35855 F8B3                      0000            dw 0x0000 ;; base 15:00
35856 F8B5                        00            db 0x00 ;; base 23:16
35857 F8B6                        00            db 0x00 ;; base 31:24
35858                                           ;----------
35859                                           ;- INT1Ah -
35860                                           ;----------
35861 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
35862                       0000FE6E            int1a_handler:
35863 FE6E           80FC                   B1    cmp ah, #0xb1
35864 FE71           75           14              jne int1a_normal
35865 FE73           E8         9967              call pcibios_real
35866 FE76           72           03              jc pcibios_error
35867 FE78           CA                   0002    retf 2
35868                       0000FE7B            pcibios_error:
35869 FE7B           88E3                         mov bl, ah
35870 FE7D           B4                     B1    mov ah, #0xb1
35871 FE7F           1E                           push ds
35872 FE80           60                           pusha
35873 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
35874 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
35875 FE85           EB           06              jmp int1a_callfunction
35876                       0000FE87            int1a_normal:
35877 FE87           1E                           push ds
35878 FE88           60                           pusha
35879 FE89           31C0                         xor ax, ax
35880 FE8B           8ED8                         mov ds, ax
35881                       0000FE8D            int1a_callfunction:
35882 FE8D           E8         8B5B              call _int1a_function
35883 FE90           61                           popa
35884 FE91           1F                           pop ds
35885 FE92           CF                           iret
35886                                           ;;
35887                                           ;; int70h: IRQ8 - CMOS RTC
35888                                           ;;
35889                       0000FE93            int70_handler:
35890 FE93           1E                           push ds
35891 FE94     66    60                           pushad
35892 FE96           31C0                         xor ax, ax
35893 FE98           8ED8                         mov ds, ax
35894 FE9A           E8         8EF7              call _int70_function
35895 FE9D     66    61                           popad
35896 FE9F           1F                           pop ds
35897 FEA0           CF                           iret
35898                                           ;---------
35899                                           ;- INT08 -
35900                                           ;---------
35901 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
35902                       0000FEA5            int08_handler:
35903 FEA5           FB                           sti
35904 FEA6     66    50                           push eax
35905 FEA8           1E                           push ds
35906 FEA9           31C0                         xor ax, ax
35907 FEAB           8ED8                         mov ds, ax
35908                                             ;; time to turn off drive(s)?
35909 FEAD           A0         0440              mov al,0x0440
35910 FEB0           08C0                         or al,al
35911 FEB2           74           10              jz int08_floppy_off
35912 FEB4           FEC8                         dec al
35913 FEB6           A2         0440              mov 0x0440,al
35914 FEB9           75           09              jnz int08_floppy_off
35915                                             ;; turn motor(s) off
35916 FEBB           52                           push dx
35917 FEBC           BA                   03F2    mov dx,#0x03f2
35918 FEBF           EC                           in al,dx
35919 FEC0           24                     CF    and al,#0xcf
35920 FEC2           EE                           out dx,al
35921 FEC3           5A                           pop dx
35922                       0000FEC4            int08_floppy_off:
35923 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
35924 FEC8     66    40                           inc eax
35925                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
35926 FECA     66    3D               001800B0    cmp eax, #0x001800B0
35927 FED0           72           07              jb int08_store_ticks
35928                                             ;; there has been a midnight rollover at this point
35929 FED2     66    31C0                         xor eax, eax ;; zero out counter
35930 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
35931                       0000FED9            int08_store_ticks:
35932 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
35933                                             ;; chain to user timer tick INT #0x1c
35934 FEDD           CD                     1C    int #0x1c
35935 FEDF           FA                           cli
35936 FEE0           E8         93C9              call eoi_master_pic
35937 FEE3           1F                           pop ds
35938 FEE4     66    58                           pop eax
35939 FEE6           CF                           iret
35940 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
35941                       0000FEF3            initial_int_vector_offset_08_1f:
35942 FEF3                      FEA5              dw int08_handler
35943 FEF5                      E987              dw int09_handler
35944 FEF7                      E9E6              dw dummy_master_pic_irq_handler
35945 FEF9                      E9E6              dw dummy_master_pic_irq_handler
35946 FEFB                      E9E6              dw dummy_master_pic_irq_handler
35947 FEFD                      E9E6              dw dummy_master_pic_irq_handler
35948 FEFF                      EF57              dw int0e_handler
35949 FF01                      E9E6              dw dummy_master_pic_irq_handler
35950 FF03                      F065              dw int10_handler
35951 FF05                      F84D              dw int11_handler
35952 FF07                      F841              dw int12_handler
35953 FF09                      E3FE              dw int13_handler
35954 FF0B                      E739              dw int14_handler
35955 FF0D                      F859              dw int15_handler
35956 FF0F                      E82E              dw int16_handler
35957 FF11                      EFD2              dw int17_handler
35958 FF13                      8F51              dw int18_handler
35959 FF15                      E6F2              dw int19_handler
35960 FF17                      FE6E              dw int1a_handler
35961 FF19                      FF53              dw dummy_iret_handler
35962 FF1B                      FF53              dw dummy_iret_handler
35963 FF1D                      0000              dw 0
35964 FF1F                      EFDE              dw diskette_param_table2
35965 FF21                      0000              dw 0
35966                                           ;------------------------------------------------
35967                                           ;- IRET Instruction for Dummy Interrupt Handler -
35968                                           ;------------------------------------------------
35969 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
35970                       0000FF53            dummy_iret_handler:
35971 FF53           CF                           iret
35972 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
35973                                             HALT(11782)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2E06    mov ax,#11782
 +a   FF5A           EF                           out dx,ax
35974 FF5B           CF                           iret
35975 FFF0                                      .org 0xfff0 ; Power-up Entry Point
35976 FFF0           EA         E05B      F000    jmp 0xf000:post
35977 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
35978 FFF5                        30            .ascii "08/01/21"
35979 FFFE                                      .org 0xfffe ; System Model ID
35980 FFFE                        FC            db 0xFC
35981 FFFF                        00            db 0x00 ; filler
35982 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
35983                                           ! 8415 endasm
35984                                           !BCC_ENDASM
35985                                           ! 8416 static Bit8u vgafont8[128*8]=
35986                                           ! Register BX used in function int70_function
35987                                           ! 8417 {
35988                                           
35989                       0000FA6E            _vgafont8:
35990                                           ! 8418  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
35991 FA6E                        00            .byte	0
35992 FA6F                        00            .byte	0
35993 FA70                        00            .byte	0
35994 FA71                        00            .byte	0
35995 FA72                        00            .byte	0
35996 FA73                        00            .byte	0
35997 FA74                        00            .byte	0
35998 FA75                        00            .byte	0
35999                                           ! 8419  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
36000 FA76                        7E            .byte	$7E
36001 FA77                        81            .byte	$81
36002 FA78                        A5            .byte	$A5
36003 FA79                        81            .byte	$81
36004 FA7A                        BD            .byte	$BD
36005 FA7B                        99            .byte	$99
36006 FA7C                        81            .byte	$81
36007 FA7D                        7E            .byte	$7E
36008                                           ! 8420  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
36009 FA7E                        7E            .byte	$7E
36010 FA7F                        FF            .byte	$FF
36011 FA80                        DB            .byte	$DB
36012 FA81                        FF            .byte	$FF
36013 FA82                        C3            .byte	$C3
36014 FA83                        E7            .byte	$E7
36015 FA84                        FF            .byte	$FF
36016 FA85                        7E            .byte	$7E
36017                                           ! 8421  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36018 FA86                        6C            .byte	$6C
36019 FA87                        FE            .byte	$FE
36020 FA88                        FE            .byte	$FE
36021 FA89                        FE            .byte	$FE
36022 FA8A                        7C            .byte	$7C
36023 FA8B                        38            .byte	$38
36024 FA8C                        10            .byte	$10
36025 FA8D                        00            .byte	0
36026                                           ! 8422  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36027 FA8E                        10            .byte	$10
36028 FA8F                        38            .byte	$38
36029 FA90                        7C            .byte	$7C
36030 FA91                        FE            .byte	$FE
36031 FA92                        7C            .byte	$7C
36032 FA93                        38            .byte	$38
36033 FA94                        10            .byte	$10
36034 FA95                        00            .byte	0
36035                                           ! 8423  0x38, 0x7c, 0x38, 0xfe, 
36036 FA96                        38            .byte	$38
36037 FA97                        7C            .byte	$7C
36038 FA98                        38            .byte	$38
36039 FA99                        FE            .byte	$FE
36040                                           ! 8423 0xfe, 0x7c, 0x38, 0x7c,
36041 FA9A                        FE            .byte	$FE
36042 FA9B                        7C            .byte	$7C
36043 FA9C                        38            .byte	$38
36044 FA9D                        7C            .byte	$7C
36045                                           ! 8424  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
36046 FA9E                        10            .byte	$10
36047 FA9F                        10            .byte	$10
36048 FAA0                        38            .byte	$38
36049 FAA1                        7C            .byte	$7C
36050 FAA2                        FE            .byte	$FE
36051 FAA3                        7C            .byte	$7C
36052 FAA4                        38            .byte	$38
36053 FAA5                        7C            .byte	$7C
36054                                           ! 8425  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
36055 FAA6                        00            .byte	0
36056 FAA7                        00            .byte	0
36057 FAA8                        18            .byte	$18
36058 FAA9                        3C            .byte	$3C
36059 FAAA                        3C            .byte	$3C
36060 FAAB                        18            .byte	$18
36061 FAAC                        00            .byte	0
36062 FAAD                        00            .byte	0
36063                                           ! 8426  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
36064 FAAE                        FF            .byte	$FF
36065 FAAF                        FF            .byte	$FF
36066 FAB0                        E7            .byte	$E7
36067 FAB1                        C3            .byte	$C3
36068 FAB2                        C3            .byte	$C3
36069 FAB3                        E7            .byte	$E7
36070 FAB4                        FF            .byte	$FF
36071 FAB5                        FF            .byte	$FF
36072                                           ! 8427  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
36073 FAB6                        00            .byte	0
36074 FAB7                        3C            .byte	$3C
36075 FAB8                        66            .byte	$66
36076 FAB9                        42            .byte	$42
36077 FABA                        42            .byte	$42
36078 FABB                        66            .byte	$66
36079 FABC                        3C            .byte	$3C
36080 FABD                        00            .byte	0
36081                                           ! 8428  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
36082 FABE                        FF            .byte	$FF
36083 FABF                        C3            .byte	$C3
36084 FAC0                        99            .byte	$99
36085 FAC1                        BD            .byte	$BD
36086 FAC2                        BD            .byte	$BD
36087 FAC3                        99            .byte	$99
36088 FAC4                        C3            .byte	$C3
36089 FAC5                        FF            .byte	$FF
36090                                           ! 8429  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
36091 FAC6                        0F            .byte	$F
36092 FAC7                        07            .byte	7
36093 FAC8                        0F            .byte	$F
36094 FAC9                        7D            .byte	$7D
36095 FACA                        CC            .byte	$CC
36096 FACB                        CC            .byte	$CC
36097 FACC                        CC            .byte	$CC
36098 FACD                        78            .byte	$78
36099                                           ! 8430  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
36100 FACE                        3C            .byte	$3C
36101 FACF                        66            .byte	$66
36102 FAD0                        66            .byte	$66
36103 FAD1                        66            .byte	$66
36104 FAD2                        3C            .byte	$3C
36105 FAD3                        18            .byte	$18
36106 FAD4                        7E            .byte	$7E
36107 FAD5                        18            .byte	$18
36108                                           ! 8431  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
36109 FAD6                        3F            .byte	$3F
36110 FAD7                        33            .byte	$33
36111 FAD8                        3F            .byte	$3F
36112 FAD9                        30            .byte	$30
36113 FADA                        30            .byte	$30
36114 FADB                        70            .byte	$70
36115 FADC                        F0            .byte	$F0
36116 FADD                        E0            .byte	$E0
36117                                           ! 8432  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
36118 FADE                        7F            .byte	$7F
36119 FADF                        63            .byte	$63
36120 FAE0                        7F            .byte	$7F
36121 FAE1                        63            .byte	$63
36122 FAE2                        63            .byte	$63
36123 FAE3                        67            .byte	$67
36124 FAE4                        E6            .byte	$E6
36125 FAE5                        C0            .byte	$C0
36126                                           ! 8433  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
36127 FAE6                        99            .byte	$99
36128 FAE7                        5A            .byte	$5A
36129 FAE8                        3C            .byte	$3C
36130 FAE9                        E7            .byte	$E7
36131 FAEA                        E7            .byte	$E7
36132 FAEB                        3C            .byte	$3C
36133 FAEC                        5A            .byte	$5A
36134 FAED                        99            .byte	$99
36135                                           ! 8434  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
36136 FAEE                        80            .byte	$80
36137 FAEF                        E0            .byte	$E0
36138 FAF0                        F8            .byte	$F8
36139 FAF1                        FE            .byte	$FE
36140 FAF2                        F8            .byte	$F8
36141 FAF3                        E0            .byte	$E0
36142 FAF4                        80            .byte	$80
36143 FAF5                        00            .byte	0
36144                                           ! 8435  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
36145 FAF6                        02            .byte	2
36146 FAF7                        0E            .byte	$E
36147 FAF8                        3E            .byte	$3E
36148 FAF9                        FE            .byte	$FE
36149 FAFA                        3E            .byte	$3E
36150 FAFB                        0E            .byte	$E
36151 FAFC                        02            .byte	2
36152 FAFD                        00            .byte	0
36153                                           ! 8436  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
36154 FAFE                        18            .byte	$18
36155 FAFF                        3C            .byte	$3C
36156 FB00                        7E            .byte	$7E
36157 FB01                        18            .byte	$18
36158 FB02                        18            .byte	$18
36159 FB03                        7E            .byte	$7E
36160 FB04                        3C            .byte	$3C
36161 FB05                        18            .byte	$18
36162                                           ! 8437  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
36163 FB06                        66            .byte	$66
36164 FB07                        66            .byte	$66
36165 FB08                        66            .byte	$66
36166 FB09                        66            .byte	$66
36167 FB0A                        66            .byte	$66
36168 FB0B                        00            .byte	0
36169 FB0C                        66            .byte	$66
36170 FB0D                        00            .byte	0
36171                                           ! 8438  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
36172 FB0E                        7F            .byte	$7F
36173 FB0F                        DB            .byte	$DB
36174 FB10                        DB            .byte	$DB
36175 FB11                        7B            .byte	$7B
36176 FB12                        1B            .byte	$1B
36177 FB13                        1B            .byte	$1B
36178 FB14                        1B            .byte	$1B
36179 FB15                        00            .byte	0
36180                                           ! 8439  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
36181 FB16                        3E            .byte	$3E
36182 FB17                        63            .byte	$63
36183 FB18                        38            .byte	$38
36184 FB19                        6C            .byte	$6C
36185 FB1A                        6C            .byte	$6C
36186 FB1B                        38            .byte	$38
36187 FB1C                        CC            .byte	$CC
36188 FB1D                        78            .byte	$78
36189                                           ! 8440  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
36190 FB1E                        00            .byte	0
36191 FB1F                        00            .byte	0
36192 FB20                        00            .byte	0
36193 FB21                        00            .byte	0
36194 FB22                        7E            .byte	$7E
36195 FB23                        7E            .byte	$7E
36196 FB24                        7E            .byte	$7E
36197 FB25                        00            .byte	0
36198                                           ! 8441  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
36199 FB26                        18            .byte	$18
36200 FB27                        3C            .byte	$3C
36201 FB28                        7E            .byte	$7E
36202 FB29                        18            .byte	$18
36203 FB2A                        7E            .byte	$7E
36204 FB2B                        3C            .byte	$3C
36205 FB2C                        18            .byte	$18
36206 FB2D                        FF            .byte	$FF
36207                                           ! 8442  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
36208 FB2E                        18            .byte	$18
36209 FB2F                        3C            .byte	$3C
36210 FB30                        7E            .byte	$7E
36211 FB31                        18            .byte	$18
36212 FB32                        18            .byte	$18
36213 FB33                        18            .byte	$18
36214 FB34                        18            .byte	$18
36215 FB35                        00            .byte	0
36216                                           ! 8443  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
36217 FB36                        18            .byte	$18
36218 FB37                        18            .byte	$18
36219 FB38                        18            .byte	$18
36220 FB39                        18            .byte	$18
36221 FB3A                        7E            .byte	$7E
36222 FB3B                        3C            .byte	$3C
36223 FB3C                        18            .byte	$18
36224 FB3D                        00            .byte	0
36225                                           ! 8444  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
36226 FB3E                        00            .byte	0
36227 FB3F                        18            .byte	$18
36228 FB40                        0C            .byte	$C
36229 FB41                        FE            .byte	$FE
36230 FB42                        0C            .byte	$C
36231 FB43                        18            .byte	$18
36232 FB44                        00            .byte	0
36233 FB45                        00            .byte	0
36234                                           ! 8445  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
36235 FB46                        00            .byte	0
36236 FB47                        30            .byte	$30
36237 FB48                        60            .byte	$60
36238 FB49                        FE            .byte	$FE
36239 FB4A                        60            .byte	$60
36240 FB4B                        30            .byte	$30
36241 FB4C                        00            .byte	0
36242 FB4D                        00            .byte	0
36243                                           ! 8446  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
36244 FB4E                        00            .byte	0
36245 FB4F                        00            .byte	0
36246 FB50                        C0            .byte	$C0
36247 FB51                        C0            .byte	$C0
36248 FB52                        C0            .byte	$C0
36249 FB53                        FE            .byte	$FE
36250 FB54                        00            .byte	0
36251 FB55                        00            .byte	0
36252                                           ! 8447  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
36253 FB56                        00            .byte	0
36254 FB57                        24            .byte	$24
36255 FB58                        66            .byte	$66
36256 FB59                        FF            .byte	$FF
36257 FB5A                        66            .byte	$66
36258 FB5B                        24            .byte	$24
36259 FB5C                        00            .byte	0
36260 FB5D                        00            .byte	0
36261                                           ! 8448  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
36262 FB5E                        00            .byte	0
36263 FB5F                        18            .byte	$18
36264 FB60                        3C            .byte	$3C
36265 FB61                        7E            .byte	$7E
36266 FB62                        FF            .byte	$FF
36267 FB63                        FF            .byte	$FF
36268 FB64                        00            .byte	0
36269 FB65                        00            .byte	0
36270                                           ! 8449  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
36271 FB66                        00            .byte	0
36272 FB67                        FF            .byte	$FF
36273 FB68                        FF            .byte	$FF
36274 FB69                        7E            .byte	$7E
36275 FB6A                        3C            .byte	$3C
36276 FB6B                        18            .byte	$18
36277 FB6C                        00            .byte	0
36278 FB6D                        00            .byte	0
36279                                           ! 8450  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
36280 FB6E                        00            .byte	0
36281 FB6F                        00            .byte	0
36282 FB70                        00            .byte	0
36283 FB71                        00            .byte	0
36284 FB72                        00            .byte	0
36285 FB73                        00            .byte	0
36286 FB74                        00            .byte	0
36287 FB75                        00            .byte	0
36288                                           ! 8451  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
36289 FB76                        30            .byte	$30
36290 FB77                        78            .byte	$78
36291 FB78                        78            .byte	$78
36292 FB79                        30            .byte	$30
36293 FB7A                        30            .byte	$30
36294 FB7B                        00            .byte	0
36295 FB7C                        30            .byte	$30
36296 FB7D                        00            .byte	0
36297                                           ! 8452  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
36298 FB7E                        6C            .byte	$6C
36299 FB7F                        6C            .byte	$6C
36300 FB80                        6C            .byte	$6C
36301 FB81                        00            .byte	0
36302 FB82                        00            .byte	0
36303 FB83                        00            .byte	0
36304 FB84                        00            .byte	0
36305 FB85                        00            .byte	0
36306                                           ! 8453  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
36307 FB86                        6C            .byte	$6C
36308 FB87                        6C            .byte	$6C
36309 FB88                        FE            .byte	$FE
36310 FB89                        6C            .byte	$6C
36311 FB8A                        FE            .byte	$FE
36312 FB8B                        6C            .byte	$6C
36313 FB8C                        6C            .byte	$6C
36314 FB8D                        00            .byte	0
36315                                           ! 8454  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
36316 FB8E                        30            .byte	$30
36317 FB8F                        7C            .byte	$7C
36318 FB90                        C0            .byte	$C0
36319 FB91                        78            .byte	$78
36320 FB92                        0C            .byte	$C
36321 FB93                        F8            .byte	$F8
36322 FB94                        30            .byte	$30
36323 FB95                        00            .byte	0
36324                                           ! 8455  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
36325 FB96                        00            .byte	0
36326 FB97                        C6            .byte	$C6
36327 FB98                        CC            .byte	$CC
36328 FB99                        18            .byte	$18
36329 FB9A                        30            .byte	$30
36330 FB9B                        66            .byte	$66
36331 FB9C                        C6            .byte	$C6
36332 FB9D                        00            .byte	0
36333                                           ! 8456  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
36334 FB9E                        38            .byte	$38
36335 FB9F                        6C            .byte	$6C
36336 FBA0                        38            .byte	$38
36337 FBA1                        76            .byte	$76
36338 FBA2                        DC            .byte	$DC
36339 FBA3                        CC            .byte	$CC
36340 FBA4                        76            .byte	$76
36341 FBA5                        00            .byte	0
36342                                           ! 8457  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
36343 FBA6                        60            .byte	$60
36344 FBA7                        60            .byte	$60
36345 FBA8                        C0            .byte	$C0
36346 FBA9                        00            .byte	0
36347 FBAA                        00            .byte	0
36348 FBAB                        00            .byte	0
36349 FBAC                        00            .byte	0
36350 FBAD                        00            .byte	0
36351                                           ! 8458  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
36352 FBAE                        18            .byte	$18
36353 FBAF                        30            .byte	$30
36354 FBB0                        60            .byte	$60
36355 FBB1                        60            .byte	$60
36356 FBB2                        60            .byte	$60
36357 FBB3                        30            .byte	$30
36358 FBB4                        18            .byte	$18
36359 FBB5                        00            .byte	0
36360                                           ! 8459  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
36361 FBB6                        60            .byte	$60
36362 FBB7                        30            .byte	$30
36363 FBB8                        18            .byte	$18
36364 FBB9                        18            .byte	$18
36365 FBBA                        18            .byte	$18
36366 FBBB                        30            .byte	$30
36367 FBBC                        60            .byte	$60
36368 FBBD                        00            .byte	0
36369                                           ! 8460  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
36370 FBBE                        00            .byte	0
36371 FBBF                        66            .byte	$66
36372 FBC0                        3C            .byte	$3C
36373 FBC1                        FF            .byte	$FF
36374 FBC2                        3C            .byte	$3C
36375 FBC3                        66            .byte	$66
36376 FBC4                        00            .byte	0
36377 FBC5                        00            .byte	0
36378                                           ! 8461  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
36379 FBC6                        00            .byte	0
36380 FBC7                        30            .byte	$30
36381 FBC8                        30            .byte	$30
36382 FBC9                        FC            .byte	$FC
36383 FBCA                        30            .byte	$30
36384 FBCB                        30            .byte	$30
36385 FBCC                        00            .byte	0
36386 FBCD                        00            .byte	0
36387                                           ! 8462  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
36388 FBCE                        00            .byte	0
36389 FBCF                        00            .byte	0
36390 FBD0                        00            .byte	0
36391 FBD1                        00            .byte	0
36392 FBD2                        00            .byte	0
36393 FBD3                        30            .byte	$30
36394 FBD4                        30            .byte	$30
36395 FBD5                        60            .byte	$60
36396                                           ! 8463  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
36397 FBD6                        00            .byte	0
36398 FBD7                        00            .byte	0
36399 FBD8                        00            .byte	0
36400 FBD9                        FC            .byte	$FC
36401 FBDA                        00            .byte	0
36402 FBDB                        00            .byte	0
36403 FBDC                        00            .byte	0
36404 FBDD                        00            .byte	0
36405                                           ! 8464  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
36406 FBDE                        00            .byte	0
36407 FBDF                        00            .byte	0
36408 FBE0                        00            .byte	0
36409 FBE1                        00            .byte	0
36410 FBE2                        00            .byte	0
36411 FBE3                        30            .byte	$30
36412 FBE4                        30            .byte	$30
36413 FBE5                        00            .byte	0
36414                                           ! 8465  0x06, 0x0c, 0x
36415 FBE6                        06            .byte	6
36416 FBE7                        0C            .byte	$C
36417                                           ! 8465 18, 0x30, 0x60, 0xc0, 0x80, 0x00,
36418 FBE8                        18            .byte	$18
36419 FBE9                        30            .byte	$30
36420 FBEA                        60            .byte	$60
36421 FBEB                        C0            .byte	$C0
36422 FBEC                        80            .byte	$80
36423 FBED                        00            .byte	0
36424                                           ! 8466  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
36425 FBEE                        7C            .byte	$7C
36426 FBEF                        C6            .byte	$C6
36427 FBF0                        CE            .byte	$CE
36428 FBF1                        DE            .byte	$DE
36429 FBF2                        F6            .byte	$F6
36430 FBF3                        E6            .byte	$E6
36431 FBF4                        7C            .byte	$7C
36432 FBF5                        00            .byte	0
36433                                           ! 8467  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
36434 FBF6                        30            .byte	$30
36435 FBF7                        70            .byte	$70
36436 FBF8                        30            .byte	$30
36437 FBF9                        30            .byte	$30
36438 FBFA                        30            .byte	$30
36439 FBFB                        30            .byte	$30
36440 FBFC                        FC            .byte	$FC
36441 FBFD                        00            .byte	0
36442                                           ! 8468  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
36443 FBFE                        78            .byte	$78
36444 FBFF                        CC            .byte	$CC
36445 FC00                        0C            .byte	$C
36446 FC01                        38            .byte	$38
36447 FC02                        60            .byte	$60
36448 FC03                        CC            .byte	$CC
36449 FC04                        FC            .byte	$FC
36450 FC05                        00            .byte	0
36451                                           ! 8469  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
36452 FC06                        78            .byte	$78
36453 FC07                        CC            .byte	$CC
36454 FC08                        0C            .byte	$C
36455 FC09                        38            .byte	$38
36456 FC0A                        0C            .byte	$C
36457 FC0B                        CC            .byte	$CC
36458 FC0C                        78            .byte	$78
36459 FC0D                        00            .byte	0
36460                                           ! 8470  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
36461 FC0E                        1C            .byte	$1C
36462 FC0F                        3C            .byte	$3C
36463 FC10                        6C            .byte	$6C
36464 FC11                        CC            .byte	$CC
36465 FC12                        FE            .byte	$FE
36466 FC13                        0C            .byte	$C
36467 FC14                        1E            .byte	$1E
36468 FC15                        00            .byte	0
36469                                           ! 8471  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
36470 FC16                        FC            .byte	$FC
36471 FC17                        C0            .byte	$C0
36472 FC18                        F8            .byte	$F8
36473 FC19                        0C            .byte	$C
36474 FC1A                        0C            .byte	$C
36475 FC1B                        CC            .byte	$CC
36476 FC1C                        78            .byte	$78
36477 FC1D                        00            .byte	0
36478                                           ! 8472  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
36479 FC1E                        38            .byte	$38
36480 FC1F                        60            .byte	$60
36481 FC20                        C0            .byte	$C0
36482 FC21                        F8            .byte	$F8
36483 FC22                        CC            .byte	$CC
36484 FC23                        CC            .byte	$CC
36485 FC24                        78            .byte	$78
36486 FC25                        00            .byte	0
36487                                           ! 8473  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
36488 FC26                        FC            .byte	$FC
36489 FC27                        CC            .byte	$CC
36490 FC28                        0C            .byte	$C
36491 FC29                        18            .byte	$18
36492 FC2A                        30            .byte	$30
36493 FC2B                        30            .byte	$30
36494 FC2C                        30            .byte	$30
36495 FC2D                        00            .byte	0
36496                                           ! 8474  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
36497 FC2E                        78            .byte	$78
36498 FC2F                        CC            .byte	$CC
36499 FC30                        CC            .byte	$CC
36500 FC31                        78            .byte	$78
36501 FC32                        CC            .byte	$CC
36502 FC33                        CC            .byte	$CC
36503 FC34                        78            .byte	$78
36504 FC35                        00            .byte	0
36505                                           ! 8475  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
36506 FC36                        78            .byte	$78
36507 FC37                        CC            .byte	$CC
36508 FC38                        CC            .byte	$CC
36509 FC39                        7C            .byte	$7C
36510 FC3A                        0C            .byte	$C
36511 FC3B                        18            .byte	$18
36512 FC3C                        70            .byte	$70
36513 FC3D                        00            .byte	0
36514                                           ! 8476  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
36515 FC3E                        00            .byte	0
36516 FC3F                        30            .byte	$30
36517 FC40                        30            .byte	$30
36518 FC41                        00            .byte	0
36519 FC42                        00            .byte	0
36520 FC43                        30            .byte	$30
36521 FC44                        30            .byte	$30
36522 FC45                        00            .byte	0
36523                                           ! 8477  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
36524 FC46                        00            .byte	0
36525 FC47                        30            .byte	$30
36526 FC48                        30            .byte	$30
36527 FC49                        00            .byte	0
36528 FC4A                        00            .byte	0
36529 FC4B                        30            .byte	$30
36530 FC4C                        30            .byte	$30
36531 FC4D                        60            .byte	$60
36532                                           ! 8478  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
36533 FC4E                        18            .byte	$18
36534 FC4F                        30            .byte	$30
36535 FC50                        60            .byte	$60
36536 FC51                        C0            .byte	$C0
36537 FC52                        60            .byte	$60
36538 FC53                        30            .byte	$30
36539 FC54                        18            .byte	$18
36540 FC55                        00            .byte	0
36541                                           ! 8479  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
36542 FC56                        00            .byte	0
36543 FC57                        00            .byte	0
36544 FC58                        FC            .byte	$FC
36545 FC59                        00            .byte	0
36546 FC5A                        00            .byte	0
36547 FC5B                        FC            .byte	$FC
36548 FC5C                        00            .byte	0
36549 FC5D                        00            .byte	0
36550                                           ! 8480  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
36551 FC5E                        60            .byte	$60
36552 FC5F                        30            .byte	$30
36553 FC60                        18            .byte	$18
36554 FC61                        0C            .byte	$C
36555 FC62                        18            .byte	$18
36556 FC63                        30            .byte	$30
36557 FC64                        60            .byte	$60
36558 FC65                        00            .byte	0
36559                                           ! 8481  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
36560 FC66                        78            .byte	$78
36561 FC67                        CC            .byte	$CC
36562 FC68                        0C            .byte	$C
36563 FC69                        18            .byte	$18
36564 FC6A                        30            .byte	$30
36565 FC6B                        00            .byte	0
36566 FC6C                        30            .byte	$30
36567 FC6D                        00            .byte	0
36568                                           ! 8482  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
36569 FC6E                        7C            .byte	$7C
36570 FC6F                        C6            .byte	$C6
36571 FC70                        DE            .byte	$DE
36572 FC71                        DE            .byte	$DE
36573 FC72                        DE            .byte	$DE
36574 FC73                        C0            .byte	$C0
36575 FC74                        78            .byte	$78
36576 FC75                        00            .byte	0
36577                                           ! 8483  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
36578 FC76                        30            .byte	$30
36579 FC77                        78            .byte	$78
36580 FC78                        CC            .byte	$CC
36581 FC79                        CC            .byte	$CC
36582 FC7A                        FC            .byte	$FC
36583 FC7B                        CC            .byte	$CC
36584 FC7C                        CC            .byte	$CC
36585 FC7D                        00            .byte	0
36586                                           ! 8484  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
36587 FC7E                        FC            .byte	$FC
36588 FC7F                        66            .byte	$66
36589 FC80                        66            .byte	$66
36590 FC81                        7C            .byte	$7C
36591 FC82                        66            .byte	$66
36592 FC83                        66            .byte	$66
36593 FC84                        FC            .byte	$FC
36594 FC85                        00            .byte	0
36595                                           ! 8485  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
36596 FC86                        3C            .byte	$3C
36597 FC87                        66            .byte	$66
36598 FC88                        C0            .byte	$C0
36599 FC89                        C0            .byte	$C0
36600 FC8A                        C0            .byte	$C0
36601 FC8B                        66            .byte	$66
36602 FC8C                        3C            .byte	$3C
36603 FC8D                        00            .byte	0
36604                                           ! 8486  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
36605 FC8E                        F8            .byte	$F8
36606 FC8F                        6C            .byte	$6C
36607 FC90                        66            .byte	$66
36608 FC91                        66            .byte	$66
36609 FC92                        66            .byte	$66
36610 FC93                        6C            .byte	$6C
36611 FC94                        F8            .byte	$F8
36612 FC95                        00            .byte	0
36613                                           ! 8487  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
36614 FC96                        FE            .byte	$FE
36615 FC97                        62            .byte	$62
36616 FC98                        68            .byte	$68
36617 FC99                        78            .byte	$78
36618 FC9A                        68            .byte	$68
36619 FC9B                        62            .byte	$62
36620 FC9C                        FE            .byte	$FE
36621 FC9D                        00            .byte	0
36622                                           ! 8488  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
36623 FC9E                        FE            .byte	$FE
36624 FC9F                        62            .byte	$62
36625 FCA0                        68            .byte	$68
36626 FCA1                        78            .byte	$78
36627 FCA2                        68            .byte	$68
36628 FCA3                        60            .byte	$60
36629 FCA4                        F0            .byte	$F0
36630 FCA5                        00            .byte	0
36631                                           ! 8489  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
36632 FCA6                        3C            .byte	$3C
36633 FCA7                        66            .byte	$66
36634 FCA8                        C0            .byte	$C0
36635 FCA9                        C0            .byte	$C0
36636 FCAA                        CE            .byte	$CE
36637 FCAB                        66            .byte	$66
36638 FCAC                        3E            .byte	$3E
36639 FCAD                        00            .byte	0
36640                                           ! 8490  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
36641 FCAE                        CC            .byte	$CC
36642 FCAF                        CC            .byte	$CC
36643 FCB0                        CC            .byte	$CC
36644 FCB1                        FC            .byte	$FC
36645 FCB2                        CC            .byte	$CC
36646 FCB3                        CC            .byte	$CC
36647 FCB4                        CC            .byte	$CC
36648 FCB5                        00            .byte	0
36649                                           ! 8491  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
36650 FCB6                        78            .byte	$78
36651 FCB7                        30            .byte	$30
36652 FCB8                        30            .byte	$30
36653 FCB9                        30            .byte	$30
36654 FCBA                        30            .byte	$30
36655 FCBB                        30            .byte	$30
36656 FCBC                        78            .byte	$78
36657 FCBD                        00            .byte	0
36658                                           ! 8492  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
36659 FCBE                        1E            .byte	$1E
36660 FCBF                        0C            .byte	$C
36661 FCC0                        0C            .byte	$C
36662 FCC1                        0C            .byte	$C
36663 FCC2                        CC            .byte	$CC
36664 FCC3                        CC            .byte	$CC
36665 FCC4                        78            .byte	$78
36666 FCC5                        00            .byte	0
36667                                           ! 8493  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
36668 FCC6                        E6            .byte	$E6
36669 FCC7                        66            .byte	$66
36670 FCC8                        6C            .byte	$6C
36671 FCC9                        78            .byte	$78
36672 FCCA                        6C            .byte	$6C
36673 FCCB                        66            .byte	$66
36674 FCCC                        E6            .byte	$E6
36675 FCCD                        00            .byte	0
36676                                           ! 8494  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
36677 FCCE                        F0            .byte	$F0
36678 FCCF                        60            .byte	$60
36679 FCD0                        60            .byte	$60
36680 FCD1                        60            .byte	$60
36681 FCD2                        62            .byte	$62
36682 FCD3                        66            .byte	$66
36683 FCD4                        FE            .byte	$FE
36684 FCD5                        00            .byte	0
36685                                           ! 8495  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
36686 FCD6                        C6            .byte	$C6
36687 FCD7                        EE            .byte	$EE
36688 FCD8                        FE            .byte	$FE
36689 FCD9                        FE            .byte	$FE
36690 FCDA                        D6            .byte	$D6
36691 FCDB                        C6            .byte	$C6
36692 FCDC                        C6            .byte	$C6
36693 FCDD                        00            .byte	0
36694                                           ! 8496  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
36695 FCDE                        C6            .byte	$C6
36696 FCDF                        E6            .byte	$E6
36697 FCE0                        F6            .byte	$F6
36698 FCE1                        DE            .byte	$DE
36699 FCE2                        CE            .byte	$CE
36700 FCE3                        C6            .byte	$C6
36701 FCE4                        C6            .byte	$C6
36702 FCE5                        00            .byte	0
36703                                           ! 8497  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
36704 FCE6                        38            .byte	$38
36705 FCE7                        6C            .byte	$6C
36706 FCE8                        C6            .byte	$C6
36707 FCE9                        C6            .byte	$C6
36708 FCEA                        C6            .byte	$C6
36709 FCEB                        6C            .byte	$6C
36710 FCEC                        38            .byte	$38
36711 FCED                        00            .byte	0
36712                                           ! 8498  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
36713 FCEE                        FC            .byte	$FC
36714 FCEF                        66            .byte	$66
36715 FCF0                        66            .byte	$66
36716 FCF1                        7C            .byte	$7C
36717 FCF2                        60            .byte	$60
36718 FCF3                        60            .byte	$60
36719 FCF4                        F0            .byte	$F0
36720 FCF5                        00            .byte	0
36721                                           ! 8499  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
36722 FCF6                        78            .byte	$78
36723 FCF7                        CC            .byte	$CC
36724 FCF8                        CC            .byte	$CC
36725 FCF9                        CC            .byte	$CC
36726 FCFA                        DC            .byte	$DC
36727 FCFB                        78            .byte	$78
36728 FCFC                        1C            .byte	$1C
36729 FCFD                        00            .byte	0
36730                                           ! 8500  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
36731 FCFE                        FC            .byte	$FC
36732 FCFF                        66            .byte	$66
36733 FD00                        66            .byte	$66
36734 FD01                        7C            .byte	$7C
36735 FD02                        6C            .byte	$6C
36736 FD03                        66            .byte	$66
36737 FD04                        E6            .byte	$E6
36738 FD05                        00            .byte	0
36739                                           ! 8501  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
36740 FD06                        78            .byte	$78
36741 FD07                        CC            .byte	$CC
36742 FD08                        E0            .byte	$E0
36743 FD09                        70            .byte	$70
36744 FD0A                        1C            .byte	$1C
36745 FD0B                        CC            .byte	$CC
36746 FD0C                        78            .byte	$78
36747 FD0D                        00            .byte	0
36748                                           ! 8502  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
36749 FD0E                        FC            .byte	$FC
36750 FD0F                        B4            .byte	$B4
36751 FD10                        30            .byte	$30
36752 FD11                        30            .byte	$30
36753 FD12                        30            .byte	$30
36754 FD13                        30            .byte	$30
36755 FD14                        78            .byte	$78
36756 FD15                        00            .byte	0
36757                                           ! 8503  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
36758 FD16                        CC            .byte	$CC
36759 FD17                        CC            .byte	$CC
36760 FD18                        CC            .byte	$CC
36761 FD19                        CC            .byte	$CC
36762 FD1A                        CC            .byte	$CC
36763 FD1B                        CC            .byte	$CC
36764 FD1C                        FC            .byte	$FC
36765 FD1D                        00            .byte	0
36766                                           ! 8504  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
36767 FD1E                        CC            .byte	$CC
36768 FD1F                        CC            .byte	$CC
36769 FD20                        CC            .byte	$CC
36770 FD21                        CC            .byte	$CC
36771 FD22                        CC            .byte	$CC
36772 FD23                        78            .byte	$78
36773 FD24                        30            .byte	$30
36774 FD25                        00            .byte	0
36775                                           ! 8505  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
36776 FD26                        C6            .byte	$C6
36777 FD27                        C6            .byte	$C6
36778 FD28                        C6            .byte	$C6
36779 FD29                        D6            .byte	$D6
36780 FD2A                        FE            .byte	$FE
36781 FD2B                        EE            .byte	$EE
36782 FD2C                        C6            .byte	$C6
36783 FD2D                        00            .byte	0
36784                                           ! 8506  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
36785 FD2E                        C6            .byte	$C6
36786 FD2F                        C6            .byte	$C6
36787 FD30                        6C            .byte	$6C
36788 FD31                        38            .byte	$38
36789 FD32                        38            .byte	$38
36790 FD33                        6C            .byte	$6C
36791 FD34                        C6            .byte	$C6
36792 FD35                        00            .byte	0
36793                                           ! 8507  0xcc
36794                                           ! 8507 , 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
36795 FD36                        CC            .byte	$CC
36796 FD37                        CC            .byte	$CC
36797 FD38                        CC            .byte	$CC
36798 FD39                        78            .byte	$78
36799 FD3A                        30            .byte	$30
36800 FD3B                        30            .byte	$30
36801 FD3C                        78            .byte	$78
36802 FD3D                        00            .byte	0
36803                                           ! 8508  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
36804 FD3E                        FE            .byte	$FE
36805 FD3F                        C6            .byte	$C6
36806 FD40                        8C            .byte	$8C
36807 FD41                        18            .byte	$18
36808 FD42                        32            .byte	$32
36809 FD43                        66            .byte	$66
36810 FD44                        FE            .byte	$FE
36811 FD45                        00            .byte	0
36812                                           ! 8509  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
36813 FD46                        78            .byte	$78
36814 FD47                        60            .byte	$60
36815 FD48                        60            .byte	$60
36816 FD49                        60            .byte	$60
36817 FD4A                        60            .byte	$60
36818 FD4B                        60            .byte	$60
36819 FD4C                        78            .byte	$78
36820 FD4D                        00            .byte	0
36821                                           ! 8510  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
36822 FD4E                        C0            .byte	$C0
36823 FD4F                        60            .byte	$60
36824 FD50                        30            .byte	$30
36825 FD51                        18            .byte	$18
36826 FD52                        0C            .byte	$C
36827 FD53                        06            .byte	6
36828 FD54                        02            .byte	2
36829 FD55                        00            .byte	0
36830                                           ! 8511  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
36831 FD56                        78            .byte	$78
36832 FD57                        18            .byte	$18
36833 FD58                        18            .byte	$18
36834 FD59                        18            .byte	$18
36835 FD5A                        18            .byte	$18
36836 FD5B                        18            .byte	$18
36837 FD5C                        78            .byte	$78
36838 FD5D                        00            .byte	0
36839                                           ! 8512  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
36840 FD5E                        10            .byte	$10
36841 FD5F                        38            .byte	$38
36842 FD60                        6C            .byte	$6C
36843 FD61                        C6            .byte	$C6
36844 FD62                        00            .byte	0
36845 FD63                        00            .byte	0
36846 FD64                        00            .byte	0
36847 FD65                        00            .byte	0
36848                                           ! 8513  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
36849 FD66                        00            .byte	0
36850 FD67                        00            .byte	0
36851 FD68                        00            .byte	0
36852 FD69                        00            .byte	0
36853 FD6A                        00            .byte	0
36854 FD6B                        00            .byte	0
36855 FD6C                        00            .byte	0
36856 FD6D                        FF            .byte	$FF
36857                                           ! 8514  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
36858 FD6E                        30            .byte	$30
36859 FD6F                        30            .byte	$30
36860 FD70                        18            .byte	$18
36861 FD71                        00            .byte	0
36862 FD72                        00            .byte	0
36863 FD73                        00            .byte	0
36864 FD74                        00            .byte	0
36865 FD75                        00            .byte	0
36866                                           ! 8515  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
36867 FD76                        00            .byte	0
36868 FD77                        00            .byte	0
36869 FD78                        78            .byte	$78
36870 FD79                        0C            .byte	$C
36871 FD7A                        7C            .byte	$7C
36872 FD7B                        CC            .byte	$CC
36873 FD7C                        76            .byte	$76
36874 FD7D                        00            .byte	0
36875                                           ! 8516  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
36876 FD7E                        E0            .byte	$E0
36877 FD7F                        60            .byte	$60
36878 FD80                        60            .byte	$60
36879 FD81                        7C            .byte	$7C
36880 FD82                        66            .byte	$66
36881 FD83                        66            .byte	$66
36882 FD84                        DC            .byte	$DC
36883 FD85                        00            .byte	0
36884                                           ! 8517  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
36885 FD86                        00            .byte	0
36886 FD87                        00            .byte	0
36887 FD88                        78            .byte	$78
36888 FD89                        CC            .byte	$CC
36889 FD8A                        C0            .byte	$C0
36890 FD8B                        CC            .byte	$CC
36891 FD8C                        78            .byte	$78
36892 FD8D                        00            .byte	0
36893                                           ! 8518  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
36894 FD8E                        1C            .byte	$1C
36895 FD8F                        0C            .byte	$C
36896 FD90                        0C            .byte	$C
36897 FD91                        7C            .byte	$7C
36898 FD92                        CC            .byte	$CC
36899 FD93                        CC            .byte	$CC
36900 FD94                        76            .byte	$76
36901 FD95                        00            .byte	0
36902                                           ! 8519  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
36903 FD96                        00            .byte	0
36904 FD97                        00            .byte	0
36905 FD98                        78            .byte	$78
36906 FD99                        CC            .byte	$CC
36907 FD9A                        FC            .byte	$FC
36908 FD9B                        C0            .byte	$C0
36909 FD9C                        78            .byte	$78
36910 FD9D                        00            .byte	0
36911                                           ! 8520  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
36912 FD9E                        38            .byte	$38
36913 FD9F                        6C            .byte	$6C
36914 FDA0                        60            .byte	$60
36915 FDA1                        F0            .byte	$F0
36916 FDA2                        60            .byte	$60
36917 FDA3                        60            .byte	$60
36918 FDA4                        F0            .byte	$F0
36919 FDA5                        00            .byte	0
36920                                           ! 8521  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
36921 FDA6                        00            .byte	0
36922 FDA7                        00            .byte	0
36923 FDA8                        76            .byte	$76
36924 FDA9                        CC            .byte	$CC
36925 FDAA                        CC            .byte	$CC
36926 FDAB                        7C            .byte	$7C
36927 FDAC                        0C            .byte	$C
36928 FDAD                        F8            .byte	$F8
36929                                           ! 8522  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
36930 FDAE                        E0            .byte	$E0
36931 FDAF                        60            .byte	$60
36932 FDB0                        6C            .byte	$6C
36933 FDB1                        76            .byte	$76
36934 FDB2                        66            .byte	$66
36935 FDB3                        66            .byte	$66
36936 FDB4                        E6            .byte	$E6
36937 FDB5                        00            .byte	0
36938                                           ! 8523  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
36939 FDB6                        30            .byte	$30
36940 FDB7                        00            .byte	0
36941 FDB8                        70            .byte	$70
36942 FDB9                        30            .byte	$30
36943 FDBA                        30            .byte	$30
36944 FDBB                        30            .byte	$30
36945 FDBC                        78            .byte	$78
36946 FDBD                        00            .byte	0
36947                                           ! 8524  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
36948 FDBE                        0C            .byte	$C
36949 FDBF                        00            .byte	0
36950 FDC0                        0C            .byte	$C
36951 FDC1                        0C            .byte	$C
36952 FDC2                        0C            .byte	$C
36953 FDC3                        CC            .byte	$CC
36954 FDC4                        CC            .byte	$CC
36955 FDC5                        78            .byte	$78
36956                                           ! 8525  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
36957 FDC6                        E0            .byte	$E0
36958 FDC7                        60            .byte	$60
36959 FDC8                        66            .byte	$66
36960 FDC9                        6C            .byte	$6C
36961 FDCA                        78            .byte	$78
36962 FDCB                        6C            .byte	$6C
36963 FDCC                        E6            .byte	$E6
36964 FDCD                        00            .byte	0
36965                                           ! 8526  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
36966 FDCE                        70            .byte	$70
36967 FDCF                        30            .byte	$30
36968 FDD0                        30            .byte	$30
36969 FDD1                        30            .byte	$30
36970 FDD2                        30            .byte	$30
36971 FDD3                        30            .byte	$30
36972 FDD4                        78            .byte	$78
36973 FDD5                        00            .byte	0
36974                                           ! 8527  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
36975 FDD6                        00            .byte	0
36976 FDD7                        00            .byte	0
36977 FDD8                        CC            .byte	$CC
36978 FDD9                        FE            .byte	$FE
36979 FDDA                        FE            .byte	$FE
36980 FDDB                        D6            .byte	$D6
36981 FDDC                        C6            .byte	$C6
36982 FDDD                        00            .byte	0
36983                                           ! 8528  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
36984 FDDE                        00            .byte	0
36985 FDDF                        00            .byte	0
36986 FDE0                        F8            .byte	$F8
36987 FDE1                        CC            .byte	$CC
36988 FDE2                        CC            .byte	$CC
36989 FDE3                        CC            .byte	$CC
36990 FDE4                        CC            .byte	$CC
36991 FDE5                        00            .byte	0
36992                                           ! 8529  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
36993 FDE6                        00            .byte	0
36994 FDE7                        00            .byte	0
36995 FDE8                        78            .byte	$78
36996 FDE9                        CC            .byte	$CC
36997 FDEA                        CC            .byte	$CC
36998 FDEB                        CC            .byte	$CC
36999 FDEC                        78            .byte	$78
37000 FDED                        00            .byte	0
37001                                           ! 8530  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
37002 FDEE                        00            .byte	0
37003 FDEF                        00            .byte	0
37004 FDF0                        DC            .byte	$DC
37005 FDF1                        66            .byte	$66
37006 FDF2                        66            .byte	$66
37007 FDF3                        7C            .byte	$7C
37008 FDF4                        60            .byte	$60
37009 FDF5                        F0            .byte	$F0
37010                                           ! 8531  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
37011 FDF6                        00            .byte	0
37012 FDF7                        00            .byte	0
37013 FDF8                        76            .byte	$76
37014 FDF9                        CC            .byte	$CC
37015 FDFA                        CC            .byte	$CC
37016 FDFB                        7C            .byte	$7C
37017 FDFC                        0C            .byte	$C
37018 FDFD                        1E            .byte	$1E
37019                                           ! 8532  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
37020 FDFE                        00            .byte	0
37021 FDFF                        00            .byte	0
37022 FE00                        DC            .byte	$DC
37023 FE01                        76            .byte	$76
37024 FE02                        66            .byte	$66
37025 FE03                        60            .byte	$60
37026 FE04                        F0            .byte	$F0
37027 FE05                        00            .byte	0
37028                                           ! 8533  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
37029 FE06                        00            .byte	0
37030 FE07                        00            .byte	0
37031 FE08                        7C            .byte	$7C
37032 FE09                        C0            .byte	$C0
37033 FE0A                        78            .byte	$78
37034 FE0B                        0C            .byte	$C
37035 FE0C                        F8            .byte	$F8
37036 FE0D                        00            .byte	0
37037                                           ! 8534  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
37038 FE0E                        10            .byte	$10
37039 FE0F                        30            .byte	$30
37040 FE10                        7C            .byte	$7C
37041 FE11                        30            .byte	$30
37042 FE12                        30            .byte	$30
37043 FE13                        34            .byte	$34
37044 FE14                        18            .byte	$18
37045 FE15                        00            .byte	0
37046                                           ! 8535  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
37047 FE16                        00            .byte	0
37048 FE17                        00            .byte	0
37049 FE18                        CC            .byte	$CC
37050 FE19                        CC            .byte	$CC
37051 FE1A                        CC            .byte	$CC
37052 FE1B                        CC            .byte	$CC
37053 FE1C                        76            .byte	$76
37054 FE1D                        00            .byte	0
37055                                           ! 8536  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
37056 FE1E                        00            .byte	0
37057 FE1F                        00            .byte	0
37058 FE20                        CC            .byte	$CC
37059 FE21                        CC            .byte	$CC
37060 FE22                        CC            .byte	$CC
37061 FE23                        78            .byte	$78
37062 FE24                        30            .byte	$30
37063 FE25                        00            .byte	0
37064                                           ! 8537  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
37065 FE26                        00            .byte	0
37066 FE27                        00            .byte	0
37067 FE28                        C6            .byte	$C6
37068 FE29                        D6            .byte	$D6
37069 FE2A                        FE            .byte	$FE
37070 FE2B                        FE            .byte	$FE
37071 FE2C                        6C            .byte	$6C
37072 FE2D                        00            .byte	0
37073                                           ! 8538  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
37074 FE2E                        00            .byte	0
37075 FE2F                        00            .byte	0
37076 FE30                        C6            .byte	$C6
37077 FE31                        6C            .byte	$6C
37078 FE32                        38            .byte	$38
37079 FE33                        6C            .byte	$6C
37080 FE34                        C6            .byte	$C6
37081 FE35                        00            .byte	0
37082                                           ! 8539  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37083 FE36                        00            .byte	0
37084 FE37                        00            .byte	0
37085 FE38                        CC            .byte	$CC
37086 FE39                        CC            .byte	$CC
37087 FE3A                        CC            .byte	$CC
37088 FE3B                        7C            .byte	$7C
37089 FE3C                        0C            .byte	$C
37090 FE3D                        F8            .byte	$F8
37091                                           ! 8540  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
37092 FE3E                        00            .byte	0
37093 FE3F                        00            .byte	0
37094 FE40                        FC            .byte	$FC
37095 FE41                        98            .byte	$98
37096 FE42                        30            .byte	$30
37097 FE43                        64            .byte	$64
37098 FE44                        FC            .byte	$FC
37099 FE45                        00            .byte	0
37100                                           ! 8541  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
37101 FE46                        1C            .byte	$1C
37102 FE47                        30            .byte	$30
37103 FE48                        30            .byte	$30
37104 FE49                        E0            .byte	$E0
37105 FE4A                        30            .byte	$30
37106 FE4B                        30            .byte	$30
37107 FE4C                        1C            .byte	$1C
37108 FE4D                        00            .byte	0
37109                                           ! 8542  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
37110 FE4E                        18            .byte	$18
37111 FE4F                        18            .byte	$18
37112 FE50                        18            .byte	$18
37113 FE51                        00            .byte	0
37114 FE52                        18            .byte	$18
37115 FE53                        18            .byte	$18
37116 FE54                        18            .byte	$18
37117 FE55                        00            .byte	0
37118                                           ! 8543  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
37119 FE56                        E0            .byte	$E0
37120 FE57                        30            .byte	$30
37121 FE58                        30            .byte	$30
37122 FE59                        1C            .byte	$1C
37123 FE5A                        30            .byte	$30
37124 FE5B                        30            .byte	$30
37125 FE5C                        E0            .byte	$E0
37126 FE5D                        00            .byte	0
37127                                           ! 8544  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37128 FE5E                        76            .byte	$76
37129 FE5F                        DC            .byte	$DC
37130 FE60                        00            .byte	0
37131 FE61                        00            .byte	0
37132 FE62                        00            .byte	0
37133 FE63                        00            .byte	0
37134 FE64                        00            .byte	0
37135 FE65                        00            .byte	0
37136                                           ! 8545  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
37137 FE66                        00            .byte	0
37138 FE67                        10            .byte	$10
37139 FE68                        38            .byte	$38
37140 FE69                        6C            .byte	$6C
37141 FE6A                        C6            .byte	$C6
37142 FE6B                        C6            .byte	$C6
37143 FE6C                        FE            .byte	$FE
37144 FE6D                        00            .byte	0
37145                                           ! 8546 };
37146                                           !BCC_EOS
37147                                           ! 8547 #asm
37148                                           !BCC_ASM
37149 CC00                                      .org 0xcc00
37150                       0000CC00            bios_table_area_end:
37151 CC00                        28            .ascii "(c) 2001-2021  The Bochs Project"
37152                                           ! 8551 endasm
37153                                           !BCC_ENDASM
37154                                           ! 8552 
37155                       0000CC20            .7C8:
37156                       0000CC20            .7D7:
37157 CC20                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
37158 CC48                        20            .ascii	" found at index %d"
37159 CC5A                        0A            .byte	$A
37160 CC5B                        00            .byte	0
37161                       0000CC5C            .7C6:
37162                       0000CC5C            .7D8:
37163 CC5C                        50            .ascii	"PCI device %04x:%04x not found at index "
37164 CC84                        25            .ascii	"%d"
37165 CC86                        0A            .byte	$A
37166 CC87                        00            .byte	0
37167                       0000CC88            .7C0:
37168                       0000CC88            .7D9:
37169 CC88                        62            .ascii	"bad PCI vendor ID %04x"
37170 CC9E                        0A            .byte	$A
37171 CC9F                        00            .byte	0
37172                       0000CCA0            .7BC:
37173                       0000CCA0            .7DA:
37174 CCA0                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
37175 CCC4                        0A            .byte	$A
37176 CCC5                        00            .byte	0
37177                       0000CCC6            .7B8:
37178                       0000CCC6            .7DB:
37179 CCC6                        50            .ascii	"PCI BIOS: PCI not present"
37180 CCDF                        0A            .byte	$A
37181 CCE0                        00            .byte	0
37182                       0000CCE1            .79D:
37183                       0000CCE1            .7DC:
37184 CCE1                        42            .ascii	"Booting from %x:%x"
37185 CCF3                        0A            .byte	$A
37186 CCF4                        00            .byte	0
37187                       0000CCF5            .788:
37188                       0000CCF5            .7DD:
37189 CCF5                        49            .ascii	"Invalid boot device (0x%x)"
37190 CD0F                        0A            .byte	$A
37191 CD10                        00            .byte	0
37192                       0000CD11            .785:
37193                       0000CD11            .7DE:
37194 CD11                        4E            .ascii	"No bootable device."
37195 CD24                        0A            .byte	$A
37196 CD25                        00            .byte	0
37197                       0000CD26            .76F:
37198                       0000CD26            .7DF:
37199 CD26                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
37200 CD4B                        0A            .byte	$A
37201 CD4C                        00            .byte	0
37202                       0000CD4D            .76A:
37203                       0000CD4D            .7E0:
37204 CD4D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
37205 CD70                        0A            .byte	$A
37206 CD71                        00            .byte	0
37207                       0000CD72            .706:
37208                       0000CD72            .7E1:
37209 CD72                        66            .ascii	"floppy: int13: bad floppy type"
37210 CD90                        0A            .byte	$A
37211 CD91                        00            .byte	0
37212                       0000CD92            .6EE:
37213                       0000CD92            .7E2:
37214 CD92                        69            .ascii	"int13_diskette_function: write error"
37215 CDB6                        0A            .byte	$A
37216 CDB7                        00            .byte	0
37217                       0000CDB8            .6E8:
37218                       0000CDB8            .7E3:
37219 CDB8                        69            .ascii	"int13_diskette: ctrl not ready"
37220 CDD6                        0A            .byte	$A
37221 CDD7                        00            .byte	0
37222                       0000CDD8            .6CE:
37223                       0000CDD8            .7E4:
37224 CDD8                        69            .ascii	"int13_diskette_function: write error"
37225 CDFC                        0A            .byte	$A
37226 CDFD                        00            .byte	0
37227                       0000CDFE            .6C5:
37228                       0000CDFE            .7E5:
37229 CDFE                        69            .ascii	"int13_diskette: ctrl not ready"
37230 CE1C                        0A            .byte	$A
37231 CE1D                        00            .byte	0
37232                       0000CE1E            .6AD:
37233                       0000CE1E            .7E6:
37234 CE1E                        69            .ascii	"int13_diskette: read/write/verify: param"
37235 CE46                        65            .ascii	"eter out of range"
37236 CE57                        0A            .byte	$A
37237 CE58                        00            .byte	0
37238                       0000CE59            .655:
37239                       0000CE59            .7E7:
37240 CE59                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
37241 CE81                        2C            .ascii	", returns fail"
37242 CE8F                        0A            .byte	$A
37243 CE90                        00            .byte	0
37244                       0000CE91            .63D:
37245                       0000CE91            .7E8:
37246 CE91                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
37247 CEB9                        0A            .byte	$A
37248 CEBA                        00            .byte	0
37249                       0000CEBB            .61F:
37250                       0000CEBB            .7E9:
37251 CEBB                        69            .ascii	"int13_cdemu: function %02x, emulation no"
37252 CEE3                        74            .ascii	"t active for DL= %02x"
37253 CEF8                        0A            .byte	$A
37254 CEF9                        00            .byte	0
37255                       0000CEFA            .61B:
37256                       0000CEFA            .7EA:
37257 CEFA                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
37258 CF1D                        0A            .byte	$A
37259 CF1E                        00            .byte	0
37260                       0000CF1F            .616:
37261                       0000CF1F            .7EB:
37262 CF1F                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
37263 CF47                        20            .ascii	" report"
37264 CF4E                        0A            .byte	$A
37265 CF4F                        00            .byte	0
37266                       0000CF50            .60B:
37267                       0000CF50            .7EC:
37268 CF50                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
37269 CF70                        0A            .byte	$A
37270 CF71                        00            .byte	0
37271                       0000CF72            .5DD:
37272                       0000CF72            .7ED:
37273 CF72                        69            .ascii	"int13_cdrom: function %02x, status %02x "
37274 CF9A                        21            .ascii	"!"
37275 CF9B                        0A            .byte	$A
37276 CF9C                        00            .byte	0
37277                       0000CF9D            .5D7:
37278                       0000CF9D            .7EE:
37279 CF9D                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
37280 CFC5                        62            .ascii	"bits lba"
37281 CFCD                        0A            .byte	$A
37282 CFCE                        00            .byte	0
37283                       0000CFCF            .5BD:
37284                       0000CFCF            .7EF:
37285 CFCF                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
37286 CFF7                        69            .ascii	"ice for ELDL=%02x"
37287 D008                        0A            .byte	$A
37288 D009                        00            .byte	0
37289                       0000D00A            .5BA:
37290                       0000D00A            .7F0:
37291 D00A                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
37292 D032                        72            .ascii	"range %02x"
37293 D03C                        0A            .byte	$A
37294 D03D                        00            .byte	0
37295                       0000D03E            .5B2:
37296                       0000D03E            .7F1:
37297 D03E                        69            .ascii	"int13_harddisk: function %02xh unsupport"
37298 D066                        65            .ascii	"ed, returns fail"
37299 D076                        0A            .byte	$A
37300 D077                        00            .byte	0
37301                       0000D078            .5AC:
37302                       0000D078            .7F2:
37303 D078                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
37304 D0A0                        6E            .ascii	"nted, returns success"
37305 D0B5                        0A            .byte	$A
37306 D0B6                        00            .byte	0
37307                       0000D0B7            .597:
37308                       0000D0B7            .7F3:
37309 D0B7                        69            .ascii	"int13_harddisk: function %02x, error %02"
37310 D0DF                        78            .ascii	"x !"
37311 D0E2                        0A            .byte	$A
37312 D0E3                        00            .byte	0
37313                       0000D0E4            .58E:
37314                       0000D0E4            .7F4:
37315 D0E4                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
37316 D10C                        66            .ascii	"f range"
37317 D113                        0A            .byte	$A
37318 D114                        00            .byte	0
37319                       0000D115            .58A:
37320                       0000D115            .7F5:
37321 D115                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
37322 D13D                        66            .ascii	"f range"
37323 D144                        0A            .byte	$A
37324 D145                        00            .byte	0
37325                       0000D146            .57C:
37326                       0000D146            .7F6:
37327 D146                        66            .ascii	"format disk track called"
37328 D15E                        0A            .byte	$A
37329 D15F                        00            .byte	0
37330                       0000D160            .57A:
37331                       0000D160            .7F7:
37332 D160                        69            .ascii	"int13_harddisk: function %02x, error %02"
37333 D188                        78            .ascii	"x !"
37334 D18B                        0A            .byte	$A
37335 D18C                        00            .byte	0
37336                       0000D18D            .56F:
37337                       0000D18D            .7F8:
37338 D18D                        69            .ascii	"int13_harddisk: function %02x, parameter"
37339 D1B5                        73            .ascii	"s out of range %04x/%04x/%04x!"
37340 D1D3                        0A            .byte	$A
37341 D1D4                        00            .byte	0
37342                       0000D1D5            .56A:
37343                       0000D1D5            .7F9:
37344 D1D5                        69            .ascii	"int13_harddisk: function %02x, parameter"
37345 D1FD                        20            .ascii	" out of range!"
37346 D20B                        0A            .byte	$A
37347 D20C                        00            .byte	0
37348                       0000D20D            .55A:
37349                       0000D20D            .7FA:
37350 D20D                        69            .ascii	"int13_harddisk: function %02x, unmapped "
37351 D235                        64            .ascii	"device for ELDL=%02x"
37352 D249                        0A            .byte	$A
37353 D24A                        00            .byte	0
37354                       0000D24B            .557:
37355                       0000D24B            .7FB:
37356 D24B                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
37357 D273                        6F            .ascii	"of range %02x"
37358 D280                        0A            .byte	$A
37359 D281                        00            .byte	0
37360                       0000D282            .4F9:
37361                       0000D282            .7FC:
37362 D282                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
37363 D2AA                        6F            .ascii	"ode are zero?"
37364 D2B7                        0A            .byte	$A
37365 D2B8                        00            .byte	0
37366                       0000D2B9            .4DD:
37367                       0000D2B9            .7FD:
37368 D2B9                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
37369 D2E1                        72            .ascii	"read: 0x%02x!"
37370 D2EE                        0A            .byte	$A
37371 D2EF                        00            .byte	0
37372                       0000D2F0            .4A8:
37373                       0000D2F0            .7FE:
37374 D2F0                        4B            .ascii	"KBD: int09 handler: AL=0"
37375 D308                        0A            .byte	$A
37376 D309                        00            .byte	0
37377                       0000D30A            .4A5:
37378                       0000D30A            .7FF:
37379 D30A                        73            .ascii	"setkbdcomm"
37380 D314                        00            .byte	0
37381                       0000D315            .49E:
37382                       0000D315            .800:
37383 D315                        73            .ascii	"sendmouse"
37384 D31E                        00            .byte	0
37385                       0000D31F            .49B:
37386                       0000D31F            .801:
37387 D31F                        65            .ascii	"enabmouse"
37388 D328                        00            .byte	0
37389                       0000D329            .494:
37390                       0000D329            .802:
37391 D329                        65            .ascii	"enabmouse"
37392 D332                        00            .byte	0
37393                       0000D333            .491:
37394                       0000D333            .803:
37395 D333                        69            .ascii	"inhibmouse"
37396 D33D                        00            .byte	0
37397                       0000D33E            .48A:
37398                       0000D33E            .804:
37399 D33E                        69            .ascii	"inhibmouse"
37400 D348                        00            .byte	0
37401                       0000D349            .47D:
37402                       0000D349            .805:
37403 D349                        4B            .ascii	"KBD: unsupported int 16h function %02x"
37404 D36F                        0A            .byte	$A
37405 D370                        00            .byte	0
37406                       0000D371            .46C:
37407                       0000D371            .806:
37408 D371                        4B            .ascii	"KBD: int16h: out of keyboard input"
37409 D393                        0A            .byte	$A
37410 D394                        00            .byte	0
37411                       0000D395            .43E:
37412                       0000D395            .807:
37413 D395                        4B            .ascii	"KBD: int16h: out of keyboard input"
37414 D3B7                        0A            .byte	$A
37415 D3B8                        00            .byte	0
37416                       0000D3B9            .42B:
37417                       0000D3B9            .808:
37418 D3B9                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37419 D3E1                        74            .ascii	"t yet supported!"
37420 D3F1                        0A            .byte	$A
37421 D3F2                        00            .byte	0
37422                       0000D3F3            .400:
37423                       0000D3F3            .809:
37424 D3F3                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37425 D41B                        74            .ascii	"t yet supported!"
37426 D42B                        0A            .byte	$A
37427 D42C                        00            .byte	0
37428                       0000D42D            .3F4:
37429                       0000D42D            .80A:
37430 D42D                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
37431 D445                        0A            .byte	$A
37432 D446                        00            .byte	0
37433                       0000D447            .3DE:
37434                       0000D447            .80B:
37435 D447                        4D            .ascii	"Mouse status returned %02x (should be ac"
37436 D46F                        6B            .ascii	"k)"
37437 D471                        0A            .byte	$A
37438 D472                        00            .byte	0
37439                       0000D473            .3CE:
37440                       0000D473            .80C:
37441 D473                        4D            .ascii	"Mouse status returned %02x (should be ac"
37442 D49B                        6B            .ascii	"k)"
37443 D49D                        0A            .byte	$A
37444 D49E                        00            .byte	0
37445                       0000D49F            .3CB:
37446                       0000D49F            .80D:
37447 D49F                        4D            .ascii	"Mouse status returned %02x (should be ac"
37448 D4C7                        6B            .ascii	"k)"
37449 D4C9                        0A            .byte	$A
37450 D4CA                        00            .byte	0
37451                       0000D4CB            .3A9:
37452                       0000D4CB            .80E:
37453 D4CB                        4D            .ascii	"Mouse reset returned %02x (should be ack"
37454 D4F3                        29            .ascii	")"
37455 D4F4                        0A            .byte	$A
37456 D4F5                        00            .byte	0
37457                       0000D4F6            .381:
37458                       0000D4F6            .80F:
37459 D4F6                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
37460 D51E                        74            .ascii	"t yet supported!"
37461 D52E                        0A            .byte	$A
37462 D52F                        00            .byte	0
37463                       0000D530            .37F:
37464                       0000D530            .810:
37465 D530                        45            .ascii	"EISA BIOS not present"
37466 D545                        0A            .byte	$A
37467 D546                        00            .byte	0
37468                       0000D547            .37B:
37469                       0000D547            .811:
37470 D547                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
37471 D56F                        72            .ascii	"rted!"
37472 D574                        0A            .byte	$A
37473 D575                        00            .byte	0
37474                       0000D576            .365:
37475                       0000D576            .812:
37476 D576                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
37477 D59E                        20            .ascii	" control not supported"
37478 D5B4                        0A            .byte	$A
37479 D5B5                        00            .byte	0
37480                       0000D5B6            .2FF:
37481                       0000D5B6            .813:
37482 D5B6                        61            .ascii	"ata_is_ready returned %d"
37483 D5CE                        0A            .byte	$A
37484 D5CF                        00            .byte	0
37485                       0000D5D0            .2E9:
37486                       0000D5D0            .814:
37487 D5D0                        25            .ascii	"%dMB medium detected"
37488 D5E4                        0A            .byte	$A
37489 D5E5                        00            .byte	0
37490                       0000D5E6            .2E4:
37491                       0000D5E6            .815:
37492 D5E6                        55            .ascii	"Unsupported sector size %u"
37493 D600                        0A            .byte	$A
37494 D601                        00            .byte	0
37495                       0000D602            .2DF:
37496                       0000D602            .816:
37497 D602                        57            .ascii	"Waiting for device to detect medium... "
37498 D629                        00            .byte	0
37499                       0000D62A            .2D1:
37500                       0000D62A            .817:
37501 D62A                        6E            .ascii	"not implemented for non-ATAPI device"
37502 D64E                        0A            .byte	$A
37503 D64F                        00            .byte	0
37504                       0000D650            .297:
37505                       0000D650            .818:
37506 D650                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
37507 D678                        65            .ascii	"et"
37508 D67A                        0A            .byte	$A
37509 D67B                        00            .byte	0
37510                       0000D67C            .255:
37511                       0000D67C            .819:
37512 D67C                        0A            .byte	$A
37513 D67D                        00            .byte	0
37514                       0000D67E            .250:
37515                       0000D67E            .81A:
37516 D67E                        6D            .ascii	"master"
37517 D684                        00            .byte	0
37518                       0000D685            .24F:
37519                       0000D685            .81B:
37520 D685                        20            .ascii	" slave"
37521 D68B                        00            .byte	0
37522                       0000D68C            .24E:
37523                       0000D68C            .81C:
37524 D68C                        61            .ascii	"ata%d %s: Unknown device"
37525 D6A4                        0A            .byte	$A
37526 D6A5                        00            .byte	0
37527                       0000D6A6            .24C:
37528                       0000D6A6            .81D:
37529 D6A6                        20            .ascii	" ATAPI-%d Device"
37530 D6B6                        0A            .byte	$A
37531 D6B7                        00            .byte	0
37532                       0000D6B8            .24A:
37533                       0000D6B8            .81E:
37534 D6B8                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
37535 D6D0                        0A            .byte	$A
37536 D6D1                        00            .byte	0
37537                       0000D6D2            .246:
37538                       0000D6D2            .81F:
37539 D6D2                        25            .ascii	"%c"
37540 D6D4                        00            .byte	0
37541                       0000D6D5            .23F:
37542                       0000D6D5            .820:
37543 D6D5                        6D            .ascii	"master"
37544 D6DB                        00            .byte	0
37545                       0000D6DC            .23E:
37546                       0000D6DC            .821:
37547 D6DC                        20            .ascii	" slave"
37548 D6E2                        00            .byte	0
37549                       0000D6E3            .23D:
37550                       0000D6E3            .822:
37551 D6E3                        61            .ascii	"ata%d %s: "
37552 D6ED                        00            .byte	0
37553                       0000D6EE            .23B:
37554                       0000D6EE            .823:
37555 D6EE                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
37556 D70C                        0A            .byte	$A
37557 D70D                        00            .byte	0
37558                       0000D70E            .239:
37559                       0000D70E            .824:
37560 D70E                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
37561 D72C                        0A            .byte	$A
37562 D72D                        00            .byte	0
37563                       0000D72E            .235:
37564                       0000D72E            .825:
37565 D72E                        25            .ascii	"%c"
37566 D730                        00            .byte	0
37567                       0000D731            .22E:
37568                       0000D731            .826:
37569 D731                        6D            .ascii	"master"
37570 D737                        00            .byte	0
37571                       0000D738            .22D:
37572                       0000D738            .827:
37573 D738                        20            .ascii	" slave"
37574 D73E                        00            .byte	0
37575                       0000D73F            .22C:
37576                       0000D73F            .828:
37577 D73F                        61            .ascii	"ata%d %s: "
37578 D749                        00            .byte	0
37579                       0000D74A            .1FB:
37580                       0000D74A            .829:
37581 D74A                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
37582 D772                        65            .ascii	"e"
37583 D773                        0A            .byte	$A
37584 D774                        00            .byte	0
37585                       0000D775            .1F6:
37586                       0000D775            .82A:
37587 D775                        20            .ascii	" LCHS=%d/%d/%d"
37588 D783                        0A            .byte	$A
37589 D784                        00            .byte	0
37590                       0000D785            .1D6:
37591                       0000D785            .82B:
37592 D785                        72            .ascii	"r-echs"
37593 D78B                        00            .byte	0
37594                       0000D78C            .1D4:
37595                       0000D78C            .82C:
37596 D78C                        6C            .ascii	"large"
37597 D791                        00            .byte	0
37598                       0000D792            .1D2:
37599                       0000D792            .82D:
37600 D792                        6C            .ascii	"lba"
37601 D795                        00            .byte	0
37602                       0000D796            .1D0:
37603                       0000D796            .82E:
37604 D796                        6E            .ascii	"none"
37605 D79A                        00            .byte	0
37606                       0000D79B            .1C6:
37607                       0000D79B            .82F:
37608 D79B                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
37609 D7BF                        00            .byte	0
37610                       0000D7C0            .1BF:
37611                       0000D7C0            .830:
37612 D7C0                        61            .ascii	"ata-detect: Failed to detect ATA device"
37613 D7E7                        0A            .byte	$A
37614 D7E8                        00            .byte	0
37615                       0000D7E9            .19E:
37616                       0000D7E9            .831:
37617 D7E9                        49            .ascii	"IDE time out"
37618 D7F5                        0A            .byte	$A
37619 D7F6                        00            .byte	0
37620                       0000D7F7            .162:
37621                       0000D7F7            .832:
37622 D7F7                        53            .ascii	"S3 resume jump to %x:%x"
37623 D80E                        0A            .byte	$A
37624 D80F                        00            .byte	0
37625                       0000D810            .15E:
37626                       0000D810            .833:
37627 D810                        53            .ascii	"S3 resume called %x 0x%lx"
37628 D829                        0A            .byte	$A
37629 D82A                        00            .byte	0
37630                       0000D82B            .158:
37631                       0000D82B            .834:
37632 D82B                        25            .ascii	"%s"
37633 D82D                        0A            .byte	$A
37634 D82E                        00            .byte	0
37635                       0000D82F            .157:
37636                       0000D82F            .835:
37637 D82F                        49            .ascii	"INT18: BOOT FAILURE"
37638 D842                        0A            .byte	$A
37639 D843                        00            .byte	0
37640                       0000D844            .156:
37641                       0000D844            .836:
37642 D844                        4E            .ascii	"NMI Handler called"
37643 D856                        0A            .byte	$A
37644 D857                        00            .byte	0
37645                       0000D858            .155:
37646                       0000D858            .837:
37647 D858                        43            .ascii	"CDROM boot failure code : %04x"
37648 D876                        0A            .byte	$A
37649 D877                        00            .byte	0
37650                       0000D878            .154:
37651                       0000D878            .838:
37652 D878                        0A            .byte	$A,$A
37653 D87A                        00            .byte	0
37654                       0000D87B            .153:
37655                       0000D87B            .839:
37656 D87B                        3A            .ascii	": could not read the boot disk"
37657 D899                        00            .byte	0
37658                       0000D89A            .151:
37659                       0000D89A            .83A:
37660 D89A                        3A            .ascii	": not a bootable disk"
37661 D8AF                        00            .byte	0
37662                       0000D8B0            .14C:
37663                       0000D8B0            .83B:
37664 D8B0                        42            .ascii	"Boot failed"
37665 D8BB                        00            .byte	0
37666                       0000D8BC            .14B:
37667                       0000D8BC            .83C:
37668 D8BC                        42            .ascii	"Bad drive type"
37669 D8CA                        0A            .byte	$A
37670 D8CB                        00            .byte	0
37671                       0000D8CC            .147:
37672                       0000D8CC            .83D:
37673 D8CC                        2E            .ascii	"..."
37674 D8CF                        0A            .byte	$A
37675 D8D0                        00            .byte	0
37676                       0000D8D1            .146:
37677                       0000D8D1            .83E:
37678 D8D1                        20            .ascii	" [%S]"
37679 D8D6                        00            .byte	0
37680                       0000D8D7            .142:
37681                       0000D8D7            .83F:
37682 D8D7                        42            .ascii	"Booting from %s"
37683 D8E6                        00            .byte	0
37684                       0000D8E7            .141:
37685                       0000D8E7            .840:
37686 D8E7                        42            .ascii	"Bad drive type"
37687 D8F5                        0A            .byte	$A
37688 D8F6                        00            .byte	0
37689                       0000D8F7            .13B:
37690                       0000D8F7            .841:
37691 D8F7                        0A            .byte	$A
37692 D8F8                        00            .byte	0
37693                       0000D8F9            .12F:
37694                       0000D8F9            .842:
37695 D8F9                        0A            .byte	$A
37696 D8FA                        00            .byte	0
37697                       0000D8FB            .12E:
37698                       0000D8FB            .843:
37699 D8FB                        20            .ascii	" [%S]"
37700 D900                        00            .byte	0
37701                       0000D901            .12B:
37702                       0000D901            .844:
37703 D901                        25            .ascii	"%s"
37704 D903                        00            .byte	0
37705                       0000D904            .129:
37706                       0000D904            .845:
37707 D904                        25            .ascii	"%s"
37708 D906                        0A            .byte	$A
37709 D907                        00            .byte	0
37710                       0000D908            .122:
37711                       0000D908            .846:
37712 D908                        25            .ascii	"%d. "
37713 D90C                        00            .byte	0
37714                       0000D90D            .11D:
37715                       0000D90D            .847:
37716 D90D                        53            .ascii	"Select boot device:"
37717 D920                        0A            .byte	$A,$A
37718 D922                        00            .byte	0
37719                       0000D923            .114:
37720                       0000D923            .848:
37721 D923                        50            .ascii	"Press F12 for boot menu."
37722 D93B                        0A            .byte	$A,$A
37723 D93D                        00            .byte	0
37724                       0000D93E            .106:
37725                       0000D93E            .849:
37726 D93E                        61            .ascii	"apmbios pcibios pnpbios eltorito rombios"
37727 D966                        33            .ascii	"32 "
37728 D969                        0A            .byte	$A,$A
37729 D96B                        00            .byte	0
37730                       0000D96C            .105:
37731                       0000D96C            .84A:
37732 D96C                        30            .ascii	"08/01/21"
37733 D974                        00            .byte	0
37734                       0000D975            .104:
37735                       0000D975            .84B:
37736 D975                        42            .ascii	"Bochs 2.7 BIOS - build: %s"
37737 D98F                        0A            .byte	$A
37738 D990                        25            .ascii	"%s"
37739 D992                        0A            .byte	$A
37740 D993                        4F            .ascii	"Options: "
37741 D99C                        00            .byte	0
37742                       0000D99D            .103:
37743                       0000D99D            .84C:
37744 D99D                        52            .ascii	"Returned from s3_resume."
37745 D9B5                        0A            .byte	$A
37746 D9B6                        00            .byte	0
37747                       0000D9B7            .102:
37748                       0000D9B7            .84D:
37749 D9B7                        55            .ascii	"Unimplemented shutdown status: %02x"
37750 D9DA                        0A            .byte	$A
37751 D9DB                        00            .byte	0
37752                       0000D9DC            .101:
37753                       0000D9DC            .84E:
37754 D9DC                        4B            .ascii	"Keyboard error:%u"
37755 D9ED                        0A            .byte	$A
37756 D9EE                        00            .byte	0
37757                       0000D9EF            .7C:
37758                       0000D9EF            .84F:
37759 D9EF                        62            .ascii	"bios_printf: unknown format"
37760 DA0A                        0A            .byte	$A
37761 DA0B                        00            .byte	0
37762                       0000DA0C            .38:
37763                       0000DA0C            .850:
37764 DA0C                        46            .ascii	"FATAL: "
37765 DA13                        00            .byte	0
37766 DA14                                      .bss
37767                                           
37768                                           ! 0 errors detected

Symbols:
..FFD8                      0 FFFC A   ..FFD9                      0 FFE0 A   
..FFDA                      0 FFDC A   ..FFDB                      0 FFDC A   
..FFDC                      0 FFF6 A   ..FFDD                      0 FFC6 A   
..FFDE                      0 FFC6 A   ..FFDF                      0 FFC6 A   
..FFE0                      0 FFC6 A   ..FFE1                      0 FFC6 A   
..FFE2                      0 FFC6 A   ..FFE3                      0 FFFC A   
..FFE4                      0 FFFC A   ..FFE5                      0 FFFC A   
..FFE6                      0 FFE0 A   ..FFE7                      0 FFE0 A   
..FFE8                      0 FFE0 A   ..FFE9                      0 FFE0 A   
..FFEA                      0 FFE0 A   ..FFEB                      0 FFE0 A   
..FFEC                      0 FFDA A   ..FFED                      0 FFDA A   
..FFEE                      0 FFDA A   ..FFEF                      0 FFDA A   
..FFF0                      0 FFDA A   ..FFF1                      0 FFDA A   
..FFF2                      0 FFF8 A   ..FFF3                      0 FFF4 A   
..FFF4                      0 FFF0 A   ..FFF5                      0 FFF0 A   
..FFF6                      0 FFF0 A   ..FFF7                      0 FFEA A   
..FFF8                      0 FFF6 A   ..FFF9                      0 F7E0 A   
..FFFA                      0 FFD4 A   ..FFFB                      0 FDB6 A   
..FFFC                      0 FDB6 A   ..FFFD                      0 FDD8 A   
..FFFE                      0 FDD8 A   ..FFFF                      0 FFC4 A   
.1                          0 0165 A   .10                         0 070D A   
.100                        0 1187 A   .101                        0 D9DC A   
.102                        0 D9B7 A   .103                        0 D99D A   
.104                        0 D975 A   .105                        0 D96C A   
.106                        0 D93E A   .107                        0 1208 A   
.108                        0 1212 A   .109                        0 121C A   
.10A                        0 1226 A   .10B                        0 1230 A   
.10C                        0 1394 A   .10D                        0 138E A   
.10E                        0 13D5 A   .10F                        0 13CE A   
.11                         0 06F7 A   .110                        0 13CB A   
.111                        0 13D5 A   .112                        0 13E8 A   
.113                        0 13E4 A   .114                        0 D923 A   
.115                        0 15AE A   .116                        0 140D A   
.117                        0 15AE A   .118                        0 141C A   
.119                        0 1428 A   .11A                        0 1421 A   
.11B                        0 141E A   .11C                        0 1428 A   
.11D                        0 D90D A   .11E                        0 1547 A   
.11F                        0 1534 A   .12                         0 073B A   
.120                        0 153B A   .121                        0 144F A   
.122                        0 D908 A   .123                        0 1534 A   
.125                        0 1518 A   .126                        0 1489 A   
.127                        0 1489 A   .128                        0 1489 A   
.129                        0 D904 A   .12A                        0 14AC A   
.12B                        0 D901 A   .12C                        0 1506 A   
.12D                        0 14D5 A   .12E                        0 D8FB A   
.12F                        0 D8F9 A   .13                         0 0727 A   
.130                        0 1547 A   .131                        0 15A0 A   
.132                        0 1599 A   .133                        0 1550 A   
.134                        0 156C A   .135                        0 1564 A   
.136                        0 155D A   .137                        0 1599 A   
.138                        0 1599 A   .139                        0 1576 A   
.13A                        0 15A0 A   .13B                        0 D8F7 A   
.13C                        0 15D4 A   .13D                        0 15CE A   
.13E                        0 15F1 A   .13F                        0 15E3 A   
.14                         0 071C A   .140                        0 15DB A   
.141                        0 D8E7 A   .142                        0 D8D7 A   
.143                        0 166A A   .144                        0 1633 A   
.145                        0 1619 A   .146                        0 D8D1 A   
.147                        0 D8CC A   .148                        0 169B A   
.149                        0 168E A   .14A                        0 1686 A   
.14B                        0 D8BC A   .14C                        0 D8B0 A   
.14D                        0 16D3 A   .14E                        0 16B0 A   
.14F                        0 16C6 A   .15                         0 070F A   
.150                        0 16B7 A   .151                        0 D89A A   
.152                        0 16D3 A   .153                        0 D87B A   
.154                        0 D878 A   .155                        0 D858 A   
.156                        0 D844 A   .157                        0 D82F A   
.158                        0 D82B A   .159                        0 175D A   
.15A                        0 1749 A   .15B                        0 176F A   
.15C                        0 177C A   .15D                        0 177E A   
.15E                        0 D810 A   .15F                        0 17F2 A   
.16                         0 0727 A   .160                        0 17EC A   
.161                        0 17E1 A   .162                        0 D7F7 A   
.163                        0 18B3 A   .164                        0 18A5 A   
.165                        0 18AC A   .166                        0 1861 A   
.167                        0 18B3 A   .168                        0 19E5 A   
.169                        0 19D5 A   .16A                        0 19DC A   
.16B                        0 18BB A   .16C                        0 19E5 A   
.16D                        0 1A14 A   .16E                        0 1A06 A   
.16F                        0 1A0D A   .17                         0 073B A   
.170                        0 19EC A   .171                        0 1A14 A   
.172                        0 1B75 A   .173                        0 1B72 A   
.174                        0 1A55 A   .175                        0 1A84 A   
.176                        0 1A79 A   .177                        0 1B18 A   
.178                        0 1AA0 A   .179                        0 1A8B A   
.17A                        0 1A98 A   .17B                        0 1A94 A   
.17C                        0 1A9A A   .17D                        0 1B18 A   
.17E                        0 1AC4 A   .17F                        0 1AA7 A   
.18                         0 072E A   .180                        0 1ABD A   
.181                        0 1AB9 A   .182                        0 1AB0 A   
.183                        0 1ABF A   .184                        0 1B18 A   
.185                        0 1AE8 A   .186                        0 1ACB A   
.187                        0 1AE1 A   .188                        0 1ADD A   
.189                        0 1AD4 A   .18A                        0 1AE3 A   
.18B                        0 1B18 A   .18C                        0 1B0C A   
.18D                        0 1AEF A   .18E                        0 1B05 A   
.18F                        0 1B01 A   .19                         0 07A8 A   
.190                        0 1AF8 A   .191                        0 1B07 A   
.192                        0 1B18 A   .193                        0 1B18 A   
.194                        0 1B13 A   .195                        0 1B25 A   
.196                        0 1B1F A   .197                        0 1B33 A   
.198                        0 1B2D A   .199                        0 1B43 A   
.19A                        0 1B3C A   .19B                        0 1B72 A   
.19C                        0 1B70 A   .19D                        0 1B4A A   
.19E                        0 D7E9 A   .19F                        0 281E A   
.1A                         0 078F A   .1A0                        0 280E A   
.1A1                        0 2815 A   .1A2                        0 1C06 A   
.1A3                        0 1C65 A   .1A4                        0 1C61 A   
.1A5                        0 1C67 A   .1A6                        0 1E2C A   
.1A7                        0 1D16 A   .1A8                        0 1D0C A   
.1A9                        0 1D3F A   .1AA                        0 1D3B A   
.1AB                        0 1D41 A   .1AC                        0 1E2C A   
.1AD                        0 1D87 A   .1AE                        0 1D7D A   
.1AF                        0 1DDE A   .1B                         0 07D6 A   
.1B0                        0 1DCA A   .1B1                        0 1DC2 A   
.1B2                        0 1E2C A   .1B3                        0 1E0A A   
.1B4                        0 1DF6 A   .1B5                        0 1DEE A   
.1B6                        0 1DE6 A   .1B7                        0 1E2C A   
.1B8                        0 1E2C A   .1B9                        0 1E1A A   
.1BA                        0 1E12 A   .1BB                        0 2314 A   
.1BC                        0 1E48 A   .1BD                        0 1EB6 A   
.1BE                        0 1EA8 A   .1BF                        0 D7C0 A   
.1C                         0 07C2 A   .1C0                        0 1EDE A   
.1C1                        0 1EDA A   .1C2                        0 1EE0 A   
.1C3                        0 1F57 A   .1C4                        0 1F2D A   
.1C5                        0 1F77 A   .1C6                        0 D79B A   
.1C7                        0 20A2 A   .1C8                        0 2091 A   
.1C9                        0 209A A   .1CA                        0 2083 A   
.1CB                        0 20A2 A   .1CC                        0 2118 A   
.1CE                        0 2108 A   .1CF                        0 20C6 A   
.1D                         0 07B7 A   .1D0                        0 D796 A   
.1D1                        0 20D6 A   .1D2                        0 D792 A   
.1D3                        0 20E6 A   .1D4                        0 D78C A   
.1D5                        0 20F6 A   .1D6                        0 D785 A   
.1D7                        0 2296 A   .1D9                        0 2280 A   
.1DA                        0 211F A   .1DB                        0 2122 A   
.1DC                        0 2179 A   .1DD                        0 2170 A   
.1DE                        0 21B6 A   .1DF                        0 218B A   
.1E                         0 07AA A   .1E0                        0 2182 A   
.1E1                        0 21B6 A   .1E2                        0 219D A   
.1E3                        0 2194 A   .1E4                        0 21B6 A   
.1E5                        0 21AF A   .1E6                        0 21A6 A   
.1E7                        0 21B6 A   .1E8                        0 21D7 A   
.1E9                        0 2252 A   .1EA                        0 21E0 A   
.1EB                        0 220B A   .1EC                        0 2204 A   
.1ED                        0 2252 A   .1EE                        0 227C A   
.1EF                        0 2273 A   .1F                         0 07C2 A   
.1F0                        0 2254 A   .1F1                        0 2273 A   
.1F2                        0 2271 A   .1F3                        0 227C A   
.1F4                        0 22A6 A   .1F5                        0 229F A   
.1F6                        0 D775 A   .1F7                        0 243C A   
.1F8                        0 231D A   .1F9                        0 238B A   
.1FA                        0 237D A   .1FB                        0 D74A A   
.1FC                        0 23AF A   .1FD                        0 23AB A   
.1FE                        0 23B1 A   .1FF                        0 23C7 A   
.2                          0 05D8 A   .20                         0 07D6 A   
.200                        0 23C3 A   .201                        0 23C9 A   
.202                        0 2664 A   .204                        0 2658 A   
.205                        0 2445 A   .206                        0 2481 A   
.208                        0 2475 A   .209                        0 244B A   
.20A                        0 2459 A   .20B                        0 2467 A   
.20C                        0 24E1 A   .20D                        0 2538 A   
.20E                        0 2527 A   .20F                        0 2530 A   
.21                         0 07C9 A   .210                        0 250E A   
.211                        0 2527 A   .212                        0 2525 A   
.213                        0 2538 A   .214                        0 25B1 A   
.215                        0 25A0 A   .216                        0 25A9 A   
.217                        0 2540 A   .218                        0 25B1 A   
.219                        0 260C A   .21A                        0 25FB A   
.21B                        0 2604 A   .21C                        0 25C7 A   
.21D                        0 25F9 A   .21E                        0 25DF A   
.21F                        0 25FB A   .22                         0 0849 A   
.220                        0 260C A   .221                        0 2654 A   
.222                        0 2614 A   .223                        0 2654 A   
.224                        0 2643 A   .225                        0 264C A   
.226                        0 262A A   .227                        0 2654 A   
.228                        0 2808 A   .22A                        0 27F8 A   
.22B                        0 266A A   .22C                        0 D73F A   
.22D                        0 D738 A   .22E                        0 D731 A   
.22F                        0 2677 A   .23                         0 0836 A   
.230                        0 2672 A   .231                        0 267A A   
.232                        0 26CF A   .233                        0 26AD A   
.234                        0 2698 A   .235                        0 D72E A   
.236                        0 26CF A   .237                        0 26F8 A   
.238                        0 26DD A   .239                        0 D70E A   
.23A                        0 2724 A   .23B                        0 D6EE A   
.23C                        0 2727 A   .23D                        0 D6E3 A   
.23E                        0 D6DC A   .23F                        0 D6D5 A   
.24                         0 0820 A   .240                        0 2734 A   
.241                        0 272F A   .242                        0 2737 A   
.243                        0 278C A   .244                        0 276A A   
.245                        0 2755 A   .246                        0 D6D2 A   
.247                        0 278C A   .248                        0 27B7 A   
.249                        0 27A0 A   .24A                        0 D6B8 A   
.24B                        0 27CC A   .24C                        0 D6A6 A   
.24D                        0 27CE A   .24E                        0 D68C A   
.24F                        0 D685 A   .25                         0 0849 A   
.250                        0 D67E A   .251                        0 27DB A   
.252                        0 27D6 A   .253                        0 27DE A   
.254                        0 281E A   .255                        0 D67C A   
.256                        0 2964 A   .257                        0 28E0 A   
.258                        0 28EB A   .259                        0 28E7 A   
.25A                        0 28ED A   .25B                        0 2953 A   
.25C                        0 2928 A   .25D                        0 2921 A   
.25E                        0 2942 A   .25F                        0 292F A   
.26                         0 08EB A   .260                        0 2953 A   
.261                        0 29E3 A   .262                        0 29DB A   
.263                        0 29D3 A   .264                        0 29F4 A   
.265                        0 2A07 A   .266                        0 29FB A   
.267                        0 2A0F A   .268                        0 2A43 A   
.269                        0 2A3C A   .26A                        0 2B52 A   
.26B                        0 2A5D A   .26C                        0 2B24 A   
.26D                        0 2A9E A   .26E                        0 2A7F A   
.26F                        0 2A74 A   .27                         0 08DF A   
.270                        0 2A68 A   .271                        0 2A6A A   
.273                        0 2BB0 A   .274                        0 2BAC A   
.275                        0 2BB2 A   .276                        0 2C07 A   
.277                        0 2BFE A   .278                        0 2C17 A   
.279                        0 2C17 A   .27A                        0 2C10 A   
.27B                        0 2D2E A   .27C                        0 2D2B A   
.27D                        0 2C18 A   .27E                        0 2C55 A   
.27F                        0 2C1F A   .28                         0 0871 A   
.280                        0 2C8B A   .281                        0 2CB9 A   
.282                        0 2CA8 A   .283                        0 2CFE A   
.284                        0 2CCF A   .285                        0 2CEA A   
.286                        0 2CD6 A   .287                        0 2CE6 A   
.288                        0 2CDF A   .289                        0 2CFC A   
.28A                        0 2CFA A   .28B                        0 2CF3 A   
.28C                        0 2D2B A   .28D                        0 2D19 A   
.28E                        0 2D05 A   .28F                        0 2D15 A   
.29                         0 08B3 A   .290                        0 2D0E A   
.291                        0 2D2B A   .292                        0 2D29 A   
.293                        0 2D22 A   .294                        0 2D2E A   
.295                        0 2D7F A   .296                        0 2D6A A   
.297                        0 D650 A   .298                        0 2D8F A   
.299                        0 2D88 A   .29A                        0 2DE5 A   
.29B                        0 2DE0 A   .29C                        0 2DF1 A   
.29D                        0 2DEC A   .29E                        0 2E32 A   
.29F                        0 2E2B A   .2A                         0 088D A   
.2A0                        0 2E9D A   .2A1                        0 2E99 A   
.2A2                        0 2E9F A   .2A3                        0 2EF2 A   
.2A4                        0 2EE9 A   .2A5                        0 2F02 A   
.2A6                        0 2F02 A   .2A7                        0 2EFB A   
.2A8                        0 2F59 A   .2A9                        0 2F36 A   
.2AA                        0 31C8 A   .2AB                        0 31C5 A   
.2AC                        0 31C2 A   .2AD                        0 2F62 A   
.2AE                        0 2F8B A   .2AF                        0 2F69 A   
.2B                         0 08D3 A   .2B0                        0 2F9C A   
.2B1                        0 2FDD A   .2B2                        0 2FDA A   
.2B3                        0 2FD1 A   .2B4                        0 2FED A   
.2B5                        0 2FE6 A   .2B6                        0 3040 A   
.2B7                        0 302A A   .2B8                        0 3054 A   
.2B9                        0 3081 A   .2BA                        0 3061 A   
.2BB                        0 30A2 A   .2BC                        0 30BC A   
.2BD                        0 30B7 A   .2BE                        0 30CA A   
.2BF                        0 30C5 A   .2C                         0 08D3 A   
.2C0                        0 30D8 A   .2C1                        0 30D3 A   
.2C2                        0 30FF A   .2C3                        0 30E1 A   
.2C4                        0 30FF A   .2C5                        0 30F8 A   
.2C6                        0 30EF A   .2C7                        0 3126 A   
.2C8                        0 3106 A   .2C9                        0 313E A   
.2CA                        0 31C5 A   .2CB                        0 31D8 A   
.2CC                        0 31D1 A   .2CD                        0 324A A   
.2CE                        0 3243 A   .2CF                        0 32B1 A   
.2D                         0 08C1 A   .2D0                        0 329C A   
.2D1                        0 D62A A   .2D2                        0 33A3 A   
.2D3                        0 3393 A   .2D4                        0 32E8 A   
.2D5                        0 331D A   .2D6                        0 3317 A   
.2D7                        0 3377 A   .2D8                        0 3336 A   
.2D9                        0 3344 A   .2DA                        0 333D A   
.2DB                        0 3377 A   .2DC                        0 3359 A   
.2DD                        0 3352 A   .2DE                        0 334B A   
.2DF                        0 D602 A   .2E                         0 08EB A   
.2E0                        0 33A3 A   .2E1                        0 340D A   
.2E2                        0 33F2 A   .2E3                        0 33DA A   
.2E4                        0 D5E6 A   .2E5                        0 346D A   
.2E6                        0 345B A   .2E7                        0 34B3 A   
.2E8                        0 348F A   .2E9                        0 D5D0 A   
.2EA                        0 34EF A   .2EB                        0 34E9 A   
.2EC                        0 3513 A   .2ED                        0 350D A   
.2EE                        0 3537 A   .2EF                        0 3531 A   
.2F                         0 0935 A   .2F0                        0 3595 A   
.2F1                        0 359B A   .2F2                        0 35ED A   
.2F3                        0 35DC A   .2F4                        0 35E5 A   
.2F5                        0 35CA A   .2F6                        0 35DC A   
.2F7                        0 35DA A   .2F8                        0 35ED A   
.2F9                        0 35FC A   .2FA                        0 35F5 A   
.2FB                        0 362E A   .2FC                        0 361C A   
.2FD                        0 3610 A   .2FE                        0 3612 A   
.2FF                        0 D5B6 A   .3                          0 05CD A   
.30                         0 0926 A   .300                        0 36A5 A   
.301                        0 369E A   .302                        0 36B4 A   
.303                        0 36AD A   .304                        0 3700 A   
.305                        0 36EE A   .306                        0 36F7 A   
.307                        0 36BC A   .308                        0 36EE A   
.309                        0 36E7 A   .30A                        0 3700 A   
.30B                        0 374E A   .30C                        0 373C A   
.30D                        0 3745 A   .30E                        0 3708 A   
.30F                        0 373C A   .31                         0 092D A   
.310                        0 3735 A   .311                        0 374E A   
.312                        0 37DD A   .313                        0 37D6 A   
.314                        0 37EC A   .315                        0 37E5 A   
.316                        0 37FB A   .317                        0 37F4 A   
.318                        0 380A A   .319                        0 3803 A   
.31A                        0 3819 A   .31B                        0 3812 A   
.31C                        0 3828 A   .31D                        0 3821 A   
.31E                        0 3849 A   .31F                        0 3842 A   
.32                         0 0915 A   .320                        0 385D A   
.321                        0 3858 A   .322                        0 3851 A   
.323                        0 385D A   .324                        0 388A A   
.325                        0 3883 A   .326                        0 3977 A   
.327                        0 3968 A   .328                        0 3A2E A   
.32A                        0 3A18 A   .32B                        0 397D A   
.32C                        0 3992 A   .32D                        0 39A7 A   
.32E                        0 39BB A   .32F                        0 3A68 A   
.33                         0 0926 A   .330                        0 3A35 A   
.331                        0 3A5F A   .332                        0 3A3C A   
.333                        0 3A68 A   .334                        0 3A74 A   
.335                        0 3A6F A   .336                        0 3CB3 A   
.337                        0 3AC6 A   .338                        0 3ABD A   
.339                        0 3CB1 A   .33B                        0 3C99 A   
.33C                        0 3ACC A   .33D                        0 3B11 A   
.33E                        0 3AF3 A   .33F                        0 3B48 A   
.34                         0 0924 A   .340                        0 3B86 A   
.341                        0 3BC2 A   .342                        0 3BA9 A   
.343                        0 3B8E A   .344                        0 3BA9 A   
.345                        0 3B9C A   .346                        0 3BC2 A   
.347                        0 3BBB A   .348                        0 3BE9 A   
.349                        0 3BC9 A   .34A                        0 3BEE A   
.34B                        0 3BF9 A   .34C                        0 3C35 A   
.34D                        0 3C1C A   .34E                        0 3C01 A   
.34F                        0 3C1C A   .35                         0 0935 A   
.350                        0 3C0F A   .351                        0 3C35 A   
.352                        0 3C2E A   .353                        0 3C58 A   
.354                        0 3C3C A   .355                        0 3C5D A   
.356                        0 3C67 A   .357                        0 3C8F A   
.358                        0 3CBB A   .359                        0 419F A   
.35B                        0 4155 A   .35C                        0 3CD3 A   
.35D                        0 3D5D A   .35F                        0 3D4B A   
.36                         0 0982 A   .360                        0 3CD8 A   
.361                        0 3CD8 A   .362                        0 3CF2 A   
.363                        0 3D13 A   .364                        0 3D28 A   
.365                        0 D576 A   .366                        0 3D60 A   
.367                        0 3D70 A   .368                        0 3D7B A   
.369                        0 3D8B A   .36A                        0 3E16 A   
.36B                        0 3D9B A   .36C                        0 3E07 A   
.36D                        0 3DA4 A   .36E                        0 3E14 A   
.36F                        0 3E5E A   .37                         0 0967 A   
.370                        0 3E4A A   .371                        0 3E1D A   
.372                        0 3E5E A   .373                        0 3E61 A   
.374                        0 3E9C A   .375                        0 3E95 A   
.376                        0 3FE9 A   .377                        0 400F A   
.378                        0 4009 A   .379                        0 401A A   
.37A                        0 40C8 A   .37B                        0 D547 A   
.37C                        0 40E6 A   .37D                        0 4102 A   
.37E                        0 4113 A   .37F                        0 D530 A   
.38                         0 DA0C A   .380                        0 4130 A   
.381                        0 D4F6 A   .382                        0 4829 A   
.384                        0 4821 A   .385                        0 41B7 A   
.386                        0 47FA A   .388                        0 47D5 A   
.389                        0 41BD A   .38A                        0 42BA A   
.38C                        0 42AC A   .38D                        0 41C3 A   
.38E                        0 4204 A   .38F                        0 41D9 A   
.39                         0 0C45 A   .390                        0 4204 A   
.391                        0 41F3 A   .392                        0 41EC A   
.393                        0 4219 A   .394                        0 4243 A   
.395                        0 4232 A   .396                        0 4287 A   
.397                        0 4259 A   .398                        0 4287 A   
.399                        0 4273 A   .39A                        0 426C A   
.39B                        0 4299 A   .39C                        0 42BD A   
.39D                        0 42BD A   .39E                        0 4334 A   
.39F                        0 42C4 A   .3A                         0 0C37 A   
.3A0                        0 42E3 A   .3A1                        0 42D2 A   
.3A2                        0 42CB A   .3A3                        0 43D3 A   
.3A4                        0 434C A   .3A5                        0 436B A   
.3A6                        0 435F A   .3A7                        0 4386 A   
.3A8                        0 4372 A   .3A9                        0 D4CB A   
.3AA                        0 43D3 A   .3AB                        0 438D A   
.3AC                        0 43D3 A   .3AD                        0 43A0 A   
.3AE                        0 43D3 A   .3AF                        0 43B3 A   
.3B                         0 0985 A   .3B0                        0 43E5 A   
.3B1                        0 4445 A   .3B3                        0 4422 A   
.3B4                        0 43EA A   .3B5                        0 43F1 A   
.3B6                        0 43F8 A   .3B7                        0 43FF A   
.3B8                        0 4406 A   .3B9                        0 440D A   
.3BA                        0 4414 A   .3BB                        0 441B A   
.3BC                        0 4443 A   .3BD                        0 4435 A   
.3BE                        0 44A5 A   .3BF                        0 444E A   
.3C                         0 099A A   .3C0                        0 4496 A   
.3C1                        0 4461 A   .3C2                        0 44A3 A   
.3C3                        0 44B2 A   .3C4                        0 44B5 A   
.3C5                        0 4553 A   .3C6                        0 44C4 A   
.3C7                        0 4544 A   .3C8                        0 44D9 A   
.3C9                        0 4500 A   .3CA                        0 44EC A   
.3CB                        0 D49F A   .3CC                        0 4535 A   
.3CD                        0 4521 A   .3CE                        0 D473 A   
.3CF                        0 4551 A   .3D                         0 098C A   
.3D0                        0 4560 A   .3D1                        0 456E A   
.3D2                        0 45B1 A   .3D3                        0 4584 A   
.3D4                        0 45BE A   .3D5                        0 45C1 A   
.3D6                        0 4739 A   .3D8                        0 4725 A   
.3D9                        0 45C7 A   .3DA                        0 467B A   
.3DB                        0 45E2 A   .3DC                        0 4609 A   
.3DD                        0 45F5 A   .3DE                        0 D447 A   
.3DF                        0 467B A   .3E                         0 0C30 A   
.3E0                        0 4612 A   .3E1                        0 467B A   
.3E2                        0 4627 A   .3E3                        0 467B A   
.3E4                        0 463A A   .3E5                        0 467B A   
.3E6                        0 464D A   .3E7                        0 4698 A   
.3E8                        0 4698 A   .3E9                        0 46B3 A   
.3EA                        0 46A5 A   .3EB                        0 46BF A   
.3EC                        0 46DF A   .3ED                        0 46C6 A   
.3EE                        0 46DA A   .3EF                        0 46DC A   
.3F                         0 0C21 A   .3F0                        0 46F5 A   
.3F1                        0 46E6 A   .3F2                        0 4702 A   
.3F3                        0 470F A   .3F4                        0 D42D A   
.3F5                        0 473C A   .3F6                        0 479C A   
.3F7                        0 4786 A   .3F8                        0 477F A   
.3F9                        0 479A A   .3FA                        0 478F A   
.3FB                        0 47A4 A   .3FC                        0 47C6 A   
.3FD                        0 47F8 A   .3FE                        0 47E8 A   
.3FF                        0 47FC A   .4                          0 05B8 A   
.40                         0 09A3 A   .400                        0 D3F3 A   
.401                        0 4D8C A   .403                        0 4D7E A   
.404                        0 48F7 A   .405                        0 493D A   
.406                        0 4D57 A   .408                        0 4D4B A   
.409                        0 4943 A   .40A                        0 4CE9 A   
.40B                        0 495E A   .40C                        0 49AC A   
.40D                        0 49A0 A   .40E                        0 4A41 A   
.40F                        0 49F1 A   .41                         0 09D2 A   
.410                        0 4CC8 A   .412                        0 4CA3 A   
.413                        0 4A70 A   .414                        0 4AA2 A   
.415                        0 4AD5 A   .416                        0 4B14 A   
.417                        0 4B07 A   .418                        0 4B1F A   
.419                        0 4B22 A   .41A                        0 4B65 A   
.41B                        0 4BD1 A   .41C                        0 4C13 A   
.41D                        0 4C5A A   .41E                        0 4C4D A   
.41F                        0 4C42 A   .42                         0 09B1 A   
.420                        0 4C64 A   .421                        0 4C66 A   
.422                        0 4C99 A   .423                        0 4CC6 A   
.424                        0 4CB6 A   .425                        0 4CEE A   
.426                        0 4CF0 A   .427                        0 4D1E A   
.428                        0 4D18 A   .429                        0 4D44 A   
.42A                        0 4D59 A   .42B                        0 D3B9 A   
.42C                        0 4E53 A   .42D                        0 4DBE A   
.42E                        0 4DEC A   .42F                        0 4DDD A   
.43                         0 09AA A   .430                        0 4DCF A   
.431                        0 4DEC A   .432                        0 4E52 A   
.433                        0 4DF9 A   .434                        0 4E43 A   
.435                        0 4E34 A   .436                        0 4E26 A   
.437                        0 4E43 A   .438                        0 513E A   
.43A                        0 50F7 A   .43B                        0 4E59 A   
.43C                        0 4E7D A   .43D                        0 4E6F A   
.43E                        0 D395 A   .43F                        0 4E92 A   
.44                         0 0C1F A   .440                        0 4E8B A   
.441                        0 4E84 A   .442                        0 4E9E A   
.443                        0 4E9E A   .444                        0 4E99 A   
.445                        0 4EB0 A   .446                        0 4ED1 A   
.447                        0 4EC5 A   .448                        0 4EE6 A   
.449                        0 4EDF A   .44A                        0 4ED8 A   
.44B                        0 4EF2 A   .44C                        0 4EF2 A   
.44D                        0 4EED A   .44E                        0 4F0C A   
.44F                        0 4F1B A   .45                         0 0A52 A   
.450                        0 4F38 A   .451                        0 4F31 A   
.452                        0 4F3D A   .453                        0 4F40 A   
.454                        0 4F48 A   .455                        0 4F8F A   
.456                        0 4F75 A   .457                        0 4F68 A   
.458                        0 4F8F A   .459                        0 4F84 A   
.45A                        0 5005 A   .45B                        0 4F98 A   
.45C                        0 5005 A   .45D                        0 4FA5 A   
.45E                        0 5005 A   .45F                        0 4FFA A   
.46                         0 09EE A   .460                        0 4FA5 A   
.461                        0 4FD4 A   .462                        0 4FBA A   
.463                        0 4FAD A   .464                        0 4FD4 A   
.465                        0 4FC9 A   .466                        0 4FFA A   
.467                        0 4FDB A   .468                        0 5005 A   
.469                        0 500E A   .46A                        0 5032 A   
.46B                        0 5024 A   .46C                        0 D371 A   
.46D                        0 5045 A   .46E                        0 5040 A   
.46F                        0 5039 A   .47                         0 09FB A   
.470                        0 5057 A   .471                        0 5078 A   
.472                        0 506C A   .473                        0 508B A   
.474                        0 5086 A   .475                        0 507F A   
.476                        0 50A5 A   .477                        0 50CC A   
.478                        0 50D3 A   .479                        0 50D5 A   
.47A                        0 50E1 A   .47B                        0 50DC A   
.47C                        0 50E1 A   .47D                        0 D349 A   
.47E                        0 5130 A   .47F                        0 510A A   
.48                         0 09F5 A   .480                        0 51C5 A   
.481                        0 5168 A   .482                        0 51BC A   
.483                        0 51A0 A   .484                        0 51B6 A   
.485                        0 51B0 A   .486                        0 51CB A   
.487                        0 51CF A   .488                        0 5215 A   
.489                        0 5203 A   .48A                        0 D33E A   
.48B                        0 5234 A   .48C                        0 5225 A   
.48D                        0 5225 A   .48E                        0 5234 A   
.48F                        0 5267 A   .49                         0 0A4F A   
.490                        0 5255 A   .491                        0 D333 A   
.492                        0 52C2 A   .493                        0 52B0 A   
.494                        0 D329 A   .495                        0 52E1 A   
.496                        0 52D2 A   .497                        0 52D2 A   
.498                        0 52E1 A   .499                        0 530E A   
.49A                        0 52FC A   .49B                        0 D31F A   
.49C                        0 5366 A   .49D                        0 5354 A   
.49E                        0 D315 A   .49F                        0 53A0 A   
.4A                         0 0A41 A   .4A0                        0 5391 A   
.4A1                        0 5391 A   .4A2                        0 53A0 A   
.4A3                        0 53E4 A   .4A4                        0 53D3 A   
.4A5                        0 D30A A   .4A6                        0 5434 A   
.4A7                        0 5422 A   .4A8                        0 D2F0 A   
.4A9                        0 595E A   .4AB                        0 5907 A   
.4AC                        0 5451 A   .4AD                        0 5470 A   
.4AE                        0 5481 A   .4AF                        0 5492 A   
.4B                         0 0A48 A   .4B0                        0 54A3 A   
.4B1                        0 54B4 A   .4B2                        0 54C5 A   
.4B3                        0 5503 A   .4B4                        0 54CE A   
.4B5                        0 54F5 A   .4B6                        0 54E5 A   
.4B7                        0 5503 A   .4B8                        0 5506 A   
.4B9                        0 5544 A   .4BA                        0 550F A   
.4BB                        0 5536 A   .4BC                        0 5526 A   
.4BD                        0 5544 A   .4BE                        0 5547 A   
.4BF                        0 556E A   .4C                         0 0A04 A   
.4C0                        0 555E A   .4C1                        0 557C A   
.4C2                        0 557F A   .4C3                        0 55A6 A   
.4C4                        0 5596 A   .4C5                        0 55B4 A   
.4C6                        0 55B7 A   .4C7                        0 55DC A   
.4C8                        0 55C0 A   .4C9                        0 55DF A   
.4CA                        0 55F6 A   .4CB                        0 55E8 A   
.4CC                        0 55F9 A   .4CD                        0 563D A   
.4CE                        0 5614 A   .4CF                        0 5602 A   
.4D                         0 0A2B A   .4D0                        0 560B A   
.4D1                        0 5659 A   .4D2                        0 565C A   
.4D3                        0 5679 A   .4D4                        0 5677 A   
.4D5                        0 5665 A   .4D6                        0 566E A   
.4D7                        0 5687 A   .4D8                        0 568A A   
.4D9                        0 5696 A   .4DA                        0 5693 A   
.4DB                        0 56B5 A   .4DC                        0 569D A   
.4DD                        0 D2B9 A   .4DE                        0 56D0 A   
.4DF                        0 56BC A   .4E                         0 0A23 A   
.4E0                        0 56D0 A   .4E1                        0 56C5 A   
.4E2                        0 571F A   .4E3                        0 56E2 A   
.4E4                        0 58CC A   .4E5                        0 5765 A   
.4E6                        0 5728 A   .4E7                        0 58CC A   
.4E8                        0 57A0 A   .4E9                        0 577C A   
.4EA                        0 576E A   .4EB                        0 5775 A   
.4EC                        0 58CC A   .4ED                        0 583D A   
.4EE                        0 57AB A   .4EF                        0 5800 A   
.4F                         0 0A37 A   .4F0                        0 57CA A   
.4F1                        0 583A A   .4F2                        0 58CC A   
.4F3                        0 5898 A   .4F4                        0 585C A   
.4F5                        0 58CC A   .4F6                        0 58F1 A   
.4F7                        0 58E3 A   .4F8                        0 58DC A   
.4F9                        0 D282 A   .4FA                        0 596F A   
.4FB                        0 5967 A   .4FC                        0 59C7 A   
.4FD                        0 59C1 A   .4FE                        0 59DD A   
.4FF                        0 59CF A   .5                          0 05CD A   
.50                         0 0A4F A   .500                        0 5A29 A   
.501                        0 5A25 A   .502                        0 5A4E A   
.503                        0 5A4A A   .504                        0 5ACF A   
.505                        0 5A75 A   .506                        0 5A9C A   
.507                        0 5A7C A   .508                        0 5AB4 A   
.509                        0 5ACD A   .50A                        0 5AC7 A   
.50B                        0 5AD6 A   .50C                        0 5B1D A   
.50D                        0 5B1F A   .50E                        0 5B33 A   
.50F                        0 5B2C A   .51                         0 0C1A A   
.510                        0 5D18 A   .511                        0 5B3D A   
.512                        0 5C48 A   .513                        0 5B6D A   
.514                        0 5C42 A   .515                        0 5C35 A   
.516                        0 5BE5 A   .517                        0 5C26 A   
.518                        0 5C28 A   .51A                        0 5C48 A   
.51B                        0 5C7F A   .51C                        0 5C4F A   
.51D                        0 5EDE A   .51E                        0 5D22 A   
.51F                        0 5DD4 A   .52                         0 0A6E A   
.520                        0 5DD0 A   .521                        0 5DD6 A   
.522                        0 5E38 A   .523                        0 5DE9 A   
.524                        0 5DF4 A   .525                        0 5DF0 A   
.526                        0 5DF6 A   .527                        0 5E0D A   
.528                        0 5E09 A   .529                        0 5E0F A   
.52A                        0 5E28 A   .52B                        0 5E24 A   
.52C                        0 5E2A A   .52D                        0 5E4F A   
.52E                        0 5E3F A   .52F                        0 5ECA A   
.53                         0 0A59 A   .530                        0 5EBC A   
.531                        0 5EC3 A   .532                        0 5EA6 A   
.533                        0 5ECA A   .534                        0 6150 A   
.535                        0 5EE8 A   .536                        0 5F37 A   
.537                        0 5F33 A   .538                        0 5F39 A   
.539                        0 5F8C A   .53A                        0 5F62 A   
.53B                        0 5F8C A   .53C                        0 5FE6 A   
.53D                        0 5F93 A   .53E                        0 603F A   
.53F                        0 603F A   .54                         0 0C1A A   
.540                        0 5FEF A   .541                        0 606C A   
.542                        0 6046 A   .543                        0 606C A   
.544                        0 60C9 A   .545                        0 60AB A   
.546                        0 60DC A   .547                        0 60D0 A   
.548                        0 60E6 A   .549                        0 6123 A   
.54A                        0 610A A   .54B                        0 6111 A   
.54C                        0 60F2 A   .54D                        0 6123 A   
.54E                        0 611C A   .54F                        0 6118 A   
.55                         0 0B79 A   .550                        0 611E A   
.551                        0 6142 A   .552                        0 6135 A   
.553                        0 614D A   .554                        0 619B A   
.555                        0 617B A   .556                        0 6174 A   
.557                        0 D24B A   .558                        0 61D3 A   
.559                        0 61B3 A   .55A                        0 D20D A   
.55B                        0 68C2 A   .55D                        0 6847 A   
.55E                        0 61D9 A   .55F                        0 61ED A   
.56                         0 0A77 A   .560                        0 6224 A   
.561                        0 621C A   .562                        0 622A A   
.563                        0 622D A   .564                        0 622D A   
.565                        0 622D A   .566                        0 629D A   
.567                        0 6283 A   .568                        0 627C A   
.569                        0 6275 A   .56A                        0 D1D5 A   
.56B                        0 6311 A   .56C                        0 62EE A   
.56D                        0 62E6 A   .56E                        0 62DE A   
.56F                        0 D18D A   .57                         0 0AE8 A   
.570                        0 631E A   .571                        0 6318 A   
.572                        0 63C6 A   .573                        0 6354 A   
.574                        0 634C A   .575                        0 6403 A   
.576                        0 63CD A   .577                        0 6438 A   
.578                        0 646A A   .579                        0 6445 A   
.57A                        0 D160 A   .57B                        0 6473 A   
.57C                        0 D146 A   .57D                        0 648E A   
.57E                        0 650E A   .57F                        0 653C A   
.58                         0 0AA6 A   .580                        0 6534 A   
.581                        0 6547 A   .582                        0 654A A   
.583                        0 65C9 A   .584                        0 65E3 A   
.585                        0 65E3 A   .586                        0 65E3 A   
.587                        0 65E3 A   .588                        0 6669 A   
.589                        0 664F A   .58A                        0 D115 A   
.58B                        0 66D3 A   .58C                        0 66B9 A   
.58D                        0 669D A   .58E                        0 D0E4 A   
.58F                        0 66E7 A   .59                         0 0AD0 A   
.590                        0 66E1 A   .591                        0 66DA A   
.592                        0 6724 A   .593                        0 66EE A   
.594                        0 6759 A   .595                        0 679D A   
.596                        0 6778 A   .597                        0 D0B7 A   
.598                        0 67A6 A   .599                        0 67A6 A   
.59A                        0 67AF A   .59B                        0 67BD A   
.59C                        0 67D9 A   .59D                        0 67D3 A   
.59E                        0 67E2 A   .59F                        0 6809 A   
.5A                         0 0AB0 A   .5A1                        0 67F7 A   
.5A2                        0 67E7 A   .5A3                        0 67E7 A   
.5A4                        0 67E7 A   .5A5                        0 67E7 A   
.5A6                        0 67EF A   .5A7                        0 680C A   
.5A8                        0 680C A   .5A9                        0 680C A   
.5AA                        0 680C A   .5AB                        0 680C A   
.5AC                        0 D078 A   .5AD                        0 6829 A   
.5AE                        0 6829 A   .5AF                        0 6829 A   
.5B                         0 0AE5 A   .5B0                        0 6829 A   
.5B1                        0 6829 A   .5B2                        0 D03E A   
.5B3                        0 688C A   .5B4                        0 685A A   
.5B5                        0 68BF A   .5B6                        0 689F A   
.5B7                        0 694E A   .5B8                        0 692E A   
.5B9                        0 6927 A   .5BA                        0 D00A A   
.5BB                        0 6986 A   .5BC                        0 6966 A   
.5BD                        0 CFCF A   .5BE                        0 6DB7 A   
.5C                         0 0B76 A   .5C0                        0 6D3C A   
.5C1                        0 698C A   .5C2                        0 698C A   
.5C3                        0 698C A   .5C4                        0 698C A   
.5C5                        0 698C A   .5C6                        0 698C A   
.5C7                        0 698C A   .5C8                        0 698C A   
.5C9                        0 6995 A   .5CA                        0 6995 A   
.5CB                        0 6995 A   .5CC                        0 69A3 A   
.5CD                        0 69DA A   .5CE                        0 69D2 A   
.5CF                        0 69E0 A   .5D                         0 0B06 A   
.5D0                        0 69E3 A   .5D1                        0 69F1 A   
.5D2                        0 6A0B A   .5D3                        0 6A0B A   
.5D4                        0 6A0B A   .5D5                        0 6A8C A   
.5D6                        0 6A72 A   .5D7                        0 CF9D A   
.5D8                        0 6AB8 A   .5D9                        0 6AB2 A   
.5DA                        0 6AAB A   .5DB                        0 6B93 A   
.5DC                        0 6B6E A   .5DD                        0 CF72 A   
.5DE                        0 6B9C A   .5DF                        0 6BA9 A   
.5E                         0 0AEF A   .5E0                        0 6BA3 A   
.5E1                        0 6C65 A   .5E3                        0 6C57 A   
.5E4                        0 6BC2 A   .5E5                        0 6BD9 A   
.5E6                        0 6BC9 A   .5E7                        0 6BFD A   
.5E8                        0 6C14 A   .5E9                        0 6C04 A   
.5EA                        0 6C3C A   .5EB                        0 6C38 A   
.5EC                        0 6C3E A   .5ED                        0 6C43 A   
.5EE                        0 6C4E A   .5EF                        0 6C4A A   
.5F                         0 0B76 A   .5F0                        0 6C50 A   
.5F1                        0 6C6E A   .5F2                        0 6C93 A   
.5F3                        0 6C88 A   .5F4                        0 6CB8 A   
.5F5                        0 6CAD A   .5F6                        0 6CC1 A   
.5F7                        0 6CDD A   .5F8                        0 6CD7 A   
.5F9                        0 6CE6 A   .5FA                        0 6CF4 A   
.5FB                        0 6D1B A   .5FD                        0 6D09 A   
.5FE                        0 6CF9 A   .5FF                        0 6CF9 A   
.6                          0 05C7 A   .60                         0 0B76 A   
.600                        0 6CF9 A   .601                        0 6CF9 A   
.602                        0 6D01 A   .603                        0 6D1E A   
.604                        0 6D1E A   .605                        0 6D1E A   
.606                        0 6D1E A   .607                        0 6D1E A   
.608                        0 6D1E A   .609                        0 6D1E A   
.60A                        0 6D1E A   .60B                        0 CF50 A   
.60C                        0 6D81 A   .60D                        0 6D4F A   
.60E                        0 6DB4 A   .60F                        0 6D94 A   
.61                         0 0B0F A   .610                        0 6FBA A   
.612                        0 6FA0 A   .613                        0 6E0F A   
.614                        0 6E0F A   .615                        0 6E0F A   
.616                        0 CF1F A   .617                        0 6E29 A   
.618                        0 6F7C A   .619                        0 6F6C A   
.61A                        0 6F83 A   .61B                        0 CEFA A   
.61C                        0 7061 A   .61D                        0 7041 A   
.61E                        0 7038 A   .61F                        0 CEBB A   
.62                         0 0B1C A   .620                        0 742B A   
.622                        0 73B0 A   .623                        0 7067 A   
.624                        0 7067 A   .625                        0 7067 A   
.626                        0 7067 A   .627                        0 7067 A   
.628                        0 7067 A   .629                        0 7067 A   
.62A                        0 7067 A   .62B                        0 7070 A   
.62C                        0 7070 A   .62D                        0 707E A   
.62E                        0 70B5 A   .62F                        0 70AD A   
.63                         0 0B16 A   .630                        0 70BB A   
.631                        0 70BE A   .632                        0 70BE A   
.633                        0 7121 A   .634                        0 711B A   
.635                        0 713F A   .636                        0 7139 A   
.637                        0 7131 A   .638                        0 7129 A   
.639                        0 714C A   .63A                        0 7146 A   
.63B                        0 72F7 A   .63C                        0 72CD A   
.63D                        0 CE91 A   .63E                        0 7300 A   
.63F                        0 736E A   .64                         0 0B76 A   
.641                        0 7362 A   .642                        0 734B A   
.643                        0 7352 A   .644                        0 7359 A   
.645                        0 7384 A   .646                        0 7392 A   
.647                        0 7392 A   .648                        0 7392 A   
.649                        0 7392 A   .64A                        0 7392 A   
.64B                        0 7392 A   .64C                        0 7392 A   
.64D                        0 7392 A   .64E                        0 7392 A   
.64F                        0 7392 A   .65                         0 0B68 A   
.650                        0 7392 A   .651                        0 7392 A   
.652                        0 7392 A   .653                        0 7392 A   
.654                        0 7392 A   .655                        0 CE59 A   
.656                        0 73F5 A   .657                        0 73C3 A   
.658                        0 7428 A   .659                        0 7408 A   
.65A                        0 74BC A   .65B                        0 74B3 A   
.65C                        0 74A7 A   .65D                        0 74BC A   
.65E                        0 74F6 A   .65F                        0 74EF A   
.66                         0 0B6F A   .660                        0 74FB A   
.661                        0 7536 A   .662                        0 752D A   
.663                        0 7521 A   .664                        0 7536 A   
.665                        0 755C A   .666                        0 753D A   
.667                        0 754D A   .668                        0 7544 A   
.669                        0 753E A   .66A                        0 754D A   
.66B                        0 757D A   .66C                        0 7573 A   
.66D                        0 7592 A   .66E                        0 758C A   
.66F                        0 75A6 A   .67                         0 0B25 A   
.670                        0 759F A   .671                        0 75C9 A   
.672                        0 75C3 A   .673                        0 75E8 A   
.674                        0 75E2 A   .675                        0 7609 A   
.676                        0 75FB A   .677                        0 7611 A   
.678                        0 7696 A   .67A                        0 7671 A   
.67B                        0 7616 A   .67C                        0 7616 A   
.67D                        0 7628 A   .67E                        0 7628 A   
.67F                        0 763A A   .68                         0 0B52 A   
.680                        0 764C A   .681                        0 764C A   
.682                        0 764C A   .683                        0 765E A   
.684                        0 7694 A   .685                        0 7684 A   
.686                        0 76A5 A   .687                        0 769D A   
.688                        0 76AB A   .689                        0 76F9 A   
.68A                        0 76F2 A   .68B                        0 76EA A   
.68C                        0 76F9 A   .68D                        0 7724 A   
.68E                        0 7714 A   .68F                        0 7732 A   
.69                         0 0B4A A   .690                        0 776C A   
.691                        0 775E A   .692                        0 7774 A   
.693                        0 7783 A   .694                        0 777B A   
.695                        0 778A A   .696                        0 863A A   
.698                        0 85FB A   .699                        0 77A0 A   
.69A                        0 77C7 A   .69B                        0 77AD A   
.69C                        0 77E8 A   .69D                        0 77DA A   
.69E                        0 77F0 A   .69F                        0 7811 A   
.6A                         0 0B5E A   .6A0                        0 77F7 A   
.6A1                        0 7839 A   .6A2                        0 785C A   
.6A3                        0 7854 A   .6A4                        0 7860 A   
.6A5                        0 7860 A   .6A6                        0 7860 A   
.6A7                        0 78CE A   .6A8                        0 78A1 A   
.6A9                        0 789A A   .6AA                        0 7893 A   
.6AB                        0 788C A   .6AC                        0 7885 A   
.6AD                        0 CE1E A   .6AE                        0 78FC A   
.6AF                        0 78DD A   .6B                         0 0B76 A   
.6B0                        0 7939 A   .6B1                        0 790B A   
.6B2                        0 7939 A   .6B3                        0 791A A   
.6B4                        0 7946 A   .6B5                        0 7940 A   
.6B6                        0 7976 A   .6B7                        0 796F A   
.6B8                        0 79B4 A   .6B9                        0 7995 A   
.6BA                        0 7A79 A   .6BB                        0 7A1D A   
.6BC                        0 7AC5 A   .6BD                        0 7B8B A   
.6BE                        0 7B84 A   .6BF                        0 7B4D A   
.6C                         0 0C1A A   .6C0                        0 7B7C A   
.6C1                        0 7B5A A   .6C2                        0 7B8B A   
.6C3                        0 7BC8 A   .6C4                        0 7BBA A   
.6C5                        0 CDFE A   .6C6                        0 7C92 A   
.6C7                        0 7C3F A   .6C8                        0 7C67 A   
.6C9                        0 7C46 A   .6CA                        0 7C92 A   
.6CB                        0 7C84 A   .6CC                        0 7C70 A   
.6CD                        0 7C92 A   .6CE                        0 CDD8 A   
.6CF                        0 7CB4 A   .6D                         0 0BB8 A   
.6D0                        0 7D05 A   .6D1                        0 7CEF A   
.6D2                        0 7CE8 A   .6D3                        0 7CE1 A   
.6D4                        0 7CDA A   .6D5                        0 7CD3 A   
.6D6                        0 7D2E A   .6D7                        0 7D14 A   
.6D8                        0 7D6B A   .6D9                        0 7D3D A   
.6DA                        0 7D6B A   .6DB                        0 7D4C A   
.6DC                        0 7D9B A   .6DD                        0 7D94 A   
.6DE                        0 7DD8 A   .6DF                        0 7DB9 A   
.6E                         0 0B80 A   .6E0                        0 7F10 A   
.6E1                        0 7F09 A   .6E2                        0 7ED7 A   
.6E3                        0 7F01 A   .6E4                        0 7EE4 A   
.6E5                        0 7F10 A   .6E6                        0 7F4D A   
.6E7                        0 7F3F A   .6E8                        0 CDB8 A   
.6E9                        0 7FEF A   .6EA                        0 7FC4 A   
.6EB                        0 7FE1 A   .6EC                        0 7FCD A   
.6ED                        0 7FEF A   .6EE                        0 CD92 A   
.6EF                        0 8017 A   .6F                         0 0BA4 A   
.6F0                        0 8054 A   .6F1                        0 8024 A   
.6F2                        0 8075 A   .6F3                        0 806E A   
.6F4                        0 8085 A   .6F5                        0 807E A   
.6F6                        0 809A A   .6F7                        0 808C A   
.6F8                        0 80A2 A   .6F9                        0 8171 A   
.6FB                        0 814A A   .6FC                        0 80C3 A   
.6FD                        0 80D0 A   .6FE                        0 80DE A   
.6FF                        0 80EC A   .7                          0 05D8 A   
.70                         0 0B8A A   .700                        0 80F9 A   
.701                        0 8106 A   .702                        0 8113 A   
.703                        0 8120 A   .704                        0 812D A   
.705                        0 813A A   .706                        0 CD72 A   
.707                        0 816F A   .708                        0 815D A   
.709                        0 818A A   .70A                        0 81A8 A   
.70B                        0 8197 A   .70C                        0 81C9 A   
.70D                        0 81BB A   .70E                        0 81D1 A   
.70F                        0 81E7 A   .71                         0 0BB6 A   
.710                        0 81E0 A   .711                        0 81EC A   
.712                        0 81F0 A   .713                        0 8217 A   
.714                        0 81FD A   .715                        0 8231 A   
.716                        0 825E A   .717                        0 8244 A   
.718                        0 8287 A   .719                        0 826D A   
.71A                        0 8292 A   .71B                        0 828E A   
.71C                        0 8294 A   .71D                        0 832A A   
.71F                        0 8318 A   .72                         0 0C1A A   
.720                        0 82AE A   .721                        0 82B8 A   
.722                        0 82C2 A   .723                        0 82CC A   
.724                        0 82F2 A   .725                        0 82E8 A   
.726                        0 82DB A   .727                        0 82FA A   
.728                        0 82FC A   .729                        0 834B A   
.72A                        0 8396 A   .72B                        0 837C A   
.72C                        0 83C1 A   .72D                        0 83A7 A   
.72E                        0 83F9 A   .72F                        0 83D0 A   
.73                         0 0BD1 A   .730                        0 83F9 A   
.731                        0 83DF A   .732                        0 841A A   
.733                        0 840C A   .734                        0 8422 A   
.735                        0 842D A   .736                        0 8429 A   
.737                        0 842F A   .738                        0 8584 A   
.73A                        0 855D A   .73B                        0 844F A   
.73C                        0 8452 A   .73D                        0 8452 A   
.73E                        0 8452 A   .73F                        0 8452 A   
.74                         0 0BBF A   .740                        0 8475 A   
.741                        0 8468 A   .742                        0 845A A   
.743                        0 8461 A   .744                        0 8478 A   
.745                        0 849D A   .746                        0 848E A   
.747                        0 8480 A   .748                        0 8487 A   
.749                        0 84B9 A   .74A                        0 84B9 A   
.74B                        0 84AC A   .74C                        0 84A5 A   
.74D                        0 84BC A   .74E                        0 84D8 A   
.74F                        0 84CB A   .75                         0 0C1A A   
.750                        0 84C4 A   .751                        0 84DB A   
.752                        0 850D A   .753                        0 84E3 A   
.754                        0 84F9 A   .755                        0 84EA A   
.756                        0 850D A   .757                        0 850D A   
.758                        0 8500 A   .759                        0 850F A   
.75A                        0 8557 A   .75B                        0 8517 A   
.75C                        0 852D A   .75D                        0 851E A   
.75E                        0 8557 A   .75F                        0 8543 A   
.76                         0 0BF7 A   .760                        0 8534 A   
.761                        0 8557 A   .762                        0 8557 A   
.763                        0 854A A   .764                        0 8559 A   
.765                        0 8582 A   .766                        0 8570 A   
.767                        0 85A2 A   .768                        0 858B A   
.769                        0 85CB A   .76A                        0 CD4D A   
.76B                        0 8620 A   .76C                        0 860E A   
.76D                        0 866D A   .76E                        0 8660 A   
.76F                        0 CD26 A   .77                         0 0BD8 A   
.770                        0 87A3 A   .771                        0 86B9 A   
.772                        0 86B0 A   .773                        0 86A6 A   
.774                        0 8737 A   .775                        0 86D1 A   
.776                        0 8737 A   .777                        0 8720 A   
.778                        0 8719 A   .779                        0 8737 A   
.77A                        0 8730 A   .77B                        0 8775 A   
.77C                        0 873E A   .77D                        0 8799 A   
.77E                        0 8791 A   .77F                        0 87AB A   
.78                         0 0C1A A   .780                        0 8844 A   
.781                        0 8818 A   .782                        0 8859 A   
.783                        0 8859 A   .784                        0 884B A   
.785                        0 CD11 A   .786                        0 8886 A   
.787                        0 8871 A   .788                        0 CCF5 A   
.789                        0 89B5 A   .78B                        0 899B A   
.78C                        0 8895 A   .78D                        0 8895 A   
.78E                        0 88A1 A   .78F                        0 889D A   
.79                         0 0C0C A   .790                        0 88A3 A   
.791                        0 88F3 A   .792                        0 88E2 A   
.793                        0 892C A   .794                        0 890A A   
.795                        0 88FB A   .796                        0 892C A   
.797                        0 891C A   .798                        0 8944 A   
.799                        0 896A A   .79A                        0 8951 A   
.79B                        0 8987 A   .79C                        0 8995 A   
.79D                        0 CCE1 A   .79E                        0 8D90 A   
.7A                         0 0BFE A   .7A0                        0 8D65 A   
.7A1                        0 89F7 A   .7A2                        0 8A1B A   
.7A3                        0 8A3E A   .7A4                        0 8A50 A   
.7A5                        0 8A45 A   .7A6                        0 8A97 A   
.7A7                        0 8AA1 A   .7A8                        0 8A9E A   
.7A9                        0 8B11 A   .7AA                        0 8B28 A   
.7AB                        0 8B1D A   .7AC                        0 8B69 A   
.7AD                        0 8B7E A   .7AE                        0 8B70 A   
.7AF                        0 8BF2 A   .7B                         0 0C1A A   
.7B0                        0 8C17 A   .7B1                        0 8C0C A   
.7B2                        0 8C21 A   .7B3                        0 8C1E A   
.7B4                        0 8C88 A   .7B5                        0 8CBC A   
.7B6                        0 8CD3 A   .7B7                        0 8CC3 A   
.7B8                        0 CCC6 A   .7B9                        0 8D4B A   
.7BA                        0 8CF0 A   .7BB                        0 8CDA A   
.7BC                        0 CCA0 A   .7BD                        0 8D4B A   
.7BE                        0 8D0A A   .7BF                        0 8CF7 A   
.7C                         0 D9EF A   .7C0                        0 CC88 A   
.7C1                        0 8D4B A   .7C2                        0 8D4B A   
.7C3                        0 8D11 A   .7C4                        0 8D31 A   
.7C5                        0 8D18 A   .7C6                        0 CC5C A   
.7C7                        0 8D4B A   .7C8                        0 CC20 A   
.7C9                        0 8D5B A   .7CA                        0 8D88 A   
.7CB                        0 8D78 A   .7CC                        0 8E78 A   
.7CD                        0 8DC6 A   .7CE                        0 8DD3 A   
.7CF                        0 8DCF A   .7D                         0 0C30 A   
.7D0                        0 8E78 A   .7D1                        0 8DDE A   
.7D2                        0 8E78 A   .7D3                        0 8DE7 A   
.7D4                        0 8E4C A   .7D5                        0 8E04 A   
.7D6                        0 8E75 A   .7D7                        0 CC20 A   
.7D8                        0 CC5C A   .7D9                        0 CC88 A   
.7DA                        0 CCA0 A   .7DB                        0 CCC6 A   
.7DC                        0 CCE1 A   .7DD                        0 CCF5 A   
.7DE                        0 CD11 A   .7DF                        0 CD26 A   
.7E                         0 0C45 A   .7E0                        0 CD4D A   
.7E1                        0 CD72 A   .7E2                        0 CD92 A   
.7E3                        0 CDB8 A   .7E4                        0 CDD8 A   
.7E5                        0 CDFE A   .7E6                        0 CE1E A   
.7E7                        0 CE59 A   .7E8                        0 CE91 A   
.7E9                        0 CEBB A   .7EA                        0 CEFA A   
.7EB                        0 CF1F A   .7EC                        0 CF50 A   
.7ED                        0 CF72 A   .7EE                        0 CF9D A   
.7EF                        0 CFCF A   .7F                         0 0C52 A   
.7F0                        0 D00A A   .7F1                        0 D03E A   
.7F2                        0 D078 A   .7F3                        0 D0B7 A   
.7F4                        0 D0E4 A   .7F5                        0 D115 A   
.7F6                        0 D146 A   .7F7                        0 D160 A   
.7F8                        0 D18D A   .7F9                        0 D1D5 A   
.7FA                        0 D20D A   .7FB                        0 D24B A   
.7FC                        0 D282 A   .7FD                        0 D2B9 A   
.7FE                        0 D2F0 A   .7FF                        0 D30A A   
.8                          0 06A1 A   .80                         0 0C4E A   
.800                        0 D315 A   .801                        0 D31F A   
.802                        0 D329 A   .803                        0 D333 A   
.804                        0 D33E A   .805                        0 D349 A   
.806                        0 D371 A   .807                        0 D395 A   
.808                        0 D3B9 A   .809                        0 D3F3 A   
.80A                        0 D42D A   .80B                        0 D447 A   
.80C                        0 D473 A   .80D                        0 D49F A   
.80E                        0 D4CB A   .80F                        0 D4F6 A   
.81                         0 0C92 A   .810                        0 D530 A   
.811                        0 D547 A   .812                        0 D576 A   
.813                        0 D5B6 A   .814                        0 D5D0 A   
.815                        0 D5E6 A   .816                        0 D602 A   
.817                        0 D62A A   .818                        0 D650 A   
.819                        0 D67C A   .81A                        0 D67E A   
.81B                        0 D685 A   .81C                        0 D68C A   
.81D                        0 D6A6 A   .81E                        0 D6B8 A   
.81F                        0 D6D2 A   .82                         0 0C78 A   
.820                        0 D6D5 A   .821                        0 D6DC A   
.822                        0 D6E3 A   .823                        0 D6EE A   
.824                        0 D70E A   .825                        0 D72E A   
.826                        0 D731 A   .827                        0 D738 A   
.828                        0 D73F A   .829                        0 D74A A   
.82A                        0 D775 A   .82B                        0 D785 A   
.82C                        0 D78C A   .82D                        0 D792 A   
.82E                        0 D796 A   .82F                        0 D79B A   
.83                         0 0C6B A   .830                        0 D7C0 A   
.831                        0 D7E9 A   .832                        0 D7F7 A   
.833                        0 D810 A   .834                        0 D82B A   
.835                        0 D82F A   .836                        0 D844 A   
.837                        0 D858 A   .838                        0 D878 A   
.839                        0 D87B A   .83A                        0 D89A A   
.83B                        0 D8B0 A   .83C                        0 D8BC A   
.83D                        0 D8CC A   .83E                        0 D8D1 A   
.83F                        0 D8D7 A   .84                         0 0C92 A   
.840                        0 D8E7 A   .841                        0 D8F7 A   
.842                        0 D8F9 A   .843                        0 D8FB A   
.844                        0 D901 A   .845                        0 D904 A   
.846                        0 D908 A   .847                        0 D90D A   
.848                        0 D923 A   .849                        0 D93E A   
.84A                        0 D96C A   .84B                        0 D975 A   
.84C                        0 D99D A   .84D                        0 D9B7 A   
.84E                        0 D9DC A   .84F                        0 D9EF A   
.85                         0 0C87 A   .850                        0 DA0C A   
.86                         0 0CD0 A   .87                         0 0CC5 A   
.88                         0 0C9A A   .89                         0 0CC5 A   
.8A                         0 0CB6 A   .8B                         0 0CD0 A   
.8C                         0 0D0D A   .8D                         0 0CF3 A   
.8E                         0 0CE6 A   .8F                         0 0D0D A   
.9                          0 0692 A   .90                         0 0D02 A   
.91                         0 0D1C A   .92                         0 0D14 A   
.93                         0 0D4C A   .94                         0 0D32 A   
.95                         0 0D24 A   .96                         0 0D4C A   
.97                         0 0D41 A   .98                         0 0D5C A   
.99                         0 0D53 A   .9A                         0 0D72 A   
.9B                         0 0D69 A   .9C                         0 0DB0 A   
.9D                         0 0D96 A   .9E                         0 0D88 A   
.9F                         0 0DB0 A   .A                          0 06B9 A   
.A0                         0 0DA5 A   .A1                         0 0DC0 A   
.A2                         0 0DB7 A   .A3                         0 0DF0 A   
.A4                         0 0DD6 A   .A5                         0 0DC8 A   
.A6                         0 0DF0 A   .A7                         0 0DE5 A   
.A8                         0 0E00 A   .A9                         0 0DF7 A   
.AA                         0 0E16 A   .AB                         0 0E0D A   
.AC                         0 0E54 A   .AD                         0 0E3A A   
.AE                         0 0E2C A   .AF                         0 0E54 A   
.B                          0 06AA A   .B0                         0 0E49 A   
.B1                         0 0E64 A   .B2                         0 0E5B A   
.B3                         0 0EA2 A   .B4                         0 0E88 A   
.B5                         0 0E7A A   .B6                         0 0EA2 A   
.B7                         0 0E97 A   .B8                         0 0EB2 A   
.B9                         0 0EA9 A   .BA                         0 0EF0 A   
.BB                         0 0ED6 A   .BC                         0 0EC8 A   
.BD                         0 0EF0 A   .BE                         0 0EE5 A   
.BF                         0 0F00 A   .C                          0 06DD A   
.C0                         0 0EF7 A   .C1                         0 0F30 A   
.C2                         0 0F16 A   .C3                         0 0F08 A   
.C4                         0 0F30 A   .C5                         0 0F25 A   
.C6                         0 0F40 A   .C7                         0 0F37 A   
.C8                         0 0F56 A   .C9                         0 0F4D A   
.CA                         0 0F86 A   .CB                         0 0F6C A   
.CC                         0 0F5E A   .CD                         0 0F86 A   
.CE                         0 0F7B A   .CF                         0 0F96 A   
.D                          0 06C2 A   .D0                         0 0F8D A   
.D1                         0 0FAC A   .D2                         0 0FA3 A   
.D3                         0 0FEA A   .D4                         0 0FD0 A   
.D5                         0 0FC2 A   .D6                         0 0FEA A   
.D7                         0 0FDF A   .D8                         0 0FFA A   
.D9                         0 0FF1 A   .DA                         0 102A A   
.DB                         0 1010 A   .DC                         0 1002 A   
.DD                         0 102A A   .DE                         0 101F A   
.DF                         0 103A A   .E                          0 06D2 A   
.E0                         0 1031 A   .E1                         0 1050 A   
.E2                         0 1047 A   .E3                         0 108E A   
.E4                         0 1074 A   .E5                         0 1066 A   
.E6                         0 108E A   .E7                         0 1083 A   
.E8                         0 109E A   .E9                         0 1095 A   
.EA                         0 10DC A   .EB                         0 10C2 A   
.EC                         0 10B4 A   .ED                         0 10DC A   
.EE                         0 10D1 A   .EF                         0 10EC A   
.F                          0 06C9 A   .F0                         0 10E3 A   
.F1                         0 112A A   .F2                         0 1110 A   
.F3                         0 1102 A   .F4                         0 112A A   
.F5                         0 111F A   .F6                         0 113A A   
.F7                         0 1131 A   .F8                         0 116A A   
.F9                         0 1150 A   .FA                         0 1142 A   
.FB                         0 116A A   .FC                         0 115F A   
.FD                         0 117A A   .FE                         0 1171 A   
.FF                         0 1190 A   .FFDA                       0 7C92 A   
.FFDD                       0 7455 A   .FFDE                       0 7444 A   
.FFDF                       0 7430 A   .FFE0                       0 7450 A   
.FFE2                       0 742B A   .FFE3                       0 6FDF A   
.FFE4                       0 6FBA A   .FFE6                       0 6DE1 A   
.FFE7                       0 6DD0 A   .FFE8                       0 6DBC A   
.FFE9                       0 6DDC A   .FFEB                       0 6DB7 A   
.FFEC                       0 68C7 A   .FFED                       0 68EC A   
.FFEE                       0 68DB A   .FFEF                       0 68E7 A   
.FFF1                       0 68C2 A   .FFF4                       0 4D59 A   
.FFFA                       0 33AA A   BcdToBin                    0 92B1 A   
__memcpyb                   0 001B A E __memcpyd                   0 0038 A E 
__memsetb                   0 0000 A E __read_byte                 0 05DF A E 
__read_dword                0 0056 A E __read_word                 0 05ED A E 
__write_byte                0 05FB A E __write_byte_SS             0 0637 A E 
__write_dword               0 0067 A E __write_word                0 060E A E 
__write_word_SS             0 0647 A E _apm16_entry                0 943E A   
_apm32_entry                0 9359 A   _apmreal_entry              0 9509 A   
_ata_cmd_data_io            0 2980 A E _ata_cmd_non_data           0 2979 A E 
_ata_cmd_packet             0 2D45 A E _ata_detect                 0 1B8A A E 
_ata_init                   0 1848 A E _ata_reset                  0 2859 A E 
_atapi_get_sense            0 31EF A E _atapi_is_cdrom             0 34D7 A E 
_atapi_is_ready             0 3274 A E _await_ide                  0 1A2A A   
_bios_printf                0 0939 A E _bios_svn_version_string    0 0165 A   
_cdemu_emulated_drive       0 3579 A E _cdemu_init                 0 353E A E 
_cdemu_isactive             0 355D A E _cdrom_boot                 0 35B3 A E 
_check_for_keystroke        0 08F2 A E _debugger_off               0 1796 A E 
_debugger_on                0 1784 A E _delay_ticks                0 084D A E 
_delay_ticks_and_check_for+ 0 0908 A E _dequeue_key                0 5142 A E 
_determine_floppy_media     0 8687 A E _drivetypes                 0 1208 A   
_eltorito                   0 359B A   _enable_mouse_int_and_even+ 0 529C A E 
_enqueue_key                0 5981 A E _floppy_drive_exists        0 7746 A E 
_floppy_drive_recal         0 76C0 A E _floppy_media_known         0 7560 A E 
_floppy_media_sense         0 75D0 A E _floppy_prepare_controller  0 74C0 A E 
_floppy_reset_controller    0 7472 A E _get_CS                     0 0657 A E 
_get_SS                     0 065A A E _get_boot_vector            0 1369 A   
_get_ebda_seg               0 0667 A E _get_keystroke              0 0900 A E 
_get_mouse_data             0 538A A E _inb                        0 0529 A E 
_inb_cmos                   0 056E A E _inhibit_mouse_int_and_eve+ 0 51EF A E 
_init_boot_vectors          0 123A A   _init_rtc                   0 057A A E 
_int09_function             0 540F A E _int13_cdemu                0 7001 A E 
_int13_cdrom                0 6909 A E _int13_diskette_function    0 778E A E 
_int13_edd                  0 5AE0 A E _int13_eltorito             0 6DFE A E 
_int13_harddisk             0 6156 A E _int14_function             0 3A92 A E 
_int15_function             0 3CBF A E _int15_function32           0 48CB A E 
_int15_function_mouse       0 41A3 A E _int16_function             0 4D90 A E 
_int17_function             0 8688 A E _int18_panic_msg            0 1709 A E 
_int19_function             0 87AF A E _int1a_function             0 89EB A E 
_int70_function             0 8D94 A E _int74_function             0 5A05 A E 
_interactive_bootkey        0 13B6 A E _inw                        0 0534 A E 
_isotag                     0 3595 A   _keyboard_init              0 0C5E A E 
_keyboard_panic             0 11A2 A E _log_bios_start             0 171B A E 
_nmi_handler_msg            0 16F7 A E _outb                       0 053F A E 
_outb_cmos                  0 055F A E _outw                       0 054F A E 
_panic_msg_keyb_buffer_ful+ 0 51CF A   _print_bios_banner          0 11E1 A E 
_print_boot_device          0 15B2 A E _print_boot_failure         0 167C A E 
_print_cdromboot_failure    0 16E2 A E _put_luint                  0 0762 A E 
_put_str                    0 0819 A E _put_uint                   0 06DF A E 
_read_byte_SS               0 0621 A E _read_dword_SS              0 007E A E 
_read_word_SS               0 062C A E _rtc_updating               0 05AB A E 
_s3_resume                  0 17A7 A E _s3_resume_panic            0 11CF A E 
_scan_to_scanascii          0 01AF A   _send                       0 0686 A E 
_send_to_mouse_ctrl         0 5340 A E _set_DS                     0 065D A E 
_set_diskette_current_cyl   0 8656 A E _set_diskette_ret_status    0 863E A E 
_set_e820_range             0 482D A E _set_enable_a20             0 1731 A E 
_set_kbd_command_byte       0 53C1 A E _shutdown_status_panic      0 11B7 A E 
_vgafont8                   0 FA6E A   _wrch                       0 0676 A E 
apm16_04                    0 943F A   apm16_05                    0 9446 A   
apm16_07                    0 944F A   apm16_07_1                  0 9473 A   
apm16_07_poweroff           0 9469 A   apm16_07_poweroff_str       0 9425 A   
apm16_07_standby            0 9485 A   apm16_07_standby_str        0 9436 A   
apm16_07_suspend            0 9476 A   apm16_07_suspend_str        0 942E A   
apm16_08                    0 9494 A   apm16_0a                    0 949A A   
apm16_0b                    0 94AE A   apm16_0e                    0 94B6 A   
apm16_0f                    0 94C0 A   apm16_10                    0 94C6 A   
apm16_error                 0 94D4 A   apm16_ok                    0 94D1 A   
apm16_out_str               0 940D A   apm16_out_str1              0 9414 A   
apm16_out_str2              0 9420 A   apm16_unimplemented         0 94D4 A   
apm32_04                    0 935B A   apm32_05                    0 9364 A   
apm32_07                    0 936F A   apm32_07_1                  0 93A0 A   
apm32_07_poweroff           0 9392 A   apm32_07_poweroff_str       0 9340 A   
apm32_07_standby            0 93B4 A   apm32_07_standby_str        0 9351 A   
apm32_07_suspend            0 93A3 A   apm32_07_suspend_str        0 9349 A   
apm32_08                    0 93C5 A   apm32_0a                    0 93CB A   
apm32_0b                    0 93E1 A   apm32_0e                    0 93E9 A   
apm32_0f                    0 93F3 A   apm32_10                    0 93F9 A   
apm32_error                 0 9409 A   apm32_ok                    0 9405 A   
apm32_out_str               0 932D A   apm32_out_str1              0 9331 A   
apm32_out_str2              0 933D A   apm32_unimplemented         0 9409 A   
apm_call                    0 F894 A   apmreal_00                  0 9509 A   
apmreal_01                  0 951B A   apmreal_02                  0 9522 A   
apmreal_03                  0 9538 A   apmreal_04                  0 9557 A   
apmreal_05                  0 955E A   apmreal_07                  0 9567 A   
apmreal_07_1                0 958B A   apmreal_07_poweroff         0 9581 A   
apmreal_07_poweroff_str     0 94EF A   apmreal_07_standby          0 959D A   
apmreal_07_standby_str      0 9500 A   apmreal_07_suspend          0 958E A   
apmreal_07_suspend_str      0 94F8 A   apmreal_08                  0 95AC A   
apmreal_0a                  0 95B2 A   apmreal_0b                  0 95C6 A   
apmreal_0e                  0 95CE A   apmreal_0f                  0 95D8 A   
apmreal_10                  0 95DE A   apmreal_error               0 95EE A   
apmreal_ok                  0 95E9 A   apmreal_out_str             0 94D7 A   
apmreal_out_str1            0 94DE A   apmreal_out_str2            0 94EA A   
apmreal_unimplemented       0 95EE A   ata_in_16                   0 2C45 A   
ata_in_32                   0 2C49 A   ata_in_adjust               0 2C31 A   
ata_in_done                 0 2C4C A   ata_in_no_adjust            0 2C38 A   
ata_out_16                  0 2C7B A   ata_out_32                  0 2C80 A   
ata_out_adjust              0 2C67 A   ata_out_done                0 2C84 A   
ata_out_no_adjust           0 2C6E A   ata_packet_after            0 317A A   
ata_packet_done             0 3194 A   ata_packet_in_16            0 3173 A   
ata_packet_in_32            0 3177 A   ata_packet_in_after_16      0 3187 A   
ata_packet_in_after_32      0 318C A   ata_packet_in_after_32_loo+ 0 318E A   
ata_packet_in_before_16     0 3151 A   ata_packet_in_before_32     0 3156 A   
ata_packet_in_before_32_lo+ 0 3158 A   ata_packet_no_before        0 315E A   
bios32_end                  0 9658 A   bios32_entry_point          0 9610 A   
bios32_structure            0 9600 A   bios_table_area_end         0 CC00 A   
bios_table_area_start       0 9D90 A   block_count_rounded         0 9C1D A   
carry_set                   0 8EB3 A   check_for_hd1               0 9146 A   
checksum_loop               0 9B62 A   checksum_out                0 9B7C A   
detect_parport              0 9B07 A   detect_serial               0 9B26 A   
diskette_param_table        0 EFC7 A   diskette_param_table2       0 EFDE A   
done                        0 08FF A   dummy_iret_handler          0 FF53 A   
dummy_master_pic_irq_handl+ 0 E9E6 A   dummy_slave_pic_irq_handle+ 0 E9EC A   
ebda_post                   0 9230 A   eoi_both_pics               0 92A8 A   
eoi_jmp_post                0 9245 A   eoi_master_pic              0 92AC A   
f0_missing                  0 8FC4 A   f1_missing                  0 8FCF A   
floppy_drive_post           0 8F89 A   halt2_loop                  0 0C4F A   
hard_drive_post             0 9010 A   hd0_post_above_2048         0 9108 A   
hd0_post_above_4096         0 9116 A   hd0_post_above_8192         0 9124 A   
hd0_post_checksum_loop      0 9139 A   hd0_post_logical_chs        0 90E7 A   
hd0_post_physical_chs       0 90D9 A   hd0_post_store_logical      0 912A A   
hd1_post_above_2048         0 91F1 A   hd1_post_above_4096         0 91FF A   
hd1_post_above_8192         0 920D A   hd1_post_checksum_loop      0 9222 A   
hd1_post_logical_chs        0 91D0 A   hd1_post_physical_chs       0 91C3 A   
hd1_post_store_logical      0 9213 A   idiv_                       0 0136 A   
idiv_u                      0 013A A   initial_int_vector_offset_+ 0 FEF3 A   
int08_floppy_off            0 FEC4 A   int08_handler               0 FEA5 A   
int08_store_ticks           0 FED9 A   int09_check_pause           0 E9BB A   
int09_done                  0 E9CC A   int09_finish                0 E9D7 A   
int09_handler               0 E987 A   int09_process_key           0 E9C9 A   
int0e_handler               0 EF57 A   int0e_loop1                 0 EF69 A   
int0e_loop2                 0 EF73 A   int0e_normal                0 EF81 A   
int10_handler               0 F065 A   int11_handler               0 F84D A   
int12_handler               0 F841 A   int13_cdemu_inactive        0 8F0B A   
int13_cdrom_rme_end         0 6CA5 A   int13_disk                  0 8F40 A   
int13_diskette              0 EC59 A   int13_handler               0 E3FE A   
int13_legacy                0 8F13 A   int13_nocdemu               0 8EF8 A   
int13_noeltorito            0 8F0F A   int13_not_eltorito          0 8ECF A   
int13_notcdrom              0 8F40 A   int13_notfloppy             0 8F27 A   
int13_out                   0 8F4D A   int13_relocated             0 8EBC A   
int14_handler               0 E739 A   int1586_tick                0 492C A   
int1586_tick_end            0 493A A   int15_handler               0 F859 A   
int15_handler32             0 F8A2 A   int15_handler32_ret         0 F88E A   
int15_handler_mouse         0 F89D A   int15_handler_mouse_ret     0 F88D A   
int15_stub                  0 F897 A   int16_F00                   0 E859 A   
int16_handler               0 E82E A   int16_key_found             0 E876 A   
int16_wait_for_key          0 E869 A   int16_zero_clear            0 E847 A   
int16_zero_set              0 E850 A   int17_handler               0 EFD2 A   
int18_handler               0 8F51 A   int19_handler               0 E6F2 A   
int19_load_done             0 88D6 A   int19_next_boot             0 8F84 A   
int19_relocated             0 8F6D A   int1a_callfunction          0 FE8D A   
int1a_handler               0 FE6E A   int1a_normal                0 FE87 A   
int70_handler               0 FE93 A   int71_handler               0 E9DD A   
int74_done                  0 8E9E A   int74_handler               0 8E7F A   
int75_handler               0 E2C7 A   int76_handler               0 9316 A   
iret_modify_cf              0 8EA8 A   iret_post_0x467             0 9279 A   
jmp_post_0x467              0 9271 A   laddl                       0 0094 A   
laddul                      0 0094 A   landl                       0 008C A   
landul                      0 008C A   lcmpl                       0 009C A   
lcmpul                      0 009C A   ldecl                       0 00D3 A   
ldecul                      0 00D3 A   ldivul                      0 013F A   
lincl                       0 00E0 A   lincul                      0 00E0 A   
lmull                       0 00BA A   lmulul                      0 00BA A   
look_drive0                 0 8FBB A   look_drive1                 0 8FC6 A   
lorl                        0 00D8 A   lorul                       0 00D8 A   
lsl_exit                    0 0135 A   lsl_loop                    0 0129 A   
lsll                        0 0118 A   lslul                       0 0118 A   
lsr_exit                    0 0117 A   lsr_loop                    0 010B A   
lsrul                       0 00FA A   lsubl                       0 00B2 A   
lsubul                      0 00B2 A   ltstl                       0 00E5 A   
ltstul                      0 00E5 A   memcpyb_end                 0 0031 A   
memcpyd_end                 0 004F A   memsetb_end                 0 0015 A   
nmi                         0 E2C3 A   no_bcv                      0 9C6D A   
no_bev                      0 9CA6 A   no_key                      0 08FD A   
no_parport                  0 9B25 A   no_prod_str                 0 9C9E A   
no_serial                   0 9B49 A   normal_post                 0 E0A3 A   
pci_found                   0 9643 A   pci_present                 0 9817 A   
pci_pro_devloop             0 968E A   pci_pro_devloop2            0 96C4 A   
pci_pro_f02                 0 967D A   pci_pro_f03                 0 96B9 A   
pci_pro_f08                 0 96F2 A   pci_pro_f09                 0 9711 A   
pci_pro_f0a                 0 972F A   pci_pro_f0b                 0 9743 A   
pci_pro_f0c                 0 975F A   pci_pro_f0d                 0 977D A   
pci_pro_fail                0 9793 A   pci_pro_get_max_bus         0 979F A   
pci_pro_nextdev             0 96A9 A   pci_pro_nextdev2            0 96E2 A   
pci_pro_no_i440bx           0 97BE A   pci_pro_ok                  0 9798 A   
pci_pro_select_reg          0 97C0 A   pci_pro_unknown             0 9791 A   
pci_real_devloop            0 984B A   pci_real_devloop2           0 987D A   
pci_real_f02                0 9838 A   pci_real_f03                0 9874 A   
pci_real_f08                0 98AA A   pci_real_f09                0 98C2 A   
pci_real_f0a                0 98DA A   pci_real_f0b                0 98ED A   
pci_real_f0c                0 9904 A   pci_real_f0d                0 991B A   
pci_real_f0e                0 992E A   pci_real_fail               0 995E A   
pci_real_get_max_bus        0 996C A   pci_real_nextdev            0 9861 A   
pci_real_nextdev2           0 9897 A   pci_real_no_i440bx          0 998C A   
pci_real_ok                 0 9964 A   pci_real_select_reg         0 998F A   
pci_real_too_small          0 9956 A   pci_real_unknown            0 995C A   
pci_routing_table_structur+ 0 99B0 A   pci_routing_table_structur+ 0 9A30 A   
pci_routing_table_structur+ 0 99D0 A   pcibios_error               0 FE7B A   
pcibios_protected           0 9660 A   pcibios_real                0 97DD A   
pmode_IDT_info              0 F8AB A   pnpbios_00                  0 9BD7 A   
pnpbios_code                0 9BBE A   pnpbios_exit                0 9BF6 A   
pnpbios_fail                0 9BF3 A   pnpbios_prot                0 9BB1 A   
pnpbios_real                0 9BB8 A   pnpbios_structure           0 9B90 A   
post                        0 E05B A   post_d0_extended            0 9072 A   
post_d0_type47              0 9083 A   post_d1_exists              0 9151 A   
post_d1_extended            0 915C A   post_d1_type47              0 916D A   
post_default_master_pic_in+ 0 9CFA A   post_default_slave_pic_int+ 0 9D0A A   
post_init_ivt               0 9CDF A   post_init_pic               0 9CBA A   
protected_mode              0 3F92 A   protmode_switch             0 40A4 A   
real_mode                   0 3FBC A   retf_post_0x467             0 9286 A   
rmode_IDT_info              0 F8B1 A   rom_checksum                0 9B4B A   
rom_scan                    0 9BF9 A   rom_scan_increment          0 9CA8 A   
rom_scan_loop               0 9BF9 A   rombios32_05                0 9A5F A   
rombios32_10                0 9A98 A   rombios32_gdt               0 9AD7 A   
rombios32_gdt_48            0 9AD1 A   rombios32_init              0 9A30 A   
rombios32_real_mode         0 9AB2 A   s3_post                     0 9293 A   
timer_tick_post             0 92C0 A   unknown_service             0 9656 A   
vga_init_ok                 0 E212 A   

00000 errors
00000 warnings
